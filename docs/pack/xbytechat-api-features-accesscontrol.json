{
  "name": "xbytechat-api/Features/AccessControl",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/AccessControl/Attributes/HasPermissionAttribute.cs",
      "sha256": "4c0b87bd0b181823afbcc065a45376dc4c185ec94ae738d09d28afeee757d71d",
      "language": "csharp",
      "size": 3182,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Services;\n\nnamespace xbytechat.api.Features.AccessControl.Attributes\n{\n    public class HasPermissionAttribute : Attribute, IAsyncAuthorizationFilter\n    {\n        private readonly string _permissionCode;\n\n        public HasPermissionAttribute(string permissionCode) => _permissionCode = permissionCode;\n\n        public async Task OnAuthorizationAsync(AuthorizationFilterContext context)\n        {\n            var user = context.HttpContext.User;\n            var planIdClaim = user.FindFirst(\"plan_id\")?.Value;\n\n            if (string.IsNullOrWhiteSpace(planIdClaim) || !Guid.TryParse(planIdClaim, out var planId))\n            {\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            var permissionService = context.HttpContext.RequestServices\n                .GetRequiredService<IPermissionCacheService>();\n\n            var permissions = await permissionService.GetPlanPermissionsAsync(planId);\n\n            var hasPermission = permissions.Any(p =>\n                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));\n\n            if (!hasPermission)\n                context.Result = new ForbidResult();\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.AspNetCore.Mvc.Filters;\n//using Microsoft.Extensions.DependencyInjection;\n//using System;\n//using System.Linq;\n//using xbytechat.api.Features.AccessControl.Services;\n\n//namespace xbytechat.api.Features.AccessControl.Attributes\n//{\n//    public class HasPermissionAttribute : Attribute, IAuthorizationFilter\n//    {\n//        private readonly string _permissionCode;\n\n//        public HasPermissionAttribute(string permissionCode)\n//        {\n//            _permissionCode = permissionCode;\n//        }\n\n//        public void OnAuthorization(AuthorizationFilterContext context)\n//        {\n//            var user = context.HttpContext.User;\n//            var planIdClaim = user.FindFirst(\"plan_id\")?.Value;\n\n//            if (string.IsNullOrEmpty(planIdClaim))\n//            {\n//                context.Result = new ForbidResult();\n//                return;\n//            }\n\n//            if (!Guid.TryParse(planIdClaim, out var planId))\n//            {\n//                context.Result = new ForbidResult();\n//                return;\n//            }\n\n//            var permissionService = context.HttpContext.RequestServices\n//                .GetRequiredService<IPermissionCacheService>();\n\n//            // Get permissions for this plan from cache\n//            var permissions = permissionService.GetPlanPermissionsAsync(planId).Result;\n\n//            // Check if any permission matches the requested code\n//            bool hasPermission = permissions.Any(p =>\n//                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));\n\n//            if (!hasPermission)\n//            {\n//                context.Result = new ForbidResult();\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PermissionController.cs",
      "sha256": "f3ef162fea0e7bd86c0bf3b538aad49c8e9e7af7213b4b00adac8b994e3e103f",
      "language": "csharp",
      "size": 3705,
      "content": "// üìÑ Features/AccessControl/Controllers/PermissionController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [ApiController]\n    [Route(\"api/permission\")]\n    [Authorize]\n    public class PermissionController : ControllerBase\n    {\n        private readonly IPermissionService _permissionService;\n\n        public PermissionController(IPermissionService permissionService)\n        {\n            _permissionService = permissionService;\n        }\n\n        // --- Existing grouped endpoint (kept for compatibility) ---\n        // GET /api/permission/grouped\n        [HttpGet(\"grouped\")]\n        public async Task<IActionResult> GetGroupedPermissions(CancellationToken ct)\n        {\n            var grouped = await _permissionService.GetGroupedPermissionsAsync();\n            return Ok(ResponseResult.SuccessInfo(\"Permissions grouped by category\", grouped));\n        }\n\n        // --- New CRUD endpoints used by PermissionsPage ---\n\n        // GET /api/permission\n        [HttpGet]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<IEnumerable<PermissionSummaryDto>>> GetAll(\n            CancellationToken ct)\n        {\n            var list = await _permissionService.GetAllAsync(ct);\n            return Ok(list); // React expects a plain array\n        }\n\n        // POST /api/permission\n        [HttpPost]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<PermissionSummaryDto>> Create(\n            [FromBody] PermissionUpsertDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var created = await _permissionService.CreateAsync(dto, ct);\n                return Ok(created);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n        }\n\n        // PUT /api/permission/{id}\n        [HttpPut(\"{id:guid}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<PermissionSummaryDto>> Update(\n            Guid id,\n            [FromBody] PermissionUpsertDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var updated = await _permissionService.UpdateAsync(id, dto, ct);\n                return Ok(updated);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n        }\n\n        // DELETE /api/permission/{id}  (soft delete)\n        [HttpDelete(\"{id:guid}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> Deactivate(\n            Guid id,\n            CancellationToken ct)\n        {\n            try\n            {\n                await _permissionService.DeactivateAsync(id, ct);\n                return NoContent();\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PlanController.cs",
      "sha256": "44b6dcfde1ac688e832cff42dabd6d3c41711e52f5e0e78cedefbd3dc43ac06a",
      "language": "csharp",
      "size": 7262,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers; // ‚úÖ For ResponseResult\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    [Authorize]\n    public class PlanController : ControllerBase\n    {\n        private readonly IPlanService _planService;\n        private readonly IPermissionCacheService _permissionCacheService;\n        private readonly ILogger<PlanController> _logger;\n        public PlanController(IPlanService planService, IPermissionCacheService permissionCacheService, ILogger<PlanController> logger)\n        {\n            _planService = planService;\n            _permissionCacheService = permissionCacheService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetPlans()\n        {\n            try\n            {\n                var plans = await _planService.GetAllPlansAsync();\n                return Ok(plans); // Return plain array\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load plans\");\n                return BadRequest(new { message = \"Failed to load plans\", error = ex.Message });\n            }\n        }\n\n        [HttpGet(\"{planId}/permissions\")]\n        public async Task<IActionResult> GetPlanPermissions(Guid planId)\n        {\n            try\n            {\n               // var permissions = await _planService.GetPermissionsForPlanAsync(planId);\n                var permissions = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n\n                return Ok(permissions);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load permissions for plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to load permissions\", error = ex.Message });\n            }\n        }\n\n     \n        [HttpPost(\"Create\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> CreatePlan([FromBody] CreatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var newPlanId = await _planService.CreatePlanAsync(dto);\n                return Ok(new { id = newPlanId, message = \"Plan created successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to create plan {PlanName}\", dto.Name);\n                return BadRequest(new { message = \"Failed to create plan\", error = ex.Message });\n            }\n        }\n\n        [HttpPut(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlan(Guid planId, [FromBody] UpdatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var updated = await _planService.UpdatePlanAsync(planId, dto);\n                if (!updated)\n                    return NotFound(new { message = \"Plan not found\" });\n\n                return Ok(new { message = \"Plan updated successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to update plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to update plan\", error = ex.Message });\n            }\n        }\n\n        [HttpDelete(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> DeletePlan(Guid planId)\n        {\n            try\n            {\n                var deleted = await _planService.DeletePlanAsync(planId);\n                if (!deleted)\n                    return NotFound(new { message = \"Plan not found or already inactive\" });\n                // ‚úÖ Clear cache when plan is deleted\n                _permissionCacheService.ClearPlanPermissionsCache(planId);\n                return Ok(new { message = \"Plan deleted successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to delete plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to delete plan\", error = ex.Message });\n            }\n        }\n      \n        [HttpGet(\"me/permissions\")]\n        public async Task<IActionResult> GetMyPlanPermissions(CancellationToken ct)\n        {\n            var role = User.FindFirst(\"role\")?.Value ?? string.Empty;\n\n            // Admin-like roles don't need a plan\n            if (role is \"superadmin\" or \"admin\" or \"partner\" or \"reseller\")\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = new[] { \"*\" }\n                });\n\n            var planIdStr = User.FindFirst(\"plan_id\")?.Value;\n            if (!Guid.TryParse(planIdStr, out var planId))\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = Array.Empty<string>()\n                });\n\n            // permissions (cached)\n            var permissionEntities = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n            var codes = permissionEntities\n                .Where(p => p.IsActive)\n                .Select(p => p.Code)\n                .Distinct()\n                .ToList();\n\n            // ‚úÖ Fetch the plan once and return it as PlanDto\n            var planDto = await _planService.GetByIdAsync(planId, ct);\n\n            return Ok(new\n            {\n                planId,\n                plan = planDto,     // PlanDto or null\n                permissions = codes\n            });\n        }\n\n        // üìÑ Features/AccessControl/Controllers/PlanController.cs\n        [HttpPut(\"{planId:guid}/permissions\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlanPermissions(\n            Guid planId,\n            [FromBody] UpdatePlanPermissionsRequest body,\n            CancellationToken ct)\n        {\n            var actor = User?.Identity?.Name ?? \"system\";\n            await _planService.UpdatePlanPermissionsAsync(\n                planId,\n                body.PermissionIds,     // must be named PermissionIds\n                body.ReplaceAll,        // default true\n                actor,\n                ct);\n\n            return NoContent(); // 204\n        }\n\n        // üìÑ Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs\n        public sealed class UpdatePlanPermissionsRequest\n        {\n            public List<Guid> PermissionIds { get; set; } = new();\n            public bool ReplaceAll { get; set; } = true;\n        }\n\n\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/UserPermissionsController.cs",
      "sha256": "950672bd933736c854e3a9e88b13449a6458b03a05c906c78e9c5916d8c48787",
      "language": "csharp",
      "size": 7589,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    /// <summary>\n    /// Manage per-user permission overrides.\n    ///\n    /// Important:\n    /// - We do NOT calculate effective permissions here.\n    ///   Plan ‚Üí permissions is handled by Plan/AccessControl services.\n    /// - This controller only manages rows in UserPermission (allow/deny overrides).\n    ///   The UI can merge:\n    ///     a) plan permissions  + \n    ///     b) these overrides\n    ///   to show the final state for each feature.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/users/{userId:guid}/permissions\")]\n    [Authorize(Roles = \"admin\")]\n    public sealed class UserPermissionsController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public UserPermissionsController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // --------- DTOs (you can later move them to Features/AccessControl/DTOs) ---------\n\n        public sealed class UserPermissionOverrideDto\n        {\n            public Guid PermissionId { get; set; }\n            public string Code { get; set; } = string.Empty;\n            public string Name { get; set; } = string.Empty;\n\n            /// <summary>\n            /// true  = explicit allow\n            /// false = explicit deny\n            /// </summary>\n            public bool IsGranted { get; set; }\n\n            /// <summary>\n            /// true  = override is logically removed (soft delete)\n            /// false = active override\n            /// </summary>\n            public bool IsRevoked { get; set; }\n\n            public DateTime AssignedAt { get; set; }\n            public string? AssignedBy { get; set; }\n        }\n\n        public sealed class UpsertUserPermissionRequest\n        {\n            public Guid PermissionId { get; set; }\n\n            /// <summary>\n            /// true  = allow\n            /// false = deny\n            /// </summary>\n            public bool IsGranted { get; set; }\n        }\n\n        // ---------------- GET: list overrides for a user ----------------\n\n        /// <summary>\n        /// Returns all active overrides for the given user.\n        /// The UI should combine this with plan permissions to show final state.\n        /// </summary>\n        [HttpGet]\n        public async Task<ActionResult<List<UserPermissionOverrideDto>>> GetOverridesForUser(\n            Guid userId,\n            CancellationToken ct)\n        {\n            // Ensure the user exists (optional but nice for admin UX)\n            var userExists = await _db.Set<User>()\n                .AnyAsync(u => u.Id == userId, ct);\n\n            if (!userExists)\n            {\n                return NotFound($\"User {userId} not found.\");\n            }\n\n            var overrides = await _db.Set<UserPermission>()\n                .AsNoTracking()\n                .Where(up => up.UserId == userId && !up.IsRevoked)\n                .Include(up => up.Permission)\n                .OrderBy(up => up.Permission.Code)\n                .Select(up => new UserPermissionOverrideDto\n                {\n                    PermissionId = up.PermissionId,\n                    Code = up.Permission.Code,\n                    Name = up.Permission.Name,\n                    IsGranted = up.IsGranted,\n                    IsRevoked = up.IsRevoked,\n                    AssignedAt = up.AssignedAt,\n                    AssignedBy = up.AssignedBy\n                })\n                .ToListAsync(ct);\n\n            return overrides;\n        }\n\n        // ---------------- POST: create/update override ----------------\n\n        /// <summary>\n        /// Create or update an override for the given user & permission.\n        /// If row exists, we update IsGranted and clear IsRevoked.\n        /// </summary>\n        [HttpPost]\n        public async Task<ActionResult<UserPermissionOverrideDto>> UpsertOverride(\n            Guid userId,\n            [FromBody] UpsertUserPermissionRequest request,\n            CancellationToken ct)\n        {\n            if (request.PermissionId == Guid.Empty)\n            {\n                return BadRequest(\"PermissionId is required.\");\n            }\n\n            var user = await _db.Set<User>()\n                .FirstOrDefaultAsync(u => u.Id == userId, ct);\n\n            if (user is null)\n            {\n                return NotFound($\"User {userId} not found.\");\n            }\n\n            var permission = await _db.Set<Permission>()\n                .FirstOrDefaultAsync(p => p.Id == request.PermissionId, ct);\n\n            if (permission is null)\n            {\n                return NotFound($\"Permission {request.PermissionId} not found.\");\n            }\n\n            var existing = await _db.Set<UserPermission>()\n                .FirstOrDefaultAsync(\n                    up => up.UserId == userId && up.PermissionId == request.PermissionId,\n                    ct);\n\n            if (existing is null)\n            {\n                existing = new UserPermission\n                {\n                    Id = Guid.NewGuid(),\n                    UserId = userId,\n                    PermissionId = request.PermissionId,\n                    IsGranted = request.IsGranted,\n                    IsRevoked = false,\n                    AssignedAt = DateTime.UtcNow,\n                    AssignedBy = User?.Identity?.Name ?? \"system\"\n                };\n\n                await _db.Set<UserPermission>().AddAsync(existing, ct);\n            }\n            else\n            {\n                existing.IsGranted = request.IsGranted;\n                existing.IsRevoked = false;\n                existing.AssignedAt = DateTime.UtcNow;\n                existing.AssignedBy = User?.Identity?.Name ?? existing.AssignedBy;\n            }\n\n            await _db.SaveChangesAsync(ct);\n\n            var dto = new UserPermissionOverrideDto\n            {\n                PermissionId = existing.PermissionId,\n                Code = permission.Code,\n                Name = permission.Name,\n                IsGranted = existing.IsGranted,\n                IsRevoked = existing.IsRevoked,\n                AssignedAt = existing.AssignedAt,\n                AssignedBy = existing.AssignedBy\n            };\n\n            return Ok(dto);\n        }\n\n        // ---------------- DELETE: soft-remove override ----------------\n\n        /// <summary>\n        /// Soft deletes an override by setting IsRevoked = true.\n        /// Effective permission will fall back to plan-level mapping.\n        /// </summary>\n        [HttpDelete(\"{permissionId:guid}\")]\n        public async Task<IActionResult> DeleteOverride(\n            Guid userId,\n            Guid permissionId,\n            CancellationToken ct)\n        {\n            var overrideRow = await _db.Set<UserPermission>()\n                .FirstOrDefaultAsync(\n                    up => up.UserId == userId && up.PermissionId == permissionId,\n                    ct);\n\n            if (overrideRow is null)\n            {\n                return NotFound();\n            }\n\n            overrideRow.IsRevoked = true;\n            // Optional: also reset grant flag ‚Äì your entitlement logic can ignore revoked rows anyway\n            // overrideRow.IsGranted = false;\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/CreatePlanDto.cs",
      "sha256": "15d5b4b092dc0019db6a3e33fc6ea49a5bd2e02c9c4fabde02403dc9c32feb90",
      "language": "csharp",
      "size": 320,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class CreatePlanDto\n    {\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\"\n        public string Name { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/GroupedPermissionDto.cs",
      "sha256": "d31e43145b8ed5908bd705af1dc96740d163615a183c30dc69b6d72097d37a76",
      "language": "csharp",
      "size": 255,
      "content": "using xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class GroupedPermissionDto\n    {\n        public string Group { get; set; }\n        public List<Permission> Features { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionDto.cs",
      "sha256": "46bfdeaa2a7dfa7bdaa56ed6c991868bae5fcc8ffb88cff1cc82d329e51eb92f",
      "language": "csharp",
      "size": 353,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PermissionDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionSummaryDto.cs",
      "sha256": "2ace6d04b01d7f967838d51fe0d7e0e0650479e1663c18f2559ca8246adf3e55",
      "language": "csharp",
      "size": 607,
      "content": "// üìÑ Features/AccessControl/DTOs/PermissionSummaryDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    /// <summary>\n    /// Flat DTO used by the Permissions admin grid.\n    /// </summary>\n    public sealed class PermissionSummaryDto\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } = default!;\n        public string Name { get; set; } = default!;\n\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionUpsertDto.cs",
      "sha256": "bc57fdb6495dbd689898b10e6b6afe9a7fc02feca1e3453f8a10250f48651a02",
      "language": "csharp",
      "size": 797,
      "content": "// üìÑ Features/AccessControl/DTOs/PermissionUpsertDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    /// <summary>\n    /// Payload for creating or updating a Permission.\n    /// Code is immutable once created (UI disables it for edit).\n    /// </summary>\n    public sealed class PermissionUpsertDto\n    {\n        [Required]\n        [MaxLength(200)]\n        public string Code { get; set; } = default!; // e.g. \"MESSAGING.SEND.TEXT\"\n\n        [Required]\n        [MaxLength(200)]\n        public string Name { get; set; } = default!; // friendly label\n\n        [MaxLength(200)]\n        public string? Group { get; set; } // \"Messaging\", \"Campaigns\", etc.\n\n        [MaxLength(1000)]\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PlanDto.cs",
      "sha256": "87bcc89fbc963d131fcc246a1bde5d2d1a9198a61fac73a55b6b985644c8ee89",
      "language": "csharp",
      "size": 303,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PlanDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/RoleDto.cs",
      "sha256": "890bec8d90e7068a2c8e49c4249b761506cdb9c26b2fd5a470bf14c6013954cf",
      "language": "csharp",
      "size": 479,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs;\n\n// DTO: Role details used across layers\npublic class RoleDto\n{\n    /// <summary>Unique identifier of the role.</summary>\n    public Guid Id { get; set; }\n\n   \n    public string Role { get; set; } = default!;\n\n   \n    public string Code { get; set; } = default!;\n\n   \n    public string? Description { get; set; }\n\n    \n    public bool IsActive { get; set; }\n\n       public RoleDto() { }\n\n    // Convenience constructor\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanDto.cs",
      "sha256": "e4a09d8fd1c1ff0cb720be4ff2ba80df60e06fc54795e1e2a23fd06b16bf8956",
      "language": "csharp",
      "size": 273,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanDto\n    {\n        public string Name { get; set; }\n        public string Code { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs",
      "sha256": "fb7246c045dc67de4e1841a2e77749da563069e5e02ebe856df70f4bb28e9c42",
      "language": "csharp",
      "size": 269,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanPermissionsRequest\n    {\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true; // optional flag your controller reads\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateRolePermissionsDto.cs",
      "sha256": "e00530db11a422793d96b8905211218a03a8e810c601034c76b75fbba37d40db",
      "language": "csharp",
      "size": 291,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdateRolePermissionsDto\n    {\n        [Required]\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateUserPermissionsDto.cs",
      "sha256": "aea509c8f87c9fda5473534a5c9926fd3af7d09a1041c2832071d1aa5ba60b31",
      "language": "csharp",
      "size": 416,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UpdateUserPermissionsDto\n    {\n        /// <summary>\n        /// List of Permission.Code values that should be enabled for this user.\n        /// Anything not in this list will be removed.\n        /// </summary>\n        public List<string> PermissionCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpsertPermissionRequest.cs",
      "sha256": "f925b63f73851fa7462e56c3f9b53a56476af6cb976cbe35d813efd03db7889b",
      "language": "csharp",
      "size": 633,
      "content": "// üìÅ Features/AccessControl/DTOs/UpsertPermissionRequest.cs\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpsertPermissionRequest\n    {\n        // Code is required only on create. On update, we ignore it.\n        public string Code { get; set; } = string.Empty;\n\n        public string Name { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Logical group/module/workspace, e.g. \"Messaging\", \"Campaigns\", \"CRM\".\n        /// This maps to Permission.Group in the model.\n        /// </summary>\n        public string? Group { get; set; }\n\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UserPermissions.cs",
      "sha256": "2f1985d1584fedd86c23fe360a05781bd5ab974fe2833c7ba1222e55c531ee6e",
      "language": "csharp",
      "size": 340,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UserPermissionItemDto\n    {\n        public string PermissionCode { get; set; } = default!;\n        public string Name { get; set; } = default!;\n        public string? Description { get; set; }\n        public bool IsAssigned { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UserPermissionSummaryDto.cs",
      "sha256": "9d6539a51791e64bf141f4f8aea394a0befa161294ac9a6e2c794fdbdde78b60",
      "language": "csharp",
      "size": 440,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UserPermissionSummaryDto\n    {\n        public Guid UserId { get; set; }\n        public string UserEmail { get; set; } = default!;\n        public Guid BusinessId { get; set; }\n        public Guid PlanId { get; set; }\n\n        public List<UserPermissionItemDto> Items { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/MakeDump.bat",
      "sha256": "1f0c8a79e7859146dab81f8a13dcdf495c12b54b888024e8500fefb4abd58a9e",
      "language": "bat",
      "size": 1618,
      "content": "@echo off\nREM This script will find relevant source files and output their names and contents into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh and write a small header\n> \"%outputFile%\" (\n    echo Folder and File Content Report\n    echo Root folder: %cd%\n    echo Generated at: %date% %time%\n)\necho. >> \"%outputFile%\"\n\nREM NOTE:\nREM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)\nREM This keeps the file smaller and much easier to review.\n\nREM Loop through all relevant files in the current directory and subdirectories\nREM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML\nfor /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (\n\n    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)\n    echo \"%%F\" | findstr /I /C:\"\\node_modules\\\" /C:\"\\bin\\\" /C:\"\\obj\\\" /C:\"\\.git\\\" /C:\"\\dist\\\" /C:\"\\.vs\\\" >nul\n    if errorlevel 1 (\n        echo ====================================================== >> \"%outputFile%\"\n        echo FILE: %%F >> \"%outputFile%\"\n        echo ====================================================== >> \"%outputFile%\"\n        echo. >> \"%outputFile%\"\n        type \"%%F\" >> \"%outputFile%\" 2>nul\n        echo. >> \"%outputFile%\"\n        echo. >> \"%outputFile%\"\n    )\n)\n\necho Finished! All content has been extracted to %outputFile%\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Permission.cs",
      "sha256": "22c58f1f832014c6129b075f027045a186874bc7c20d0f312befe1d658bb0ab4",
      "language": "csharp",
      "size": 832,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Permission\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // Unique key like \"ViewDashboard\"\n\n        public string Name { get; set; } // Friendly name like \"View Dashboard\"\n\n        public string? Group { get; set; } // Optional grouping, e.g., \"CRM\", \"Catalog\", \"Admin\"\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n\n        public ICollection<UserPermission> UserPermissions { get; set; }\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Plan.cs",
      "sha256": "9f3414b6a49c2c27b0784e659367f5f64258b19e19195a52a4248936020542be",
      "language": "csharp",
      "size": 758,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Plan\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\", \"ADVANCED\"\n        public string Name { get; set; } // Friendly display name\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsInternal { get; set; } = false;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n        public ICollection<Business> Businesses { get; set; } = new List<Business>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/PlanPermission.cs",
      "sha256": "e6e65f0ae33c19e9d2585d73812bcf99ed207d52ac6d804a3c2bf86b3152eca7",
      "language": "csharp",
      "size": 525,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class PlanPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n        public Plan Plan { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin email or ID\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Role.cs",
      "sha256": "4c2e237e65d702febee355976cfc64209fd4cf2d98f87e7ef6de4b199dd048a4",
      "language": "csharp",
      "size": 760,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Role\n    {\n        public Guid Id { get; set; }\n\n        public string Name { get; set; } // e.g. SuperAdmin, PartnerAdmin, BusinessAdmin, Staff, etc.\n\n        public string? Description { get; set; }\n\n        public bool IsSystemDefined { get; set; } = false; // true for SuperAdmin, PartnerAdmin\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n        public ICollection<User> Users { get; set; } // üß© One-to-many relation: Role ‚Üí Users\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/RolePermission.cs",
      "sha256": "d9b31669bec3fbda1b95c89def9a6cc641e0dd21f5e38583b8dae4c0239b9a8a",
      "language": "csharp",
      "size": 619,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class RolePermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid RoleId { get; set; }\n        public Role Role { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin user email or ID\n\n        public bool IsActive { get; set; } = true; // ‚úÖ Add this line\n        public bool IsRevoked { get; set; } = false; // ‚úÖ Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/UserPermission.cs",
      "sha256": "6b85321ec68fced21477222e85ac56594106c4654b5d99061c42bc1c46d876aa",
      "language": "csharp",
      "size": 677,
      "content": "using System;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class UserPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid UserId { get; set; }\n        public User User { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsGranted { get; set; } = true; // ‚úÖ true = allow, false = explicitly deny\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin or system\n\n        public bool IsRevoked { get; set; } = false; // ‚úÖ Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/PermissionConstants.cs",
      "sha256": "47104d91bf08a96917121e247b83aac03fe402f24bb851d3fa4b1b9ee5375469",
      "language": "csharp",
      "size": 1126,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class PermissionConstants\n    {\n        public static class Dashboard\n        {\n            public const string View = \"dashboard.view\";\n        }\n\n        public static class Campaigns\n        {\n            public const string View = \"campaign.view\";\n            public const string Create = \"campaign.create\";\n            public const string Delete = \"campaign.delete\";\n        }\n\n        public static class Products\n        {\n            public const string View = \"product.view\";\n            public const string Create = \"product.create\";\n            public const string Delete = \"product.delete\";\n        }\n\n        public static class CRM\n        {\n            public const string ContactsView = \"contacts.view\";\n            public const string TagsEdit = \"tags.edit\";\n        }\n\n        public static class Admin\n        {\n            public const string BusinessApprove = \"admin.business.approve\";\n            public const string ViewLogs = \"admin.logs.view\";\n        }\n\n        // üÜï Add more modules and permissions here as needed\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/RolePermissionMapping.cs",
      "sha256": "47f001a1b2d6404c28e73be68faf79485c10c1c0a7dab0a5346cc06fff4f049a",
      "language": "csharp",
      "size": 1302,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class RolePermissionMapping\n    {\n        public static readonly Dictionary<string, List<string>> RolePermissions = new()\n        {\n            [\"admin\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.Campaigns.Create,\n                PermissionConstants.Campaigns.Delete,\n                PermissionConstants.Products.View,\n                PermissionConstants.Products.Create,\n                PermissionConstants.Products.Delete,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.CRM.TagsEdit,\n                PermissionConstants.Admin.BusinessApprove,\n                PermissionConstants.Admin.ViewLogs\n            },\n\n            [\"business\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.Products.View\n            },\n\n            [\"staff\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.CRM.ContactsView\n            }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/AccessControlService.cs",
      "sha256": "7715aa1fb932cf63407c3a5e5502b6c3f751e331055be04257cfd120a8671fcb",
      "language": "csharp",
      "size": 7685,
      "content": "//using Microsoft.EntityFrameworkCore;\n//using System.Collections.Generic;\n//using System.Security.Claims;\n//using System.Threading.Tasks;\n\n//using xbytechat.api.Features.AccessControl.Models;\n\n//namespace xbytechat.api.Features.AccessControl.Services\n//{\n//    public class AccessControlService : IAccessControlService\n//    {\n//        private readonly AppDbContext _context;\n\n//        public AccessControlService(AppDbContext context)\n//        {\n//            _context = context;\n//        }\n\n//        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()\n//        {\n//            return await _context.Permissions\n//                .AsNoTracking()\n//                .Where(p => p.IsActive)\n//                .ToListAsync();\n//        }\n//        //public async Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId)\n//        //{\n//        //    // First, check if the user has direct permissions\n//        //    var userPermissions = await _context.UserPermissions\n//        //        .Where(up => up.UserId == userId && up.IsGranted && !up.IsRevoked)\n//        //        .Select(up => up.Permission)\n//        //        .Where(p => p.IsActive)\n//        //        .ToListAsync();\n\n//        //    // If no direct permissions, fall back to role permissions\n//        //    if (!userPermissions.Any())\n//        //    {\n//        //        userPermissions = await _context.RolePermissions\n//        //            .Where(rp => rp.Role.Users.Any(u => u.Id == userId) && rp.IsActive && !rp.IsRevoked)\n//        //            .Select(rp => rp.Permission)\n//        //            .Where(p => p.IsActive)\n//        //            .ToListAsync();\n//        //    }\n\n//        //    return userPermissions;\n//        //}\n       \n        \n       \n//    }\n//}\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Repositories.Interfaces;\nusing System.Linq.Expressions;\n\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class AccessControlService : IAccessControlService\n    {\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IGenericRepository<RolePermission> _rolePermissionRepo;\n        private readonly IGenericRepository<UserPermission> _userPermissionRepo;\n        private readonly IGenericRepository<Permission> _permissionRepo;\n        private readonly AppDbContext _context;\n        public AccessControlService(\n            IGenericRepository<User> userRepo,\n            IGenericRepository<RolePermission> rolePermissionRepo,\n            IGenericRepository<UserPermission> userPermissionRepo,\n            IGenericRepository<Permission> permissionRepo, AppDbContext context\n        )\n        {\n            _userRepo = userRepo;\n            _rolePermissionRepo = rolePermissionRepo;\n            _userPermissionRepo = userPermissionRepo;\n            _permissionRepo = permissionRepo;\n            _context = context;\n        }\n\n        /// <summary>\n        /// ‚úÖ Fetch all permissions (Role-based + User-specific) for a given user\n        /// </summary>\n        //public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        //{\n        //    var user = await _userRepo.FindByIdAsync(userId);\n        //    if (user == null || user.RoleId == null)\n        //        return new List<string>();\n\n        //    // üîê Get Role-based permissions\n        //    var rolePerms = await _rolePermissionRepo\n        //        .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n        //    // üîê Get User-specific extra permissions\n        //    var userPerms = await _userPermissionRepo\n        //        .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n        //    // üß† Merge permission IDs\n        //    var permissionIds = rolePerms.Select(r => r.PermissionId)\n        //        .Union(userPerms.Select(u => u.PermissionId))\n        //        .Distinct()\n        //        .ToList();\n\n        //    // üéØ Get full permission names from Permission table\n        //    var allPerms = await _permissionRepo\n        //        .WhereAsync(p => permissionIds.Contains(p.Id));\n\n        //    return allPerms.Select(p => p.Code).Distinct().ToList(); // Use Code (standard)\n        //}\n\n        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()\n        {\n            return await _permissionRepo.WhereAsync(p => p.IsActive);\n        }\n\n\n        public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        {\n            var user = await _userRepo.FindByIdAsync(userId);\n\n            if (user == null || user.RoleId == null)\n                return new List<string>();\n\n            // üöÄ Bypass: SuperAdmin always gets full access\n            if (user.Role != null && user.Role.Name.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase))\n            {\n                var allPerms = await _permissionRepo.GetAllAsync();\n                return allPerms.Select(p => p.Code).Distinct().ToList();\n            }\n\n            // üîê Get Role-based permissions\n            var rolePerms = await _rolePermissionRepo\n                .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n            // üîê Get User-specific extra permissions\n            var userPerms = await _userPermissionRepo\n                .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n            // üß† Merge permission IDs\n            var permissionIds = rolePerms.Select(r => r.PermissionId)\n                .Union(userPerms.Select(u => u.PermissionId))\n                .Distinct()\n                .ToList();\n\n            // üéØ Get full permission names from Permission table\n            var allAllowedPerms = await _permissionRepo\n                .WhereAsync(p => permissionIds.Contains(p.Id));\n\n            return allAllowedPerms.Select(p => p.Code).Distinct().ToList();\n        }\n\n        public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        {\n            // üöÄ Bypass: SuperAdmin always passes\n            //var roleClaim = user.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Role)?.Value;\n            var roleClaim = user.Claims.FirstOrDefault(c =>\n                c.Type == ClaimTypes.Role || c.Type.Equals(\"role\", StringComparison.OrdinalIgnoreCase)\n            )?.Value;\n\n            if (!string.IsNullOrEmpty(roleClaim) && roleClaim.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase))\n                return true;\n\n            var perms = user.Claims\n                .Where(c => c.Type == \"permissions\")\n                .Select(c => c.Value)\n                .ToList();\n\n            return perms.Contains(requiredPermission);\n        }\n\n        /// <summary>\n        /// ‚úÖ Runtime permission checker (for controller/middleware)\n        /// </summary>\n        //public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        //{\n        //    var perms = user.Claims\n        //        .Where(c => c.Type == \"permissions\")\n        //        .Select(c => c.Value)\n        //        .ToList();\n\n        //    return perms.Contains(requiredPermission);\n        //}\n\n        public async Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId)\n        {\n            if (!planId.HasValue)\n                return new List<string>();\n\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId.Value && pp.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync();\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IAccessControlService.cs",
      "sha256": "a7175ca2ec5d8ac4aae9b09095d675ab36d2c52dd6a62b3d23c6b6990de055e2",
      "language": "csharp",
      "size": 853,
      "content": "//using System.Collections.Generic;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.AccessControl.Models;\n\n//namespace xbytechat.api.Features.AccessControl.Services\n//{\n//    public interface IAccessControlService\n//    {\n//        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n//        Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId);\n\n//    }\n//}\n\n\nusing System.Security.Claims;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IAccessControlService\n    {\n        Task<List<string>> GetPermissionsAsync(Guid userId);\n        bool HasPermission(ClaimsPrincipal user, string permission);\n        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n        Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPermissionService.cs.cs",
      "sha256": "9b90beeeaaf8c3d5077265251342d6ae3cf51e442106d302d2a143b7b00ae417",
      "language": "csharp",
      "size": 1071,
      "content": "// üìÑ Features/AccessControl/Services/IPermissionService.cs.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionService\n    {\n        // Existing grouped view (used by older UI / internal tools)\n        Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync();\n\n        // New flat CRUD endpoints\n        Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(\n            CancellationToken ct = default);\n\n        Task<PermissionSummaryDto> CreateAsync(\n            PermissionUpsertDto dto,\n            CancellationToken ct = default);\n\n        Task<PermissionSummaryDto> UpdateAsync(\n            Guid id,\n            PermissionUpsertDto dto,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Soft-delete / deactivate a permission.\n        /// </summary>\n        Task DeactivateAsync(Guid id, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPlanService.cs",
      "sha256": "52ab5621692cbe324646331e6ac2ee6a1c4b4fe9fdfc5b75e602322a29263f19",
      "language": "csharp",
      "size": 1128,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPlanService\n    {\n        Task<IEnumerable<PlanDto>> GetAllPlansAsync();\n        Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId);\n       // Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task<Guid> CreatePlanAsync(CreatePlanDto dto);\n        Task<bool> DeletePlanAsync(Guid planId);\n        Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto);\n\n        // New methods for permissions\n        Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId);\n        //Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task UpdatePlanPermissionsAsync(\n    Guid planId,\n    IReadOnlyCollection<Guid> permissionIds,\n    bool replaceAll,\n    string? assignedBy,\n    CancellationToken ct);\n        Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionCacheService.cs",
      "sha256": "c268071425295dc74c3f7323b4ebcbc3f413d9eaea473b6b55ada75cc0117ea9",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionCacheService\n    {\n        Task<List<Permission>> GetPlanPermissionsAsync(Guid planId);\n        void ClearPlanPermissionsCache(Guid planId);\n    }\n\n    public class PermissionCacheService : IPermissionCacheService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMemoryCache _cache;\n        private const string CacheKeyPrefix = \"plan_permissions_\";\n\n        public PermissionCacheService(AppDbContext context, IMemoryCache cache)\n        {\n            _context = context;\n            _cache = cache;\n        }\n\n        public async Task<List<Permission>> GetPlanPermissionsAsync(Guid planId)\n        {\n            var cacheKey = $\"{CacheKeyPrefix}{planId}\";\n\n            // Try to get from cache\n            if (_cache.TryGetValue(cacheKey, out List<Permission> cachedPermissions))\n                return cachedPermissions;\n\n            // Fetch from DB\n            var permissions = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => pp.Permission)\n                .ToListAsync();\n\n            // Store in cache\n            _cache.Set(cacheKey, permissions, TimeSpan.FromHours(1));\n\n            return permissions;\n        }\n\n        public void ClearPlanPermissionsCache(Guid planId)\n        {\n            _cache.Remove($\"{CacheKeyPrefix}{planId}\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionService.cs",
      "sha256": "ae835be421a784aa982c1f38056103da2edb440cc7794714ff48ac0c3dfaa0fa",
      "language": "csharp",
      "size": 5344,
      "content": "// üìÑ Features/AccessControl/Services/PermissionService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PermissionService : IPermissionService\n    {\n        private readonly AppDbContext _context;\n\n        public PermissionService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync()\n        {\n            // Legacy / grouped view (kept for compatibility)\n            return await _context.Permissions\n                .Where(p => p.IsActive)\n                .GroupBy(p => p.Group ?? \"Ungrouped\")\n                .Select(g => new GroupedPermissionDto\n                {\n                    Group = g.Key,\n                    Features = g.ToList()\n                })\n                .ToListAsync();\n        }\n\n        public async Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(\n            CancellationToken ct = default)\n        {\n            return await _context.Permissions\n                .OrderBy(p => p.Group)\n                .ThenBy(p => p.Code)\n                .Select(p => new PermissionSummaryDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Group = p.Group,\n                    Description = p.Description,\n                    IsActive = p.IsActive,\n                    CreatedAt = p.CreatedAt\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<PermissionSummaryDto> CreateAsync(\n            PermissionUpsertDto dto,\n            CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var code = dto.Code?.Trim();\n            var name = dto.Name?.Trim();\n\n            if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(name))\n            {\n                throw new InvalidOperationException(\"Code and Name are required.\");\n            }\n\n            var normalizedCode = code.ToUpperInvariant();\n\n            var exists = await _context.Permissions\n                .AnyAsync(p => p.Code == normalizedCode, ct);\n\n            if (exists)\n            {\n                throw new InvalidOperationException(\n                    $\"Permission code '{normalizedCode}' already exists.\");\n            }\n\n            var permission = new Permission\n            {\n                Id = Guid.NewGuid(),\n                Code = normalizedCode,\n                Name = name,\n                Group = string.IsNullOrWhiteSpace(dto.Group)\n                    ? null\n                    : dto.Group!.Trim(),\n                Description = string.IsNullOrWhiteSpace(dto.Description)\n                    ? null\n                    : dto.Description!.Trim(),\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.Permissions.Add(permission);\n            await _context.SaveChangesAsync(ct);\n\n            return ToSummary(permission);\n        }\n\n        public async Task<PermissionSummaryDto> UpdateAsync(\n            Guid id,\n            PermissionUpsertDto dto,\n            CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var permission = await _context.Permissions\n                .FirstOrDefaultAsync(p => p.Id == id, ct);\n\n            if (permission == null)\n                throw new KeyNotFoundException(\"Permission not found.\");\n\n            var name = dto.Name?.Trim();\n            if (string.IsNullOrWhiteSpace(name))\n                throw new InvalidOperationException(\"Name is required.\");\n\n            // Code is intentionally immutable (UI keeps it disabled).\n            permission.Name = name;\n            permission.Group = string.IsNullOrWhiteSpace(dto.Group)\n                ? null\n                : dto.Group!.Trim();\n            permission.Description = string.IsNullOrWhiteSpace(dto.Description)\n                ? null\n                : dto.Description!.Trim();\n\n            await _context.SaveChangesAsync(ct);\n\n            return ToSummary(permission);\n        }\n\n        public async Task DeactivateAsync(Guid id, CancellationToken ct = default)\n        {\n            var permission = await _context.Permissions\n                .FirstOrDefaultAsync(p => p.Id == id, ct);\n\n            if (permission == null)\n                throw new KeyNotFoundException(\"Permission not found.\");\n\n            if (!permission.IsActive)\n                return;\n\n            permission.IsActive = false;\n            await _context.SaveChangesAsync(ct);\n        }\n\n        private static PermissionSummaryDto ToSummary(Permission p)\n        {\n            return new PermissionSummaryDto\n            {\n                Id = p.Id,\n                Code = p.Code,\n                Name = p.Name,\n                Group = p.Group,\n                Description = p.Description,\n                IsActive = p.IsActive,\n                CreatedAt = p.CreatedAt\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PlanService.cs",
      "sha256": "c4e23f3ca4fc67f7f1340294e9d4851943aa91acc14b4d402fe4116f1822a63c",
      "language": "csharp",
      "size": 11164,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PlanService : IPlanService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<PlanService> _logger;\n        private readonly IPermissionCacheService _permissionCacheService;\n\n        public PlanService(AppDbContext context, ILogger<PlanService> logger, IPermissionCacheService permissionCacheService)\n        {\n            _context = context;\n            _logger = logger;\n            _permissionCacheService = permissionCacheService;\n        }\n\n\n\n        public async Task<IEnumerable<PlanDto>> GetAllPlansAsync()\n        {\n            return await _context.Plans\n                .Where(p => p.IsActive)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description,\n                    IsActive = pp.Permission.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default)\n        {\n            return await _context.Plans\n                .AsNoTracking()\n                .Where(p => p.Id == planId)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .FirstOrDefaultAsync(ct);\n        }\n\n        //public async Task<IEnumerable<Permission>> GetPermissionsForPlanAsync(Guid planId)\n        //{\n        //    _logger.LogInformation(\"Fetching permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        return await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId && pp.IsActive)\n        //            .Include(pp => pp.Permission)\n        //            .Select(pp => pp.Permission)\n        //            .AsNoTracking()\n        //            .ToListAsync();\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error fetching permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    _logger.LogInformation(\"Updating permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        // Remove all existing permissions for the plan\n        //        var existing = await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId)\n        //            .ToListAsync();\n\n        //        _context.PlanPermissions.RemoveRange(existing);\n\n        //        // Add new permissions\n        //        var newPlanPermissions = permissionIds.Select(pid => new PlanPermission\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            PlanId = planId,\n        //            PermissionId = pid,\n        //            IsActive = true,\n        //            AssignedAt = DateTime.UtcNow,\n        //            AssignedBy = \"System\"\n        //        });\n\n        //        await _context.PlanPermissions.AddRangeAsync(newPlanPermissions);\n        //        await _context.SaveChangesAsync();\n        //        _logger.LogInformation(\"Permissions updated for plan {PlanId}\", planId);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error updating permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        public async Task<Guid> CreatePlanAsync(CreatePlanDto dto)\n        {\n            _logger.LogInformation(\"Creating new plan: {PlanName}\", dto.Name);\n            try\n            {\n                var plan = new Plan\n                {\n                    Id = Guid.NewGuid(),\n                    Code = dto.Code,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    IsActive = dto.IsActive\n                };\n\n                _context.Plans.Add(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan created with ID: {PlanId}\", plan.Id);\n                return plan.Id;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error creating plan {PlanName}\", dto.Name);\n                throw;\n            }\n        }\n\n        public async Task<bool> DeletePlanAsync(Guid planId)\n        {\n            _logger.LogInformation(\"Deleting (soft) plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null || !plan.IsActive)\n                {\n                    _logger.LogWarning(\"Plan not found or already inactive: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.IsActive = false;\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} soft deleted.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto)\n        {\n            _logger.LogInformation(\"Updating plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null)\n                {\n                    _logger.LogWarning(\"Plan not found: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.Code = dto.Code;\n                plan.Name = dto.Name;\n                plan.Description = dto.Description;\n                plan.IsActive = dto.IsActive;\n\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} updated successfully.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task UpdatePlanPermissionsAsync(\n         Guid planId,\n         IReadOnlyCollection<Guid> permissionIds,\n         bool replaceAll,\n         string? assignedBy,\n         CancellationToken ct)\n        {\n            using var trx = await _context.Database.BeginTransactionAsync(ct);\n\n            var existing = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId)\n                .ToListAsync(ct);\n\n            var want = new HashSet<Guid>(permissionIds);\n            var byPerm = existing.ToDictionary(pp => pp.PermissionId);\n\n            // upsert requested permissions ‚Üí Active\n            foreach (var pid in want)\n            {\n                if (byPerm.TryGetValue(pid, out var row))\n                {\n                    if (!row.IsActive)\n                    {\n                        row.IsActive = true;\n                        row.AssignedAt = DateTime.UtcNow;\n                        row.AssignedBy = assignedBy;\n                        _context.PlanPermissions.Update(row);\n                    }\n                }\n                else\n                {\n                    _context.PlanPermissions.Add(new PlanPermission\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        PermissionId = pid,\n                        IsActive = true,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = assignedBy\n                    });\n                }\n            }\n\n            // replaceAll => deactivate anything not requested\n            if (replaceAll)\n            {\n                foreach (var row in existing)\n                {\n                    if (!want.Contains(row.PermissionId) && row.IsActive)\n                    {\n                        row.IsActive = false;\n                        _context.PlanPermissions.Update(row);\n                    }\n                }\n            }\n\n            await _context.SaveChangesAsync(ct);\n            await trx.CommitAsync(ct);\n\n            // Bust the plan permission cache\n            _permissionCacheService.ClearPlanPermissionsCache(planId);\n        }\n\n\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    // Remove old mappings\n        //    var existing = await _context.PlanPermissions\n        //        .Where(pp => pp.PlanId == planId)\n        //        .ToListAsync();\n        //    _context.PlanPermissions.RemoveRange(existing);\n\n        //    // Add new mappings\n        //    var newMappings = permissionIds.Select(pid => new PlanPermission\n        //    {\n        //        PlanId = planId,\n        //        PermissionId = pid,\n        //        AssignedAt = DateTime.UtcNow,\n        //        AssignedBy = \"system\" // replace with logged-in admin\n        //    });\n\n        //    await _context.PlanPermissions.AddRangeAsync(newMappings);\n        //    await _context.SaveChangesAsync();\n        //    //// Clear cache\n        //    _permissionCacheService.ClearPlanPermissionsCache(planId);\n        //}\n        public async Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description\n                })\n                .ToListAsync();\n        }\n    }\n}\n"
    }
  ]
}
