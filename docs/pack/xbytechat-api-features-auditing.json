{
  "name": "xbytechat-api/Features/Auditing",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Auditing/Controllers/FlowExecutionsController.cs",
      "sha256": "cd9482252d3b70cb771d4826a5a216a9c93b9c5074a29b9ae1dadc60743a3612",
      "language": "csharp",
      "size": 3843,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\nusing xbytechat.api.Features.Auditing.FlowExecutions.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Controllers\n{\n    /// <summary>\n    /// Internal / debugging API for exploring flow execution logs.\n    /// This is not meant to be exposed to end customers directly.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/flow-executions\")]\n    public class FlowExecutionsController : ControllerBase\n    {\n        private readonly IFlowExecutionQueryService _queryService;\n        private readonly ILogger<FlowExecutionsController> _logger;\n\n        public FlowExecutionsController(\n            IFlowExecutionQueryService queryService,\n            ILogger<FlowExecutionsController> logger)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        /// <summary>\n        /// Returns recent flow execution steps for a business, ordered by latest first.\n        /// \n        /// Example:\n        /// GET /api/flow-executions/recent?businessId=...&origin=AutoReply&limit=50\n        /// </summary>\n        [HttpGet(\"recent\")]\n        public async Task<ActionResult<IReadOnlyList<FlowExecutionLogDto>>> GetRecent(\n            [FromQuery] Guid businessId,\n            [FromQuery] FlowExecutionOrigin? origin,\n            [FromQuery] Guid? flowId,\n            [FromQuery] string? contactPhone,\n            [FromQuery] int limit = 50,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            var filter = new FlowExecutionFilter\n            {\n                Origin = origin,\n                FlowId = flowId,\n                ContactPhone = contactPhone,\n                Limit = limit\n            };\n\n            _logger.LogInformation(\n                \"[FlowExecutions] GetRecent biz={BusinessId} origin={Origin} flowId={FlowId} phone={Phone} limit={Limit}\",\n                businessId,\n                origin,\n                flowId,\n                contactPhone,\n                limit);\n\n            var results = await _queryService\n                .GetRecentExecutionsAsync(businessId, filter, ct)\n                .ConfigureAwait(false);\n\n            return Ok(results);\n        }\n\n        [HttpGet(\"run/{runId:guid}\")]\n        public async Task<ActionResult<IReadOnlyList<FlowExecutionLogDto>>> GetRunTimeline(\n           [FromRoute] Guid runId,\n           [FromQuery] Guid businessId,\n           CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required\");\n            }\n\n            if (runId == Guid.Empty)\n            {\n                return BadRequest(\"runId is required\");\n            }\n\n            try\n            {\n                var rows = await _queryService.GetRunTimelineAsync(\n                    businessId,\n                    runId,\n                    ct);\n\n                // Even if no rows, that's a valid 200 with empty list.\n                return Ok(rows);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"[FlowExecutions] Error in GetRunTimeline for BusinessId={BusinessId}, RunId={RunId}\",\n                    businessId,\n                    runId);\n\n                return StatusCode(500, \"Failed to fetch run timeline.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/DTOs/FlowExecutionFilter.cs",
      "sha256": "4b5d3d9134e83169856fccecac2a1e261d435e0aa4ddfc3fd81d79dcd9bc3519",
      "language": "csharp",
      "size": 1252,
      "content": "using System;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.DTOs\n{\n    /// <summary>\n    /// Filter options when querying flow execution logs.\n    /// All fields are optional except BusinessId (which is passed separately).\n    /// </summary>\n    public class FlowExecutionFilter\n    {\n        /// <summary>\n        /// Optional: restrict to a specific origin (AutoReply, Campaign, etc.).\n        /// </summary>\n        public FlowExecutionOrigin? Origin { get; set; }\n\n        /// <summary>\n        /// Optional: restrict to a specific flow id.\n        /// This is usually the CTAFlowConfig.Id or AutoReplyFlow.Id,\n        /// depending on how FlowId is populated.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// Optional: restrict to a specific contact phone number.\n        /// Stored exactly as in FlowExecutionLogs (usually WhatsApp \"from\" number).\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        /// <summary>\n        /// Maximum number of rows to return.\n        /// Defaults to 50; upper capped in service for safety.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/DTOs/FlowExecutionLogDto.cs",
      "sha256": "fe73dcb4340e01df3f5dafa5035c89bd7bca11471759f98c08afe2287908de06",
      "language": "csharp",
      "size": 3418,
      "content": "using System;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.DTOs\n{\n    /// <summary>\n    /// Lightweight projection of a FlowExecutionLog row for debugging/analytics.\n    /// Matches the current FlowExecutionLog entity in CTAFlowBuilder.Models.\n    /// </summary>\n    public class FlowExecutionLogDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Correlation id for a single run of a flow (e.g. one user journey).\n        /// Nullable because older rows might not have it.\n        /// </summary>\n        public Guid? RunId { get; set; }\n\n        /// <summary>\n        /// Flow id being executed:\n        /// - For CTA flows: CTAFlowConfig.Id\n        /// - For AutoReply flows: AutoReplyFlow.Id (depending on how you log it)\n        /// Nullable because your entity uses Guid?.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// If this execution was started by an AutoReply flow, this can carry that flow id.\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// If this execution was started as part of a campaign, this can carry Campaign.Id.\n        /// </summary>\n        public Guid? CampaignId { get; set; }\n\n        /// <summary>\n        /// Optional link to a specific campaign send log.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; set; }\n\n        /// <summary>\n        /// Optional link to a tracking log row (e.g. button click tracking).\n        /// </summary>\n        public Guid? TrackingLogId { get; set; }\n\n        public FlowExecutionOrigin Origin { get; set; }\n\n        /// <summary>\n        /// Contact's WhatsApp phone number (as stored in FlowExecutionLog).\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        public Guid StepId { get; set; }\n\n        public string StepName { get; set; } = string.Empty;\n\n        /// <summary>\n        /// If the step was triggered by a button click, this can store the button text.\n        /// </summary>\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        /// <summary>\n        /// True if the step was executed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Error message when Success == false.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n\n        /// <summary>\n        /// Raw provider response (optional).\n        /// </summary>\n        public string? RawResponse { get; set; }\n\n        /// <summary>\n        /// Optional link back to the originating MessageLog.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n\n        /// <summary>\n        /// Which button index (0..2) was clicked, if applicable.\n        /// </summary>\n        public short? ButtonIndex { get; set; }\n\n        /// <summary>\n        /// Optional request id correlation (for cross-service tracing).\n        /// </summary>\n        public Guid? RequestId { get; set; }\n\n        /// <summary>\n        /// When this step was executed (UTC). Backed by FlowExecutionLog.ExecutedAt.\n        /// </summary>\n        public DateTime ExecutedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/Services/FlowExecutionQueryService.cs",
      "sha256": "934d7e5e7f2aeadcdb33937ca6db5cab3241978f0ffcdcab048e27a2c4e1ba8b",
      "language": "csharp",
      "size": 8423,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Services\n{\n    /// <summary>\n    /// Default implementation of IFlowExecutionQueryService.\n    /// Performs filtered, read-only queries over FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionQueryService : IFlowExecutionQueryService\n    {\n        private readonly AppDbContext _db;\n\n        public FlowExecutionQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRecentExecutionsAsync(\n            Guid businessId,\n            FlowExecutionFilter filter,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            filter ??= new FlowExecutionFilter();\n\n            // Hard cap to avoid accidental huge result sets\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 500)\n            {\n                limit = 500;\n            }\n\n            var query = _db.FlowExecutionLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId);\n\n            if (filter.Origin.HasValue)\n            {\n                query = query.Where(x => x.Origin == filter.Origin.Value);\n            }\n\n            if (filter.FlowId.HasValue)\n            {\n                var flowId = filter.FlowId.Value;\n                // Entity FlowId is Guid?, so we just compare directly.\n                query = query.Where(x => x.FlowId == flowId);\n            }\n\n            if (!string.IsNullOrWhiteSpace(filter.ContactPhone))\n            {\n                var phone = filter.ContactPhone.Trim();\n                query = query.Where(x => x.ContactPhone == phone);\n            }\n\n            // Order by latest execution first, using FlowExecutionLog.ExecutedAt\n            query = query\n                .OrderByDescending(x => x.ExecutedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit);\n\n            var results = await query\n                .Select(x => new FlowExecutionLogDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    RunId = x.RunId,\n                    FlowId = x.FlowId,\n                    AutoReplyFlowId = x.AutoReplyFlowId,\n                    CampaignId = x.CampaignId,\n                    CampaignSendLogId = x.CampaignSendLogId,\n                    TrackingLogId = x.TrackingLogId,\n                    Origin = x.Origin,\n                    ContactPhone = x.ContactPhone,\n                    StepId = x.StepId,\n                    StepName = x.StepName,\n                    TriggeredByButton = x.TriggeredByButton,\n                    TemplateName = x.TemplateName,\n                    TemplateType = x.TemplateType,\n                    Success = x.Success,\n                    ErrorMessage = x.ErrorMessage,\n                    RawResponse = x.RawResponse,\n                    MessageLogId = x.MessageLogId,\n                    ButtonIndex = x.ButtonIndex,\n                    RequestId = x.RequestId,\n                    ExecutedAtUtc = x.ExecutedAt\n                })\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            return results;\n        }\n\n        //public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n        //    Guid businessId,\n        //    Guid runId,\n        //    CancellationToken ct = default)\n        //{\n        //    if (businessId == Guid.Empty)\n        //        throw new ArgumentException(\"BusinessId is required\", nameof(businessId));\n\n        //    if (runId == Guid.Empty)\n        //        throw new ArgumentException(\"RunId is required\", nameof(runId));\n\n        //    var query = _db.FlowExecutionLogs\n        //        .AsNoTracking()\n        //        .Where(x =>\n        //            x.BusinessId == businessId &&\n        //            x.RunId == runId);\n\n        //    // For a timeline we want oldest â†’ newest.\n        //    query = query\n        //        .OrderBy(x => x.ExecutedAt)\n        //        .ThenBy(x => x.Id);\n\n        //    return await query\n        //        .Select(x => new FlowExecutionLogDto\n        //        {\n        //            Id = x.Id,\n        //            RunId = x.RunId,\n        //            BusinessId = x.BusinessId,\n        //            FlowId = x.FlowId,\n        //            AutoReplyFlowId = x.AutoReplyFlowId,\n        //            CampaignId = x.CampaignId,\n        //            Origin = x.Origin,\n\n        //            StepId = x.StepId,\n        //            StepName = x.StepName,\n        //            ContactPhone = x.ContactPhone,\n        //            TriggeredByButton = x.TriggeredByButton,\n        //            TemplateName = x.TemplateName,\n        //            TemplateType = x.TemplateType,\n        //            Success = x.Success,\n        //            ErrorMessage = x.ErrorMessage,\n        //            RawResponse = x.RawResponse,\n        //            MessageLogId = x.MessageLogId,\n        //            ButtonIndex = x.ButtonIndex,\n        //            RequestId = x.RequestId,\n        //            ExecutedAtUtc = x.ExecutedAt\n        //        })\n        //        .ToListAsync(ct)\n        //        .ConfigureAwait(false);\n        //}\n        public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n            Guid businessId,\n            Guid runId,\n            CancellationToken ct = default)\n        {\n            if (runId == Guid.Empty)\n                throw new ArgumentException(\"RunId is required\", nameof(runId));\n\n            // Primary query: business-scoped (what we expect normally)\n            IQueryable<FlowExecutionLog> query = _db.FlowExecutionLogs\n                .AsNoTracking()\n                .Where(x => x.RunId == runId);\n\n            if (businessId != Guid.Empty)\n            {\n                query = query.Where(x => x.BusinessId == businessId);\n            }\n\n            var primary = await query\n                .OrderBy(x => x.ExecutedAt)\n                .ThenBy(x => x.Id)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            // If nothing found, fall back to \"by RunId only\" (no business filter).\n            // This makes the explorer robust against any mismatched BusinessId data.\n            List<FlowExecutionLog> rows;\n            if (primary.Count > 0)\n            {\n                rows = primary;\n            }\n            else\n            {\n                rows = await _db.FlowExecutionLogs\n                    .AsNoTracking()\n                    .Where(x => x.RunId == runId)\n                    .OrderBy(x => x.ExecutedAt)\n                    .ThenBy(x => x.Id)\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n            }\n\n            return rows\n                .Select(x => new FlowExecutionLogDto\n                {\n                    Id = x.Id,\n                    RunId = x.RunId,\n                    BusinessId = x.BusinessId,\n                    FlowId = x.FlowId,\n                    AutoReplyFlowId = x.AutoReplyFlowId,\n                    CampaignId = x.CampaignId,\n                    CampaignSendLogId = x.CampaignSendLogId,\n                    TrackingLogId = x.TrackingLogId,\n                    Origin = x.Origin,\n                    StepId = x.StepId,\n                    StepName = x.StepName,\n                    ContactPhone = x.ContactPhone,\n                    TriggeredByButton = x.TriggeredByButton,\n                    TemplateName = x.TemplateName,\n                    TemplateType = x.TemplateType,\n                    Success = x.Success,\n                    ErrorMessage = x.ErrorMessage,\n                    RawResponse = x.RawResponse,\n                    MessageLogId = x.MessageLogId,\n                    ButtonIndex = x.ButtonIndex,\n                    RequestId = x.RequestId,\n                    ExecutedAtUtc = x.ExecutedAt\n                })\n                .ToList();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/Services/IFlowExecutionQueryService.cs",
      "sha256": "39152ea71e1d5e0622da76c594765c55a889dd175676f056cc875e966c1043f5",
      "language": "csharp",
      "size": 1167,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Services\n{\n    /// <summary>\n    /// Read-only query service for inspecting flow execution logs.\n    /// Used by internal tools / analytics / debug endpoints.\n    /// </summary>\n    public interface IFlowExecutionQueryService\n    {\n        /// <summary>\n        /// Returns recent flow execution steps for a given business,\n        /// ordered by ExecutedAtUtc descending.\n        /// </summary>\n        /// <param name=\"businessId\">The tenant/business id to filter by (required).</param>\n        /// <param name=\"filter\">Optional filters for origin, flow, contact, and limit.</param>\n        Task<IReadOnlyList<FlowExecutionLogDto>> GetRecentExecutionsAsync(\n            Guid businessId,\n            FlowExecutionFilter filter,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n           Guid businessId,\n           Guid runId,\n           CancellationToken ct = default);\n    }\n}\n"
    }
  ]
}
