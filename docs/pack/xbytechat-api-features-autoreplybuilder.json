{
  "name": "xbytechat-api/Features/AutoReplyBuilder",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyFlowsController.cs",
      "sha256": "25ac7814daf6df137e5beb976fe5ba21a8d94fdb458c29a1a8531aea723c3077",
      "language": "csharp",
      "size": 12787,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    /// <summary>\n    /// Controller for AutoReply builder operations:\n    /// - CRUD for AutoReply flows used by the canvas UI\n    /// - Test-match endpoint used by the \"Test Auto-Reply Match\" panel\n    /// </summary>\n    [ApiController]\n    [Route(\"api/autoreplyflows\")]\n    [Authorize]\n    public sealed class AutoReplyFlowsController : ControllerBase\n    {\n        private readonly IAutoReplyFlowService _service;\n        private readonly IAutoReplyRuntimeService _runtime;\n        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n        public AutoReplyFlowsController(\n            IAutoReplyFlowService service,\n            IAutoReplyRuntimeService runtime,\n            ILogger<AutoReplyFlowsController> logger)\n        {\n            _service = service;\n            _runtime = runtime;\n            _logger = logger;\n        }\n\n        // ---------------------------------------------------------\n        // 1) LIST FLOWS  - used when the builder page loads\n        // GET /api/autoreplyflows\n        // ---------------------------------------------------------\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<AutoReplyFlowSummaryDto>>> GetAll(\n            CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var flows = await _service.GetFlowsForBusinessAsync(bizId, ct);\n            return Ok(flows);\n        }\n\n        // ---------------------------------------------------------\n        // 2) GET SINGLE FLOW - used when opening a specific flow\n        // GET /api/autoreplyflows/{id}\n        // ---------------------------------------------------------\n        [HttpGet(\"{id:guid}\")]\n        public async Task<ActionResult<AutoReplyFlowDto>> Get(Guid id, CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var flow = await _service.GetFlowAsync(bizId, id, ct);\n            if (flow is null) return NotFound();\n            return Ok(flow);\n        }\n\n        // ---------------------------------------------------------\n        // 3) CREATE / UPDATE FLOW - used when you click Save in builder\n        // POST /api/autoreplyflows\n        // ---------------------------------------------------------\n        [HttpPost]\n        public async Task<ActionResult<AutoReplyFlowDto>> Save(\n            [FromBody] AutoReplyFlowDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"AutoReplyFlow model invalid: {@ModelState}\", ModelState);\n                return ValidationProblem(ModelState);\n            }\n\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var saved = await _service.SaveFlowAsync(bizId, dto, ct);\n            return Ok(saved);\n        }\n\n        // ---------------------------------------------------------\n        // 3a) BACK-COMPAT ALIAS FOR OLDER FRONTEND\n        // POST /api/autoreplyflows/save\n        // ---------------------------------------------------------\n        [HttpPost(\"save\")]\n        public Task<ActionResult<AutoReplyFlowDto>> SaveAlias(\n            [FromBody] AutoReplyFlowDto dto,\n            CancellationToken ct)\n            => Save(dto, ct);\n\n        // ---------------------------------------------------------\n        // 4) DELETE FLOW\n        // DELETE /api/autoreplyflows/{id}\n        // ---------------------------------------------------------\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete(Guid id, CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            await _service.DeleteFlowAsync(bizId, id, ct);\n            return NoContent();\n        }\n        // ---------------------------------------------------------\n        // 4a) UPDATE FLOW STATUS (ACTIVE / INACTIVE)\n        // PATCH /api/autoreplyflows/{id}/status\n        // ---------------------------------------------------------\n        [HttpPatch(\"{id:guid}/status\")]\n        public async Task<IActionResult> UpdateStatus(\n            Guid id,\n            [FromBody] AutoReplyFlowStatusUpdateDto dto,\n            CancellationToken ct)\n        {\n            if (dto is null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n\n            await _service.SetActiveAsync(\n                bizId,\n                id,\n                dto.IsActive,\n                ct);\n\n            return NoContent();\n        }\n\n        // ---------------------------------------------------------\n        // 5) TEST-MATCH ENDPOINT FOR BUILDER PANEL\n        // POST /api/autoreplyflows/test-match\n        //\n        // Frontend sends: { businessId, incomingText }\n        // Response: { isMatch, flowId, flowName, matchedKeyword, startNodeType, startNodeName }\n        // ---------------------------------------------------------\n        [HttpPost(\"test-match\")]\n        public async Task<ActionResult<AutoReplyTestMatchResponseDto>> TestMatchAsync(\n            [FromBody] AutoReplyTestMatchRequestDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return ValidationProblem(ModelState);\n            }\n\n            _logger.LogInformation(\n                \"üîç AutoReply test-match requested for Business {BusinessId} with text: {Text}\",\n                dto.BusinessId,\n                dto.IncomingText\n            );\n\n            // NOTE: Right now the runtime is mostly stubbed.\n            // This call will later contain the real keyword/flow matching logic.\n            var result = await _runtime.TestMatchAsync(dto.BusinessId, dto.IncomingText, ct);\n\n            var response = new AutoReplyTestMatchResponseDto\n            {\n                IsMatch = result.Handled,\n                FlowId = result.AutoReplyFlowId ?? result.CtaFlowConfigId,\n                FlowName = null, // will be filled when runtime returns metadata\n                MatchedKeyword = result.MatchedKeyword,\n                StartNodeType = null, // will be wired from CTAFlow metadata later\n                StartNodeName = null\n            };\n\n            return Ok(response);\n        }\n    }\n}\n\n\n//using System;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.AutoReplyBuilder.Services;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n//{\n//    /// <summary>\n//    /// Controller for AutoReply builder operations (test match, later maybe listing flows, etc.).\n//    /// </summary>\n//    [ApiController]\n//    [Route(\"api/autoreplyflows\")]\n//    public sealed class AutoReplyFlowsController : ControllerBase\n//    {\n//        private readonly IAutoReplyRuntimeService _autoReplyRuntime;\n//        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n//        public AutoReplyFlowsController(\n//            IAutoReplyRuntimeService autoReplyRuntime,\n//            ILogger<AutoReplyFlowsController> logger)\n//        {\n//            _autoReplyRuntime = autoReplyRuntime;\n//            _logger = logger;\n//        }\n\n//        /// <summary>\n//        /// Test whether a given incoming text would match any AutoReply rule.\n//        /// Used by the AutoReplyBuilder \"Test Auto-Reply Match\" panel.\n//        /// </summary>\n//        [HttpPost(\"test-match\")]\n//        public async Task<ActionResult<AutoReplyTestMatchResponseDto>> TestMatchAsync(\n//            [FromBody] AutoReplyTestMatchRequestDto dto,\n//            CancellationToken ct)\n//        {\n//            if (!ModelState.IsValid)\n//            {\n//                return ValidationProblem(ModelState);\n//            }\n\n//            _logger.LogInformation(\n//                \"üîç AutoReply test-match requested for Business {BusinessId} with text: {Text}\",\n//                dto.BusinessId,\n//                dto.IncomingText\n//            );\n\n//            var result = await _autoReplyRuntime.TestMatchAsync(dto.BusinessId, dto.IncomingText, ct);\n\n//            // For now, runtime always returns NotHandled, so IsMatch will be false.\n//            // Later, when we implement matching, Handled = true will mean a rule matched.\n//            var response = new AutoReplyTestMatchResponseDto\n//            {\n//                IsMatch = result.Handled,\n//                FlowId = result.AutoReplyFlowId ?? result.CtaFlowConfigId,\n//                FlowName = null, // will be populated once runtime can surface flow metadata\n//                MatchedKeyword = result.MatchedKeyword,\n//                StartNodeType = null, // to be filled when CTAFlow metadata is integrated\n//                StartNodeName = null  // same as above\n//            };\n\n//            return Ok(response);\n//        }\n//    }\n//}\n\n\n////using Microsoft.AspNetCore.Authorization;\n////using Microsoft.AspNetCore.Mvc;\n////using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n////using xbytechat.api.Shared;\n////using xbytechat.api.Features.AutoReplyBuilder.Services;\n////using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\n////namespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n////{\n////    [ApiController]\n////    [Route(\"api/autoreplyflows\")]\n////    [Authorize]\n////    public sealed class AutoReplyFlowsController : ControllerBase\n////    {\n////        private readonly IAutoReplyFlowService _service;\n////        private readonly IAutoReplyRuntimeService _runtime;\n////        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n////        public AutoReplyFlowsController(\n////            IAutoReplyFlowService service,\n////            IAutoReplyRuntimeService runtime,\n////            ILogger<AutoReplyFlowsController> logger)\n////        {\n////            _service = service;\n////            _runtime = runtime;\n////            _logger = logger;\n////        }\n\n////        // GET /api/autoreplyflows\n////        [HttpGet]\n////        public async Task<ActionResult<IEnumerable<AutoReplyFlowSummaryDto>>> GetAll(CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            var flows = await _service.GetFlowsForBusinessAsync(bizId, ct);\n////            return Ok(flows);\n////        }\n\n////        // GET /api/autoreplyflows/{id}\n////        [HttpGet(\"{id:guid}\")]\n////        public async Task<ActionResult<AutoReplyFlowDto>> Get(Guid id, CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            var flow = await _service.GetFlowAsync(bizId, id, ct);\n////            if (flow is null) return NotFound();\n////            return Ok(flow);\n////        }\n\n////        // POST /api/autoreplyflows (create or update)\n////        [HttpPost]\n////        public async Task<ActionResult<AutoReplyFlowDto>> Save([FromBody] AutoReplyFlowDto dto, CancellationToken ct)\n////        {\n////            if (!ModelState.IsValid)\n////            {\n////                _logger.LogWarning(\"AutoReplyFlow model invalid: {@ModelState}\", ModelState);\n////                return ValidationProblem(ModelState);\n////            }\n\n////            var bizId = User.GetBusinessId();\n////            var saved = await _service.SaveFlowAsync(bizId, dto, ct);\n////            return Ok(saved);\n////        }\n\n////        // Back-compat alias for older frontend\n////        [HttpPost(\"save\")]\n////        public Task<ActionResult<AutoReplyFlowDto>> SaveAlias([FromBody] AutoReplyFlowDto dto, CancellationToken ct) => Save(dto, ct);\n\n////        // DELETE /api/autoreplyflows/{id}\n////        [HttpDelete(\"{id:guid}\")]\n////        public async Task<IActionResult> Delete(Guid id, CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            await _service.DeleteFlowAsync(bizId, id, ct);\n////            return NoContent();\n////        }\n\n////        // POST /api/autoreplyflows/test-match\n////        [HttpPost(\"test-match\")]\n////        public async Task<ActionResult<AutoReplyMatchResultDto>> TestMatch([FromBody] AutoReplyMatchRequestDto request, CancellationToken ct)\n////        {\n////            var result = await _runtime.FindMatchAsync(request, ct);\n////            return Ok(result);\n////        }\n////    }\n////}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyLogsController.cs",
      "sha256": "73bd3aafc0179cf97c57ab38413426d298cba586c91bbed26edadc7c77b691f8",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    /// <summary>\n    /// Read-only endpoints for AutoReply logs, used by the builder UI.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // same auth pattern as other feature controllers\n    public class AutoReplyLogsController : ControllerBase\n    {\n        private readonly IAutoReplyLogService _logService;\n\n        public AutoReplyLogsController(IAutoReplyLogService logService)\n        {\n            _logService = logService;\n        }\n\n        /// <summary>\n        /// Returns most recent auto-reply triggers for the current business.\n        /// GET /api/autoreplylogs/recent?take=20\n        /// </summary>\n        [HttpGet(\"recent\")]\n        [ProducesResponseType(typeof(IReadOnlyList<AutoReplyLogSummaryDto>), 200)]\n        public async Task<ActionResult<IReadOnlyList<AutoReplyLogSummaryDto>>> GetRecentAsync(\n            [FromQuery] int take = 20,\n            CancellationToken cancellationToken = default)\n        {\n            // BusinessId comes from JWT claims\n            var businessId = User.GetBusinessId();\n\n            if (businessId == Guid.Empty)\n            {\n                return Unauthorized(\"Missing or invalid business id in token.\");\n            }\n\n            var items = await _logService.GetRecentAsync(\n                businessId,\n                take,\n                cancellationToken);\n\n            return Ok(items);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyRuntimeController.cs",
      "sha256": "a9f67fd1830276dc16b500b095809916f5e927e4468ad792e90bb991da999ceb",
      "language": "csharp",
      "size": 2328,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"api/auto-reply-runtime\")]\n    [Authorize]\n    public class AutoReplyRuntimeController : ControllerBase\n    {\n        private readonly IAutoReplyRuntimeService _runtimeService;\n        private readonly ILogger<AutoReplyRuntimeController> _logger;\n\n        public AutoReplyRuntimeController(\n            IAutoReplyRuntimeService runtimeService,\n            ILogger<AutoReplyRuntimeController> logger)\n        {\n            _runtimeService = runtimeService;\n            _logger = logger;\n        }\n\n        // üîÅ Simple button-click matcher (uses the new keyword matcher under the hood)\n        [HttpPost(\"button-click\")]\n        public async Task<ActionResult<AutoReplyMatchResultDto>> HandleButtonClick([FromBody] AutoReplyButtonClickDto dto)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n\n            _logger.LogInformation(\"üîò Button clicked: BusinessId={BusinessId}, Phone={Phone}, Button={ButtonText}, RefMsg={RefMessageId}\",\n                businessId, dto.Phone, dto.ButtonText, dto.RefMessageId?.ToString() ?? \"null\");\n\n            var result = await _runtimeService.FindMatchAsync(\n                new AutoReplyMatchRequestDto\n                {\n                    BusinessId = businessId,\n                    IncomingText = dto.ButtonText ?? string.Empty\n                });\n\n            return Ok(result);\n        }\n\n        // üß™ Manual test (canvas-based flow trigger) - now returns a match preview only\n        [HttpPost(\"flow-by-button\")]\n        public async Task<ActionResult<AutoReplyMatchResultDto>> TriggerFlowByButton([FromBody] AutoReplyButtonClickDto dto)\n        {\n            var businessId = dto.BusinessId != Guid.Empty ? dto.BusinessId : ClaimsBusinessDetails.GetBusinessId(User);\n            var match = await _runtimeService.FindMatchAsync(new AutoReplyMatchRequestDto\n            {\n                BusinessId = businessId,\n                IncomingText = dto.ButtonText ?? string.Empty\n            });\n\n            return Ok(match);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/TemplatesController.cs",
      "sha256": "555d0e0c3deaa65e82290ddcf55e06bb4fa67bbcf43e5b9d56ea5109f7c236b8",
      "language": "csharp",
      "size": 995,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.TemplateMessages.DTOs;\n\nnamespace xbytechat.api.Features.TemplateMessages.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TemplatesController : ControllerBase\n    {\n        private static readonly List<TemplateDto> MockTemplates = new()\n        {\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Welcome Template\",\n                Placeholders = 2\n            },\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Offer Reminder\",\n                Placeholders = 1\n            },\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Follow Up\",\n                Placeholders = 3\n            }\n        };\n\n        [HttpGet]\n        public ActionResult<List<TemplateDto>> GetAll()\n        {\n            return Ok(MockTemplates);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyButtonClickDto.cs",
      "sha256": "c33e345f9a02ff4d627ba42ba92505f5819a034035b07bde678784a244b9d6ac",
      "language": "csharp",
      "size": 412,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class AutoReplyButtonClickDto\n    {\n        public Guid FlowId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string Phone { get; set; } = string.Empty;\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? RefMessageId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowDefinitionDto.cs",
      "sha256": "4c8f724416a637942e075af6566e476ec364a649fe98839fc0288bcefbc2277d",
      "language": "csharp",
      "size": 3849,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Runtime shape for an AutoReply flow definition, deserialized from AutoReplyFlow.NodesJson.\n    /// This is NOT an EF entity and is never mapped to a DB table.\n    /// </summary>\n    public sealed class AutoReplyFlowDefinitionDto\n    {\n        /// <summary>\n        /// Optional ‚Äì if your NodesJson stores the starting node id.\n        /// If your runtime method uses this, it will be populated; otherwise it can stay null/empty.\n        /// </summary>\n        public string? StartNodeId { get; set; }\n\n        /// <summary>\n        /// All nodes that belong to this flow, in whatever order they were saved by the builder.\n        /// ExecuteFlowLinearAsync can order or chain them as it likes.\n        /// </summary>\n        public List<AutoReplyFlowNodeDto> Nodes { get; set; } = new();\n    }\n\n    /// <summary>\n    /// Runtime shape for a single node inside an AutoReply flow.\n    /// This is intentionally kept as a \"flattened\" shape that matches the\n    /// needs of ExecuteFlowLinearAsync:\n    /// - Node type (message / template / set-tag / wait)\n    /// - Content fields for that type\n    /// - Linear chaining info (Order / NextNodeId)\n    /// </summary>\n    public sealed class AutoReplyFlowNodeDto\n    {\n        /// <summary>\n        /// Unique id of the node inside this flow (often the same as the ReactFlow node id).\n        /// </summary>\n        public string Id { get; set; } = null!;\n\n        /// <summary>\n        /// Node type. Expected values (by the new runtime) include:\n        /// \"message\", \"template\", \"set-tag\", \"wait\"\n        /// </summary>\n        public string Type { get; set; } = null!;\n\n        /// <summary>\n        /// Optional friendly name / label shown in the builder UI.\n        /// Not required for runtime, but useful for logs and debugging.\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// Execution order for linear flows, if you are ordering by an explicit number.\n        /// If your runtime doesn‚Äôt use this, it can safely remain 0.\n        /// </summary>\n        public int Order { get; set; }\n\n        // ----- Content for \"message\" nodes -----\n\n        /// <summary>\n        /// Plain text to send for \"message\" type nodes.\n        /// </summary>\n        public string? Text { get; set; }\n\n        // ----- Content for \"template\" nodes -----\n\n        /// <summary>\n        /// Template name for \"template\" type nodes.\n        /// </summary>\n        public string? TemplateName { get; set; }\n\n        /// <summary>\n        /// Optional template namespace / category if you store it.\n        /// </summary>\n        public string? TemplateNamespace { get; set; }\n\n        /// <summary>\n        /// Optional template language code (e.g., \"en\", \"en_US\").\n        /// </summary>\n        public string? TemplateLanguage { get; set; }\n\n        // ----- Content for \"set-tag\" nodes -----\n\n        /// <summary>\n        /// Tag key to set on the contact (e.g., \"lead_stage\").\n        /// </summary>\n        public string? TagKey { get; set; }\n\n        /// <summary>\n        /// Tag value to set on the contact (e.g., \"hot\", \"warm\", \"cold\").\n        /// </summary>\n        public string? TagValue { get; set; }\n\n        // ----- Content for \"wait\" nodes -----\n\n        /// <summary>\n        /// Delay for \"wait\" nodes, in seconds.\n        /// </summary>\n        public int? WaitSeconds { get; set; }\n\n        // ----- Basic chaining -----\n\n        /// <summary>\n        /// Next node id for simple linear flows.\n        /// If your runtime walks the flow by following NextNodeId,\n        /// this will be populated when saving from the builder.\n        /// </summary>\n        public string? NextNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowDto.cs",
      "sha256": "8e0d6126ca3f97d47b6802a4f859f24ab1ba134be25ee89b6746df52ffc34fee",
      "language": "csharp",
      "size": 3507,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Full flow DTO (including nodes) for CRUD in the builder.\n    /// </summary>\n    public sealed class AutoReplyFlowDto\n    {\n        public Guid? Id { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; }\n\n        /// <summary>\n        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\".\n        /// </summary>\n        public string? TriggerKeyword { get; set; }\n\n        public string? IndustryTag { get; set; }\n\n        public string? UseCase { get; set; }\n\n        public bool IsDefaultTemplate { get; set; }\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Defaults to \"Word\" on the backend when not provided.\n        /// </summary>\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher values win. Default is 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n\n        /// <summary>\n        /// When the flow was first created (UTC).\n        /// </summary>\n        public DateTime CreatedAt { get; set; }\n\n        /// <summary>\n        /// When the flow was last updated (UTC). Null if never updated after creation.\n        /// </summary>\n        public DateTime? UpdatedAt { get; set; }\n\n        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n    }\n}\n\n\n//using System;\n//using System.Collections.Generic;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n//{\n//    /// <summary>\n//    /// Full flow DTO (including nodes) for CRUD in the builder.\n//    /// </summary>\n//    public sealed class AutoReplyFlowDto\n//    {\n//        public Guid? Id { get; set; }\n\n//        public string Name { get; set; } = string.Empty;\n\n//        public string? Description { get; set; }\n\n//        public bool IsActive { get; set; }\n\n//        public string? TriggerKeyword { get; set; }\n\n//        public string? IndustryTag { get; set; }\n\n//        public string? UseCase { get; set; }\n\n//        public bool IsDefaultTemplate { get; set; }\n\n//        /// <summary>\n//        /// When the flow was first created (UTC).\n//        /// </summary>\n//        public DateTime CreatedAt { get; set; }\n\n//        /// <summary>\n//        /// When the flow was last updated (UTC). Null if never updated after creation.\n//        /// </summary>\n//        public DateTime? UpdatedAt { get; set; }\n\n//        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n//    }\n//}\n\n\n//using System;\n//using System.Collections.Generic;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n//{\n//    /// <summary>\n//    /// Full flow DTO (including nodes) for CRUD in the builder.\n//    /// </summary>\n//    public sealed class AutoReplyFlowDto\n//    {\n//        public Guid? Id { get; set; }\n//        public string Name { get; set; } = string.Empty;\n//        public string? Description { get; set; }\n//        public bool IsActive { get; set; }\n//        public string? TriggerKeyword { get; set; }\n//        public string? IndustryTag { get; set; }\n//        public string? UseCase { get; set; }\n//        public bool IsDefaultTemplate { get; set; }\n//        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowStatusUpdateDto.cs",
      "sha256": "ba3e8768d81a1c89519ccb2061a16b269765b8bf58fd2874adecfb0e99fe7903",
      "language": "csharp",
      "size": 459,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Simple DTO used to toggle the active status of an AutoReplyFlow\n    /// from the Flows modal (Activate / Deactivate).\n    /// </summary>\n    public sealed class AutoReplyFlowStatusUpdateDto\n    {\n        /// <summary>\n        /// True to mark the flow as active, false to deactivate it.\n        /// </summary>\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowSummaryDto.cs",
      "sha256": "0e7186cfa19fdb74bd8833bdf02389698600b368428dfde4f96d1f8290035540",
      "language": "csharp",
      "size": 944,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Lightweight projection for list screens.\n    /// </summary>\n    public sealed class AutoReplyFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public bool IsActive { get; set; }\n\n        public string? TriggerKeyword { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? UpdatedAt { get; set; }\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Default is \"Word\".\n        /// </summary>\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher values win. Default is 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyLogDto.cs",
      "sha256": "dd13070b128bd950f4a1234e9f4d72c462a54c9add4b75cdd3146d7a05c7c4e6",
      "language": "csharp",
      "size": 1728,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// DTO used to log when an AutoReply flow is triggered for a contact.\n    /// </summary>\n    public class AutoReplyLogDto\n    {\n        /// <summary>\n        /// Primary key of the log entry.\n        /// </summary>\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Business (tenant) that owns this log entry.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact that triggered this auto-reply.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Type of trigger. Currently always \"flow\" since the legacy rule engine is removed.\n        /// </summary>\n        public string TriggerType { get; set; } = \"flow\";\n\n        /// <summary>\n        /// The keyword that matched and caused the flow to trigger.\n        /// </summary>\n        public string TriggerKeyword { get; set; } = string.Empty;\n\n        /// <summary>\n        /// The reply content that was sent (for auditing / analytics).\n        /// </summary>\n        public string ReplyContent { get; set; } = string.Empty;\n\n        /// <summary>\n        /// UTC timestamp when the auto-reply was triggered.\n        /// </summary>\n        public DateTime TriggeredAt { get; set; }\n\n        /// <summary>\n        /// Optional human-friendly name of the flow that handled the message.\n        /// </summary>\n        public string? FlowName { get; set; }\n\n        /// <summary>\n        /// Optional reference to the outbound MessageLog row that represents the sent auto-reply.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyLogSummaryDto.cs",
      "sha256": "2f6883f2a2298da7abbafad539c5126c4a8ec49cd73c4da82f53b7e8d0ed26b8",
      "language": "csharp",
      "size": 644,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Lightweight read model for showing recent auto-reply triggers\n    /// in the builder UI.\n    /// </summary>\n    public sealed class AutoReplyLogSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string? TriggerType { get; set; }\n        public string? TriggerKeyword { get; set; }\n        public string? FlowName { get; set; }\n        public string? ReplyContent { get; set; }\n        public Guid? ContactId { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public DateTime TriggeredAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyMatchRequestDto.cs",
      "sha256": "25f4ad69dbe593fa20f959847f215102af791cbd025936ae93b6658d4344be13",
      "language": "csharp",
      "size": 352,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Minimal request for testing runtime auto-reply flow matching.\n    /// </summary>\n    public sealed class AutoReplyMatchRequestDto\n    {\n        public Guid BusinessId { get; set; }\n        public string IncomingText { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyMatchResultDto.cs",
      "sha256": "6ed66ea75c1c11f1baa718db9002019e755393a93e1dae1b941a84b4c6a2fd65",
      "language": "csharp",
      "size": 598,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Result of a runtime match attempt.\n    /// </summary>\n    public sealed class AutoReplyMatchResultDto\n    {\n        public Guid? FlowId { get; set; }\n        public string? FlowName { get; set; }\n        public string? MatchedKeyword { get; set; }\n        public string? MatchType { get; set; }\n        public Guid? StartNodeId { get; set; }\n        public string? StartNodeType { get; set; }\n        public string? StartNodeConfigJson { get; set; }\n        public bool IsMatch { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyNodeDto.cs",
      "sha256": "82540be38bfc3ac4fea1deafff566c384f68b97f8492374619440e52133f21bd",
      "language": "csharp",
      "size": 689,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// DTO for a single node inside an auto-reply flow.\n    /// Maps directly to <see cref=\"Models.AutoReplyFlowNode\"/> so builder edits round-trip cleanly.\n    /// </summary>\n    public sealed class AutoReplyNodeDto\n    {\n        public Guid? Id { get; set; }\n        public string NodeType { get; set; } = string.Empty;\n        public string? Label { get; set; }\n        public string? NodeName { get; set; }\n        public string? ConfigJson { get; set; }\n        public double PositionX { get; set; }\n        public double PositionY { get; set; }\n        public int Order { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyTestMatchRequestDto.cs",
      "sha256": "a8c862e0b53ae6f8dd27d5e7491b372192ed4bb196cf42e7fb15364c7a82efc6",
      "language": "csharp",
      "size": 692,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Request body for POST /api/autoreplyflows/test-match.\n    /// Sent by the AutoReplyBuilder UI when testing a sample message.\n    /// </summary>\n    public sealed class AutoReplyTestMatchRequestDto\n    {\n        /// <summary>\n        /// Business (tenant) ID ‚Äì taken from the logged-in user's auth context in the UI.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Sample incoming text typed by the user in the \"Test Auto-Reply Match\" panel.\n        /// </summary>\n        public string IncomingText { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyTestMatchResponseDto.cs",
      "sha256": "c52ef35fdd714cd41dcb48bd3729017170cbec767dbd748c362495b94ba9f5a3",
      "language": "csharp",
      "size": 1244,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Response shape for POST /api/autoreplyflows/test-match.\n    /// This is what the AutoReplyBuilder UI expects in testResult.\n    /// </summary>\n    public sealed class AutoReplyTestMatchResponseDto\n    {\n        /// <summary>\n        /// True if a matching AutoReply flow was found for the given text.\n        /// </summary>\n        public bool IsMatch { get; set; }\n\n        /// <summary>\n        /// The matched AutoReply flow ID, if any.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// The matched AutoReply flow name, if available.\n        /// </summary>\n        public string? FlowName { get; set; }\n\n        /// <summary>\n        /// The keyword or rule that matched, for display/debugging.\n        /// </summary>\n        public string? MatchedKeyword { get; set; }\n\n        /// <summary>\n        /// The type of the Start node (e.g. \"message\", \"template\", etc.).\n        /// </summary>\n        public string? StartNodeType { get; set; }\n\n        /// <summary>\n        /// The name/label of the Start node.\n        /// </summary>\n        public string? StartNodeName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowExecutionContextDto.cs",
      "sha256": "46002b4a0231f0341915cd9d899d5264fb27bdaa0b829348f628f9e655a274fc",
      "language": "csharp",
      "size": 1390,
      "content": "using System;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Runtime-only context for executing an AutoReply flow.\n    /// This is NOT an EF entity ‚Äì it will never create a DB table.\n    /// </summary>\n    public class FlowExecutionContextDto\n    {\n        /// <summary>\n        /// The AutoReply flow being executed (DB entity loaded from AutoReplyFlow table).\n        /// </summary>\n        public AutoReplyFlow Flow { get; set; } = null!;\n\n        /// <summary>\n        /// Business (tenant) ID for scoping.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact ID in your CRM / Contacts table.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (MSISDN) of the contact.\n        /// </summary>\n        public string ContactPhone { get; set; } = null!;\n\n        /// <summary>\n        /// Channel source, e.g. \"whatsapp\". Kept flexible for future multi-channel.\n        /// </summary>\n        public string SourceChannel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Optional industry tag (restaurant, clinic, etc.) for analytics / specialization.\n        /// </summary>\n        public string IndustryTag { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ButtonChoiceNodeConfig.cs",
      "sha256": "a573ed18c3b3cce438f3f126b958408f9c6245ac01be98c3db1d0c4a92adbb18",
      "language": "csharp",
      "size": 577,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ButtonChoiceNodeConfig\n    {\n        public string PromptText { get; set; } = \"Please choose an option:\";\n\n        public List<ButtonOption> Options { get; set; } = new();\n    }\n\n    public class ButtonOption\n    {\n        public string Label { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n\n        // Optional metadata to control button behavior\n        public string? NextStepHint { get; set; } // Can guide user or be used for logging\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ConditionNodeConfig.cs",
      "sha256": "836736c40f25f700d3a84836ee147930568713f5f623bcdc1569b42ff5b4432e",
      "language": "csharp",
      "size": 306,
      "content": "using System.Collections.Generic;\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ConditionNodeConfig\n    {\n    \n        public string InputKey { get; set; } = \"buttonText\";\n\n        public Dictionary<string, string> PathMap { get; set; } = new();\n       \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/DecisionNodeConfig.cs",
      "sha256": "5575668b5865a5bb2847165208e60278c44386e8f710abb968606e22bb52fe70",
      "language": "csharp",
      "size": 418,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class DecisionNodeConfig\n    {\n        public string ConditionType { get; set; } = \"keyword\"; // or \"tag\", \"time\", \"plan\", etc.\n        public string Parameter { get; set; } = string.Empty;   // e.g. \"yes\", \"vip\", \"evening\"\n        public string SourceChannel { get; set; } = \"whatsapp\"; // Optional for multi-channel control\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/FormInputNodeConfig.cs",
      "sha256": "34b1ef9a54bc19dbb2163a80371edaf8d5bf75420e9924e90e82762fa4831216",
      "language": "csharp",
      "size": 596,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class FormInputNodeConfig\n    {\n        public string QuestionText { get; set; } = \"Please enter your response:\";\n\n        public string FieldKey { get; set; } = \"customer_name\";\n        // Used for storing user response under a label\n\n        public string? ValidationRegex { get; set; }\n        // Optional, e.g., @\"^[0-9]{10}$\" for phone numbers\n\n        public string? PlaceholderHint { get; set; }\n        // e.g., \"Full Name\", \"10-digit Phone\"\n\n        public bool IsRequired { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/FormNodeConfig.cs",
      "sha256": "f839475742eb0fc23ab0c6e58e1f23a0583e4b649301ac588feb0808dd1c243d",
      "language": "csharp",
      "size": 818,
      "content": "using System.Collections.Generic;\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class FormNodeConfig\n    {\n        public string Title { get; set; } = \"Please fill out this form\";\n\n        public List<FormFieldConfig> Fields { get; set; } = new();\n\n        public bool SaveToContact { get; set; } = true; // Whether to update contact info\n\n        public string? SubmitMessage { get; set; } = \"Thanks for submitting!\";\n    }\n\n    public class FormFieldConfig\n    {\n        public string Key { get; set; } = string.Empty;      // contactName, email, phone\n        public string Label { get; set; } = string.Empty;    // \"Your Name\"\n        public string Type { get; set; } = \"text\";           // text, number, email, etc.\n        public bool Required { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ForwardToAgentNodeConfig.cs",
      "sha256": "486eab52256f3ee2bfea5f06ada3bf8fade4f055f1012e4a1291ac0e61c9f35c",
      "language": "csharp",
      "size": 268,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ForwardToAgentNodeConfig\n    {\n        public string? NoteToAgent { get; set; } // Optional instruction for agent\n        public bool MarkAsUrgent { get; set; } = false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/NodeIconMap.cs",
      "sha256": "e56ce9b9bdedf03682aaa6c56815fb85dd510ecd2ec1e4c82f53c0fa5c8f9401",
      "language": "csharp",
      "size": 591,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class NodeIconMap\n    {\n        public static readonly Dictionary<string, string> IconMap = new()\n        {\n            { NodeTypeEnum.Message, \"üó®Ô∏è\" },\n            { NodeTypeEnum.Template, \"üìÑ\" },\n            { NodeTypeEnum.Tag, \"üè∑Ô∏è\" },\n            { NodeTypeEnum.Wait, \"‚è±Ô∏è\" },\n            { NodeTypeEnum.ButtonChoice, \"üîò\" },\n            { NodeTypeEnum.Branch, \"üåø\" },\n            { NodeTypeEnum.AgentHandoff, \"üë®‚Äçüíº\" },\n            { NodeTypeEnum.End, \"‚õî\" }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/NodeTypeEnum.cs",
      "sha256": "d21739b3b7651f2a026a4e412de76d45fe215ae50907b0c7ee025bee0c1ed189",
      "language": "csharp",
      "size": 572,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class NodeTypeEnum\n    {\n        public const string Message = \"message\";\n        public const string Template = \"template\";\n        public const string Tag = \"tag\";\n        public const string Wait = \"wait\";\n        public const string ButtonChoice = \"button_choice\";\n        public const string Branch = \"branch\";\n        public const string End = \"end\"; // Optional: Used for flow exit\n        public const string AgentHandoff = \"agent_handoff\"; // Optional: Transfer to human\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/RenameFlowDto.cs",
      "sha256": "c2ad4577f121df77190a9463e0eb6528c20054bd0901e7bc9a355aedfb53031c",
      "language": "csharp",
      "size": 146,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class RenameFlowDto\n    {\n        public string NewName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/SaveFlowDto.cs",
      "sha256": "b4b9d49533bad3114236c255a28ecc08bc82a01f1141b981146f320c76cc39f4",
      "language": "csharp",
      "size": 2315,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs\n{\n    public class SaveFlowDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; }\n        public string? TriggerKeyword { get; set; }\n        public List<NodeDto> Nodes { get; set; } = new();\n        public List<EdgeDto> Edges { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n\n        public string? IndustryTag { get; set; }     // e.g. \"restaurant\", \"clinic\", etc.\n        public string? UseCase { get; set; }         // e.g. \"Order Flow\", \"Appointment Flow\"\n        public bool IsDefaultTemplate { get; set; } = false; // Flag for prebuilt templates\n\n    }\n\n    public class NodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n        public string Type { get; set; } = string.Empty;\n        public AutoPositionDto Position { get; set; } = new();\n        public NodeDataDto Data { get; set; } = new();\n    }\n\n    public class AutoPositionDto\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n    }\n\n    public class NodeDataDto\n    {\n        public string Label { get; set; } = string.Empty;\n        public object Config { get; set; } = new { };\n    }\n\n    public class EdgeDto\n    {\n        public string Id { get; set; } = string.Empty;\n        public string Source { get; set; } = string.Empty;\n        public string Target { get; set; } = string.Empty;\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n        public string SourceHandle { get; set; } = string.Empty;\n        public string TargetHandle { get; set; } = string.Empty;\n    }\n}\n\n\n//using System;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs\n//{\n//    public class SaveFlowDto\n//    {\n//        public Guid Id { get; set; }\n//        public Guid BusinessId { get; set; }\n//        public string Name { get; set; } = string.Empty;\n//        public List<Dictionary<string, object>> Nodes { get; set; }\n\n//        public List<Dictionary<string, object>> Edges { get; set; }\n//        public DateTime CreatedAt { get; set; }\n//        public string? TriggerKeyword { get; set; }\n\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/TemplateDto.cs",
      "sha256": "42ae32842447bb89f8178a8bae3c490d1fe646b526c27cbe72571e23536f7116",
      "language": "csharp",
      "size": 240,
      "content": "namespace xbytechat.api.Features.TemplateMessages.DTOs\n{\n    public class TemplateDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public int Placeholders { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/AutoReplyEdgeDto.cs",
      "sha256": "5cbac1daff177794f7ae69aabf6b323f279f0b7132dc060e462a91226849f868",
      "language": "csharp",
      "size": 264,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class AutoReplyEdgeDto\n    {\n        public string Id { get; set; }\n        public string SourceNodeId { get; set; }\n        public string TargetNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/MessageConfig.cs",
      "sha256": "6e7673134b9b3fabb432529dd4b510007ff1d934f016b3a2d831a4503d01c2c7",
      "language": "csharp",
      "size": 201,
      "content": "// MessageConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/RuntimeConfigs.cs",
      "sha256": "280793d810ae7ce0f016f2671b3627cd52a4029b6ea574d0fee20e0c0e11e5ae",
      "language": "csharp",
      "size": 125,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class RuntimeConfigs\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/TagNodeConfig.cs",
      "sha256": "d9fade9fca5845b7cb33279a01288a4dd94a90aaaed58d384a778209656b5ead",
      "language": "csharp",
      "size": 197,
      "content": "// TagConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/TemplateConfig.cs",
      "sha256": "5c7ea8f78b131705f6bccf1ced0e21a754dadf67bbd6420696995f565c07767a",
      "language": "csharp",
      "size": 682,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class TemplateConfig\n    {\n        public string TemplateName { get; set; } = string.Empty;\n        public List<string> Placeholders { get; set; } = new();\n        public string? Language { get; set; } = \"en_US\";\n        public string? ImageUrl { get; set; }\n        public List<TemplateButtonDto>? MultiButtons { get; set; } = new();\n    }\n\n    public class TemplateButtonDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"url\"; // or \"quick_reply\"\n        public string TargetUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/WaitConfig.cs",
      "sha256": "afe336952d0d4959422bbbc499884b286291888fcbd64dd068f26013160261c6",
      "language": "csharp",
      "size": 179,
      "content": "// WaitConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/Enum/NodeTypes.cs",
      "sha256": "94b210bd5bbbbce823c3a1beb8172eddf708305bfbb8b897d1e3c7ef10097b36",
      "language": "csharp",
      "size": 538,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.Enum\n{\n    public class NodeTypes\n    {\n        public const string Start = \"start\";\n        public const string Message = \"message\";\n        public const string Template = \"template\";\n        public const string Wait = \"wait\";\n        public const string Tag = \"tag\";\n        public const string Agent = \"agent\";\n        public const string Condition = \"condition\"; // Coming soon\n        public const string Form = \"form\";           // For ‚ÄúAsk Name‚Äù, ‚ÄúAsk Email‚Äù\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlow.cs",
      "sha256": "4010a313f312dd02ea7373389accf18917c52426f75519fa7691d773cb7e60ce",
      "language": "csharp",
      "size": 3631,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Models\n{\n    public class AutoReplyFlow\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public string Name { get; set; } = string.Empty;\n\n        [Required]\n        public string NodesJson { get; set; } = string.Empty;\n\n        [Required]\n        public string EdgesJson { get; set; } = string.Empty;\n\n        // Stored in UTC; set on first create\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // Nullable; updated on every SaveFlowAsync\n        public DateTime? UpdatedAt { get; set; }\n\n        /// <summary>\n        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\"\n        /// </summary>\n        public string? TriggerKeyword { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        // Optional metadata for templates / catalog\n        public string? IndustryTag { get; set; }    // e.g., \"restaurant\", \"clinic\", \"education\"\n        public string? UseCase { get; set; }        // e.g., \"Order Flow\", \"Booking Flow\"\n\n        /// <summary>\n        /// Flag to indicate system-provided template (vs user-created).\n        /// </summary>\n        public bool IsDefaultTemplate { get; set; } = false;\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Default: \"Word\".\n        /// </summary>\n        [MaxLength(32)]\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher value wins.\n        /// Default: 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n\n        /// <summary>\n        /// Legacy alias for TriggerKeyword; still populated for older code paths.\n        /// </summary>\n        public string? Keyword { get; set; }\n    }\n}\n\n\n\n\n//using System;\n//using System.ComponentModel.DataAnnotations;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Flows.Models\n//{\n//    public class AutoReplyFlow\n//    {\n//        [Key]\n//        public Guid Id { get; set; }\n\n//        public Guid BusinessId { get; set; }\n\n//        [Required]\n//        public string Name { get; set; } = string.Empty;\n\n//        [Required]\n//        public string NodesJson { get; set; } = string.Empty;\n\n//        [Required]\n//        public string EdgesJson { get; set; } = string.Empty;\n\n//        // Stored in UTC; set on first create\n//        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n//        // Nullable; updated on every SaveFlowAsync\n//        public DateTime? UpdatedAt { get; set; }\n\n//        /// <summary>\n//        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\"\n//        /// </summary>\n//        public string? TriggerKeyword { get; set; }\n\n//        public bool IsActive { get; set; } = true;\n\n//        // Optional metadata for templates / catalog\n//        public string? IndustryTag { get; set; }    // e.g., \"restaurant\", \"clinic\", \"education\"\n//        public string? UseCase { get; set; }        // e.g., \"Order Flow\", \"Booking Flow\"\n\n//        /// <summary>\n//        /// Flag to indicate system-provided template (vs user-created).\n//        /// </summary>\n//        public bool IsDefaultTemplate { get; set; } = false;\n\n//        /// <summary>\n//        /// Legacy alias for TriggerKeyword; still populated for older code paths.\n//        /// </summary>\n//        public string? Keyword { get; set; }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlowEdge.cs",
      "sha256": "7996bdb8fa1917943e90dad9ad4225984a34b6342eb153028849b30ca63abd7f",
      "language": "csharp",
      "size": 763,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyFlowEdge\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow Flow { get; set; }\n\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n    \n        public string? SourceHandle { get; set; }\n        public string? TargetHandle { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlowNode.cs",
      "sha256": "88a50d45fe3b72f6c3bc0593104b7ee549180c842628cb3d9048c5227a025871",
      "language": "csharp",
      "size": 1013,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyFlowNode\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow Flow { get; set; }\n\n        // üîÑ Use a constrained string or enum (recommended for future)\n        [Required]\n        public string NodeType { get; set; } = string.Empty;\n\n        public string Label { get; set; } = string.Empty;\n\n        public string? NodeName { get; set; } // üÜï Optional internal label for debugging\n\n        [Required]\n        public string ConfigJson { get; set; } = string.Empty;\n\n        public Position Position { get; set; } = new();\n\n        public int Order { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyLog.cs",
      "sha256": "6683278ee0d8c068bb3a8b08629bb11c8b223bb71c9b00f2b1567560ad515d22",
      "language": "csharp",
      "size": 908,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    [Table(\"AutoReplyLogs\")]\n    public class AutoReplyLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string TriggerKeyword { get; set; } = string.Empty; // e.g., \"hi\", \"price\"\n        public string TriggerType { get; set; } = \"flow\";    // \"flow\" or \"rule\"\n\n        public string ReplyContent { get; set; } = string.Empty;    // Plaintext summary of what was sent\n        public string? FlowName { get; set; }                       // Nullable if rule-based\n\n        public Guid? MessageLogId { get; set; }                     // Optional link to MessageLog\n        public DateTime TriggeredAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowNode.cs",
      "sha256": "8991ad6277d58a2785f6a93fd8b8ca815af4ce80351d38f30aaf47890909471f",
      "language": "csharp",
      "size": 318,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class FlowNode\n    {\n        public string Id { get; set; }\n        public string Type { get; set; }\n        public Position Position { get; set; }\n        public Dictionary<string, object> Data { get; set; }  // This should capture config\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowRunResult.cs",
      "sha256": "67982580319a635214c13b2ec05cc279d9afc21fdeb1224248a8060036e27f5c",
      "language": "csharp",
      "size": 463,
      "content": "// File: Features/AutoReplyBuilder/Models/FlowRunResult.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    /// <summary>\n    /// Encapsulates the result of running a visual flow, including agent handoff status.\n    /// </summary>\n    public class FlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n\n        public Guid? HandoffNodeId { get; set; }\n\n        public string? ContextJson { get; set; }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/Position.cs",
      "sha256": "0c352c43f4dfcebdc462622ca0acdcd8c1eaafa07a91a70804793d8c76724201",
      "language": "csharp",
      "size": 176,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class Position\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyFlowRepository.cs",
      "sha256": "d919b1d695c3c29ccc653b806d4884197b3d52fb9eb5f86c0f32f893eb198671",
      "language": "csharp",
      "size": 4350,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\npublic class AutoReplyFlowRepository : IAutoReplyFlowRepository\n{\n    private readonly AppDbContext _context;\n    private readonly ILogger<AutoReplyFlowRepository> _logger;\n\n    public AutoReplyFlowRepository(AppDbContext context, ILogger<AutoReplyFlowRepository> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public async Task<AutoReplyFlow> SaveAsync(AutoReplyFlow flow)\n    {\n        _context.AutoReplyFlows.Add(flow);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"‚ùå Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return flow;\n    }\n\n    public async Task SaveNodesAndEdgesAsync(IEnumerable<AutoReplyFlowNode> nodes, IEnumerable<AutoReplyFlowEdge> edges)\n    {\n        _context.AutoReplyFlowNodes.AddRange(nodes);\n        _context.AutoReplyFlowEdges.AddRange(edges);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"‚ùå Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n    }\n\n    public async Task<List<AutoReplyFlow>> GetAllByBusinessIdAsync(Guid businessId)\n    {\n        return await _context.AutoReplyFlows\n            .Where(f => f.BusinessId == businessId)\n            .OrderByDescending(f => f.CreatedAt)\n            .ToListAsync();\n    }\n\n    public async Task<AutoReplyFlow?> GetByIdAsync(Guid flowId, Guid businessId)\n    {\n        return await _context.AutoReplyFlows\n            .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n    }\n\n    public async Task<int> GetFlowCountAsync(Guid businessId)\n    {\n        return await _context.AutoReplyFlows.CountAsync(f => f.BusinessId == businessId);\n    }\n\n    public async Task<bool> RenameFlowAsync(Guid id, string newName)\n    {\n        var flow = await _context.AutoReplyFlows.FindAsync(id);\n        if (flow == null) return false;\n\n        flow.Name = newName;\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"‚ùå Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return true;\n    }\n\n    public async Task<bool> DeleteFlowAsync(Guid id, Guid businessId)\n    {\n        var flow = await _context.AutoReplyFlows\n            .FirstOrDefaultAsync(f => f.Id == id && f.BusinessId == businessId);\n\n        if (flow == null) return false;\n\n        _context.AutoReplyFlows.Remove(flow);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"‚ùå Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return true;\n    }\n    public async Task<List<AutoReplyFlowNode>> GetNodesByFlowIdAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowNodes\n            .Where(n => n.FlowId == flowId)\n            .ToListAsync();\n    }\n\n    public async Task<List<AutoReplyFlowEdge>> GetEdgesByFlowIdAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowEdges\n            .Where(e => e.FlowId == flowId)\n            .ToListAsync();\n    }\n    public async Task<AutoReplyFlow?> FindFlowByKeywordAsync(Guid businessId, string keyword)\n    {\n        return await _context.AutoReplyFlows\n            .Where(f => f.BusinessId == businessId && f.IsActive && f.TriggerKeyword == keyword)\n            .OrderByDescending(f => f.CreatedAt)\n            .FirstOrDefaultAsync();\n    }\n    public async Task<List<AutoReplyFlowNode>> GetStructuredNodesAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowNodes\n            .Where(n => n.FlowId == flowId)\n            .ToListAsync();\n    }\n\n    public async Task<List<AutoReplyFlowEdge>> GetStructuredEdgesAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowEdges\n            .Where(e => e.FlowId == flowId)\n            .ToListAsync();\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyLogRepository.cs",
      "sha256": "4a8777aecfb95fef141063dfa3475992a3848fdd582209819e66ab552d045f71",
      "language": "csharp",
      "size": 1569,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Models;\nusing xbytechat.api.Shared;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public class AutoReplyLogRepository : IAutoReplyLogRepository\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<AutoReplyLogRepository> _logger;\n\n        public AutoReplyLogRepository(AppDbContext context, ILogger<AutoReplyLogRepository> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task SaveAsync(AutoReplyLogDto dto)\n        {\n            try\n            {\n                var log = new AutoReplyLog\n                {\n                    Id = dto.Id,\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    TriggerKeyword = dto.TriggerKeyword,\n                    TriggerType = dto.TriggerType,\n                    ReplyContent = dto.ReplyContent,\n                    TriggeredAt = dto.TriggeredAt,\n                    FlowName = dto.FlowName,\n                    MessageLogId = dto.MessageLogId\n                };\n\n                _context.AutoReplyLogs.Add(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to save AutoReplyLog\");\n                throw;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyFlowRepository.cs",
      "sha256": "f78ae431c2892c49cc0844c2f19e5df301598c964326722b3ca52aec7e9ba61d",
      "language": "csharp",
      "size": 1161,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories\n{\n    public interface IAutoReplyFlowRepository\n    {\n        Task<AutoReplyFlow> SaveAsync(AutoReplyFlow flow);\n        Task<AutoReplyFlow?> GetByIdAsync(Guid flowId, Guid businessId);\n        Task<List<AutoReplyFlow>> GetAllByBusinessIdAsync(Guid businessId);\n        Task<int> GetFlowCountAsync(Guid businessId);\n        Task<bool> RenameFlowAsync(Guid id, string newName);\n        Task<bool> DeleteFlowAsync(Guid id, Guid businessId);\n        Task SaveNodesAndEdgesAsync(IEnumerable<AutoReplyFlowNode> nodes, IEnumerable<AutoReplyFlowEdge> edges);\n        Task<List<AutoReplyFlowNode>> GetNodesByFlowIdAsync(Guid flowId);\n        Task<List<AutoReplyFlowEdge>> GetEdgesByFlowIdAsync(Guid flowId);\n        Task<AutoReplyFlow?> FindFlowByKeywordAsync(Guid businessId, string keyword);\n        Task<List<AutoReplyFlowNode>> GetStructuredNodesAsync(Guid flowId);\n        Task<List<AutoReplyFlowEdge>> GetStructuredEdgesAsync(Guid flowId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyLogRepository.cs",
      "sha256": "49f1ecf8c4ab7bb6a0122d7d98e22eb4cb6e2b4b522c99c3963ca64d57889264",
      "language": "csharp",
      "size": 255,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public interface IAutoReplyLogRepository\n    {\n        Task SaveAsync(AutoReplyLogDto logDto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyFlowService.cs",
      "sha256": "2145c395e2e5488a5f0e21d854bba3ab8c61fc831b8369e19789c390c8f6d5ef",
      "language": "csharp",
      "size": 9422,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Minimal CRUD service for the Auto-Reply flow builder.\n    /// Keeps one flow -> many nodes persisted in PostgreSQL.\n    /// </summary>\n    public class AutoReplyFlowService : IAutoReplyFlowService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<AutoReplyFlowService> _log;\n\n        public AutoReplyFlowService(AppDbContext db, ILogger<AutoReplyFlowService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task<IReadOnlyList<AutoReplyFlowSummaryDto>> GetFlowsForBusinessAsync(Guid businessId, CancellationToken ct = default)\n        {\n            return await _db.AutoReplyFlows\n                .AsNoTracking()\n                .Where(f => f.BusinessId == businessId)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new AutoReplyFlowSummaryDto\n                {\n                    Id = f.Id,\n                    Name = f.Name,\n                    IsActive = f.IsActive,\n                    TriggerKeyword = f.TriggerKeyword,\n                    CreatedAt = f.CreatedAt,\n                    UpdatedAt = f.UpdatedAt // entity does not currently track updates\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<AutoReplyFlowDto?> GetFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows\n                .AsNoTracking()\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n\n            if (flow == null)\n            {\n                return null;\n            }\n\n            var nodes = await _db.AutoReplyNodes\n                .AsNoTracking()\n                .Where(n => n.FlowId == flowId)\n                .OrderBy(n => n.Order)\n                .ThenBy(n => n.CreatedAt)\n                .ToListAsync(ct);\n\n            return MapToDto(flow, nodes);\n        }\n\n        public async Task<AutoReplyFlowDto> SaveFlowAsync(\n        Guid businessId,\n        AutoReplyFlowDto dto,\n        CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n            if (string.IsNullOrWhiteSpace(dto.Name))\n                throw new ArgumentException(\"Name is required\", nameof(dto));\n\n            _log.LogInformation(\n                \"[AutoReplyFlow] SaveFlowAsync biz={BusinessId} flow={FlowName}\",\n                businessId,\n                dto.Name);\n\n            var flow = dto.Id.HasValue\n                ? await _db.AutoReplyFlows.FirstOrDefaultAsync(\n                    f => f.Id == dto.Id.Value && f.BusinessId == businessId,\n                    ct)\n                : null;\n\n            var isNew = flow == null;\n            if (isNew)\n            {\n                flow = new AutoReplyFlow\n                {\n                    Id = dto.Id ?? Guid.NewGuid(),\n                    BusinessId = businessId,\n                    CreatedAt = DateTime.UtcNow,\n                };\n                _db.AutoReplyFlows.Add(flow);\n            }\n\n            // üîß Core fields\n            flow.Name = dto.Name.Trim();\n            flow.TriggerKeyword = dto.TriggerKeyword?.Trim();\n            flow.Keyword = dto.TriggerKeyword?.Trim(); // legacy alias used elsewhere\n            flow.IsActive = dto.IsActive;\n            flow.IndustryTag = dto.IndustryTag;\n            flow.UseCase = dto.UseCase;\n            flow.IsDefaultTemplate = dto.IsDefaultTemplate;\n\n            // üïí Always stamp \"last updated\"\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            // Ensure required JSON columns never stay null (legacy storage)\n            flow.NodesJson = string.IsNullOrWhiteSpace(flow.NodesJson) ? \"[]\" : flow.NodesJson;\n            flow.EdgesJson = string.IsNullOrWhiteSpace(flow.EdgesJson) ? \"[]\" : flow.EdgesJson;\n\n            // Replace nodes wholesale for now (simple + safe for MVP)\n            var existingNodes = await _db.AutoReplyNodes\n                .Where(n => n.FlowId == flow.Id)\n                .ToListAsync(ct);\n\n            if (existingNodes.Count > 0)\n            {\n                _db.AutoReplyNodes.RemoveRange(existingNodes);\n            }\n\n            var incomingNodes = dto.Nodes ?? new List<AutoReplyNodeDto>();\n\n            var newNodes = incomingNodes.Select((n, index) => new AutoReplyFlowNode\n            {\n                Id = n.Id == null || n.Id == Guid.Empty ? Guid.NewGuid() : n.Id.Value,\n                FlowId = flow.Id,\n                NodeType = n.NodeType,\n                Label = n.Label ?? string.Empty,\n                NodeName = string.IsNullOrWhiteSpace(n.NodeName) ? n.Label : n.NodeName,\n                ConfigJson = string.IsNullOrWhiteSpace(n.ConfigJson) ? \"{}\" : n.ConfigJson,\n                Position = new Position\n                {\n                    X = n.PositionX,\n                    Y = n.PositionY\n                },\n                Order = n.Order != 0 ? n.Order : index,\n                CreatedAt = DateTime.UtcNow\n            }).ToList();\n\n            if (newNodes.Count > 0)\n            {\n                _db.AutoReplyNodes.AddRange(newNodes);\n\n                // üîÅ Keep NodesJson in sync with the rows (only fields runtime cares about)\n                var nodesJsonPayload = newNodes\n                    .Select(n => new\n                    {\n                        Id = (Guid?)n.Id,\n                        NodeType = n.NodeType,\n                        NodeName = n.NodeName,\n                        ConfigJson = n.ConfigJson,\n                        Order = n.Order\n                    })\n                    .ToList();\n\n                flow.NodesJson = System.Text.Json.JsonSerializer.Serialize(nodesJsonPayload);\n            }\n            else\n            {\n                flow.NodesJson = \"[]\";\n            }\n\n            await _db.SaveChangesAsync(ct);\n\n            return MapToDto(flow, newNodes);\n        }\n\n\n\n        public async Task DeleteFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows.FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n            if (flow == null)\n            {\n                _log.LogInformation(\"[AutoReplyFlow] Delete skipped - not found biz={BusinessId} flowId={FlowId}\", businessId, flowId);\n                return;\n            }\n\n            _db.AutoReplyFlows.Remove(flow); // nodes cascade via FK\n            await _db.SaveChangesAsync(ct);\n            _log.LogInformation(\"[AutoReplyFlow] Deleted biz={BusinessId} flowId={FlowId}\", businessId, flowId);\n        }\n        public async Task SetActiveAsync(\n    Guid businessId,\n    Guid flowId,\n    bool isActive,\n    CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n\n            if (flow == null)\n            {\n                _log.LogWarning(\n                    \"[AutoReplyFlow] SetActiveAsync: flow not found. Biz={BusinessId}, Flow={FlowId}\",\n                    businessId,\n                    flowId);\n                return;\n            }\n\n            if (flow.IsActive == isActive)\n            {\n                _log.LogDebug(\n                    \"[AutoReplyFlow] SetActiveAsync: no-op, already IsActive={IsActive}. Biz={BusinessId}, Flow={FlowId}\",\n                    isActive,\n                    businessId,\n                    flowId);\n                return;\n            }\n\n            flow.IsActive = isActive;\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync(ct);\n\n            _log.LogInformation(\n                \"[AutoReplyFlow] SetActiveAsync: updated IsActive={IsActive}. Biz={BusinessId}, Flow={FlowId}\",\n                isActive,\n                businessId,\n                flowId);\n        }\n\n        private static AutoReplyFlowDto MapToDto(\n     AutoReplyFlow flow,\n     IReadOnlyCollection<AutoReplyFlowNode> nodes)\n        {\n            return new AutoReplyFlowDto\n            {\n                Id = flow.Id,\n                Name = flow.Name,\n                IsActive = flow.IsActive,\n                TriggerKeyword = flow.TriggerKeyword ?? flow.Keyword,\n                IndustryTag = flow.IndustryTag,\n                UseCase = flow.UseCase,\n                IsDefaultTemplate = flow.IsDefaultTemplate,\n                CreatedAt = flow.CreatedAt,\n                UpdatedAt = flow.UpdatedAt,\n                Nodes = nodes.Select(n => new AutoReplyNodeDto\n                {\n                    Id = n.Id,\n                    NodeType = n.NodeType,\n                    Label = n.Label,\n                    NodeName = n.NodeName,\n                    ConfigJson = n.ConfigJson,\n                    PositionX = n.Position?.X ?? 0,\n                    PositionY = n.Position?.Y ?? 0,\n                    Order = n.Order\n                }).ToList()\n            };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyLogService.cs",
      "sha256": "62ff3476179f2420bd95eb00c54f7ad8a33f2600eac49979f8a8e0886d429e43",
      "language": "csharp",
      "size": 4764,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Query-only service for reading AutoReplyLogs for analytics / UI.\n    /// </summary>\n    public sealed class AutoReplyLogService : IAutoReplyLogService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly ILogger<AutoReplyLogService> _logger;\n\n        public AutoReplyLogService(\n            AppDbContext dbContext,\n            ILogger<AutoReplyLogService> logger)\n        {\n            _dbContext = dbContext;\n            _logger = logger;\n        }\n\n        public async Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n            Guid businessId,\n            int take,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return Array.Empty<AutoReplyLogSummaryDto>();\n            }\n\n            // Clamp \"take\" to safe range\n            if (take <= 0) take = 20;\n            if (take > 100) take = 100;\n\n            _logger.LogDebug(\n                \"Fetching {Take} recent AutoReplyLogs for BusinessId={BusinessId}\",\n                take, businessId);\n\n            var query = _dbContext.Set<AutoReplyLog>()\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId)\n                .OrderByDescending(x => x.TriggeredAt)\n                .Take(take);\n\n            var items = await query\n                .Select(x => new AutoReplyLogSummaryDto\n                {\n                    Id = x.Id,\n                    TriggerType = x.TriggerType,\n                    TriggerKeyword = x.TriggerKeyword,\n                    FlowName = x.FlowName,\n                    ReplyContent = x.ReplyContent,\n                    ContactId = x.ContactId,\n                    MessageLogId = x.MessageLogId,\n                    TriggeredAt = x.TriggeredAt\n                })\n                .ToListAsync(cancellationToken);\n\n            return items;\n        }\n    }\n}\n\n\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.AutoReplyBuilder.Models;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Services\n//{\n//    /// <summary>\n//    /// Query-only service for reading AutoReplyLogs for analytics / UI.\n//    /// </summary>\n//    public sealed class AutoReplyLogService : IAutoReplyLogService\n//    {\n//        private readonly AppDbContext _dbContext;\n//        private readonly ILogger<AutoReplyLogService> _logger;\n\n//        public AutoReplyLogService(\n//            AppDbContext dbContext,\n//            ILogger<AutoReplyLogService> logger)\n//        {\n//            _dbContext = dbContext;\n//            _logger = logger;\n//        }\n\n//        public async Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n//            Guid businessId,\n//            int take,\n//            CancellationToken cancellationToken = default)\n//        {\n//            if (businessId == Guid.Empty)\n//            {\n//                return Array.Empty<AutoReplyLogSummaryDto>();\n//            }\n\n//            // clamp \"take\" to a safe range\n//            if (take <= 0) take = 20;\n//            if (take > 100) take = 100;\n\n//            _logger.LogDebug(\n//                \"Fetching {Take} recent AutoReplyLogs for BusinessId={BusinessId}\",\n//                take, businessId);\n\n//            var query = _dbContext.Set<AutoReplyLog>()\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId)\n//                .OrderByDescending(x => x.TriggeredAt)\n//                .Take(take);\n\n//            var items = await query\n//                .Select(x => new AutoReplyLogSummaryDto\n//                {\n//                    Id = x.Id,\n//                    TriggerType = x.TriggerType,\n//                    TriggerKeyword = x.TriggerKeyword,\n//                    FlowName = x.FlowName,\n//                    ReplyContent = x.ReplyContent,\n//                    ContactId = x.ContactId,\n//                    MessageLogId = x.MessageLogId,\n//                    TriggeredAt = x.TriggeredAt\n//                })\n//                .ToListAsync(cancellationToken);\n\n//            return items;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyRuntimeResult.cs",
      "sha256": "73f400851fbb9d03de3a8766167d5fff0a8f423760ac0a9e1f73c549d712987d",
      "language": "csharp",
      "size": 3973,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Result of trying to handle an incoming message via AutoReply.\n    /// This is used by the webhook and by the test-match endpoint.\n    /// </summary>\n    public class AutoReplyRuntimeResult\n    {\n        /// <summary>\n        /// True if this incoming message was handled by AutoReply logic\n        /// (either by sending a simple reply or starting a CTA flow).\n        /// </summary>\n        public bool Handled { get; set; }\n\n        /// <summary>\n        /// True if we sent an immediate/simple reply (text/template) as part of handling.\n        /// </summary>\n        public bool SentSimpleReply { get; set; }\n\n        /// <summary>\n        /// True if, instead of only replying once, we started a CTA flow journey.\n        /// </summary>\n        public bool StartedCtaFlow { get; set; }\n\n        /// <summary>\n        /// The AutoReply flow/rule that matched (if any).\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// If a CTA flow was started, this is the CTAFlowConfig.Id that was kicked off.\n        /// </summary>\n        public Guid? CtaFlowConfigId { get; set; }\n\n        /// <summary>\n        /// The keyword or pattern that matched, for debugging/analytics.\n        /// </summary>\n        public string? MatchedKeyword { get; set; }\n\n        /// <summary>\n        /// Optional notes for logging / debugging (e.g. why nothing matched).\n        /// </summary>\n        public string? Notes { get; set; }\n\n        /// <summary>\n        /// (Test-mode only) Type of the first action node we plan to execute\n        /// in the matched flow (e.g. \"message\", \"wait\", \"set-tag\").\n        /// </summary>\n        public string? StartNodeType { get; set; }\n\n        /// <summary>\n        /// (Test-mode only) Display name of the first action node.\n        /// </summary>\n        public string? StartNodeName { get; set; }\n\n        // ---- Helper factories ----\n\n        public static AutoReplyRuntimeResult NotHandled(string? notes = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = false,\n                SentSimpleReply = false,\n                StartedCtaFlow = false,\n                Notes = notes,\n                AutoReplyFlowId = null,\n                CtaFlowConfigId = null,\n                MatchedKeyword = null,\n                StartNodeType = null,\n                StartNodeName = null\n            };\n\n        public static AutoReplyRuntimeResult SimpleReply(\n            Guid? autoReplyFlowId,\n            string? matchedKeyword = null,\n            string? notes = null,\n            string? startNodeType = null,\n            string? startNodeName = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = true,\n                SentSimpleReply = true,\n                StartedCtaFlow = false,\n                AutoReplyFlowId = autoReplyFlowId,\n                CtaFlowConfigId = null,\n                MatchedKeyword = matchedKeyword,\n                Notes = notes,\n                StartNodeType = startNodeType,\n                StartNodeName = startNodeName\n            };\n\n        public static AutoReplyRuntimeResult CtaFlowStarted(\n            Guid? autoReplyFlowId,\n            Guid? ctaFlowConfigId,\n            string? matchedKeyword = null,\n            string? notes = null,\n            string? startNodeType = null,\n            string? startNodeName = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = true,\n                SentSimpleReply = false,\n                StartedCtaFlow = true,\n                AutoReplyFlowId = autoReplyFlowId,\n                CtaFlowConfigId = ctaFlowConfigId,\n                MatchedKeyword = matchedKeyword,\n                Notes = notes,\n                StartNodeType = startNodeType,\n                StartNodeName = startNodeName\n            };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyRuntimeService.cs",
      "sha256": "7e58549520774f608f999c6463dc18dbad0f2a61054d16c309d35127a257015b",
      "language": "csharp",
      "size": 50616,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing System.Text.Json.Serialization;\nusing xbytechat.api.Features.MessagesEngine.Enums;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Default implementation of the AutoReply runtime engine.\n    ///\n    /// Responsibilities:\n    /// - Match inbound text against AutoReplyFlow.TriggerKeyword (builder flows).\n    /// - Provide:\n    ///     * Test-only matching for the AutoReplyBuilder UI (no sending).\n    ///     * Runtime matching for the WhatsApp webhook (executes multi-step flows).\n    ///     * Legacy DTO-based matching for existing APIs (FindMatchAsync).\n    /// - For builder flows, can inspect NodesJson and execute \"message\" / \"template\" /\n    ///   \"tag\" / \"wait\" nodes in order (simple linear runner for now).\n    /// </summary>\n    public sealed class AutoReplyRuntimeService : IAutoReplyRuntimeService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ILogger<AutoReplyRuntimeService> _logger;\n        private readonly IFlowExecutionLogger _flowExecutionLogger;\n        private readonly ICtaFlowRuntimeService _ctaFlowRuntime;\n\n        public AutoReplyRuntimeService(\n            AppDbContext dbContext,\n            IMessageEngineService messageEngine,\n            ILogger<AutoReplyRuntimeService> logger,\n            IFlowExecutionLogger flowExecutionLogger,\n            ICtaFlowRuntimeService ctaFlowRuntime)\n        {\n            _dbContext = dbContext;\n            _messageEngine = messageEngine;\n            _logger = logger;\n            _flowExecutionLogger = flowExecutionLogger;\n            _ctaFlowRuntime = ctaFlowRuntime;\n        }\n\n        // ----------------------------------------------------\n        // 1) Runtime ‚Äì used by the webhook\n        // ----------------------------------------------------\n\n        public async Task<AutoReplyRuntimeResult> TryHandleAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string incomingText,\n            CancellationToken cancellationToken = default)\n        {\n            var text = (incomingText ?? string.Empty).Trim();\n\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(text))\n            {\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"BusinessId was empty or incoming text was blank (runtime).\");\n            }\n\n            _logger.LogInformation(\n                \"ü§ñ AutoReplyRuntime invoked (runtime) for Business={BusinessId}, Contact={ContactId}, Phone={Phone}, Text={Text}\",\n                businessId,\n                contactId,\n                contactPhone,\n                text);\n\n            // Reuse the canonical matching logic (builder flows only)\n            var matchResult = await TestMatchAsync(businessId, text, cancellationToken);\n\n            // ‚õî Only short-circuit when we have NO builder flow id at all.\n            // If AutoReplyFlowId is present, we still try to execute the flow\n            // even if Handled == false.\n            if (!matchResult.Handled && !matchResult.AutoReplyFlowId.HasValue)\n            {\n                _logger.LogDebug(\n                    \"üëÇ AutoReplyRuntime (runtime) found no matching visual flow for Business={BusinessId}\",\n                    businessId);\n\n                return matchResult;\n            }\n\n            _logger.LogInformation(\n                \"ü§ñ AutoReplyRuntime (runtime) matched flow {FlowId} with keyword '{Keyword}'. Notes: {Notes}\",\n                matchResult.AutoReplyFlowId ?? matchResult.CtaFlowConfigId,\n                matchResult.MatchedKeyword,\n                matchResult.Notes);\n\n            // New behaviour: execute the full visual builder flow as a linear sequence.\n            if (matchResult.AutoReplyFlowId.HasValue)\n            {\n                var flowId = matchResult.AutoReplyFlowId.Value;\n\n                var flow = await _dbContext.Set<AutoReplyFlow>()\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(\n                        f => f.Id == flowId && f.BusinessId == businessId,\n                        cancellationToken);\n\n                if (flow == null)\n                {\n                    _logger.LogWarning(\n                        \"AutoReplyRuntime matched flow id {FlowId} but could not reload AutoReplyFlow from DB.\",\n                        flowId);\n\n                    matchResult.SentSimpleReply = false;\n                    // Keep original Handled flag; webhook can decide what to do.\n                    return matchResult;\n                }\n\n                // Extra visibility for debugging\n                var matchMode = string.IsNullOrWhiteSpace(flow.MatchMode) ? \"Word\" : flow.MatchMode;\n                _logger.LogInformation(\n                    \"ü§ñ AutoReplyRuntime (runtime) executing flow {FlowId} '{FlowName}' for Business={BusinessId}, Contact={ContactId}. Mode={MatchMode}, Priority={Priority}, Keyword='{Keyword}'\",\n                    flow.Id,\n                    flow.Name,\n                    businessId,\n                    contactId,\n                    matchMode,\n                    flow.Priority,\n                    matchResult.MatchedKeyword);\n\n                var outcome = await ExecuteFlowLinearAsync(\n                    flow,\n                    businessId,\n                    contactId,\n                    contactPhone,\n                    cancellationToken);\n\n                // Mark as ‚Äúwe responded‚Äù only if at least one step sent something.\n                matchResult.SentSimpleReply = outcome.AnySent;\n                if (outcome.AnySent)\n                {\n                    // Force Handled = true so webhook does NOT fall back\n                    // to the legacy AutomationService greeting.\n                    matchResult.Handled = true;\n                }\n\n                if (!outcome.AnySent)\n                {\n                    _logger.LogWarning(\n                        \"AutoReplyRuntime executed flow {FlowId} for Business={BusinessId} but no messages/templates were sent.\",\n                        flowId,\n                        businessId);\n\n                    return matchResult;\n                }\n\n                _logger.LogInformation(\n                    \"‚úÖ AutoReplyRuntime executed flow {FlowId} for Business={BusinessId}, Contact={ContactId}. Summary={Summary}\",\n                    flowId,\n                    businessId,\n                    contactId,\n                    outcome.Summary ?? \"(no summary)\");\n\n                // üìù Always log the trigger (match + executed steps)\n                await LogAutoReplyAsync(\n                    businessId,\n                    contactId,\n                    matchResult.MatchedKeyword,\n                    flow,\n                    outcome.Summary,\n                    messageLogId: null, // we can wire a real MessageLogId later\n                    ct: cancellationToken);\n\n                return matchResult;\n            }\n\n            // In future we can support direct CTA-flow start via matchResult.CtaFlowConfigId.\n            return matchResult;\n        }\n\n\n        // ----------------------------------------------------\n        // 2) Test mode ‚Äì used by AutoReplyBuilder \"Test Match\"\n        // ----------------------------------------------------\n        public async Task<AutoReplyRuntimeResult> TestMatchAsync(\n            Guid businessId,\n            string incomingText,\n            CancellationToken cancellationToken = default)\n        {\n            var text = (incomingText ?? string.Empty).Trim();\n\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(text))\n            {\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"BusinessId was empty or incoming text was blank (test).\");\n            }\n\n            _logger.LogDebug(\n                \"üß™ AutoReplyRuntime test-match for Business={BusinessId}, Text={Text}\",\n                businessId,\n                text);\n\n            var normalizedText = text.ToLowerInvariant();\n            var incomingWords = SplitIntoWords(normalizedText);\n\n            // 2.1) Builder flows (new AutoReplyBuilder)\n            var flows = await _dbContext.Set<AutoReplyFlow>()\n                .AsNoTracking()\n                .Where(f =>\n                    f.BusinessId == businessId &&\n                    f.IsActive &&\n                    !string.IsNullOrWhiteSpace(f.TriggerKeyword))\n                .OrderBy(f => f.Name)\n                .ThenBy(f => f.Id)\n                .ToListAsync(cancellationToken);\n\n            var candidates = new List<FlowMatchCandidate>();\n\n            foreach (var flow in flows)\n            {\n                var triggerField = flow.TriggerKeyword ?? string.Empty;\n\n                // Support comma / newline separated triggers\n                var keywords = triggerField\n                    .Split(new[] { ',', '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries)\n                    .Select(k => k.Trim())\n                    .Where(k => !string.IsNullOrWhiteSpace(k))\n                    .ToList();\n\n                if (keywords.Count == 0)\n                    continue;\n\n                var rawMatchMode = string.IsNullOrWhiteSpace(flow.MatchMode)\n                    ? \"Word\"\n                    : flow.MatchMode.Trim();\n\n                var matchMode = rawMatchMode.ToUpperInvariant();\n\n                foreach (var kw in keywords)\n                {\n                    var normalizedKeyword = kw.ToLowerInvariant();\n\n                    if (IsKeywordMatch(\n                            normalizedKeyword,\n                            normalizedText,\n                            matchMode,\n                            incomingWords))\n                    {\n                        candidates.Add(new FlowMatchCandidate\n                        {\n                            Flow = flow,\n                            Keyword = kw,\n                            MatchMode = matchMode,\n                            Priority = flow.Priority,\n                            KeywordLength = normalizedKeyword.Length\n                        });\n                    }\n                }\n            }\n\n            if (candidates.Count == 0)\n            {\n                // ‚úÖ No legacy rule fallback anymore: if no flow matches, we just say \"not handled\".\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"No AutoReply flow matched the incoming text.\");\n            }\n\n            // üéØ Big-player style selection:\n            // 1) Highest Priority\n            // 2) Longest keyword (more specific)\n            // 3) Newest flow (CreatedAt)\n            // 4) Stable by Id\n            var winner = candidates\n                .OrderByDescending(c => c.Priority)\n                .ThenByDescending(c => c.KeywordLength)\n                .ThenByDescending(c => c.Flow.CreatedAt)\n                .ThenBy(c => c.Flow.Id)\n                .First();\n\n            var matchedFlow = winner.Flow;\n            var matchedKeyword = winner.Keyword;\n\n            var startSummary = GetFirstActionNodeSummary(matchedFlow);\n\n            var note =\n                $\"Matched flow '{matchedFlow.Name}' ({matchedFlow.Id}) by trigger '{matchedKeyword}'. \" +\n                $\"Mode={winner.MatchMode}, Priority={winner.Priority}, Candidates={candidates.Count}.\";\n\n            _logger.LogInformation(\n                \"üß™ AutoReplyRuntime (test) matched winner flow {FlowId} '{FlowName}' with keyword '{Keyword}'. Mode={MatchMode}, Priority={Priority}, Candidates={CandidateCount}.\",\n                matchedFlow.Id,\n                matchedFlow.Name,\n                matchedKeyword,\n                winner.MatchMode,\n                winner.Priority,\n                candidates.Count);\n\n            // Still treat as \"simple reply\" from the point of view of the test API,\n            // even though runtime now executes multi-step flows.\n            return AutoReplyRuntimeResult.SimpleReply(\n                autoReplyFlowId: matchedFlow.Id,\n                matchedKeyword: matchedKeyword,\n                notes: note,\n                startNodeType: startSummary?.NodeType,\n                startNodeName: startSummary?.NodeName\n            );\n        }\n\n        // ----------------------------------------------------\n        // 3) Legacy DTO adapter ‚Äì for existing APIs\n        // ----------------------------------------------------\n        public async Task<AutoReplyMatchResultDto> FindMatchAsync(\n            AutoReplyMatchRequestDto request,\n            CancellationToken cancellationToken = default)\n        {\n            var runtimeResult = await TestMatchAsync(\n                request.BusinessId,\n                request.IncomingText,\n                cancellationToken);\n\n            if (!runtimeResult.Handled)\n            {\n                // Back-compat: previously returned IsMatch=false with everything else null.\n                return new AutoReplyMatchResultDto\n                {\n                    IsMatch = false\n                };\n            }\n\n            var dto = new AutoReplyMatchResultDto\n            {\n                IsMatch = true,\n                FlowId = runtimeResult.AutoReplyFlowId ?? runtimeResult.CtaFlowConfigId,\n                FlowName = null, // TODO: surface flow name once we propagate it from flow entity.\n                MatchedKeyword = runtimeResult.MatchedKeyword,\n                MatchType = runtimeResult.StartedCtaFlow ? \"CTA_FLOW\" : \"SIMPLE_REPLY\",\n                StartNodeId = null,\n                StartNodeType = null,\n                StartNodeConfigJson = null\n            };\n\n            return dto;\n        }\n\n        // ----------------------------------------------------\n        // 4) Multi-step flow execution (builder flows)\n        // ----------------------------------------------------\n\n        /// <summary>\n        /// Represents the outcome of executing a visual AutoReply flow.\n        /// </summary>\n        private sealed class FlowExecutionOutcome\n        {\n            /// <summary>\n            /// True if at least one message/template was sent.\n            /// </summary>\n            public bool AnySent { get; set; }\n\n            /// <summary>\n            /// Number of plain text messages sent in this run.\n            /// </summary>\n            public int SentTextMessages { get; set; }\n\n            /// <summary>\n            /// Number of template messages sent in this run.\n            /// </summary>\n            public int SentTemplates { get; set; }\n\n            /// <summary>\n            /// Extra notes about execution (e.g. errors, loop guards, tags/waits summary).\n            /// </summary>\n            public string? Notes { get; set; }\n\n            /// <summary>\n            /// Short human-readable summary for logs.\n            /// </summary>\n            public string? Summary\n            {\n                get\n                {\n                    var parts = new List<string>();\n\n                    if (SentTextMessages > 0)\n                    {\n                        parts.Add($\"Text x{SentTextMessages}\");\n                    }\n\n                    if (SentTemplates > 0)\n                    {\n                        parts.Add($\"Template x{SentTemplates}\");\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(Notes))\n                    {\n                        parts.Add(Notes!);\n                    }\n\n                    return parts.Count == 0 ? null : string.Join(\" | \", parts);\n                }\n            }\n\n            public static FlowExecutionOutcome Empty { get; } = new();\n        }\n\n        /// <summary>\n        /// Execute a builder-based flow as a simple linear sequence of nodes.\n        /// For now:\n        /// - Supports: \"message\", \"template\", \"wait\", \"tag\".\n        /// - Executes in the order defined by node.Order, ignoring the visual \"start\" node.\n        /// </summary>\n        private async Task<FlowExecutionOutcome> ExecuteFlowLinearAsync(\n            AutoReplyFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            CancellationToken ct)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n            {\n                _logger.LogWarning(\n                    \"AutoReply flow {FlowId} for Business={BusinessId} has no nodes; nothing to execute.\",\n                    flow.Id,\n                    businessId);\n\n                return FlowExecutionOutcome.Empty;\n            }\n\n            // For now we treat flows as linear sequences:\n            // - ignore the explicit edges graph\n            // - skip the visual \"start\" node\n            var orderedNodes = nodes\n                .Where(n => !string.Equals(n.NodeType, \"start\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .ToList();\n\n            if (orderedNodes.Count == 0)\n            {\n                _logger.LogWarning(\n                    \"AutoReply flow {FlowId} for Business={BusinessId} has only a start node and no action nodes.\",\n                    flow.Id,\n                    businessId);\n\n                return FlowExecutionOutcome.Empty;\n            }\n\n            var outcome = new FlowExecutionOutcome();\n            var pieces = new List<string>();\n\n            foreach (var node in orderedNodes)\n            {\n                if (ct.IsCancellationRequested)\n                {\n                    _logger.LogInformation(\n                        \"AutoReply flow execution cancelled for FlowId={FlowId}, Business={BusinessId}, Contact={ContactId}.\",\n                        flow.Id,\n                        businessId,\n                        contactId);\n                    break;\n                }\n\n                var nodeType = node.NodeType?.Trim().ToLowerInvariant();\n                AutoReplyNodeConfig? cfg = null;\n\n                if (!string.IsNullOrWhiteSpace(node.ConfigJson))\n                {\n                    try\n                    {\n                        var options = new JsonSerializerOptions\n                        {\n                            PropertyNameCaseInsensitive = true\n                        };\n                        cfg = JsonSerializer.Deserialize<AutoReplyNodeConfig>(node.ConfigJson, options);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogError(\n                            ex,\n                            \"Failed to parse ConfigJson for AutoReply node {NodeId} in flow {FlowId}. ConfigJson={ConfigJson}\",\n                            node.Id,\n                            flow.Id,\n                            node.ConfigJson);\n\n                        // Log as failed step and continue\n                        await LogFlowStepAsync(\n                            businessId,\n                            flow,\n                            node,\n                            contactPhone,\n                            messageLogId: null,\n                            success: false,\n                            errorMessage: \"ConfigJson deserialization failed\",\n                            templateName: null,\n                            templateType: null,\n                            cancellationToken: ct);\n\n                        continue;\n                    }\n                }\n\n                switch (nodeType)\n                {\n                    case \"message\":\n                        {\n                            var body = cfg?.Text ?? cfg?.Body;\n                            if (string.IsNullOrWhiteSpace(body))\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply message node {NodeId} in flow {FlowId} has empty body.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Empty message body\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEXT\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            var trimmedBody = body.Trim();\n\n                            _logger.LogInformation(\n                                \"üìÑ AutoReplyRuntime sending text message node {NodeId} for flow {FlowId}.\",\n                                node.Id,\n                                flow.Id);\n\n                            // ‚úÖ Now use DeliveryMode.Immediate (conversational reply)\n                            var sendResult = await _messageEngine.SendAutoReplyTextAsync(\n                                businessId,\n                                contactPhone,\n                                trimmedBody,\n                                DeliveryMode.Immediate,\n                                ct);\n\n                            if (!sendResult.Success)\n                            {\n                                _logger.LogWarning(\n                                    \"‚ùå AutoReplyRuntime failed to send text node {NodeId} in flow {FlowId}, Business={BusinessId}, Contact={ContactId}: {Message}\",\n                                    node.Id,\n                                    flow.Id,\n                                    businessId,\n                                    contactId,\n                                    sendResult.Message);\n\n                                outcome.Notes = $\"Failed to send text node {node.Id}: {sendResult.Message}\";\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null, // TODO: wire real MessageLogId from sendResult if available\n                                    success: false,\n                                    errorMessage: sendResult.Message,\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEXT\",\n                                    cancellationToken: ct);\n\n                                return outcome;\n                            }\n\n                            outcome.AnySent = true;\n                            outcome.SentTextMessages++;\n                            pieces.Add(trimmedBody);\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null, // TODO: from sendResult\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_TEXT\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"template\":\n                        {\n                            var templateName = cfg?.TemplateName;\n                            if (string.IsNullOrWhiteSpace(templateName))\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply template node {NodeId} in flow {FlowId} has no TemplateName configured.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Missing TemplateName\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEMPLATE\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            var dto = new SimpleTemplateMessageDto\n                            {\n                                RecipientNumber = contactPhone,\n                                TemplateName = templateName!,\n                                TemplateParameters = new List<string>(),\n                                HasStaticButtons = false\n                            };\n\n                            _logger.LogInformation(\n                                \"üìÑ AutoReplyRuntime sending template node {NodeId} (template={TemplateName}) for flow {FlowId}.\",\n                                node.Id,\n                                templateName,\n                                flow.Id);\n\n                            // ‚úÖ Now use DeliveryMode.Immediate (conversational template)\n                            var sendResult = await _messageEngine.SendTemplateMessageSimpleAsync(\n                                businessId,\n                                dto,\n                                DeliveryMode.Immediate);\n\n                            if (!sendResult.Success)\n                            {\n                                _logger.LogWarning(\n                                    \"‚ùå AutoReplyRuntime failed to send template node {NodeId} in flow {FlowId}, Business={BusinessId}, Contact={ContactId}: {Message}\",\n                                    node.Id,\n                                    flow.Id,\n                                    businessId,\n                                    contactId,\n                                    sendResult.Message);\n\n                                outcome.Notes = $\"Failed to send template node {node.Id}: {sendResult.Message}\";\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: sendResult.Message,\n                                    templateName: templateName,\n                                    templateType: \"AUTO_REPLY_TEMPLATE\",\n                                    cancellationToken: ct);\n\n                                return outcome;\n                            }\n\n                            outcome.AnySent = true;\n                            outcome.SentTemplates++;\n                            pieces.Add($\"[TEMPLATE:{templateName}]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: templateName,\n                                templateType: \"AUTO_REPLY_TEMPLATE\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"tag\":\n                        {\n                            var tags = cfg?.Tags\n                                        ?? cfg?.TagIds\n                                        ?? Array.Empty<string>();\n\n                            if (tags.Length == 0)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply tag node {NodeId} in flow {FlowId} has no tags configured.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"No tags configured\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TAG\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            _logger.LogInformation(\n                                \"üè∑ AutoReply tag node {NodeId} in flow {FlowId} would apply tags: {Tags}.\",\n                                node.Id,\n                                flow.Id,\n                                string.Join(\",\", tags));\n\n                            pieces.Add($\"[TAGS:{string.Join(\",\", tags)}]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_TAG\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"wait\":\n                        {\n                            var seconds = cfg?.Seconds\n                                           ?? cfg?.DelaySeconds\n                                           ?? cfg?.WaitSeconds\n                                           ?? 0;\n\n                            if (seconds <= 0)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply wait node {NodeId} in flow {FlowId} has invalid or zero Seconds.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Invalid wait seconds\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_WAIT\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            const int MaxWaitSeconds = 15;\n                            var requestedSeconds = seconds;\n                            if (seconds > MaxWaitSeconds)\n                            {\n                                seconds = MaxWaitSeconds;\n                            }\n\n                            _logger.LogInformation(\n                                \"‚è± AutoReply wait node {NodeId} in flow {FlowId} performing inline wait of {Seconds}s (requested {RequestedSeconds}s).\",\n                                node.Id,\n                                flow.Id,\n                                seconds,\n                                requestedSeconds);\n\n                            try\n                            {\n                                await Task.Delay(TimeSpan.FromSeconds(seconds), ct);\n                            }\n                            catch (TaskCanceledException)\n                            {\n                                _logger.LogInformation(\n                                    \"AutoReply wait node {NodeId} in flow {FlowId} was cancelled during wait of {Seconds}s.\",\n                                    node.Id,\n                                    flow.Id,\n                                    seconds);\n                                throw;\n                            }\n\n                            pieces.Add($\"[WAIT:{seconds}s]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_WAIT\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"cta_flow\":\n                        {\n                            // ‚¨áÔ∏è use the Guid parsed from the string\n                            var ctaConfigId = cfg?.CtaFlowConfigGuid ?? Guid.Empty;\n                            if (ctaConfigId == Guid.Empty)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply CTA_FLOW node {NodeId} in flow {FlowId} has no CtaFlowConfigId configured.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Missing CtaFlowConfigId\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_CTA_FLOW\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            _logger.LogInformation(\n                                \"üöÄ AutoReply CTA_FLOW node {NodeId} in flow {FlowId} starting CTA flow config {ConfigId} for Business={BusinessId}, Contact={ContactId}.\",\n                                node.Id,\n                                flow.Id,\n                                ctaConfigId,\n                                businessId,\n                                contactId);\n\n                            var runResult = await _ctaFlowRuntime.StartFlowAsync(\n                                businessId,\n                                contactId,\n                                contactPhone,\n                                ctaConfigId,\n                                FlowExecutionOrigin.AutoReply,\n                                flow.Id,\n                                ct);\n\n                            // ... existing success/error handling for CTA flow (unchanged) ...\n\n                            break;\n                        }\n\n                    default:\n                        {\n                            _logger.LogDebug(\n                                \"AutoReplyRuntime encountered unsupported node type '{NodeType}' in flow {FlowId}, node {NodeId}.\",\n                                node.NodeType,\n                                flow.Id,\n                                node.Id);\n                            break;\n                        }\n\n                }\n            }\n\n            if (pieces.Count > 0)\n            {\n                outcome.Notes = string.Join(\" | \", pieces);\n            }\n\n            return outcome;\n        }\n\n        // ----------------------------------------------------\n        // Helpers ‚Äì keyword matching\n        // ----------------------------------------------------\n        private static List<string> SplitIntoWords(string normalizedIncoming)\n        {\n            if (string.IsNullOrWhiteSpace(normalizedIncoming))\n                return new List<string>();\n\n            var parts = normalizedIncoming.Split(\n                new[]\n                {\n                    ' ', '\\t', '\\r', '\\n',\n                    '.', ',', '!', '?', ';', ':',\n                    '-', '_', '/', '\\\\',\n                    '(', ')', '[', ']', '{', '}',\n                    '\"', '\\'', '‚Äô'\n                },\n                StringSplitOptions.RemoveEmptyEntries);\n\n            return parts.ToList();\n        }\n\n        private static bool IsKeywordMatch(\n            string normalizedKeyword,\n            string normalizedIncoming,\n            string matchMode,\n            IReadOnlyList<string> incomingWords)\n        {\n            if (string.IsNullOrWhiteSpace(normalizedKeyword) ||\n                string.IsNullOrWhiteSpace(normalizedIncoming))\n            {\n                return false;\n            }\n\n            var mode = string.IsNullOrWhiteSpace(matchMode)\n                ? \"WORD\"\n                : matchMode.Trim().ToUpperInvariant();\n\n            switch (mode)\n            {\n                case \"EXACT\":\n                    // Entire text must be exactly the keyword\n                    return string.Equals(\n                        normalizedIncoming,\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"WORD\":\n                    // For single words: token-based match (message must contain that word).\n                    // For multi-word keywords: fall back to simple substring contains.\n                    if (!normalizedKeyword.Contains(' '))\n                    {\n                        if (incomingWords == null || incomingWords.Count == 0)\n                            return false;\n\n                        foreach (var w in incomingWords)\n                        {\n                            if (string.Equals(w, normalizedKeyword, StringComparison.Ordinal))\n                                return true;\n                        }\n\n                        return false;\n                    }\n\n                    return normalizedIncoming.Contains(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"STARTSWITH\":\n                    return normalizedIncoming.StartsWith(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"CONTAINS\":\n                default:\n                    return normalizedIncoming.Contains(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n            }\n        }\n\n        // ----------------------------------------------------\n        // Helpers ‚Äì nodes / configs\n        // ----------------------------------------------------\n        private FlowNodeSummary? GetFirstActionNodeSummary(AutoReplyFlow flow)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n                return null;\n\n            var firstAction = nodes\n                .Where(n => !string.Equals(n.NodeType, \"start\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .FirstOrDefault();\n\n            if (firstAction == null)\n                return null;\n\n            return new FlowNodeSummary(\n                firstAction.NodeType ?? \"?\",\n                firstAction.NodeName ?? \"?\");\n        }\n\n        /// <summary>\n        /// Reads the first \"message\" node and extracts the text/body we want to send.\n        /// Kept for compatibility; not used by the new multi-step runner.\n        /// </summary>\n        private string? GetSimpleReplyText(AutoReplyFlow flow)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n                return null;\n\n            var msgNode = nodes\n                .Where(n =>\n                    string.Equals(n.NodeType, \"message\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .FirstOrDefault();\n\n            if (msgNode == null || string.IsNullOrWhiteSpace(msgNode.ConfigJson))\n                return null;\n\n            try\n            {\n                // ‚öôÔ∏è IMPORTANT: make it case-insensitive so \"text\" / \"body\" also bind.\n                var options = new JsonSerializerOptions\n                {\n                    PropertyNameCaseInsensitive = true\n                };\n\n                var cfg = JsonSerializer.Deserialize<AutoReplyNodeConfig>(msgNode.ConfigJson, options);\n                var text = cfg?.Text ?? cfg?.Body;\n\n                return string.IsNullOrWhiteSpace(text)\n                    ? null\n                    : text.Trim();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"Failed to parse AutoReply message node config for flow {FlowId}. ConfigJson={ConfigJson}\",\n                    flow.Id,\n                    msgNode.ConfigJson);\n\n                return null;\n            }\n        }\n\n        private static List<AutoReplyNodeRecord>? DeserializeNodes(string? nodesJson)\n        {\n            if (string.IsNullOrWhiteSpace(nodesJson))\n                return null;\n\n            try\n            {\n                var options = new JsonSerializerOptions\n                {\n                    PropertyNameCaseInsensitive = true\n                };\n\n                return JsonSerializer.Deserialize<List<AutoReplyNodeRecord>>(nodesJson, options);\n            }\n            catch\n            {\n                // If we cannot parse nodes, treat as no nodes.\n                return null;\n            }\n        }\n\n        // ----------------------------------------------------\n        // AutoReply logging helper\n        // ----------------------------------------------------\n        private async Task LogAutoReplyAsync(\n            Guid businessId,\n            Guid contactId,\n            string? matchedKeyword,\n            AutoReplyFlow? flow,\n            string? replyText,\n            Guid? messageLogId,\n            CancellationToken ct)\n        {\n            try\n            {\n                var log = new AutoReplyLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    TriggerType = \"flow\",\n                    TriggerKeyword = matchedKeyword ?? string.Empty,\n                    ReplyContent = replyText ?? string.Empty,\n                    FlowName = flow?.Name,\n                    MessageLogId = messageLogId,\n                    TriggeredAt = DateTime.UtcNow\n                };\n\n                _dbContext.Set<AutoReplyLog>().Add(log);\n                await _dbContext.SaveChangesAsync(ct);\n\n                _logger.LogInformation(\n                    \"üìù AutoReplyLog inserted for BusinessId={BusinessId}, ContactId={ContactId}, FlowName={FlowName}, Keyword='{Keyword}'.\",\n                    businessId,\n                    contactId,\n                    flow?.Name,\n                    matchedKeyword);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"‚ùå Failed to insert AutoReplyLog for BusinessId={BusinessId}, ContactId={ContactId}, FlowName={FlowName}.\",\n                    businessId,\n                    contactId,\n                    flow?.Name);\n            }\n        }\n\n        /// <summary>\n        /// Helper to write a single origin-aware FlowExecutionLog row for an AutoReply step.\n        /// </summary>\n        private async Task LogFlowStepAsync(\n           Guid businessId,\n           AutoReplyFlow flow,\n           AutoReplyNodeRecord node,\n           string contactPhone,\n           Guid? messageLogId,\n           bool success,\n           string? errorMessage,\n           string? templateName,\n           string? templateType,\n           CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (flow == null)\n                {\n                    _logger.LogWarning(\n                        \"Skipping FlowExecution log because AutoReplyFlow is null. BusinessId={BusinessId}, Contact={ContactPhone}\",\n                        businessId,\n                        contactPhone);\n\n                    return;\n                }\n\n                if (node == null)\n                {\n                    _logger.LogWarning(\n                        \"Skipping FlowExecution log because AutoReply node is null. BusinessId={BusinessId}, AutoReplyFlowId={FlowId}, Contact={ContactPhone}\",\n                        businessId,\n                        flow.Id,\n                        contactPhone);\n\n                    return;\n                }\n\n                // AutoReplyNodeRecord.Id is Guid?; if somehow missing, keep Guid.Empty so we can see it in logs.\n                var stepId = node.Id ?? Guid.Empty;\n\n                var ctx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    Origin = FlowExecutionOrigin.AutoReply,\n\n                    // For AutoReply we DO NOT use CTA FlowId; that column is reserved for CTAFlowConfigId.\n                    FlowId = null,\n\n                    StepId = stepId,\n                    StepName = node.NodeName ?? node.NodeType ?? \"AUTO_REPLY_STEP\",\n\n                    // No per-run grouping yet; can add when you introduce FlowRunId\n                    RunId = null,\n\n                    // AutoReply-origin, not a campaign broadcast\n                    CampaignId = null,\n                    AutoReplyFlowId = flow.Id,\n                    CampaignSendLogId = null,\n                    TrackingLogId = null,\n\n                    MessageLogId = messageLogId,\n                    ContactPhone = contactPhone,\n\n                    // No buttons involved for plain AutoReply nodes (we log button stuff in CTAFlowRuntime)\n                    TriggeredByButton = null,\n                    ButtonIndex = null,\n\n                    TemplateName = templateName,\n                    TemplateType = templateType,\n\n                    RequestId = null,\n                    Success = success,\n                    ErrorMessage = errorMessage,\n                    RawResponse = null,\n\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowExecutionLogger.LogStepAsync(ctx, cancellationToken);\n\n                _logger.LogInformation(\n                    \"[AutoReplyFlowLog] Logged step. Biz={BusinessId}, AutoReplyFlowId={FlowId}, StepId={StepId}, StepName={StepName}, Success={Success}, Template={TemplateName}\",\n                    businessId,\n                    flow.Id,\n                    stepId,\n                    ctx.StepName,\n                    ctx.Success,\n                    ctx.TemplateName ?? \"(none)\");\n            }\n            catch (Exception ex)\n            {\n                // Never break AutoReply runtime because logging failed.\n                _logger.LogError(\n                    ex,\n                    \"Failed to log AutoReply FlowExecution step for BusinessId={BusinessId}, AutoReplyFlowId={FlowId}, NodeId={NodeId}\",\n                    businessId,\n                    flow?.Id,\n                    node?.Id);\n            }\n        }\n\n        // ----------------------------------------------------\n        // Private types for node parsing / choosing winners\n        // ----------------------------------------------------\n\n        private sealed class AutoReplyNodeRecord\n        {\n            public Guid? Id { get; set; }\n            public string? NodeType { get; set; }\n            public string? NodeName { get; set; }\n            public string? ConfigJson { get; set; }\n            public int Order { get; set; }\n            // positionX/positionY etc exist in JSON but we don't need them here\n        }\n\n        private sealed class AutoReplyNodeConfig\n        {\n            public string? Text { get; set; }           // for \"message\" nodes\n            public string? Body { get; set; }           // sometimes templates/body may reuse this\n            public string? TemplateName { get; set; }   // for template nodes\n\n            // Tag node ‚Äì support both \"tags\" and \"tagIds\" shapes\n            public string[]? Tags { get; set; }\n            public string[]? TagIds { get; set; }\n\n            // Wait node ‚Äì support multiple property names coming from builder\n            public int? Seconds { get; set; }\n            public int? DelaySeconds { get; set; }\n            public int? WaitSeconds { get; set; }\n\n            // CTA flow node ‚Äì ID of the CTA flow config to start\n            public string? CtaFlowConfigId { get; set; }\n\n            [JsonIgnore]\n            public Guid? CtaFlowConfigGuid =>\n              Guid.TryParse(CtaFlowConfigId, out var g) ? g : (Guid?)null;\n        }\n\n        private sealed record FlowNodeSummary(string NodeType, string NodeName);\n\n        private sealed class FlowMatchCandidate\n        {\n            public AutoReplyFlow Flow { get; init; } = null!;\n            public string Keyword { get; init; } = string.Empty;\n            public string MatchMode { get; init; } = \"WORD\";\n            public int Priority { get; init; }\n            public int KeywordLength { get; init; }\n        }\n    }\n}\n\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/FlowRunner.cs",
      "sha256": "d8c0004b19eb4964915bcf51a0ecdadf6dc89cfe50220970befa0fe58a5d4307",
      "language": "csharp",
      "size": 103,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class FlowRunner\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyFlowService.cs",
      "sha256": "ed0bc4cbd7017360eb700dcd3012a016a2189ba01c7a945a5056e1e5d8177c65",
      "language": "csharp",
      "size": 876,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyFlowService\n    {\n        Task<IReadOnlyList<AutoReplyFlowSummaryDto>> GetFlowsForBusinessAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<AutoReplyFlowDto?> GetFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default);\n\n        Task<AutoReplyFlowDto> SaveFlowAsync(Guid businessId, AutoReplyFlowDto dto, CancellationToken ct = default);\n\n        Task DeleteFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default);\n        Task SetActiveAsync(\n            Guid businessId,\n            Guid flowId,\n            bool isActive,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyLogService.cs",
      "sha256": "f684d51cf8e980999c33b87dc4aa280b02eb818e12b7f4b8bc90368ce5458fd2",
      "language": "csharp",
      "size": 609,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyLogService\n    {\n        /// <summary>\n        /// Returns the most recent auto-reply triggers for a business,\n        /// ordered by TriggeredAt desc.\n        /// </summary>\n        Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n            Guid businessId,\n            int take,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyRuntimeService.cs",
      "sha256": "4182b20e2a5b814027abc73f1a31f3b96f2a70b8d9ccaacf33ea64b98514e014",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyRuntimeService\n    {\n        /// <summary>\n        /// Real runtime handler used by the webhook when an inbound WhatsApp message arrives.\n        /// </summary>\n        Task<AutoReplyRuntimeResult> TryHandleAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string incomingText,\n            CancellationToken cancellationToken = default);\n\n        /// <summary>\n        /// Test-only match used by the AutoReply Builder UI (\"Test Auto-Reply Match\" panel).\n        /// MUST NOT send any real messages.\n        /// </summary>\n        Task<AutoReplyRuntimeResult> TestMatchAsync(\n            Guid businessId,\n            string incomingText,\n            CancellationToken cancellationToken = default);\n\n        /// <summary>\n        /// Legacy DTO-based matcher used by existing endpoints\n        /// (e.g. /api/auto-reply-runtime/button-click).\n        /// Thin adapter over <see cref=\"TestMatchAsync\"/>.\n        /// </summary>\n        Task<AutoReplyMatchResultDto> FindMatchAsync(\n            AutoReplyMatchRequestDto request,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IFlowRunner.cs",
      "sha256": "11438f4864857ba65f652f4ed62baf47119c77fcd6933106db70602675dce48b",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class IFlowRunner\n    {\n    }\n}\n"
    }
  ]
}
