{
  "name": "xbytechat-api/Features/Billing",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppMetaWebhookController.cs",
      "sha256": "5d6058aacf89412c04875981d4a5cb9a6231ff533ce9db9796e201479e55a252",
      "language": "csharp",
      "size": 2829,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Billing.Security;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/meta\")]\n    public class WhatsAppMetaWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppMetaWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n        private readonly IConfiguration _config;\n        private readonly IMetaSignatureValidator _metaSigValidator;\n        public WhatsAppMetaWebhookController(ILogger<WhatsAppMetaWebhookController> log,\n            IBillingIngestService ingest, IConfiguration config, IMetaSignatureValidator metaSigValidator)\n        {\n            _log = log;\n            _ingest = ingest;\n            _config = config;\n            _metaSigValidator = metaSigValidator;\n        }\n\n        // Meta verification handshake\n        // GET /api/webhooks/whatsapp/meta?hub.mode=subscribe&hub.challenge=...&hub.verify_token=...&businessId=...\n        [HttpGet]\n        public IActionResult Verify([FromQuery(Name = \"hub.mode\")] string mode,\n                                    [FromQuery(Name = \"hub.challenge\")] string challenge,\n                                    [FromQuery(Name = \"hub.verify_token\")] string verifyToken,\n                                    [FromQuery] Guid? businessId = null)\n        {\n            var expected = _config[\"WhatsApp:MetaVerifyToken\"]; // optional; if empty we accept\n            if (!string.IsNullOrWhiteSpace(expected) && !string.Equals(expected, verifyToken))\n            {\n                _log.LogWarning(\"Meta webhook verify failed. Provided token does not match.\");\n                return Unauthorized();\n            }\n            _log.LogInformation(\"Meta webhook verified. BusinessId={BusinessId}\", businessId);\n            return Content(challenge ?? string.Empty, \"text/plain\");\n        }\n\n        // POST /api/webhooks/whatsapp/meta?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            var sig = Request.Headers[\"X-Hub-Signature-256\"].ToString();\n\n            if (!_metaSigValidator.IsValid(sig, payload))\n            {\n                _log.LogWarning(\"Meta webhook: invalid signature for business {BusinessId}\", businessId);\n                return Unauthorized();\n            }\n\n            await _ingest.IngestFromWebhookAsync(businessId, \"META_CLOUD\", payload);\n\n            return Ok();\n        }\n\n\n        // If you need GET verification for Meta webhook, add it here.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppPinnacleWebhookController.cs",
      "sha256": "50c4e7ef562320331826b09fa5210313b19967296a61f89daf10e2e421b8bf73",
      "language": "csharp",
      "size": 1268,
      "content": "using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/pinnacle\")]\n    public class WhatsAppPinnacleWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppPinnacleWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n\n        public WhatsAppPinnacleWebhookController(\n            ILogger<WhatsAppPinnacleWebhookController> log,\n            IBillingIngestService ingest)\n        {\n            _log = log;\n            _ingest = ingest;\n        }\n\n        // POST /api/webhooks/whatsapp/pinnacle?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            _log.LogInformation(\"Pinnacle webhook payload ({Len} chars) for Biz {Biz}\", payload?.Length ?? 0, businessId);\n            await _ingest.IngestFromWebhookAsync(businessId, \"PINNACLE\", payload);\n\n            return Ok();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/DTOs/BillingSnapshotDto.cs",
      "sha256": "ccb71af46ccda4580bcf96c49ae7cab671224aa519eaaf63e561d2fa39d0eb26",
      "language": "csharp",
      "size": 534,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat_api.Features.Billing.DTOs\n{\n    public class BillingSnapshotDto\n    {\n        public int TotalMessages { get; set; }\n        public int ChargeableMessages { get; set; }\n        public int FreeMessages { get; set; }\n        public Dictionary<string, int> CountByCategory { get; set; } = new();    // marketing, utility, authentication, service, free_entry\n        public Dictionary<string, decimal> SpendByCurrency { get; set; } = new();// \"USD\" => 12.34, \"INR\" => 250.00\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Models/ProviderBillingEvent.cs",
      "sha256": "f923e2377733fecf0ad48ff39d28f1a6e1bbfe4e78f370748b864f1568285824",
      "language": "csharp",
      "size": 1179,
      "content": "using System;\n\nnamespace xbytechat_api.Features.Billing.Models\n{\n    public class ProviderBillingEvent\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n\n        // Link if we can; may be null if webhook arrives before we create MessageLog\n        public Guid? MessageLogId { get; set; }\n\n        public string Provider { get; set; } = \"\";          // \"Meta_cloud\", \"Pinnacle\"\n        public string EventType { get; set; } = \"\";         // \"conversation_started\", \"message_delivered\", \"pricing_update\", etc.\n\n        public string? ProviderMessageId { get; set; }      // \"wamid...\"\n        public string? ConversationId { get; set; }\n        public string? ConversationCategory { get; set; }\n        public bool? IsChargeable { get; set; }\n        public decimal? PriceAmount { get; set; }\n        public string? PriceCurrency { get; set; }\n\n        public string PayloadJson { get; set; } = \"\";       // original provider payload for audit\n        public DateTimeOffset OccurredAt { get; set; }      // when provider says it happened\n        public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Security/MetaSignatureValidator.cs",
      "sha256": "2f5296dfd490f127acd70615ed255b07d30937004ef7b3f58ee8d2a6b1521863",
      "language": "csharp",
      "size": 1745,
      "content": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.Extensions.Configuration;\n\nnamespace xbytechat.api.Features.Billing.Security\n{\n    public interface IMetaSignatureValidator\n    {\n        bool IsValid(string signatureHeader, string payload);\n    }\n\n    public class MetaSignatureValidator : IMetaSignatureValidator\n    {\n        private readonly string _appSecret;\n\n        public MetaSignatureValidator(IConfiguration config)\n        {\n            _appSecret = config[\"WhatsApp:MetaAppSecret\"]\n                         ?? throw new InvalidOperationException(\"WhatsApp:MetaAppSecret is not configured\");\n        }\n\n        public bool IsValid(string signatureHeader, string payload)\n        {\n            if (string.IsNullOrWhiteSpace(signatureHeader) || string.IsNullOrEmpty(payload))\n                return false;\n\n            // header format: sha256=HEX\n            const string prefix = \"sha256=\";\n            if (!signatureHeader.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))\n                return false;\n\n            var sent = signatureHeader.Substring(prefix.Length);\n\n            using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(_appSecret));\n            var hashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(payload));\n            var expected = BitConverter.ToString(hashBytes).Replace(\"-\", \"\").ToLowerInvariant();\n\n            return CryptographicEquals(expected, sent);\n        }\n\n        private static bool CryptographicEquals(string a, string b)\n        {\n            if (a.Length != b.Length) return false;\n\n            var result = 0;\n            for (int i = 0; i < a.Length; i++)\n                result |= a[i] ^ b[i];\n\n            return result == 0;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingIngestService.cs",
      "sha256": "c608eae99d94309f2e21fc3c2fb7843c97bb8301e0f262a34cbe263bce124153",
      "language": "csharp",
      "size": 26626,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // AppDbContext\nusing xbytechat_api.Features.Billing.Models;\nusing Npgsql;\nusing Serilog;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingIngestService : IBillingIngestService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<BillingIngestService> _log;\n\n        public BillingIngestService(AppDbContext db, ILogger<BillingIngestService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson)\n        {\n            // Guard: only accept events for known businesses\n            var hasBiz = await _db.Businesses.AnyAsync(b => b.Id == businessId);\n            if (!hasBiz)\n            {\n                _log.LogWarning(\"Ignoring send-response for unknown business {BusinessId}\", businessId);\n                return;\n            }\n\n            try\n            {\n                using var doc = JsonDocument.Parse(rawResponseJson);\n\n                string? providerMessageId =\n                    doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0\n                        ? (msgs[0].TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null)\n                        : (doc.RootElement.TryGetProperty(\"id\", out var idEl2) ? idEl2.GetString() : null);\n\n                var logRow = await _db.MessageLogs\n                    .FirstOrDefaultAsync(x => x.Id == messageLogId && x.BusinessId == businessId);\n\n                if (logRow != null)\n                {\n                    logRow.Provider = provider;\n                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                        logRow.ProviderMessageId = providerMessageId;\n                }\n\n                var ev = new ProviderBillingEvent\n                {\n                    BusinessId = businessId,\n                    MessageLogId = messageLogId,\n                    Provider = provider,\n                    EventType = \"send_response\",\n                    ProviderMessageId = providerMessageId,\n                    PayloadJson = rawResponseJson,\n                    OccurredAt = DateTimeOffset.UtcNow\n                };\n\n                _db.ProviderBillingEvents.Add(ev);\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to ingest send response payload for business {BusinessId}\", businessId);\n            }\n        }\n\n        public async Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson)\n        {\n            // Guard: only accept events for known businesses\n            var hasBiz = await _db.Businesses.AnyAsync(b => b.Id == businessId);\n            if (!hasBiz)\n            {\n                _log.LogWarning(\"Ignoring {Provider} webhook for unknown business {BusinessId}\", provider, businessId);\n                return;\n            }\n\n            try\n            {\n                using var doc = JsonDocument.Parse(payloadJson);\n                var now = DateTimeOffset.UtcNow;\n\n                // For the common/strong-keyed case (ProviderMessageId), we rely on DB unique index.\n                // For weaker cases (no ProviderMessageId, only ConversationId), we still probe with ExistsAsync.\n\n                Task<bool> ExistsForConversationAsync(string eventType, string? conversationId)\n                {\n                    if (string.IsNullOrWhiteSpace(conversationId))\n                        return Task.FromResult(false);\n\n                    return _db.ProviderBillingEvents.AsNoTracking().AnyAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.Provider == provider &&\n                        x.EventType == eventType &&\n                        x.ConversationId == conversationId);\n                }\n\n                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n                {\n                    foreach (var entry in Enumerate(doc.RootElement, \"entry\"))\n                        foreach (var change in Enumerate(entry, \"changes\"))\n                        {\n                            if (!change.TryGetProperty(\"value\", out var value))\n                                continue;\n\n                            foreach (var st in Enumerate(value, \"statuses\"))\n                            {\n                                string? providerMessageId = st.TryGetProperty(\"id\", out var idEl)\n                                    ? idEl.GetString()\n                                    : null;\n\n                                string? status = null;\n                                if (st.TryGetProperty(\"status\", out var statusEl) && statusEl.ValueKind == JsonValueKind.String)\n                                    status = statusEl.GetString()?.ToLowerInvariant();\n\n                                // OccurredAt from provider if present\n                                var occurredAt = now;\n                                if (st.TryGetProperty(\"timestamp\", out var tsEl))\n                                {\n                                    if (tsEl.ValueKind == JsonValueKind.String &&\n                                        long.TryParse(tsEl.GetString(), out var tsLong))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsLong);\n                                    else if (tsEl.ValueKind == JsonValueKind.Number &&\n                                             tsEl.TryGetInt64(out var tsNum))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsNum);\n                                }\n\n                                // Conversation info\n                                string? conversationId = null;\n                                DateTimeOffset? convStartedAt = null;\n\n                                if (st.TryGetProperty(\"conversation\", out var convEl) &&\n                                    convEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (convEl.TryGetProperty(\"id\", out var cidEl))\n                                        conversationId = cidEl.GetString();\n\n                                    if (convEl.TryGetProperty(\"expiration_timestamp\", out var expEl))\n                                    {\n                                        long exp = 0;\n                                        if (expEl.ValueKind == JsonValueKind.String &&\n                                            long.TryParse(expEl.GetString(), out var expStr))\n                                            exp = expStr;\n                                        else if (expEl.ValueKind == JsonValueKind.Number &&\n                                                 expEl.TryGetInt64(out var expNum))\n                                            exp = expNum;\n\n                                        if (exp > 0)\n                                        {\n                                            var expiration = DateTimeOffset.FromUnixTimeSeconds(exp);\n                                            convStartedAt = expiration.AddHours(-24);\n                                        }\n                                    }\n                                }\n\n                                // Pricing block (optional)\n                                string? category = null;\n                                bool? billable = null;\n                                decimal? amount = null;\n                                string? currency = null;\n\n                                if (st.TryGetProperty(\"pricing\", out var pEl) &&\n                                    pEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (pEl.TryGetProperty(\"category\", out var catEl))\n                                        category = catEl.GetString()?.ToLowerInvariant();\n\n                                    if (pEl.TryGetProperty(\"billable\", out var bilEl) &&\n                                        (bilEl.ValueKind == JsonValueKind.True ||\n                                         bilEl.ValueKind == JsonValueKind.False))\n                                        billable = bilEl.GetBoolean();\n\n                                    if (pEl.TryGetProperty(\"amount\", out var amtEl) &&\n                                        amtEl.ValueKind == JsonValueKind.Number)\n                                        amount = amtEl.GetDecimal();\n\n                                    if (pEl.TryGetProperty(\"currency\", out var curEl) &&\n                                        curEl.ValueKind == JsonValueKind.String)\n                                        currency = curEl.GetString();\n                                }\n\n                                // 1) Status event (if present)\n                                if (!string.IsNullOrWhiteSpace(status))\n                                {\n                                    var ev = new ProviderBillingEvent\n                                    {\n                                        BusinessId = businessId,\n                                        Provider = provider,\n                                        EventType = status, // sent/delivered/read etc.\n                                        ProviderMessageId = providerMessageId,\n                                        ConversationId = conversationId,\n                                        ConversationCategory = category,\n                                        IsChargeable = billable,\n                                        PriceAmount = amount,\n                                        PriceCurrency = currency,\n                                        PayloadJson = payloadJson,\n                                        OccurredAt = occurredAt\n                                    };\n\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                    {\n                                        await TryAddBillingEventAsync(ev);\n                                    }\n                                    else\n                                    {\n                                        // fallback: dedupe via conversation id if no provider message id\n                                        if (!await ExistsForConversationAsync(status, conversationId))\n                                        {\n                                            _db.ProviderBillingEvents.Add(ev);\n                                        }\n                                    }\n                                }\n\n                                // 2) Pricing update (if any pricing fields)\n                                var hasAnyPricing =\n                                    !string.IsNullOrWhiteSpace(category) ||\n                                    billable.HasValue ||\n                                    amount.HasValue ||\n                                    !string.IsNullOrWhiteSpace(currency);\n\n                                if (hasAnyPricing)\n                                {\n                                    var pricingEv = new ProviderBillingEvent\n                                    {\n                                        BusinessId = businessId,\n                                        Provider = provider,\n                                        EventType = \"pricing_update\",\n                                        ProviderMessageId = providerMessageId,\n                                        ConversationId = conversationId,\n                                        ConversationCategory = category,\n                                        IsChargeable = billable,\n                                        PriceAmount = amount,\n                                        PriceCurrency = currency,\n                                        PayloadJson = payloadJson,\n                                        OccurredAt = occurredAt\n                                    };\n\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                    {\n                                        await TryAddBillingEventAsync(pricingEv);\n                                    }\n                                    else\n                                    {\n                                        if (!await ExistsForConversationAsync(\"pricing_update\", conversationId))\n                                        {\n                                            _db.ProviderBillingEvents.Add(pricingEv);\n                                        }\n                                    }\n                                }\n\n                                // Keep MessageLog in sync (best effort)\n                                var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                                if (logRow != null)\n                                {\n                                    logRow.Provider = provider;\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                        logRow.ProviderMessageId = providerMessageId;\n                                    if (!string.IsNullOrWhiteSpace(conversationId))\n                                        logRow.ConversationId = conversationId;\n                                    if (convStartedAt.HasValue)\n                                        logRow.ConversationStartedAt = convStartedAt;\n\n                                    if (billable.HasValue)\n                                        logRow.IsChargeable = billable.Value;\n                                    if (!string.IsNullOrWhiteSpace(category))\n                                        logRow.ConversationCategory = category;\n                                    if (amount.HasValue)\n                                        logRow.PriceAmount = amount;\n                                    if (!string.IsNullOrWhiteSpace(currency))\n                                        logRow.PriceCurrency = currency;\n                                }\n                            }\n                        }\n                }\n                else if (string.Equals(provider, \"PINNACLE\", StringComparison.OrdinalIgnoreCase))\n                {\n                    // Best-effort scan for pricing blocks\n                    foreach (var pricing in JsonPathAll(doc.RootElement, \"pricing\"))\n                    {\n                        string? category = pricing.TryGetProperty(\"category\", out var catEl)\n                            ? catEl.GetString()?.ToLowerInvariant()\n                            : null;\n\n                        bool? billable =\n                            pricing.TryGetProperty(\"billable\", out var bilEl) &&\n                            (bilEl.ValueKind == JsonValueKind.True ||\n                             bilEl.ValueKind == JsonValueKind.False)\n                                ? bilEl.GetBoolean()\n                                : (bool?)null;\n\n                        decimal? amount = null;\n                        if (pricing.TryGetProperty(\"amount\", out var amtEl) &&\n                            amtEl.ValueKind == JsonValueKind.Number)\n                            amount = amtEl.GetDecimal();\n\n                        string? currency = pricing.TryGetProperty(\"currency\", out var curEl)\n                            ? curEl.GetString()\n                            : null;\n\n                        var parent = TryGetParentObject(doc.RootElement, pricing);\n                        string? providerMessageId =\n                            TryGetString(parent, \"id\")\n                            ?? TryGetString(parent, \"message_id\")\n                            ?? TryGetString(parent, \"wamid\");\n\n                        string? conversationId =\n                            TryGetString(parent, \"conversation_id\")\n                            ?? TryGetNestedString(parent, \"conversation\", \"id\");\n\n                        string? status = TryGetString(parent, \"status\")?.ToLowerInvariant();\n\n                        // Pricing event\n                        var pricingEv = new ProviderBillingEvent\n                        {\n                            BusinessId = businessId,\n                            Provider = provider,\n                            EventType = \"pricing_update\",\n                            ProviderMessageId = providerMessageId,\n                            ConversationId = conversationId,\n                            ConversationCategory = category,\n                            IsChargeable = billable,\n                            PriceAmount = amount,\n                            PriceCurrency = currency,\n                            PayloadJson = payloadJson,\n                            OccurredAt = now\n                        };\n\n                        if (!string.IsNullOrWhiteSpace(providerMessageId))\n                        {\n                            await TryAddBillingEventAsync(pricingEv);\n                        }\n                        else\n                        {\n                            if (!await ExistsForConversationAsync(\"pricing_update\", conversationId))\n                                _db.ProviderBillingEvents.Add(pricingEv);\n                        }\n\n                        // Optional status event from same parent\n                        if (!string.IsNullOrWhiteSpace(status))\n                        {\n                            var statusEv = new ProviderBillingEvent\n                            {\n                                BusinessId = businessId,\n                                Provider = provider,\n                                EventType = status,\n                                ProviderMessageId = providerMessageId,\n                                ConversationId = conversationId,\n                                ConversationCategory = category,\n                                IsChargeable = billable,\n                                PriceAmount = amount,\n                                PriceCurrency = currency,\n                                PayloadJson = payloadJson,\n                                OccurredAt = now\n                            };\n\n                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n                            {\n                                await TryAddBillingEventAsync(statusEv);\n                            }\n                            else\n                            {\n                                if (!await ExistsForConversationAsync(status, conversationId))\n                                    _db.ProviderBillingEvents.Add(statusEv);\n                            }\n                        }\n\n                        // Sync MessageLog where possible\n                        var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                        if (logRow != null)\n                        {\n                            logRow.Provider = provider;\n                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                logRow.ProviderMessageId = providerMessageId;\n                            if (!string.IsNullOrWhiteSpace(conversationId))\n                                logRow.ConversationId = conversationId;\n\n                            if (billable.HasValue)\n                                logRow.IsChargeable = billable.Value;\n                            if (!string.IsNullOrWhiteSpace(category))\n                                logRow.ConversationCategory = category;\n                            if (amount.HasValue)\n                                logRow.PriceAmount = amount;\n                            if (!string.IsNullOrWhiteSpace(currency))\n                                logRow.PriceCurrency = currency;\n                        }\n                    }\n                }\n                else\n                {\n                    // Unknown provider; keep audit trail, but flagged\n                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                    {\n                        BusinessId = businessId,\n                        Provider = provider,\n                        EventType = \"unknown_provider_webhook\",\n                        PayloadJson = payloadJson,\n                        OccurredAt = now\n                    });\n                }\n\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to ingest webhook payload for business {BusinessId}\", businessId);\n            }\n        }\n\n        // -------- helpers --------\n\n\n\n        private async Task<ProviderBillingEvent?> TryAddBillingEventAsync(ProviderBillingEvent ev)\n        {\n            if (string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n            {\n                // No strong key; let caller handle SaveChanges once.\n                _db.ProviderBillingEvents.Add(ev);\n                return ev;\n            }\n\n            _db.ProviderBillingEvents.Add(ev);\n\n            try\n            {\n                await _db.SaveChangesAsync();\n                return ev;\n            }\n            catch (DbUpdateException ex) when (IsUniqueViolation(ex))\n            {\n                _log.LogDebug(\"Duplicate ProviderBillingEvent ignored for message {ProviderMessageId}\", ev.ProviderMessageId);\n                _db.Entry(ev).State = EntityState.Detached;\n                return null;\n            }\n        }\n\n        private static bool IsUniqueViolation(DbUpdateException ex)\n        {\n            // Postgres example\n            if (ex.InnerException is PostgresException pg &&\n                pg.SqlState == PostgresErrorCodes.UniqueViolation)\n            {\n                return true;\n            }\n\n            // For SQL Server / others, check error numbers here.\n\n            return false;\n        }\n\n        private async Task<MessageLog?> FindMatchingMessageLog(Guid businessId, string? providerMessageId, string? conversationId)\n        {\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var byMsgId = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.ProviderMessageId == providerMessageId);\n                if (byMsgId != null) return byMsgId;\n            }\n\n            if (!string.IsNullOrWhiteSpace(conversationId))\n            {\n                var byConv = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.ConversationId == conversationId);\n                if (byConv != null) return byConv;\n            }\n\n            return null;\n        }\n\n        private static IEnumerable<JsonElement> Enumerate(JsonElement root, string name)\n        {\n            if (root.ValueKind != JsonValueKind.Object) yield break;\n            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) yield break;\n\n            foreach (var x in arr.EnumerateArray())\n                yield return x;\n        }\n\n        private static IEnumerable<JsonElement> JsonPathAll(JsonElement root, string name)\n        {\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (string.Equals(p.Name, name, StringComparison.OrdinalIgnoreCase))\n                        yield return p.Value;\n\n                    foreach (var x in JsonPathAll(p.Value, name))\n                        yield return x;\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var item in root.EnumerateArray())\n                    foreach (var x in JsonPathAll(item, name))\n                        yield return x;\n            }\n        }\n\n        private static JsonElement? TryGetParentObject(JsonElement root, JsonElement node)\n        {\n            // Best-effort: System.Text.Json has no parent pointer; we scan recursively.\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (p.Value.ValueKind == JsonValueKind.Object)\n                    {\n                        if (object.ReferenceEquals(p.Value, node)) return root;\n                        var cand = TryGetParentObject(p.Value, node);\n                        if (cand.HasValue) return cand;\n                    }\n                    else if (p.Value.ValueKind == JsonValueKind.Array)\n                    {\n                        foreach (var e in p.Value.EnumerateArray())\n                        {\n                            if (object.ReferenceEquals(e, node)) return root;\n                            var cand = TryGetParentObject(e, node);\n                            if (cand.HasValue) return cand;\n                        }\n                    }\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var e in root.EnumerateArray())\n                {\n                    var cand = TryGetParentObject(e, node);\n                    if (cand.HasValue) return cand;\n                }\n            }\n\n            return null;\n        }\n\n        private static string? TryGetString(JsonElement? obj, string name)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object)\n                return null;\n\n            return obj.Value.TryGetProperty(name, out var el) ? el.GetString() : null;\n        }\n\n        private static string? TryGetNestedString(JsonElement? obj, string name1, string name2)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object)\n                return null;\n\n            if (!obj.Value.TryGetProperty(name1, out var inner) || inner.ValueKind != JsonValueKind.Object)\n                return null;\n\n            return inner.TryGetProperty(name2, out var v) ? v.GetString() : null;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingReadService.cs",
      "sha256": "0298676bbd8d96132ccbaf42ca893f76a03f769606106dfe82a6bed17982b5fc",
      "language": "csharp",
      "size": 7066,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\n\nusing xbytechat.api;                               // AppDbContext\nusing xbytechat_api.Features.Billing.DTOs;         // BillingSnapshotDto\nusing xbytechat_api.Features.Billing.Models;       // ProviderBillingEvent (for _db.ProviderBillingEvents)\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingReadService : IBillingReadService\n    {\n        private readonly AppDbContext _db;\n        public BillingReadService(AppDbContext db) => _db = db;\n\n        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n        {\n            // Build inclusive [from..to] range in UTC\n            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n            // 1) Volume: total messages in the period (unchanged behavior)\n            var totalMessages = await _db.MessageLogs.AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt)\n                .CountAsync();\n\n            // 2) Billing source of truth: pricing_update events in the period\n            //    (Only select small projection; we'll dedupe in-memory safely.)\n            var evRaw = await _db.ProviderBillingEvents.AsNoTracking()\n                .Where(e => e.BusinessId == businessId\n                            && e.EventType == \"pricing_update\"\n                            && e.OccurredAt >= fromDt && e.OccurredAt <= toDt)\n                .Select(e => new {\n                    e.Provider,\n                    e.ProviderMessageId,\n                    e.EventType,\n                    e.ConversationId,\n                    e.ConversationCategory,\n                    e.IsChargeable,\n                    e.PriceAmount,\n                    e.PriceCurrency\n                })\n                .ToListAsync();\n\n            // 2a) Defend against webhook replays (if DB unique index not yet deployed)\n            //     Deduplicate on Provider+ProviderMessageId+EventType to drop repeats of the same message event.\n            var evDedup = evRaw\n                .GroupBy(e => new { e.Provider, e.ProviderMessageId, e.EventType })\n                .Select(g => g.First())\n                .ToList();\n\n            // 2b) Group by conversation to compute window-level metrics\n            var convGroups = evDedup\n                .Where(e => !string.IsNullOrWhiteSpace(e.ConversationId))\n                .GroupBy(e => e.ConversationId!)\n                .ToList();\n\n            // Chargeable windows: any event in the conversation marked billable == true\n            var chargeableWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == true));\n\n            // Free windows: conversations explicitly marked billable == false and NOT marked true anywhere\n            var freeWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == false) && !g.Any(x => x.IsChargeable == true));\n\n            // Count by category (per conversation, pick first non-empty category; default \"unknown\")\n            var countByCategory = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                var category = g.Select(x => x.ConversationCategory)\n                                .FirstOrDefault(s => !string.IsNullOrWhiteSpace(s))\n                                ?.ToLowerInvariant() ?? \"unknown\";\n                countByCategory[category] = countByCategory.TryGetValue(category, out var c) ? c + 1 : 1;\n            }\n\n            // Spend by currency: for each conversation, take the latest non-null amount (if any), then sum by currency\n            var spendByCurrency = new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                // Prefer an explicit currency on any event in the conversation\n                var amountWithCurrency = g.LastOrDefault(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency));\n                if (amountWithCurrency?.IsChargeable == true) // only count billable windows\n                {\n                    var cur = amountWithCurrency.PriceCurrency!.ToUpperInvariant();\n                    var amt = amountWithCurrency.PriceAmount!.Value;\n                    spendByCurrency[cur] = spendByCurrency.TryGetValue(cur, out var sum) ? sum + amt : amt;\n                }\n            }\n\n            // Compose DTO\n            var dto = new BillingSnapshotDto\n            {\n                TotalMessages = totalMessages,\n                // These two are now \"window\"-level metrics (conversations) â€“ most accurate for billing with Meta.\n                ChargeableMessages = chargeableWindows,\n                FreeMessages = freeWindows,\n                CountByCategory = countByCategory,\n                SpendByCurrency = spendByCurrency\n            };\n\n            return dto;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n//using xbytechat_api.Features.Billing.DTOs;\n\n//namespace xbytechat_api.Features.Billing.Services\n//{\n//    public class BillingReadService : IBillingReadService\n//    {\n//        private readonly AppDbContext _db;\n//        public BillingReadService(AppDbContext db) => _db = db;\n\n//        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n//        {\n//            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n//            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n//            var q = _db.MessageLogs.AsNoTracking()\n//                    .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt);\n\n//            var list = await q.Select(x => new {\n//                x.IsChargeable,\n//                x.ConversationCategory,\n//                x.PriceAmount,\n//                x.PriceCurrency\n//            }).ToListAsync();\n\n//            var dto = new BillingSnapshotDto\n//            {\n//                TotalMessages = list.Count,\n//                ChargeableMessages = list.Count(x => x.IsChargeable == true),\n//                FreeMessages = list.Count(x => x.IsChargeable == false)\n//            };\n\n//            dto.CountByCategory = list\n//                .GroupBy(x => string.IsNullOrWhiteSpace(x.ConversationCategory) ? \"unknown\" : x.ConversationCategory!.ToLowerInvariant())\n//                .ToDictionary(g => g.Key, g => g.Count());\n\n//            dto.SpendByCurrency = list\n//                .Where(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency))\n//                .GroupBy(x => x.PriceCurrency!)\n//                .ToDictionary(g => g.Key, g => g.Sum(v => v.PriceAmount!.Value));\n\n//            return dto;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingIngestService.cs",
      "sha256": "8678a1ec3a5979b124caa81faa47d93d5ca21bd8c0d97bf35a8d55bb50824bdf",
      "language": "csharp",
      "size": 416,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingIngestService\n    {\n        Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson);\n        Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson);\n        \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingReadService.cs",
      "sha256": "146ab2ebc0dea7d43cd6d050c51c28118cf4c7655b369657e198861aa6c9c3ca",
      "language": "csharp",
      "size": 306,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingReadService\n    {\n        Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to);\n    }\n}\n"
    }
  ]
}
