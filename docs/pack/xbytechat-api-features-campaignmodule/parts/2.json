{
  "name": "xbytechat-api/Features/CampaignModule",
  "part": 2,
  "of": 2,
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/MappingSuggestionService.cs",
      "sha256": "e6a82a860c5406f0e22ef3c89577a8c06081e49d21add5f9bc6682c0dc974dd3",
      "language": "csharp",
      "size": 5965,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Heuristics:\n    /// - If Campaign.TemplateParameters is a JSON array of tokens, suggest for those tokens.\n    /// - Else, derive tokens by normalizing CSV headers (lowercase, alnum only, '_' joined).\n    /// - Match by normalized equality/contains; special-case phone names.\n    /// - Unmatched tokens get \"static:\" so UI shows a clear placeholder.\n    /// </summary>\n    public sealed class MappingSuggestionService : IMappingSuggestionService\n    {\n        private readonly AppDbContext _db;\n\n        private static readonly string[] PhoneHeaderCandidates =\n        {\n            \"phone\", \"mobile\", \"whatsapp\", \"msisdn\", \"whatsapp_number\", \"contact\", \"contact_number\"\n        };\n\n        public MappingSuggestionService(AppDbContext db) => _db = db;\n\n        public async Task<Dictionary<string, string>> SuggestAsync(\n            Guid businessId,\n            Guid campaignId,\n            Guid batchId,\n            CancellationToken ct = default)\n        {\n            // Load campaign to read TemplateParameters (if present)\n            var campaign = await _db.Campaigns.AsNoTracking()\n                .Where(c => c.Id == campaignId && c.BusinessId == businessId)\n                .Select(c => new { c.Id, c.BusinessId, c.TemplateParameters })\n                .FirstOrDefaultAsync(ct);\n\n            if (campaign == null) throw new KeyNotFoundException(\"Campaign not found.\");\n\n            // Load batch headers\n            var batch = await _db.CsvBatches.AsNoTracking()\n                .Where(b => b.Id == batchId && b.BusinessId == businessId)\n                .Select(b => new { b.HeadersJson })\n                .FirstOrDefaultAsync(ct);\n\n            if (batch == null) throw new KeyNotFoundException(\"CSV batch not found.\");\n\n            var headers = ParseHeaders(batch.HeadersJson);\n            var normHeaders = headers.ToDictionary(h => Normalize(h), h => h, StringComparer.OrdinalIgnoreCase);\n\n            // Determine tokens\n            var tokens = ParseTemplateTokens(campaign.TemplateParameters);\n            if (tokens.Count == 0)\n            {\n                // Fall back: derive tokens directly from headers\n                tokens = headers.Select(Normalize).Where(s => !string.IsNullOrWhiteSpace(s)).Distinct(StringComparer.OrdinalIgnoreCase).ToList();\n            }\n\n            // Suggestion: token -> source\n            var suggestions = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            foreach (var token in tokens)\n            {\n                var normToken = Normalize(token);\n\n                // 1) direct equality with header\n                if (normHeaders.TryGetValue(normToken, out var exactHeader))\n                {\n                    suggestions[token] = $\"csv:{exactHeader}\";\n                    continue;\n                }\n\n                // 2) phone special-case\n                if (IsPhoneToken(normToken))\n                {\n                    var headerPick = headers.FirstOrDefault(h => PhoneHeaderCandidates.Contains(Normalize(h)));\n                    if (!string.IsNullOrEmpty(headerPick))\n                    {\n                        suggestions[token] = $\"csv:{headerPick}\";\n                        continue;\n                    }\n                }\n\n                // 3) contains / fuzzy-lite\n                var contains = headers.FirstOrDefault(h => Normalize(h).Contains(normToken, StringComparison.OrdinalIgnoreCase));\n                if (!string.IsNullOrEmpty(contains))\n                {\n                    suggestions[token] = $\"csv:{contains}\";\n                    continue;\n                }\n\n                // 4) default: static placeholder (UI can highlight to user)\n                suggestions[token] = \"static:\";\n            }\n\n            return suggestions;\n        }\n\n        private static List<string> ParseHeaders(string? headersJson)\n        {\n            if (string.IsNullOrWhiteSpace(headersJson)) return new List<string>();\n            try\n            {\n                var arr = JsonSerializer.Deserialize<List<string>>(headersJson);\n                return arr?.Where(h => !string.IsNullOrWhiteSpace(h)).ToList() ?? new List<string>();\n            }\n            catch\n            {\n                // Fallback: maybe comma-separated\n                return headersJson.Split(',').Select(s => s.Trim()).Where(s => s.Length > 0).ToList();\n            }\n        }\n\n        private static List<string> ParseTemplateTokens(string? templateParametersJson)\n        {\n            if (string.IsNullOrWhiteSpace(templateParametersJson)) return new List<string>();\n            try\n            {\n                var arr = JsonSerializer.Deserialize<List<string>>(templateParametersJson);\n                return arr?.Where(t => !string.IsNullOrWhiteSpace(t)).ToList() ?? new List<string>();\n            }\n            catch\n            {\n                return new List<string>();\n            }\n        }\n\n        private static bool IsPhoneToken(string normToken)\n        {\n            if (string.IsNullOrWhiteSpace(normToken)) return false;\n            if (PhoneHeaderCandidates.Contains(normToken)) return true;\n            return normToken.Contains(\"phone\") || normToken.Contains(\"mobile\") || normToken.Contains(\"whatsapp\");\n        }\n\n        private static string Normalize(string s)\n        {\n            var lowered = (s ?? \"\").Trim().ToLowerInvariant();\n            if (lowered.Length == 0) return lowered;\n            var alnum = Regex.Replace(lowered, @\"[^a-z0-9]+\", \"_\");\n            alnum = Regex.Replace(alnum, \"_{2,}\", \"_\").Trim('_');\n            return alnum;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/NoopVariableMappingService.cs",
      "sha256": "24a343d03f2ab867121a8ebfe09ebcf7672fb7a3261095b6dc2322633e1ae722",
      "language": "csharp",
      "size": 984,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Default stub: returns no saved mappings.\n    /// Swap this out later with a DB-backed implementation that reads CampaignVariableMap.\n    /// </summary>\n    public sealed class NoopVariableMappingService : IVariableMappingService\n    {\n        public Task<Dictionary<string, string>> GetForCampaignAsync(\n            Guid businessId,\n            Guid campaignId,\n            CancellationToken ct = default)\n        {\n            return Task.FromResult(new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase));\n        }\n\n        public Task SaveAsync(\n           Guid businessId,\n           Guid campaignId,\n           Dictionary<string, string> mappings,\n           CancellationToken ct = default)\n        {\n            // no-op\n            return Task.CompletedTask;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/OutboundCampaignQueueService.cs",
      "sha256": "b81f57bff9d0409d1f72e2347814800b56d2a94f6696ce7a5ae1500b38c9648b",
      "language": "csharp",
      "size": 8110,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;                       // <-- add\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.Queueing.DTOs;    // <-- add for OutboundCampaignJobCreateDto\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public class OutboundCampaignQueueService : IOutboundCampaignQueueService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<OutboundCampaignQueueService> _log;\n\n        public OutboundCampaignQueueService(AppDbContext db, ILogger<OutboundCampaignQueueService> log)\n        {\n            _db = db; _log = log;\n        }\n\n        public async Task<Guid> EnqueueAsync(Guid businessId, Guid campaignId, bool forceDuplicate = false)\n        {\n            if (!forceDuplicate)\n            {\n                var existing = await _db.OutboundCampaignJobs\n                    .Where(j => j.CampaignId == campaignId && (j.Status == \"queued\" || j.Status == \"running\"))\n                    .OrderByDescending(j => j.CreatedAt)\n                    .FirstOrDefaultAsync();\n\n                if (existing != null)\n                {\n                    var found = await _db.Campaigns\n                        .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n                    if (found != null && found.Status != \"Queued\")\n                    {\n                        found.Status = \"Queued\";\n                        found.UpdatedAt = DateTime.UtcNow;\n                        await _db.SaveChangesAsync();\n                    }\n\n                    _log.LogInformation(\"Campaign {CampaignId} already queued/running. Job={JobId}\", campaignId, existing.Id);\n                    return existing.Id;\n                }\n            }\n\n            var job = new OutboundCampaignJob\n            {\n                BusinessId = businessId,\n                CampaignId = campaignId,\n                Status = \"queued\",\n                Attempt = 0,\n                MaxAttempts = 5,\n                NextAttemptAt = DateTimeOffset.UtcNow\n            };\n\n            _db.OutboundCampaignJobs.Add(job);\n\n            var row = await _db.Campaigns\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n            if (row != null)\n            {\n                row.Status = \"Queued\";\n                row.UpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n            return job.Id;\n        }\n\n        public async Task<bool> MarkSucceededAsync(Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FindAsync(jobId);\n            if (j == null) return false;\n\n            j.Attempt += 1;\n            j.Status = \"succeeded\";\n            j.UpdatedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> MarkFailedAsync(Guid jobId, string error, bool scheduleRetry = true)\n        {\n            var j = await _db.OutboundCampaignJobs.FindAsync(jobId);\n            if (j == null) return false;\n\n            j.Attempt += 1;\n            j.LastError = Truncate(error, 3900);\n            j.UpdatedAt = DateTime.UtcNow;\n\n            if (!scheduleRetry || j.Attempt >= j.MaxAttempts)\n            {\n                j.Status = \"failed\";\n            }\n            else\n            {\n                var backoff = j.Attempt switch\n                {\n                    1 => TimeSpan.FromMinutes(1),\n                    2 => TimeSpan.FromMinutes(5),\n                    3 => TimeSpan.FromMinutes(15),\n                    4 => TimeSpan.FromMinutes(60),\n                    _ => TimeSpan.FromMinutes(180)\n                };\n                j.Status = \"queued\";\n                j.NextAttemptAt = DateTimeOffset.UtcNow.Add(backoff);\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<List<OutboundCampaignJob>> GetJobsForCampaignAsync(Guid businessId, Guid campaignId)\n        {\n            return await _db.OutboundCampaignJobs\n                .Where(j => j.BusinessId == businessId && j.CampaignId == campaignId)\n                .OrderByDescending(j => j.CreatedAt)\n                .ToListAsync();\n        }\n\n        public async Task<OutboundCampaignJob?> GetActiveJobForCampaignAsync(Guid businessId, Guid campaignId)\n        {\n            return await _db.OutboundCampaignJobs\n                .Where(j => j.BusinessId == businessId && j.CampaignId == campaignId &&\n                            (j.Status == \"queued\" || j.Status == \"running\"))\n                .OrderBy(j => j.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task<bool> CancelAsync(Guid businessId, Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FirstOrDefaultAsync(x => x.Id == jobId && x.BusinessId == businessId);\n            if (j == null) return false;\n\n            if (j.Status == \"queued\" || j.Status == \"running\")\n            {\n                j.Status = \"canceled\";\n                j.UpdatedAt = DateTime.UtcNow;\n                await _db.SaveChangesAsync();\n\n                var campaign = await _db.Campaigns.FirstOrDefaultAsync(c => c.Id == j.CampaignId && c.BusinessId == businessId);\n                if (campaign != null)\n                {\n                    var hasActive = await _db.OutboundCampaignJobs.AnyAsync(x =>\n                        x.CampaignId == j.CampaignId &&\n                        x.BusinessId == businessId &&\n                        (x.Status == \"queued\" || x.Status == \"running\"));\n\n                    if (!hasActive && (campaign.Status == \"Queued\" || campaign.Status == \"Sending\"))\n                    {\n                        campaign.Status = \"Draft\";\n                        campaign.UpdatedAt = DateTime.UtcNow;\n                        await _db.SaveChangesAsync();\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n\n        public async Task<bool> ForceRetryNowAsync(Guid businessId, Guid jobId)\n        {\n            var j = await _db.OutboundCampaignJobs.FirstOrDefaultAsync(x => x.Id == jobId && x.BusinessId == businessId);\n            if (j == null) return false;\n\n            j.Status = \"queued\";\n            j.NextAttemptAt = DateTimeOffset.UtcNow;\n            j.UpdatedAt = DateTime.UtcNow;\n\n            var campaign = await _db.Campaigns.FirstOrDefaultAsync(c => c.Id == j.CampaignId && c.BusinessId == businessId);\n            if (campaign != null && campaign.Status != \"Queued\")\n            {\n                campaign.Status = \"Queued\";\n                campaign.UpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // NEW: bulk enqueue used by CampaignDispatcher\n        public Task<int> EnqueueBulkAsync(IEnumerable<OutboundCampaignJobCreateDto> jobs, CancellationToken ct = default)\n        {\n            // For now, just log & return a deduped count. Replace with real queue later.\n            var list = (jobs ?? Enumerable.Empty<OutboundCampaignJobCreateDto>()).ToList();\n\n            // Deduplicate by provided IdempotencyKey (or fallback to a stable composite)\n            var enqueuedCount = list\n                .GroupBy(j => string.IsNullOrWhiteSpace(j.IdempotencyKey)\n                                ? $\"{j.CampaignId}:{j.CampaignRecipientId}\"\n                                : j.IdempotencyKey)\n                .Count();\n\n            _log.LogInformation(\"Bulk enqueue requested: {Requested} jobs, deduped to {Enqueued}\",\n                list.Count, enqueuedCount);\n\n            // TODO: push to a real queue/bus and persist queue records as needed.\n            return Task.FromResult(enqueuedCount);\n        }\n\n        private static string Truncate(string s, int max) =>\n            string.IsNullOrEmpty(s) ? s : (s.Length <= max ? s : s.Substring(0, max));\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/OutboundCampaignSendWorker.cs",
      "sha256": "87b84f4ac6b994c6b307f46968b63be7090fa022a3681ae696e01ae348432261",
      "language": "csharp",
      "size": 13092,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Claims due OutboundCampaignJobs and invokes the campaign sender.\n    /// Uses ExecuteUpdateAsync to flip Campaign.Status without tracking entities,\n    /// eliminating \"already being tracked\" conflicts.\n    /// </summary>\n    public class OutboundCampaignSendWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundCampaignSendWorker> _log;\n\n        // Global cap & polling cadence\n        private const int MaxParallel = 3;\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(10);\n\n        public OutboundCampaignSendWorker(IServiceProvider sp, ILogger<OutboundCampaignSendWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            // small warm-up delay\n            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var now = DateTime.UtcNow;\n\n                    // Find up to MaxParallel due jobs\n                    var due = await db.OutboundCampaignJobs\n                        .Where(j => j.Status == \"queued\" && j.NextAttemptAt <= now)\n                        .OrderBy(j => j.NextAttemptAt)\n                        .ThenBy(j => j.CreatedAt)\n                        .Take(MaxParallel)\n                        .ToListAsync(stoppingToken);\n\n                    // Claim jobs (do NOT increment Attempt here)\n                    foreach (var job in due)\n                    {\n                        job.Status = \"running\";\n                        job.UpdatedAt = DateTime.UtcNow;\n                    }\n\n                    if (due.Count > 0)\n                        await db.SaveChangesAsync(stoppingToken);\n\n                    // Process in parallel within this sweep\n                    var tasks = due.Select(job => ProcessJobAsync(job.Id, stoppingToken)).ToArray();\n                    await Task.WhenAll(tasks);\n                }\n                catch (Exception ex)\n                {\n                    _log.LogWarning(ex, \"Send queue sweep failed\");\n                }\n\n                await Task.Delay(SweepEvery, stoppingToken);\n            }\n        }\n\n        private async Task ProcessJobAsync(Guid jobId, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var queue = scope.ServiceProvider.GetRequiredService<IOutboundCampaignQueueService>();\n            var campaignService = scope.ServiceProvider.GetRequiredService<ICampaignService>();\n            var log = scope.ServiceProvider.GetRequiredService<ILogger<OutboundCampaignSendWorker>>();\n\n            var job = await db.OutboundCampaignJobs.FirstOrDefaultAsync(j => j.Id == jobId, ct);\n            if (job == null) return;\n\n            // Flip to \"Sending\" (no entity tracked)\n            await db.Campaigns\n                .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId && c.Status != \"Sending\")\n                .ExecuteUpdateAsync(s => s\n                    .SetProperty(c => c.Status, _ => \"Sending\")\n                    .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                    ct);\n\n            try\n            {\n                // Call by ID only â€“ service manages its own DbContext/queries\n                var result = await campaignService.SendTemplateCampaignWithTypeDetectionAsync(job.CampaignId);\n\n                if (result.Success)\n                {\n                    await db.Campaigns\n                        .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(c => c.Status, _ => \"Sent\")\n                            .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                            ct);\n\n                    await queue.MarkSucceededAsync(job.Id);\n                    log.LogInformation(\"Job {Job} succeeded for campaign {Campaign}\", jobId, job.CampaignId);\n                }\n                else\n                {\n                    var willRetry = job.Attempt + 1 < job.MaxAttempts;\n                    var nextStatus = willRetry ? \"Queued\" : \"Failed\";\n\n                    await db.Campaigns\n                        .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(c => c.Status, _ => nextStatus)\n                            .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                            ct);\n\n                    await queue.MarkFailedAsync(job.Id, result.Message ?? \"Unknown send error\", scheduleRetry: true);\n                    log.LogWarning(\"Job {Job} failed for campaign {Campaign}: {Msg}\", jobId, job.CampaignId, result.Message);\n                }\n            }\n            catch (Exception ex)\n            {\n                var willRetry = job.Attempt + 1 < job.MaxAttempts;\n                var nextStatus = willRetry ? \"Queued\" : \"Failed\";\n\n                await db.Campaigns\n                    .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(c => c.Status, _ => nextStatus)\n                        .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                        ct);\n\n                await queue.MarkFailedAsync(job.Id, ex.ToString(), scheduleRetry: true);\n                log.LogWarning(ex, \"Job {Job} exception for campaign {Campaign}\", jobId, job.CampaignId);\n            }\n        }\n    }\n}\n\n\n//////using System;\n//////using System.Linq;\n//////using System.Threading;\n//////using System.Threading.Tasks;\n//////using Microsoft.EntityFrameworkCore;\n//////using Microsoft.Extensions.DependencyInjection;\n//////using Microsoft.Extensions.Hosting;\n//////using Microsoft.Extensions.Logging;\n//////using xbytechat.api;\n//////using xbytechat.api.Features.CampaignModule.Services;\n\n//////namespace xbytechat.api.Features.CampaignModule.Services\n//////{\n//////    /// <summary>\n//////    /// Background worker that claims due jobs and invokes CampaignService to send.\n//////    /// Flips Campaign.Status for truthful UI: Queued -> Sending -> Sent / Queued / Failed\n//////    /// </summary>\n//////    public class OutboundCampaignSendWorker : BackgroundService\n//////    {\n//////        private readonly IServiceProvider _sp;\n//////        private readonly ILogger<OutboundCampaignSendWorker> _log;\n\n//////        // Simple global concurrency cap & polling cadence\n//////        private const int MaxParallel = 3;\n//////        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(10);\n//////        private readonly IDbContextFactory<AppDbContext> _dbFactory;\n\n//////        public OutboundCampaignSendWorker(IServiceProvider sp, ILogger<OutboundCampaignSendWorker> log, IDbContextFactory<AppDbContext> dbFactory)\n//////        {\n//////            _sp = sp; _log = log;\n//////            _dbFactory = dbFactory;\n//////        }\n\n//////        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//////        {\n//////            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);\n\n//////            while (!stoppingToken.IsCancellationRequested)\n//////            {\n//////                try\n//////                {\n//////                    using var scope = _sp.CreateScope();\n//////                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//////                    var now = DateTimeOffset.UtcNow;\n\n//////                    // Find up to MaxParallel due jobs\n//////                    var due = await db.OutboundCampaignJobs\n//////                        .Where(j => j.Status == \"queued\" && j.NextAttemptAt <= now)\n//////                        .OrderBy(j => j.NextAttemptAt)\n//////                        .ThenBy(j => j.CreatedAt)\n//////                        .Take(MaxParallel)\n//////                        .ToListAsync(stoppingToken);\n\n//////                    // Claim jobs (do NOT increment Attempt here)\n//////                    foreach (var job in due)\n//////                    {\n//////                        job.Status = \"running\";\n//////                        job.UpdatedAt = DateTime.UtcNow;\n//////                    }\n//////                    if (due.Count > 0)\n//////                        await db.SaveChangesAsync(stoppingToken);\n\n//////                    var tasks = due.Select(job => ProcessJobAsync(job.Id, stoppingToken)).ToArray();\n//////                    await Task.WhenAll(tasks);\n//////                }\n//////                catch (Exception ex)\n//////                {\n//////                    _log.LogWarning(ex, \"Send queue sweep failed\");\n//////                }\n\n//////                await Task.Delay(SweepEvery, stoppingToken);\n//////            }\n//////        }\n\n//////        private async Task ProcessJobAsync(Guid jobId, CancellationToken ct)\n//////        {\n//////            using var scope = _sp.CreateScope();\n//////            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//////            var queue = scope.ServiceProvider.GetRequiredService<IOutboundCampaignQueueService>();\n//////            var campaignService = scope.ServiceProvider.GetRequiredService<ICampaignService>();\n//////            var log = scope.ServiceProvider.GetRequiredService<ILogger<OutboundCampaignSendWorker>>();\n\n//////            var job = await db.OutboundCampaignJobs.FirstOrDefaultAsync(j => j.Id == jobId, ct);\n//////            if (job == null) return;\n\n//////            // Mark Campaign -> Sending\n//////            var campaign = await db.Campaigns\n//////                .FirstOrDefaultAsync(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId, ct);\n\n//////            if (campaign != null && campaign.Status != \"Sending\")\n//////            {\n//////                campaign.Status = \"Sending\";\n//////                campaign.UpdatedAt = DateTime.UtcNow;\n//////                await db.SaveChangesAsync(ct);\n//////            }\n\n//////            try\n//////            {\n//////                var result = await campaignService.SendTemplateCampaignWithTypeDetectionAsync(job.CampaignId);\n\n//////                if (result.Success)\n//////                {\n//////                    if (campaign != null)\n//////                    {\n//////                        campaign.Status = \"Sent\";\n//////                        campaign.UpdatedAt = DateTime.UtcNow;\n//////                        await db.SaveChangesAsync(ct);\n//////                    }\n\n//////                    await queue.MarkSucceededAsync(job.Id);\n//////                    log.LogInformation(\"Job {Job} succeeded for campaign {Campaign}\", jobId, job.CampaignId);\n//////                }\n//////                else\n//////                {\n//////                    // Compute whether we will retry BEFORE calling MarkFailed (Attempt not yet incremented)\n//////                    var willRetry = job.Attempt + 1 < job.MaxAttempts;\n\n//////                    if (campaign != null)\n//////                    {\n//////                        campaign.Status = willRetry ? \"Queued\" : \"Failed\";\n//////                        campaign.UpdatedAt = DateTime.UtcNow;\n//////                        await db.SaveChangesAsync(ct);\n//////                    }\n\n//////                    await queue.MarkFailedAsync(job.Id, result.Message ?? \"Unknown send error\", scheduleRetry: true);\n//////                    log.LogWarning(\"Job {Job} failed for campaign {Campaign}: {Msg}\", jobId, job.CampaignId, result.Message);\n//////                }\n//////            }\n//////            catch (Exception ex)\n//////            {\n//////                var willRetry = job.Attempt + 1 < job.MaxAttempts;\n\n//////                if (campaign != null)\n//////                {\n//////                    campaign.Status = willRetry ? \"Queued\" : \"Failed\";\n//////                    campaign.UpdatedAt = DateTime.UtcNow;\n//////                    await db.SaveChangesAsync(ct);\n//////                }\n\n//////                await queue.MarkFailedAsync(job.Id, ex.ToString(), scheduleRetry: true);\n//////                log.LogWarning(ex, \"Job {Job} exception for campaign {Campaign}\", jobId, job.CampaignId);\n//////            }\n//////        }\n//////    }\n//////}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboundSenderWorker.cs",
      "sha256": "74e4df795d756850a50bdf962865fd3ff0b38fa2cd0e5ba71aa402aa94a6a6de",
      "language": "csharp",
      "size": 63230,
      "content": "// ðŸ“„ File: Features/CampaignModule/Workers/OutboundSenderWorker.cs\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Channels;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Npgsql;\n\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Logging;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.MessageLogging.Services;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.CampaignModule.SendEngine;\nusing xbytechat_api.Features.Billing.Services;\nusing xbytechat.api.Infrastructure.Observability;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.WhatsAppSettings.Helpers;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public class OutboundSenderWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundSenderWorker> _log;\n        private readonly Channel<OutboundMessageJob> _channel;\n        private const int DEFAULT_MAX_ATTEMPTS = 3;\n\n        // Concurrency caps\n        private readonly int _globalDop = 32;   // total parallel consumers\n        private readonly int _perNumberDop = 8; // per (provider, PhoneNumberId)\n\n        private readonly TimeSpan _pollInterval = TimeSpan.FromMilliseconds(250);\n        private static readonly TimeSpan _flightTimeout = TimeSpan.FromMinutes(5);\n\n        private int _inChannel;\n        private readonly Random _rand = new();\n\n        // =========================[ Template Button Cache + Parsers ]=========================\n        private static readonly ConcurrentDictionary<string, IReadOnlyList<ButtonMeta>> _btnCache =\n            new(StringComparer.Ordinal);\n\n        private static readonly Regex RxButtonTypeMeta = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n        private static readonly Regex RxButtonTypePinn = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        private static string CacheKeyForTemplate(WhatsAppTemplate tpl)\n            => $\"{tpl.BusinessId}|{tpl.Provider}|{tpl.Name}|{tpl.LanguageCode}\".ToUpperInvariant();\n\n        private static IReadOnlyList<ButtonMeta> GetTemplateButtonsCached(WhatsAppTemplate tpl)\n            => _btnCache.GetOrAdd(CacheKeyForTemplate(tpl), _ => ParseButtonsFromTemplateRow(tpl));\n\n        private static IReadOnlyList<ButtonMeta> ParseButtonsFromTemplateRow(WhatsAppTemplate tpl)\n        {\n            if (!string.IsNullOrWhiteSpace(tpl.UrlButtons))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.UrlButtons);\n                    if (doc.RootElement.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n                        foreach (var el in doc.RootElement.EnumerateArray())\n                        {\n                            var text = el.TryGetProperty(\"ButtonText\", out var pText) ? pText.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Text\", out var pText2) ? pText2.GetString() ?? \"\" : \"\";\n                            var type = el.TryGetProperty(\"ButtonType\", out var pType) ? pType.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Type\", out var pType2) ? pType2.GetString() ?? \"\" : \"\";\n                            var url = el.TryGetProperty(\"TargetUrl\", out var pUrl) ? pUrl.GetString() : null;\n\n                            if (!string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(type))\n                                list.Add(new ButtonMeta(text, type, url));\n                        }\n                        return list;\n                    }\n                }\n                catch { /* fallthrough */ }\n            }\n\n            if (!string.IsNullOrWhiteSpace(tpl.RawJson))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.RawJson);\n\n                    JsonElement comps = default;\n                    if (doc.RootElement.TryGetProperty(\"template\", out var tplNode) &&\n                        tplNode.TryGetProperty(\"components\", out var comps1))\n                    {\n                        comps = comps1;\n                    }\n                    else if (doc.RootElement.TryGetProperty(\"components\", out var comps2))\n                    {\n                        comps = comps2;\n                    }\n\n                    if (comps.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n\n                        foreach (var c in comps.EnumerateArray())\n                        {\n                            if (!c.TryGetProperty(\"type\", out var tProp)) continue;\n                            if (!string.Equals(tProp.GetString(), \"button\", StringComparison.OrdinalIgnoreCase)) continue;\n\n                            var isUrl =\n                                (c.TryGetProperty(\"sub_type\", out var st) && RxButtonTypeMeta.IsMatch(st.GetString() ?? \"\")) ||\n                                (c.TryGetProperty(\"subType\", out var st2) && RxButtonTypePinn.IsMatch(st2.GetString() ?? \"\"));\n\n                            if (!isUrl) continue;\n\n                            string text = \"Open\";\n                            string type = \"url\";\n                            string? url = null;\n\n                            if (c.TryGetProperty(\"parameters\", out var pars) && pars.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var p in pars.EnumerateArray())\n                                {\n                                    if (p.TryGetProperty(\"text\", out var txtProp))\n                                    {\n                                        var v = txtProp.GetString();\n                                        if (!string.IsNullOrWhiteSpace(v)) { url = v; break; }\n                                    }\n                                }\n                            }\n\n                            list.Add(new ButtonMeta(text, type, url));\n                            if (list.Count >= 3) break;\n                        }\n\n                        return list;\n                    }\n                }\n                catch { /* ignore */ }\n            }\n\n            return Array.Empty<ButtonMeta>();\n        }\n        // =====================================================================================\n\n        public OutboundSenderWorker(IServiceProvider sp, ILogger<OutboundSenderWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n\n            _channel = Channel.CreateBounded<OutboundMessageJob>(new BoundedChannelOptions(5000)\n            {\n                SingleReader = false,\n                SingleWriter = false,\n                FullMode = BoundedChannelFullMode.Wait\n            });\n        }\n\n\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);\n            var ct = cts.Token;\n\n            var consumers = Enumerable.Range(0, _globalDop)\n                .Select(_ => Task.Run(() => ConsumeAsync(ct), ct))\n                .ToArray();\n\n            var producer = Task.Run(() => ProduceAsync(ct), ct);\n\n            var all = consumers.Append(producer).ToArray();\n\n            try\n            {\n                await Task.WhenAll(all);\n            }\n            catch\n            {\n                try { cts.Cancel(); } catch { /* ignore */ }\n                throw;\n            }\n        }\n\n        private async Task ProduceAsync(CancellationToken ct)\n        {\n            const int ChannelCapacity = 5000;\n\n            var idleDelay = _pollInterval;\n            var maxIdleDelay = TimeSpan.FromSeconds(1);\n            var longIdleDelay = TimeSpan.FromSeconds(30);\n            int consecutiveEmpty = 0;\n\n            const string sql = @\"\nWITH cte AS (\n    SELECT \"\"Id\"\"\n    FROM \"\"OutboundMessageJobs\"\"\n    WHERE \"\"Status\"\" = 'Pending'\n      AND (\"\"NextAttemptAt\"\" IS NULL OR \"\"NextAttemptAt\"\" <= NOW())\n    ORDER BY \"\"NextAttemptAt\"\" NULLS FIRST, \"\"CreatedAt\"\"\n    FOR UPDATE SKIP LOCKED\n    LIMIT @take\n)\nUPDATE \"\"OutboundMessageJobs\"\" j\nSET \"\"Status\"\" = 'InFlight',\n    \"\"NextAttemptAt\"\" = NOW() + make_interval(secs => @flight),\n    \"\"LastError\"\" = NULL\nWHERE j.\"\"Id\"\" IN (SELECT \"\"Id\"\" FROM cte)\nRETURNING j.*;\";\n\n            try { await Task.Delay(_rand.Next(100, 500), ct); } catch { /* ignore */ }\n\n            while (!ct.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var approxCount = Volatile.Read(ref _inChannel);\n                    var budget = Math.Max(0, ChannelCapacity - approxCount);\n\n                    if (budget <= 0)\n                    {\n                        await Task.Delay(idleDelay, ct);\n                        idleDelay = TimeSpan.FromMilliseconds(\n                            Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 1.25)\n                        );\n                        continue;\n                    }\n\n                    idleDelay = _pollInterval;\n\n                    var take = Math.Min(budget, 2000);\n                    var flightSecs = (int)Math.Ceiling(_flightTimeout.TotalSeconds);\n\n                    var takeParam = new NpgsqlParameter<int>(\"take\", take);\n                    var flightParam = new NpgsqlParameter<int>(\"flight\", flightSecs);\n\n                    var prevTimeout = db.Database.GetCommandTimeout();\n                    db.Database.SetCommandTimeout(5);\n\n                    List<OutboundMessageJob> jobs;\n                    try\n                    {\n                        jobs = await db.OutboundMessageJobs\n                            .FromSqlRaw(sql, takeParam, flightParam)\n                            .AsNoTracking()\n                            .ToListAsync(ct);\n                    }\n                    finally\n                    {\n                        db.Database.SetCommandTimeout(prevTimeout);\n                    }\n\n                    foreach (var job in jobs)\n                    {\n                        await _channel.Writer.WriteAsync(job, ct);\n                        Interlocked.Increment(ref _inChannel);\n                    }\n\n                    if (jobs.Count == 0)\n                    {\n                        consecutiveEmpty++;\n                        var jitterMs = _rand.Next(0, 200);\n                        var delay = idleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        if (consecutiveEmpty >= 8 && idleDelay >= maxIdleDelay)\n                            delay = longIdleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        await Task.Delay(delay, ct);\n\n                        if (idleDelay < maxIdleDelay)\n                        {\n                            idleDelay = TimeSpan.FromMilliseconds(\n                                Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 2)\n                            );\n                        }\n                    }\n                    else\n                    {\n                        consecutiveEmpty = 0;\n                        idleDelay = _pollInterval;\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[Outbox] Producer loop error\");\n                    try { await Task.Delay(TimeSpan.FromSeconds(2), ct); } catch { /* ignore */ }\n                }\n            }\n        }\n\n        // ---- keyed concurrency gate (per sender) ---------------------------------------\n        private sealed class KeyedSemaphore\n        {\n            private readonly ConcurrentDictionary<string, SemaphoreSlim> _map = new();\n            public async Task<IDisposable> AcquireAsync(string key, int dop, CancellationToken ct)\n            {\n                var sem = _map.GetOrAdd(key, _ => new SemaphoreSlim(dop));\n                await sem.WaitAsync(ct);\n                return new Releaser(sem);\n            }\n            private sealed class Releaser : IDisposable\n            {\n                private readonly SemaphoreSlim _s;\n                public Releaser(SemaphoreSlim s) => _s = s;\n                public void Dispose() => _s.Release();\n            }\n        }\n        private static readonly KeyedSemaphore _perSenderGate = new();\n        // -------------------------------------------------------------------------------\n\n        // Best-effort extraction of provider message id from a Meta success body\n        private static string? TryExtractProviderMessageId(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            try\n            {\n                using var doc = JsonDocument.Parse(raw);\n                if (doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0 &&\n                    msgs[0].TryGetProperty(\"id\", out var idProp))\n                {\n                    return idProp.GetString();\n                }\n            }\n            catch { /* ignore */ }\n            return null;\n        }\n\n        private async Task ConsumeAsync(CancellationToken ct)\n        {\n            static async Task<string> ResolveRecipientPhoneAsync(AppDbContext db, Guid recipientId, CancellationToken ct2)\n            {\n                var phone = await db.CampaignRecipients\n                    .AsNoTracking()\n                    .Where(r => r.Id == recipientId)\n                    .Select(r =>\n                        r.Contact != null\n                            ? r.Contact.PhoneNumber\n                            : (r.AudienceMember != null\n                                ? (r.AudienceMember.PhoneE164 ?? r.AudienceMember.PhoneRaw)\n                                : null))\n                    .FirstOrDefaultAsync(ct2);\n\n                return phone ?? string.Empty;\n            }\n\n            while (await _channel.Reader.WaitToReadAsync(ct))\n            {\n                if (!_channel.Reader.TryRead(out var job))\n                    continue;\n\n                Interlocked.Decrement(ref _inChannel);\n\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var engine = scope.ServiceProvider.GetRequiredService<IMessageEngineService>();\n                    var billing = scope.ServiceProvider.GetRequiredService<IBillingIngestService>();\n                    var logger = scope.ServiceProvider.GetRequiredService<ILogger<OutboundSenderWorker>>();\n                    var logSink = scope.ServiceProvider.GetRequiredService<ICampaignLogSink>();\n                    var limiter = scope.ServiceProvider.GetRequiredService<xbytechat.api.Infrastructure.RateLimiting.IPhoneNumberRateLimiter>();\n                    var messageLogSink = scope.ServiceProvider.GetRequiredService<IMessageLogSink>();\n                    var builder = scope.ServiceProvider.GetRequiredService<ITemplatePayloadBuilder>();\n                    var validator = scope.ServiceProvider.GetRequiredService<ICampaignSendValidator>();\n\n                    var senderKey = $\"{job.Provider}|{job.PhoneNumberId}\";\n\n                    using (await _perSenderGate.AcquireAsync(senderKey, _perNumberDop, ct))\n                    {\n                        var lease = await limiter.AcquireAsync(senderKey, ct);\n                        if (!lease.IsAcquired)\n                        {\n                            await Task.Delay(50, ct);\n                            continue;\n                        }\n\n                        var recipientPhone = await ResolveRecipientPhoneAsync(db, job.RecipientId, ct);\n                        if (string.IsNullOrWhiteSpace(recipientPhone))\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = \"Recipient phone not found.\";\n                            var backoff1 = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff1);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Recipient phone not found. job={JobId} recipient={RecipientId}\", job.Id, job.RecipientId);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        var lang = job.LanguageCode ?? \"en_US\";\n                        var tmplRow = await db.WhatsAppTemplates\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(t =>\n                                t.BusinessId == job.BusinessId &&\n                                t.Provider == job.Provider &&\n                                t.Name == job.TemplateName &&\n                                t.LanguageCode == lang,\n                                ct);\n\n                        if (tmplRow == null)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = $\"Template not found: {job.TemplateName} ({lang}) for {job.Provider}.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Template not found. job={JobId} template={Template} lang={Lang} provider={Provider}\",\n                                job.Id, job.TemplateName, lang, job.Provider);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        HeaderKind headerKind = tmplRow.HeaderKind?.ToLowerInvariant() switch\n                        {\n                            \"text\" => HeaderKind.Text,\n                            \"image\" => HeaderKind.Image,\n                            \"video\" => HeaderKind.Video,\n                            \"document\" => HeaderKind.Document,\n                            \"none\" or null => HeaderKind.None,\n                            _ => HeaderKind.None\n                        };\n                        if (headerKind == HeaderKind.None && !string.IsNullOrWhiteSpace(job.MediaType))\n                        {\n                            headerKind = job.MediaType.ToLowerInvariant() switch\n                            {\n                                \"text\" => HeaderKind.Text,\n                                \"image\" => HeaderKind.Image,\n                                \"video\" => HeaderKind.Video,\n                                \"document\" => HeaderKind.Document,\n                                _ => HeaderKind.None\n                            };\n                        }\n\n                        var providerEnum = ProviderUtil.Parse(job.Provider);\n                        var buttonsFromTemplate = GetTemplateButtonsCached(tmplRow);\n\n                        var plan = new SendPlan(\n                            BusinessId: job.BusinessId,\n                            Provider: providerEnum,\n                            PhoneNumberId: job.PhoneNumberId!,\n                            TemplateName: job.TemplateName!,\n                            LanguageCode: lang,\n                            HeaderKind: headerKind,\n                            HeaderUrl: job.HeaderMediaUrl,\n                            Buttons: buttonsFromTemplate\n                        );\n\n                        var recipient = new RecipientPlan(\n                            RecipientId: job.RecipientId,\n                            ToPhoneE164: recipientPhone,\n                            ParametersJson: job.ResolvedParamsJson ?? \"[]\",\n                            ButtonParamsJson: job.ResolvedButtonUrlsJson,\n                            IdempotencyKey: job.IdempotencyKey ?? $\"{job.CampaignId}:{recipientPhone}:{job.TemplateName}\"\n                        );\n\n                        var envelope = builder.Build(plan, recipient);\n\n                        var (ok, error) = validator.Validate(plan, recipient, envelope, tmplRow);\n                        if (!ok)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = error ?? \"Validation failed.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Validation failed job={JobId} error={Error}\", job.Id, job.LastError);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        object payload = providerEnum switch\n                        {\n                            Provider.MetaCloud =>\n                                scope.ServiceProvider.GetRequiredService<MetaCloudPayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            Provider.Pinnacle =>\n                                scope.ServiceProvider.GetRequiredService<PinnaclePayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            _ => throw new InvalidOperationException(\"Unknown provider\")\n                        };\n\n                        var sw = Stopwatch.StartNew();\n                        var engineResult = await engine.SendPayloadAsync(job.BusinessId, job.Provider, payload, job.PhoneNumberId);\n                        sw.Stop();\n                        MetricsRegistry.SendLatencyMs.Record(sw.Elapsed.TotalMilliseconds);\n\n                        if (!engineResult.Success)\n                        {\n                            var err = engineResult.ErrorMessage ?? string.Empty;\n                            if (err.Contains(\"429\", StringComparison.Ordinal) ||\n                                err.Contains(\"Too Many Requests\", StringComparison.OrdinalIgnoreCase))\n                            {\n                                limiter.UpdateLimits(senderKey, permitsPerSecond: 5, burst: 5);\n                                MetricsRegistry.RateLimited429s.Add(1);\n                            }\n                        }\n\n                        // âœ… Surface provider ID and raw body for visibility\n                        var providerMsgId = !string.IsNullOrWhiteSpace(engineResult.MessageId)\n                            ? engineResult.MessageId\n                            : TryExtractProviderMessageId(engineResult.RawResponse);\n\n                        if (engineResult.Success)\n                        {\n                            logger.LogInformation(\"Provider send OK | providerMessageId={ProviderId} job={JobId} to={To}\",\n                                providerMsgId, job.Id, recipientPhone);\n                        }\n                        else\n                        {\n                            logger.LogWarning(\"Provider send FAILED | job={JobId} to={To} error={Error} body={Body}\",\n                                job.Id, recipientPhone, engineResult.ErrorMessage, engineResult.RawResponse);\n                        }\n\n                        // Persist MessageLogs (COPY sink)\n                        var now = DateTime.UtcNow;\n                        var runId = Guid.NewGuid();\n                        var logId = Guid.NewGuid();\n\n                        logger.LogInformation(\n                            \"[OutboundSenderWorker] Enqueue MessageLog id={LogId} recipient={RecipientId} job={JobId}\",\n                            logId, job.RecipientId, job.Id);\n\n                        messageLogSink.Enqueue(new MessageLog\n                        {\n                            Id = logId,\n                            BusinessId = job.BusinessId,\n                            CampaignId = job.CampaignId,\n                            RecipientNumber = recipientPhone,\n                            MessageContent = job.TemplateName,\n                            MediaUrl = job.HeaderMediaUrl,\n                            Status = engineResult.Success ? \"Sent\" : \"Failed\",\n                            MessageId = providerMsgId,\n                            ErrorMessage = engineResult.ErrorMessage,\n                            RawResponse = engineResult.RawResponse,\n                            CreatedAt = now,\n                            SentAt = engineResult.Success ? now : (DateTime?)null,\n                            Source = \"campaign\",\n                            RunId = runId,\n                            Provider = job.Provider,\n                            ProviderMessageId = providerMsgId,\n                            IsIncoming = false,\n                            IsChargeable = false\n                        });\n\n                        // Batched CampaignSendLog (COPY via sink)\n                        logSink.Enqueue(new CampaignLogRecord(\n                            Id: Guid.NewGuid(),\n                            RunId: runId,\n                            MessageId: providerMsgId,\n                            CampaignId: job.CampaignId,\n                            ContactId: null,\n                            RecipientId: job.RecipientId,\n                            MessageBody: job.MessageBody ?? job.TemplateName,\n                            TemplateId: job.TemplateName,\n                            SendStatus: engineResult.Success ? \"Sent\" : \"Failed\",\n                            ErrorMessage: engineResult.ErrorMessage,\n                            CreatedAt: now,\n                            CreatedBy: \"system\",\n                            SentAt: engineResult.Success ? now : (DateTime?)null,\n                            DeliveredAt: null,\n                            ReadAt: null,\n                            IpAddress: null,\n                            DeviceInfo: null,\n                            MacAddress: null,\n                            SourceChannel: \"campaign\",\n                            DeviceType: null,\n                            Browser: null,\n                            Country: null,\n                            City: null,\n                            IsClicked: false,\n                            ClickedAt: null,\n                            ClickType: null,\n                            RetryCount: job.Attempt,\n                            LastRetryAt: now,\n                            LastRetryStatus: engineResult.Success ? \"Success\" : \"Failed\",\n                            AllowRetry: job.Attempt < DEFAULT_MAX_ATTEMPTS,\n                            MessageLogId: logId,\n                            BusinessId: job.BusinessId,\n                            CTAFlowConfigId: null,\n                            CTAFlowStepId: null,\n                            ButtonBundleJson: null\n                        ));\n\n                        // Update job (retry/backoff if needed)\n                        job.Status = engineResult.Success ? \"Sent\" : \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = engineResult.ErrorMessage;\n\n                        if (!engineResult.Success)\n                        {\n                            var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                        }\n                        else\n                        {\n                            job.NextAttemptAt = null;\n                            MetricsRegistry.MessagesSent.Add(1);\n                        }\n\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n\n                        await billing.IngestFromSendResponseAsync(\n                            job.BusinessId,\n                            logId,\n                            job.Provider,\n                            engineResult.RawResponse ?? \"{}\"\n                        );\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    try\n                    {\n                        using var scope = _sp.CreateScope();\n                        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                        job.Status = \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = ex.Message;\n                        var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                        job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n                    }\n                    catch { /* swallow */ }\n\n                    MetricsRegistry.MessagesFailed.Add(1);\n                    _log.LogError(ex, \"[Outbox] Consume error job={JobId}\", job.Id);\n                }\n            }\n        }\n    }\n}\n\n\n//// ðŸ“„ File: Features/CampaignModule/Workers/OutboundSenderWorker.cs\n//using System;\n//using System.Collections.Concurrent;\n//using System.Collections.Generic;   // NEW\n//using System.Diagnostics;\n//using System.Linq;\n//using System.Text.Json;            // NEW\n//using System.Text.RegularExpressions; // NEW\n//using System.Threading;\n//using System.Threading.Channels;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.DependencyInjection;\n//using Microsoft.Extensions.Hosting;\n//using Microsoft.Extensions.Logging;\n//using Npgsql;\n\n//using xbytechat.api;\n//using xbytechat.api.Features.CampaignModule.Models;\n//using xbytechat.api.Features.CampaignTracking.Logging;\n//using xbytechat.api.Features.CampaignTracking.Models;\n//using xbytechat.api.Features.MessageLogging.Services;\n//using xbytechat.api.Features.MessagesEngine.Abstractions;\n//using xbytechat.api.Features.CampaignModule.SendEngine;\n//using xbytechat_api.Features.Billing.Services;\n//using xbytechat.api.Infrastructure.Observability;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.WhatsAppSettings.Helpers;\n//using xbytechat.api.AuthModule.Models;\n\n//namespace xbytechat.api.Features.CampaignModule.Workers\n//{\n//    public class OutboundSenderWorker : BackgroundService\n//    {\n//        private readonly IServiceProvider _sp;\n//        private readonly ILogger<OutboundSenderWorker> _log;\n//        private readonly Channel<OutboundMessageJob> _channel;\n//        private const int DEFAULT_MAX_ATTEMPTS = 3;\n\n//        // Concurrency caps (override via appsettings if you expose options)\n//        private readonly int _globalDop = 32;   // total parallel consumers\n//        private readonly int _perNumberDop = 8; // per (provider, PhoneNumberId)\n\n//        private readonly TimeSpan _pollInterval = TimeSpan.FromMilliseconds(250);\n//        private static readonly TimeSpan _flightTimeout = TimeSpan.FromMinutes(5);\n\n//        private int _inChannel;\n//        private readonly Random _rand = new();\n\n//        // =========================[ NEW: Template Button Cache + Parsers ]=========================\n//        // Cache key = BusinessId|Provider|TemplateName|Language (upper-invariant)\n//        private static readonly ConcurrentDictionary<string, IReadOnlyList<ButtonMeta>> _btnCache =\n//            new(StringComparer.Ordinal);\n\n//        // Precompiled regexes for any legacy/raw variations (cheap + fast on hot path)\n//        private static readonly Regex RxButtonTypeMeta = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n//        private static readonly Regex RxButtonTypePinn = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n//        private static string CacheKeyForTemplate(WhatsAppTemplate tpl)\n//            => $\"{tpl.BusinessId}|{tpl.Provider}|{tpl.Name}|{tpl.LanguageCode}\".ToUpperInvariant();\n\n//        private static IReadOnlyList<ButtonMeta> GetTemplateButtonsCached(WhatsAppTemplate tpl)\n//            => _btnCache.GetOrAdd(CacheKeyForTemplate(tpl), _ => ParseButtonsFromTemplateRow(tpl));\n\n//        private static IReadOnlyList<ButtonMeta> ParseButtonsFromTemplateRow(WhatsAppTemplate tpl)\n//        {\n//            // 1) Preferred: light-weight ButtonsJson (DTO-style) if available\n//            if (!string.IsNullOrWhiteSpace(tpl.UrlButtons))\n//            {\n//                try\n//                {\n//                    using var doc = JsonDocument.Parse(tpl.UrlButtons);\n//                    if (doc.RootElement.ValueKind == JsonValueKind.Array)\n//                    {\n//                        var list = new List<ButtonMeta>(capacity: 3);\n//                        foreach (var el in doc.RootElement.EnumerateArray())\n//                        {\n//                            // Support both historical shapes:\n//                            // { \"ButtonText\",\"ButtonType\",\"TargetUrl\" }  OR  { \"Text\",\"Type\",\"TargetUrl\" }\n//                            var text = el.TryGetProperty(\"ButtonText\", out var pText) ? pText.GetString() ?? \"\" :\n//                                       el.TryGetProperty(\"Text\", out var pText2) ? pText2.GetString() ?? \"\" : \"\";\n//                            var type = el.TryGetProperty(\"ButtonType\", out var pType) ? pType.GetString() ?? \"\" :\n//                                       el.TryGetProperty(\"Type\", out var pType2) ? pType2.GetString() ?? \"\" : \"\";\n//                            var url = el.TryGetProperty(\"TargetUrl\", out var pUrl) ? pUrl.GetString() : null;\n\n//                            if (!string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(type))\n//                                list.Add(new ButtonMeta(text, type, url));\n//                        }\n//                        return list;\n//                    }\n//                }\n//                catch\n//                {\n//                    // Fallthrough to RawJson parser\n//                }\n//            }\n\n//            // 2) Fallback: parse RawJson (provider-native). Look for button components with url subtype.\n//            if (!string.IsNullOrWhiteSpace(tpl.RawJson))\n//            {\n//                try\n//                {\n//                    using var doc = JsonDocument.Parse(tpl.RawJson);\n\n//                    // Try to locate \"components\" either under \"template\" or at root\n//                    JsonElement comps = default;\n//                    if (doc.RootElement.TryGetProperty(\"template\", out var tplNode) &&\n//                        tplNode.TryGetProperty(\"components\", out var comps1))\n//                    {\n//                        comps = comps1;\n//                    }\n//                    else if (doc.RootElement.TryGetProperty(\"components\", out var comps2))\n//                    {\n//                        comps = comps2;\n//                    }\n\n//                    if (comps.ValueKind == JsonValueKind.Array)\n//                    {\n//                        var list = new List<ButtonMeta>(capacity: 3);\n\n//                        foreach (var c in comps.EnumerateArray())\n//                        {\n//                            // Meta:   { \"type\":\"button\", \"sub_type\":\"url\", \"index\":\"0\", ... }\n//                            // Pinn.:  { \"type\":\"button\", \"subType\":\"url\", \"index\": 0, ... }\n//                            if (!c.TryGetProperty(\"type\", out var tProp)) continue;\n//                            if (!string.Equals(tProp.GetString(), \"button\", StringComparison.OrdinalIgnoreCase)) continue;\n\n//                            var isUrl =\n//                                (c.TryGetProperty(\"sub_type\", out var st) && RxButtonTypeMeta.IsMatch(st.GetString() ?? \"\")) ||\n//                                (c.TryGetProperty(\"subType\", out var st2) && RxButtonTypePinn.IsMatch(st2.GetString() ?? \"\"));\n\n//                            if (!isUrl) continue;\n\n//                            // Text label may not be present in raw; use a neutral label\n//                            string text = \"Open\";\n//                            string type = \"url\";\n//                            string? url = null;\n\n//                            // If static url parameter is present, try to read it\n//                            if (c.TryGetProperty(\"parameters\", out var pars) && pars.ValueKind == JsonValueKind.Array)\n//                            {\n//                                foreach (var p in pars.EnumerateArray())\n//                                {\n//                                    if (p.TryGetProperty(\"text\", out var txtProp))\n//                                    {\n//                                        var v = txtProp.GetString();\n//                                        if (!string.IsNullOrWhiteSpace(v)) { url = v; break; }\n//                                    }\n//                                }\n//                            }\n\n//                            list.Add(new ButtonMeta(text, type, url));\n//                            if (list.Count >= 3) break; // WhatsApp UI supports up to 3 buttons\n//                        }\n\n//                        return list;\n//                    }\n//                }\n//                catch\n//                {\n//                    // ignore, fallthrough\n//                }\n//            }\n\n//            return Array.Empty<ButtonMeta>();\n//        }\n//        // ==========================================================================================\n\n//        public OutboundSenderWorker(IServiceProvider sp, ILogger<OutboundSenderWorker> log)\n//        {\n//            _sp = sp;\n//            _log = log;\n\n//            _channel = Channel.CreateBounded<OutboundMessageJob>(new BoundedChannelOptions(5000)\n//            {\n//                SingleReader = false,\n//                SingleWriter = false,\n//                FullMode = BoundedChannelFullMode.Wait\n//            });\n//        }\n\n//        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//        {\n//            using var cts = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);\n//            var ct = cts.Token;\n\n//            var consumers = Enumerable.Range(0, _globalDop)\n//                .Select(_ => Task.Run(() => ConsumeAsync(ct), ct))\n//                .ToArray();\n\n//            var producer = Task.Run(() => ProduceAsync(ct), ct);\n\n//            var all = consumers.Append(producer).ToArray();\n\n//            try\n//            {\n//                await Task.WhenAll(all);\n//            }\n//            catch\n//            {\n//                try { cts.Cancel(); } catch { /* ignore */ }\n//                throw;\n//            }\n//        }\n\n//        private async Task ProduceAsync(CancellationToken ct)\n//        {\n//            const int ChannelCapacity = 5000;\n\n//            // Backoff controls\n//            var idleDelay = _pollInterval;                 // starts small\n//            var maxIdleDelay = TimeSpan.FromSeconds(1);    // back off up to 1s\n//            var longIdleDelay = TimeSpan.FromSeconds(30);  // after many empties\n//            int consecutiveEmpty = 0;\n\n//            // Prioritize due items; then FIFO by CreatedAt\n//            const string sql = @\"\n//WITH cte AS (\n//    SELECT \"\"Id\"\"\n//    FROM \"\"OutboundMessageJobs\"\"\n//    WHERE \"\"Status\"\" = 'Pending'\n//      AND (\"\"NextAttemptAt\"\" IS NULL OR \"\"NextAttemptAt\"\" <= NOW())\n//    ORDER BY \"\"NextAttemptAt\"\" NULLS FIRST, \"\"CreatedAt\"\"\n//    FOR UPDATE SKIP LOCKED\n//    LIMIT @take\n//)\n//UPDATE \"\"OutboundMessageJobs\"\" j\n//SET \"\"Status\"\" = 'InFlight',\n//    \"\"NextAttemptAt\"\" = NOW() + make_interval(secs => @flight),\n//    \"\"LastError\"\" = NULL\n//WHERE j.\"\"Id\"\" IN (SELECT \"\"Id\"\" FROM cte)\n//RETURNING j.*;\";\n\n//            // Small jittered pause on startup to avoid log bursts on app boot\n//            try { await Task.Delay(_rand.Next(100, 500), ct); } catch { /* ignore */ }\n\n//            while (!ct.IsCancellationRequested)\n//            {\n//                try\n//                {\n//                    using var scope = _sp.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//                    // Channel budget\n//                    var approxCount = Volatile.Read(ref _inChannel);\n//                    var budget = Math.Max(0, ChannelCapacity - approxCount);\n\n//                    if (budget <= 0)\n//                    {\n//                        await Task.Delay(idleDelay, ct);\n//                        idleDelay = TimeSpan.FromMilliseconds(\n//                            Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 1.25)\n//                        );\n//                        continue;\n//                    }\n\n//                    // We have budget; donâ€™t carry a long backoff into a fresh poll cycle\n//                    idleDelay = _pollInterval;\n\n//                    var take = Math.Min(budget, 2000);\n//                    var flightSecs = (int)Math.Ceiling(_flightTimeout.TotalSeconds);\n\n//                    var takeParam = new NpgsqlParameter<int>(\"take\", take);\n//                    var flightParam = new NpgsqlParameter<int>(\"flight\", flightSecs);\n\n//                    var prevTimeout = db.Database.GetCommandTimeout();\n//                    db.Database.SetCommandTimeout(5);\n\n//                    List<OutboundMessageJob> jobs;\n//                    try\n//                    {\n//                        jobs = await db.OutboundMessageJobs\n//                            .FromSqlRaw(sql, takeParam, flightParam)\n//                            .AsNoTracking()\n//                            .ToListAsync(ct);\n//                    }\n//                    finally\n//                    {\n//                        db.Database.SetCommandTimeout(prevTimeout);\n//                    }\n\n//                    // Push to channel; track occupancy\n//                    foreach (var job in jobs)\n//                    {\n//                        await _channel.Writer.WriteAsync(job, ct);\n//                        Interlocked.Increment(ref _inChannel);\n//                    }\n\n//                    if (jobs.Count == 0)\n//                    {\n//                        consecutiveEmpty++;\n\n//                        // No work â†’ exponential backoff, then step up to a longer 30s sleep\n//                        var jitterMs = _rand.Next(0, 200);\n//                        var delay = idleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n//                        // After several empty loops, cut DB chatter significantly\n//                        if (consecutiveEmpty >= 8 && idleDelay >= maxIdleDelay)\n//                            delay = longIdleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n//                        await Task.Delay(delay, ct);\n\n//                        if (idleDelay < maxIdleDelay)\n//                        {\n//                            idleDelay = TimeSpan.FromMilliseconds(\n//                                Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 2)\n//                            );\n//                        }\n//                    }\n//                    else\n//                    {\n//                        consecutiveEmpty = 0;\n//                        idleDelay = _pollInterval;\n//                    }\n//                }\n//                catch (TaskCanceledException)\n//                {\n//                    // normal shutdown\n//                }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"[Outbox] Producer loop error\");\n//                    try { await Task.Delay(TimeSpan.FromSeconds(2), ct); } catch { /* ignore */ }\n//                }\n//            }\n//        }\n\n//        // ---- keyed concurrency gate (per sender) ---------------------------------------\n//        private sealed class KeyedSemaphore\n//        {\n//            private readonly ConcurrentDictionary<string, SemaphoreSlim> _map = new();\n//            public async Task<IDisposable> AcquireAsync(string key, int dop, CancellationToken ct)\n//            {\n//                var sem = _map.GetOrAdd(key, _ => new SemaphoreSlim(dop));\n//                await sem.WaitAsync(ct);\n//                return new Releaser(sem);\n//            }\n//            private sealed class Releaser : IDisposable\n//            {\n//                private readonly SemaphoreSlim _s;\n//                public Releaser(SemaphoreSlim s) => _s = s;\n//                public void Dispose() => _s.Release();\n//            }\n//        }\n//        private static readonly KeyedSemaphore _perSenderGate = new();\n//        // -------------------------------------------------------------------------------\n//        private async Task ConsumeAsync(CancellationToken ct)\n//        {\n//            // Resolve a phone number for a recipient (Contact.Phone or AudienceMember.PhoneE164/Raw)\n//            static async Task<string> ResolveRecipientPhoneAsync(AppDbContext db, Guid recipientId, CancellationToken ct2)\n//            {\n//                var phone = await db.CampaignRecipients\n//                    .AsNoTracking()\n//                    .Where(r => r.Id == recipientId)\n//                    .Select(r =>\n//                        r.Contact != null\n//                            ? r.Contact.PhoneNumber\n//                            : (r.AudienceMember != null\n//                                ? (r.AudienceMember.PhoneE164 ?? r.AudienceMember.PhoneRaw)\n//                                : null))\n//                    .FirstOrDefaultAsync(ct2);\n\n//                return phone ?? string.Empty;\n//            }\n\n//            while (await _channel.Reader.WaitToReadAsync(ct))\n//            {\n//                if (!_channel.Reader.TryRead(out var job))\n//                    continue;\n\n//                // decrement occupancy as soon as we pull from the channel\n//                Interlocked.Decrement(ref _inChannel);\n\n//                try\n//                {\n//                    using var scope = _sp.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//                    var engine = scope.ServiceProvider.GetRequiredService<IMessageEngineService>();\n//                    var billing = scope.ServiceProvider.GetRequiredService<IBillingIngestService>();\n//                    var logger = scope.ServiceProvider.GetRequiredService<ILogger<OutboundSenderWorker>>();\n//                    var logSink = scope.ServiceProvider.GetRequiredService<ICampaignLogSink>();\n//                    var limiter = scope.ServiceProvider.GetRequiredService<xbytechat.api.Infrastructure.RateLimiting.IPhoneNumberRateLimiter>();\n//                    var messageLogSink = scope.ServiceProvider.GetRequiredService<IMessageLogSink>();\n//                    var builder = scope.ServiceProvider.GetRequiredService<ITemplatePayloadBuilder>();\n//                    var validator = scope.ServiceProvider.GetRequiredService<ICampaignSendValidator>(); // âœ…\n\n//                    // Per-sender key = provider + phoneNumberId\n//                    var senderKey = $\"{job.Provider}|{job.PhoneNumberId}\";\n\n//                    using (await _perSenderGate.AcquireAsync(senderKey, _perNumberDop, ct))\n//                    {\n//                        // Rate limit per number (token bucket via your registered limiter)\n//                        var lease = await limiter.AcquireAsync(senderKey, ct);\n//                        if (!lease.IsAcquired)\n//                        {\n//                            await Task.Delay(50, ct);\n//                            continue;\n//                        }\n\n//                        // Resolve phone\n//                        var recipientPhone = await ResolveRecipientPhoneAsync(db, job.RecipientId, ct);\n//                        if (string.IsNullOrWhiteSpace(recipientPhone))\n//                        {\n//                            job.Status = \"Failed\";\n//                            job.Attempt += 1;\n//                            job.LastError = \"Recipient phone not found.\";\n//                            var backoff1 = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff1);\n//                            db.Update(job);\n//                            await db.SaveChangesAsync(ct);\n\n//                            logger.LogWarning(\"[Outbox] Recipient phone not found. job={JobId} recipient={RecipientId}\", job.Id, job.RecipientId);\n//                            MetricsRegistry.MessagesFailed.Add(1);\n//                            continue;\n//                        }\n\n//                        // ===== Load template row (cached metadata for validation)\n//                        var lang = job.LanguageCode ?? \"en_US\";\n//                        var tmplRow = await db.WhatsAppTemplates\n//                            .AsNoTracking()\n//                            .FirstOrDefaultAsync(t =>\n//                                t.BusinessId == job.BusinessId &&\n//                                t.Provider == job.Provider &&\n//                                t.Name == job.TemplateName &&\n//                                t.LanguageCode == lang,\n//                                ct);\n\n//                        if (tmplRow == null)\n//                        {\n//                            job.Status = \"Failed\";\n//                            job.Attempt += 1;\n//                            job.LastError = $\"Template not found: {job.TemplateName} ({lang}) for {job.Provider}.\";\n//                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n//                            db.Update(job);\n//                            await db.SaveChangesAsync(ct);\n\n//                            logger.LogWarning(\"[Outbox] Template not found. job={JobId} template={Template} lang={Lang} provider={Provider}\",\n//                                job.Id, job.TemplateName, lang, job.Provider);\n//                            MetricsRegistry.MessagesFailed.Add(1);\n//                            continue;\n//                        }\n\n//                        // Prefer DB header kind (normalized), fallback to job.MediaType\n//                        HeaderKind headerKind = tmplRow.HeaderKind?.ToLowerInvariant() switch\n//                        {\n//                            \"text\" => HeaderKind.Text,\n//                            \"image\" => HeaderKind.Image,\n//                            \"video\" => HeaderKind.Video,\n//                            \"document\" => HeaderKind.Document,\n//                            \"none\" or null => HeaderKind.None,\n//                            _ => HeaderKind.None\n//                        };\n//                        if (headerKind == HeaderKind.None && !string.IsNullOrWhiteSpace(job.MediaType))\n//                        {\n//                            headerKind = job.MediaType.ToLowerInvariant() switch\n//                            {\n//                                \"text\" => HeaderKind.Text,\n//                                \"image\" => HeaderKind.Image,\n//                                \"video\" => HeaderKind.Video,\n//                                \"document\" => HeaderKind.Document,\n//                                _ => HeaderKind.None\n//                            };\n//                        }\n\n//                        // ===== Build plan & recipient\n//                        var providerEnum = ProviderUtil.Parse(job.Provider);\n\n//                        // NEW: hydrate ButtonMeta list from the template row (cached)\n//                        var buttonsFromTemplate = GetTemplateButtonsCached(tmplRow);\n\n//                        var plan = new SendPlan(\n//                            BusinessId: job.BusinessId,\n//                            Provider: providerEnum,\n//                            PhoneNumberId: job.PhoneNumberId!,\n//                            TemplateName: job.TemplateName!,\n//                            LanguageCode: lang,\n//                            HeaderKind: headerKind,\n//                            HeaderUrl: job.HeaderMediaUrl,\n//                            Buttons: buttonsFromTemplate // <-- previously Array.Empty<ButtonMeta>()\n//                        );\n\n//                        var recipient = new RecipientPlan(\n//                            RecipientId: job.RecipientId,\n//                            ToPhoneE164: recipientPhone,\n//                            ParametersJson: job.ResolvedParamsJson ?? \"[]\",\n//                            ButtonParamsJson: job.ResolvedButtonUrlsJson,\n//                            IdempotencyKey: job.IdempotencyKey ?? $\"{job.CampaignId}:{recipientPhone}:{job.TemplateName}\"\n//                        );\n\n//                        // ===== Build envelope (generic) then VALIDATE before provider mapping\n//                        var envelope = builder.Build(plan, recipient); // TemplateEnvelope\n\n//                        // ICampaignSendValidator.Validate(plan, recipient, envelope, tmplRow)\n//                        var (ok, error) = validator.Validate(plan, recipient, envelope, tmplRow);\n//                        if (!ok)\n//                        {\n//                            job.Status = \"Failed\";\n//                            job.Attempt += 1;\n//                            job.LastError = error ?? \"Validation failed.\";\n//                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n//                            db.Update(job);\n//                            await db.SaveChangesAsync(ct);\n\n//                            logger.LogWarning(\"[Outbox] Validation failed job={JobId} error={Error}\", job.Id, job.LastError);\n//                            MetricsRegistry.MessagesFailed.Add(1);\n//                            continue;\n//                        }\n\n//                        // ===== Map to provider payload AFTER validation\n//                        object payload = providerEnum switch\n//                        {\n//                            Provider.MetaCloud =>\n//                                scope.ServiceProvider.GetRequiredService<MetaCloudPayloadMapper>()\n//                                    .BuildPayload(plan, recipient, envelope),\n\n//                            Provider.Pinnacle =>\n//                                scope.ServiceProvider.GetRequiredService<PinnaclePayloadMapper>()\n//                                    .BuildPayload(plan, recipient, envelope),\n\n//                            _ => throw new InvalidOperationException(\"Unknown provider\")\n//                        };\n//                        // ===== End unified build =====\n\n//                        // --- Send via engine + metrics timers ---\n//                        var sw = Stopwatch.StartNew();\n//                        var engineResult = await engine.SendPayloadAsync(job.BusinessId, job.Provider, payload, job.PhoneNumberId);\n//                        sw.Stop();\n//                        MetricsRegistry.SendLatencyMs.Record(sw.Elapsed.TotalMilliseconds);\n\n//                        // Adaptive nudge on 429 (based on error text)\n//                        if (!engineResult.Success)\n//                        {\n//                            var err = engineResult.ErrorMessage ?? string.Empty;\n//                            if (err.Contains(\"429\", StringComparison.Ordinal) ||\n//                                err.Contains(\"Too Many Requests\", StringComparison.OrdinalIgnoreCase))\n//                            {\n//                                limiter.UpdateLimits(senderKey, permitsPerSecond: 5, burst: 5);\n//                                MetricsRegistry.RateLimited429s.Add(1);\n//                            }\n//                        }\n\n//                        // Persist MessageLogs (COPY sink)\n//                        var now = DateTime.UtcNow;\n//                        var runId = Guid.NewGuid();\n//                        var logId = Guid.NewGuid();\n\n//                        messageLogSink.Enqueue(new MessageLog\n//                        {\n//                            Id = logId,\n//                            BusinessId = job.BusinessId,\n//                            CampaignId = job.CampaignId,\n//                            RecipientNumber = recipientPhone,\n//                            MessageContent = job.TemplateName,\n//                            MediaUrl = job.HeaderMediaUrl,\n//                            Status = engineResult.Success ? \"Sent\" : \"Failed\",\n//                            MessageId = engineResult.MessageId,\n//                            ErrorMessage = engineResult.ErrorMessage,\n//                            RawResponse = engineResult.RawResponse,\n//                            CreatedAt = now,\n//                            SentAt = engineResult.Success ? now : (DateTime?)null,\n//                            Source = \"campaign\",\n//                            RunId = runId,\n//                            Provider = job.Provider,\n//                            ProviderMessageId = engineResult.MessageId,\n//                            IsIncoming = false,\n//                            IsChargeable=false\n//                        });\n\n//                        // Batched CampaignSendLog (COPY via sink)\n//                        logSink.Enqueue(new CampaignLogRecord(\n//                            Id: Guid.NewGuid(),\n//                            RunId: runId,\n//                            MessageId: engineResult.MessageId,\n//                            CampaignId: job.CampaignId,\n//                            ContactId: null,\n//                            RecipientId: job.RecipientId,\n//                            MessageBody: job.MessageBody ?? job.TemplateName,\n//                            TemplateId: job.TemplateName,\n//                            SendStatus: engineResult.Success ? \"Sent\" : \"Failed\",\n//                            ErrorMessage: engineResult.ErrorMessage,\n//                            CreatedAt: now,\n//                            CreatedBy: \"system\",\n//                            SentAt: engineResult.Success ? now : (DateTime?)null,\n//                            DeliveredAt: null,\n//                            ReadAt: null,\n//                            IpAddress: null,\n//                            DeviceInfo: null,\n//                            MacAddress: null,\n//                            SourceChannel: \"campaign\",\n//                            DeviceType: null,\n//                            Browser: null,\n//                            Country: null,\n//                            City: null,\n//                            IsClicked: false,\n//                            ClickedAt: null,\n//                            ClickType: null,\n//                            RetryCount: job.Attempt,\n//                            LastRetryAt: now,\n//                            LastRetryStatus: engineResult.Success ? \"Success\" : \"Failed\",\n//                            AllowRetry: job.Attempt < DEFAULT_MAX_ATTEMPTS,\n//                            MessageLogId: logId,\n//                            BusinessId: job.BusinessId,\n//                            CTAFlowConfigId: null,\n//                            CTAFlowStepId: null,\n//                            ButtonBundleJson: null\n//                        ));\n\n//                        // Update job (retry/backoff if needed)\n//                        job.Status = engineResult.Success ? \"Sent\" : \"Failed\";\n//                        job.Attempt += 1;\n//                        job.LastError = engineResult.ErrorMessage;\n\n//                        if (!engineResult.Success)\n//                        {\n//                            var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n//                            MetricsRegistry.MessagesFailed.Add(1);\n//                        }\n//                        else\n//                        {\n//                            job.NextAttemptAt = null;\n//                            MetricsRegistry.MessagesSent.Add(1);\n//                        }\n\n//                        db.Update(job);\n//                        await db.SaveChangesAsync(ct);\n\n//                        // Async billing ingest (complete before scope disposed)\n//                        await billing.IngestFromSendResponseAsync(\n//                            job.BusinessId,\n//                            logId,\n//                            job.Provider,\n//                            engineResult.RawResponse ?? \"{}\"\n//                        );\n//                    }\n//                }\n//                catch (TaskCanceledException)\n//                {\n//                    // graceful shutdown\n//                }\n//                catch (Exception ex)\n//                {\n//                    try\n//                    {\n//                        using var scope = _sp.CreateScope();\n//                        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//                        job.Status = \"Failed\";\n//                        job.Attempt += 1;\n//                        job.LastError = ex.Message;\n//                        var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                        job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n//                        db.Update(job);\n//                        await db.SaveChangesAsync(ct);\n//                    }\n//                    catch { /* swallow */ }\n\n//                    MetricsRegistry.MessagesFailed.Add(1);\n//                    _log.LogError(ex, \"[Outbox] Consume error job={JobId}\", job.Id);\n//                }\n//            }\n//        }\n//    }\n//}\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboxReaperWorker.cs",
      "sha256": "62e23d9733ccd68ae2166ca2bc11a9b2024183cf0b91163984e6d7e40e7d2f15",
      "language": "csharp",
      "size": 3194,
      "content": "using Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public sealed class OutboxReaperWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboxReaperWorker> _log;\n\n        // How often we sweep\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(30);\n\n        // Keep in sync with your sender logic / DEFAULT_MAX_ATTEMPTS\n        private const int MAX_ATTEMPTS = 3;\n\n        public OutboxReaperWorker(IServiceProvider sp, ILogger<OutboxReaperWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        // OutboxReaperWorker.cs\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var now = DateTime.UtcNow;\n\n                    // ---- Recover stale InFlight jobs (no Random in the expression) ----\n                    var jitterSeconds = 2 + (int)((ulong)DateTime.UtcNow.Ticks % 3); // 2..4s\n                    var backoffAt = now.AddSeconds(jitterSeconds);\n\n                    var recovered = await db.OutboundMessageJobs\n                        .Where(j => j.Status == \"InFlight\" &&\n                                    j.NextAttemptAt != null &&\n                                    j.NextAttemptAt < now)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Pending\")\n                            .SetProperty(j => j.NextAttemptAt, _ => backoffAt)\n                            .SetProperty(j => j.LastError, _ => \"Recovered from stale in-flight\"),\n                            stoppingToken);\n\n                    // ---- Kill over-retried jobs ----\n                    const int MAX_ATTEMPTS = 3;\n                    var killed = await db.OutboundMessageJobs\n                        .Where(j => (j.Status == \"Pending\" || j.Status == \"Failed\" || j.Status == \"InFlight\") &&\n                                    j.Attempt >= MAX_ATTEMPTS)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Dead\")\n                            .SetProperty(j => j.NextAttemptAt, _ => (DateTime?)null)\n                            .SetProperty(j => j.LastError, _ => \"Max attempts exceeded\"),\n                            stoppingToken);\n\n                    if (recovered > 0 || killed > 0)\n                        _log.LogInformation(\"[OutboxReaper] recovered={Recovered} killed={Killed}\", recovered, killed);\n                }\n                catch (TaskCanceledException) { /* shutdown */ }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[OutboxReaper] sweep failed\");\n                }\n\n                try { await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken); }\n                catch (TaskCanceledException) { /* shutdown */ }\n            }\n        }\n\n    }\n}\n"
    }
  ]
}
