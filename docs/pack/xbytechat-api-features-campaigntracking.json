{
  "name": "xbytechat-api/Features/CampaignTracking",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CampaignTracking/Config/TrackingOptions.cs",
      "sha256": "76b42450eeb28f2d73ad6fc86ec956bc6e278f17ee17f5e517e0689e8a247483",
      "language": "csharp",
      "size": 337,
      "content": "// ðŸ“„ Features/CampaignTracking/Config/TrackingOptions.cs\nnamespace xbytechat.api.Features.CampaignTracking.Config\n{\n    public class TrackingOptions\n    {\n        public string BaseUrl { get; set; } = \"\";\n        public string Secret { get; set; } = \"\";\n        public TimeSpan TokenTtl { get; set; } = TimeSpan.FromDays(30);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignAnalyticsController.cs",
      "sha256": "7542c47e6bbe6d8117004542788bb0f078570eeae04c8045b385fc3b7eb5dde4",
      "language": "csharp",
      "size": 2494,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class CampaignAnalyticsController : BusinessControllerBase\n    {\n        private readonly ICampaignAnalyticsService _campaignAnalyticsService;\n        public CampaignAnalyticsController(ICampaignAnalyticsService svc) => _campaignAnalyticsService = svc;\n\n        [HttpGet(\"top-campaigns\")]\n        public async Task<IActionResult> GetTopCampaigns([FromQuery] int count = 5)\n            => Ok(await _campaignAnalyticsService.GetTopCampaignsAsync(BusinessId, count));\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using System.Security.Claims;\n//using xbytechat.api.Features.CampaignTracking.Services;\n\n//namespace xbytechat.api.Features.CampaignTracking.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/[controller]\")]\n//    [Authorize]\n//    public class CampaignAnalyticsController : ControllerBase\n//    {\n//        private readonly ICampaignAnalyticsService _campaignAnalyticsService;\n\n//        public CampaignAnalyticsController(ICampaignAnalyticsService campaignAnalyticsService)\n//        {\n//            _campaignAnalyticsService = campaignAnalyticsService;\n//        }\n\n//        [HttpGet(\"status-dashboard\")]\n//        //public async Task<IActionResult> GetStatusDashboard()\n//        //{\n//        //    var businessIdString = User.FindFirstValue(\"BusinessId\");\n//        //    if (!Guid.TryParse(businessIdString, out var businessId))\n//        //    {\n//        //        return Unauthorized(\"Invalid business identifier.\");\n//        //    }\n//        //    var result = await _campaignAnalyticsService.GetStatusDashboardAsync(businessId);\n//        //    return Ok(result);\n//        //}\n\n//        [HttpGet(\"top-campaigns\")]\n//        public async Task<IActionResult> GetTopCampaigns([FromQuery] int count = 5)\n//        {\n//            var businessIdString = User.FindFirstValue(\"BusinessId\");\n//            if (!Guid.TryParse(businessIdString, out var businessId))\n//            {\n//                return Unauthorized(\"Invalid business identifier.\");\n//            }\n//            var result = await _campaignAnalyticsService.GetTopCampaignsAsync(businessId, count);\n//            return Ok(result);\n//        }\n//    }\n//}"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignRetryController.cs",
      "sha256": "7fb4bd32c18410353886a39bebaf5c0c6e24ea48ce01a75d6bb0c553613438f8",
      "language": "csharp",
      "size": 1241,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Authorize] // âœ… add this\n    [Route(\"api/campaign-retry\")]\n    public class CampaignRetryController : ControllerBase\n    {\n        private readonly ICampaignTrackingRetryService _retryService;\n\n        public CampaignRetryController(ICampaignTrackingRetryService retryService)\n        {\n            _retryService = retryService;\n        }\n\n        [HttpPost(\"{logId}/retry\")]\n        public async Task<IActionResult> RetrySingle(Guid logId)\n        {\n            var success = await _retryService.RetrySingleAsync(logId);\n            if (!success) return BadRequest(new { message = \"Retry failed or not allowed for this log.\" });\n            return Ok(new { success = true, message = \"Retry completed.\" });\n        }\n\n        [HttpPost(\"campaign/{campaignId}/retry-all\")]\n        public async Task<IActionResult> RetryAllInCampaign(Guid campaignId)\n            => Ok(new { success = true, retriedCount = await _retryService.RetryFailedInCampaignAsync(campaignId) });\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignSendLogController.cs",
      "sha256": "95a189e3fdcff8f648aef7e688a3e3ee83fb7147e59f77d78259862f9b99d84b",
      "language": "csharp",
      "size": 4499,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaign-logs\")]\n    public class CampaignSendLogController : ControllerBase\n    {\n        private readonly ICampaignSendLogService _logService;\n        private readonly ICampaignTrackingRetryService _retryService;\n\n        public CampaignSendLogController(\n            ICampaignSendLogService logService,\n            ICampaignTrackingRetryService retryService\n        )\n        {\n            _logService = logService;\n            _retryService = retryService;\n        }\n\n        //[HttpGet(\"campaign/{campaignId}\")]\n        //public async Task<IActionResult> GetLogsByCampaign(Guid campaignId)\n        //{\n        //    var logs = await _logService.GetLogsByCampaignIdAsync(campaignId);\n        //    return Ok(logs);\n        //}\n        [HttpGet(\"campaign/{campaignId}\")]\n        public async Task<IActionResult> GetLogsByCampaign(\n         Guid campaignId,\n         [FromQuery] string? status,\n         [FromQuery] string? search,\n         [FromQuery] int page = 1,\n         [FromQuery] int pageSize = 10)\n        {\n            var result = await _logService.GetLogsByCampaignIdAsync(campaignId, status, search, page, pageSize);\n            return Ok(result);\n        }\n        [HttpGet(\"campaign/{campaignId}/contact/{contactId}\")]\n        public async Task<IActionResult> GetLogsForContact(Guid campaignId, Guid contactId)\n        {\n            var logs = await _logService.GetLogsForContactAsync(campaignId, contactId);\n            return Ok(logs);\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddSendLog([FromBody] CampaignSendLogDto dto)\n        {\n            var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n            var userAgent = Request.Headers[\"User-Agent\"].ToString() ?? \"unknown\";\n\n            var result = await _logService.AddSendLogAsync(dto, ipAddress, userAgent);\n            if (!result)\n                return BadRequest(new { message = \"Failed to add send log\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPut(\"{logId}/status\")]\n        public async Task<IActionResult> UpdateDeliveryStatus(Guid logId, [FromBody] DeliveryStatusUpdateDto dto)\n        {\n            var result = await _logService.UpdateDeliveryStatusAsync(logId, dto.Status, dto.DeliveredAt, dto.ReadAt);\n            if (!result)\n                return NotFound(new { message = \"Log not found\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPut(\"{logId}/track-click\")]\n        public async Task<IActionResult> TrackClick(Guid logId, [FromBody] ClickTrackDto dto)\n        {\n            var result = await _logService.TrackClickAsync(logId, dto.ClickType);\n            if (!result)\n                return NotFound(new { message = \"Log not found\" });\n\n            return Ok(new { success = true });\n        }\n\n        // âœ… FIXED: Retry a single log using correct interface method\n        [HttpPost(\"{logId}/retry\")]\n        public async Task<IActionResult> RetrySingle(Guid logId)\n        {\n            var result = await _retryService.RetrySingleAsync(logId);\n            if (!result)\n                return BadRequest(new { message = \"Retry failed\" });\n\n            return Ok(new { success = true });\n        }\n\n        // âœ… FIXED: Retry all failed logs using correct interface method\n        [HttpPost(\"campaign/{campaignId}/retry-all\")]\n        public async Task<IActionResult> RetryAll(Guid campaignId)\n        {\n            var result = await _retryService.RetryFailedInCampaignAsync(campaignId);\n            return Ok(new { success = true, retried = result });\n        }\n        // âœ… FIXED: Get summary of campaign logs as per Campaign ID\n        [HttpGet(\"campaign/{campaignId}/summary\")]\n        public async Task<IActionResult> GetCampaignSummary(Guid campaignId)\n        {\n            var summary = await _logService.GetCampaignSummaryAsync(campaignId);\n            return Ok(summary);\n        }\n\n    }\n\n    public class DeliveryStatusUpdateDto\n    {\n        public string Status { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n    }\n\n    public class ClickTrackDto\n    {\n        public string ClickType { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignTrackingController.cs",
      "sha256": "1e3e2b1e60144ec933cafdb53414ae6fad20463810533d32b90327dba457fde6",
      "language": "csharp",
      "size": 25258,
      "content": "// ðŸ“„ Features/CampaignTracking/Controllers/CampaignTrackingController.cs\nusing System.Text.Encodings.Web;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Features.CampaignTracking.Worker;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"r\")] // /r/{token}\n    public class CampaignTrackingController : ControllerBase\n    {\n        private static readonly HtmlEncoder HtmlEnc = HtmlEncoder.Default;\n\n        private readonly ILogger<CampaignTrackingController> _log;\n        private readonly IClickTokenService _token;\n        private readonly IClickEventQueue _queue;\n        private readonly AppDbContext _db;\n\n        public CampaignTrackingController(\n            ILogger<CampaignTrackingController> log,\n            IClickTokenService token,\n            IClickEventQueue queue,\n            AppDbContext db)\n        {\n            _log = log;\n            _token = token;\n            _queue = queue;\n            _db = db;\n        }\n\n        //[HttpGet(\"{token}\")]\n        //[AllowAnonymous]\n        //public async Task<IActionResult> RedirectByToken([FromRoute] string token, CancellationToken ct)\n        //{\n        //    // 1) Validate token\n        //    if (!_token.TryValidate(token, out var p, out var reason))\n        //    {\n        //        _log.LogWarning(\"Tracking token rejected. reason={Reason}\", reason);\n        //        return BadRequest(\"Invalid token.\");\n        //    }\n\n        //    // 2) Normalize + classify destination\n        //    if (!TryNormalizeAllowedDestination(p!.to, out var safeDest, out var scheme))\n        //    {\n        //        _log.LogWarning(\"Rejected destination for cid {Cid}: {Dest}\", p.cid, p.to);\n        //        return BadRequest(\"Invalid destination.\");\n        //    }\n\n        //    // 3) Capture client info\n        //    var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"0.0.0.0\";\n        //    var ua = Request.Headers.UserAgent.ToString();\n        //    var now = DateTime.UtcNow;\n\n        //    // 4) Determine click type (web | call | whatsapp)\n        //    var clickType = ClassifyClickType(safeDest, scheme);\n\n        //    // 4.1) Fetch related ids from the send log (for ContactId & CampaignId)\n        //    Guid? contactId = null;\n        //    Guid campaignId = Guid.Empty;\n        //    try\n        //    {\n        //        var sendLog = await _db.CampaignSendLogs\n        //            .AsNoTracking()\n        //            .Where(x => x.Id == p.cid)\n        //            .Select(x => new { x.ContactId, x.CampaignId })\n        //            .FirstOrDefaultAsync(ct);\n\n        //        if (sendLog is not null)\n        //        {\n        //            contactId = sendLog.ContactId;\n        //            campaignId = sendLog.CampaignId;\n        //        }\n        //        else\n        //        {\n        //            _log.LogWarning(\"SendLog not found for click cid={Cid}\", p.cid);\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Failed to fetch ContactId/CampaignId for cid={Cid}\", p.cid);\n        //    }\n\n        //    // 5) Write-through (guaranteed persistence)\n        //    try\n        //    {\n        //        await _db.CampaignClickLogs.AddAsync(new CampaignClickLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            CampaignSendLogId = p.cid,\n        //            CampaignId = campaignId,        // <-- populated if available (else Guid.Empty)\n        //            ContactId = contactId,          // <-- populated if available (nullable)\n        //            ButtonIndex = p.bi,\n        //            ButtonTitle = p.bt,\n        //            Destination = safeDest,\n        //            ClickedAt = now,\n        //            Ip = ip,\n        //            UserAgent = ua,\n        //            ClickType = clickType,\n        //            RunId = csl?.RunId\n        //        }, ct);\n\n        //        await _db.SaveChangesAsync(ct);\n\n        //        _log.LogInformation(\n        //            \"CLICK WRITE-THROUGH cid={Cid} idx={Idx} type={Type} dest={Dest}\",\n        //            p.cid, p.bi, clickType, safeDest);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Write-through insert failed. cid={Cid}\", p.cid);\n        //    }\n\n        //    // 6) Enqueue for async worker (best effort) â€” keeps existing ClickEvent signature\n        //    try\n        //    {\n        //        var enq = _queue.TryWrite(new ClickEvent(\n        //            CampaignSendLogId: p.cid,\n        //            ButtonIndex: p.bi,\n        //            ButtonTitle: p.bt,\n        //            Destination: safeDest,\n        //            ClickedAtUtc: now,\n        //            Ip: ip,\n        //            UserAgent: ua,\n        //            ClickType: clickType\n        //        ));\n        //        _log.LogInformation(\"CLICK ENQUEUE cid={Cid} idx={Idx} enqueued={Enqueued}\", p.cid, p.bi, enq);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Queue write threw. cid={Cid}\", p.cid);\n        //    }\n\n        //    // 7) First-click fast path\n        //    try\n        //    {\n        //        await _db.Database.ExecuteSqlRawAsync(\n        //            @\"update \"\"CampaignSendLogs\"\"\n        //                set \"\"IsClicked\"\"=TRUE, \"\"ClickedAt\"\"=NOW() at time zone 'utc'\n        //              where \"\"Id\"\"={0} and \"\"IsClicked\"\"=FALSE;\",\n        //            p.cid);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogDebug(ex, \"First-click update skipped.\");\n        //    }\n\n        //    // 8) Redirect handling\n        //    if (clickType is \"call\" or \"whatsapp\")\n        //    {\n        //        // Deep link â†’ return an HTML/JS shim to trigger immediately, with a safe fallback link.\n        //        var destHtml = HtmlEnc.Encode(safeDest);\n        //        var destJs = JsEscape(safeDest);\n\n        //        var html = $@\"<!doctype html>\n        //        <html lang=\"\"en\"\">\n        //        <head>\n        //          <meta charset=\"\"utf-8\"\">\n        //          <meta http-equiv=\"\"x-ua-compatible\"\" content=\"\"ie=edge\"\">\n        //          <meta name=\"\"viewport\"\" content=\"\"width=device-width, initial-scale=1\"\">\n        //          <meta http-equiv=\"\"refresh\"\" content=\"\"0;url={destHtml}\"\">\n        //          <title>Redirectingâ€¦</title>\n        //          <style>\n        //            body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:24px;}}\n        //            a{{color:#2563eb;text-decoration:underline;}}\n        //          </style>\n        //          <script>\n        //            // Trigger deep link immediately; reveal fallback if blocked by the browser.\n        //            window.addEventListener('load', function() {{\n        //              try {{ window.location.replace('{destJs}'); }} catch (e) {{}}\n        //              setTimeout(function() {{\n        //                var f = document.getElementById('fallback');\n        //                if (f) f.style.display = 'inline';\n        //              }}, 1200);\n        //            }});\n        //          </script>\n        //        </head>\n        //        <body>\n        //          <p>Redirectingâ€¦ If you are not redirected automatically, <a id=\"\"fallback\"\" style=\"\"display:none\"\" href=\"\"{destHtml}\"\">tap here</a>.</p>\n        //        </body>\n        //        </html>\";\n\n        //        Response.Headers[\"Cache-Control\"] = \"no-store, max-age=0\";\n        //        Response.Headers[\"Pragma\"] = \"no-cache\";\n        //        Response.Headers[\"X-Content-Type-Options\"] = \"nosniff\";\n        //        Response.Headers[\"Referrer-Policy\"] = \"no-referrer\";\n        //        Response.Headers[\"X-Frame-Options\"] = \"DENY\";\n        //        Response.Headers[\"Permissions-Policy\"] = \"geolocation=(), microphone=(), camera=()\";\n        //        Response.Headers[\"Content-Security-Policy\"] =\n        //            \"default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; base-uri 'none'; frame-ancestors 'none'\";\n\n        //        return new ContentResult\n        //        {\n        //            Content = html,\n        //            ContentType = \"text/html; charset=utf-8\",\n        //            StatusCode = 200\n        //        };\n        //    }\n\n        //    // Regular web links â†’ normal 302\n        //    return Redirect(safeDest);\n        //}\n\n        // --- helpers ---\n\n\n        //[HttpGet(\"{token}\")]\n        //[AllowAnonymous]\n\n\n        //[HttpGet(\"{token}\")]\n        //[AllowAnonymous]\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous]\n        public async Task<IActionResult> RedirectByToken([FromRoute] string token, CancellationToken ct)\n        {\n            // 1) Validate token\n            if (!_token.TryValidate(token, out var p, out var reason))\n            {\n                _log.LogWarning(\"Tracking token rejected. reason={Reason}\", reason);\n                return BadRequest(\"Invalid token.\");\n            }\n\n            // 2) Normalize + classify destination\n            if (!TryNormalizeAllowedDestination(p!.to, out var safeDest, out var scheme))\n            {\n                _log.LogWarning(\"Rejected destination for cid {Cid}: {Dest}\", p.cid, p.to);\n                return BadRequest(\"Invalid destination.\");\n            }\n\n            // 3) Capture client info\n            var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"0.0.0.0\";\n            var ua = Request.Headers.UserAgent.ToString();\n            var now = DateTime.UtcNow;\n\n            // 4) Determine click type (web | call | whatsapp)\n            var clickType = ClassifyClickType(safeDest, scheme);\n\n            // 4.1) Fetch related ids from the send log (ContactId, CampaignId, RunId)\n            Guid? contactId = null;\n            Guid? campaignId = null;   // <- make this nullable\n            Guid? runId = null;\n\n            try\n            {\n                var sendLog = await _db.CampaignSendLogs\n                    .AsNoTracking()\n                    .Where(x => x.Id == p.cid)\n                    .Select(x => new { x.ContactId, x.CampaignId, x.RunId })\n                    .FirstOrDefaultAsync(ct);\n\n                if (sendLog is not null)\n                {\n                    contactId = sendLog.ContactId;   // Guid?\n                    campaignId = sendLog.CampaignId;  // Guid?\n                    runId = sendLog.RunId;       // Guid?\n                }\n                else\n                {\n                    _log.LogWarning(\"SendLog not found for click cid={Cid}\", p.cid);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to fetch ContactId/CampaignId/RunId for cid={Cid}\", p.cid);\n            }\n\n            // 5) Write-through (guaranteed persistence)\n            try\n            {\n                await _db.CampaignClickLogs.AddAsync(new CampaignClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignSendLogId = p.cid,\n                    // If the column is NON-nullable, coalesce to Guid.Empty; if you've made it nullable, assign campaignId directly.\n                    CampaignId = campaignId ?? Guid.Empty,\n                    ContactId = contactId,    // nullable OK\n                    ButtonIndex = p.bi,\n                    ButtonTitle = p.bt,\n                    Destination = safeDest,\n                    ClickedAt = now,\n                    Ip = ip,\n                    UserAgent = ua,\n                    ClickType = clickType,\n                    RunId = runId\n                }, ct);\n\n                await _db.SaveChangesAsync(ct);\n\n                _log.LogInformation(\"CLICK WRITE-THROUGH cid={Cid} idx={Idx} type={Type} dest={Dest}\",\n                    p.cid, p.bi, clickType, safeDest);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Write-through insert failed. cid={Cid}\", p.cid);\n            }\n\n            // 6) Enqueue for async worker (best effort)\n            try\n            {\n                var enq = _queue.TryWrite(new ClickEvent(\n                    CampaignSendLogId: p.cid,\n                    ButtonIndex: p.bi,\n                    ButtonTitle: p.bt,\n                    Destination: safeDest,\n                    ClickedAtUtc: now,\n                    Ip: ip,\n                    UserAgent: ua,\n                    ClickType: clickType\n                ));\n                _log.LogInformation(\"CLICK ENQUEUE cid={Cid} idx={Idx} enqueued={Enqueued}\", p.cid, p.bi, enq);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Queue write threw. cid={Cid}\", p.cid);\n            }\n\n            // 7) First-click fast path\n            try\n            {\n                await _db.Database.ExecuteSqlRawAsync(\n                    @\"update \"\"CampaignSendLogs\"\"\n              set \"\"IsClicked\"\"=TRUE,\n                  \"\"ClickedAt\"\"=NOW() at time zone 'utc',\n                  \"\"ClickType\"\"={1}\n              where \"\"Id\"\"={0} and \"\"IsClicked\"\"=FALSE;\",\n                    p.cid, clickType);\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"First-click update skipped.\");\n            }\n\n            // 8) Redirect handling\n            if (clickType is \"call\" or \"whatsapp\")\n            {\n                // ... (unchanged deep-link HTML)\n            }\n\n            return Redirect(safeDest);\n        }\n\n        //public async Task<IActionResult> RedirectByToken([FromRoute] string token, CancellationToken ct)\n        //{\n        //    // 1) Validate token\n        //    if (!_token.TryValidate(token, out var p, out var reason))\n        //    {\n        //        _log.LogWarning(\"Tracking token rejected. reason={Reason}\", reason);\n        //        return BadRequest(\"Invalid token.\");\n        //    }\n\n        //    // 2) Normalize + classify destination\n        //    if (!TryNormalizeAllowedDestination(p!.to, out var safeDest, out var scheme))\n        //    {\n        //        _log.LogWarning(\"Rejected destination for cid {Cid}: {Dest}\", p.cid, p.to);\n        //        return BadRequest(\"Invalid destination.\");\n        //    }\n\n        //    // 3) Capture client info\n        //    var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"0.0.0.0\";\n        //    var ua = Request.Headers.UserAgent.ToString();\n        //    var now = DateTime.UtcNow;\n\n        //    // 4) Determine click type (web | call | whatsapp)\n        //    var clickType = ClassifyClickType(safeDest, scheme);\n\n        //    // 4.1) Fetch related ids from the send log (ContactId, CampaignId, **RunId**)\n        //    Guid? contactId = null;\n        //    Guid campaignId = Guid.Empty;\n        //    Guid? runId = null; // ðŸ‘ˆ NEW\n\n        //    try\n        //    {\n        //        var sendLog = await _db.CampaignSendLogs\n        //            .AsNoTracking()\n        //            .Where(x => x.Id == p.cid)\n        //            .Select(x => new { x.ContactId, x.CampaignId, x.RunId })\n        //            .FirstOrDefaultAsync(ct);\n\n        //        if (sendLog is not null)\n        //        {\n        //            contactId = sendLog.ContactId;\n        //            campaignId = sendLog.CampaignId;\n        //            runId = sendLog.RunId; // ðŸ‘ˆ carry through to click log\n        //        }\n        //        else\n        //        {\n        //            _log.LogWarning(\"SendLog not found for click cid={Cid}\", p.cid);\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Failed to fetch ContactId/CampaignId/RunId for cid={Cid}\", p.cid);\n        //    }\n\n        //    // 5) Write-through (guaranteed persistence)\n        //    try\n        //    {\n        //        await _db.CampaignClickLogs.AddAsync(new CampaignClickLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            CampaignSendLogId = p.cid,\n        //            CampaignId = campaignId,   // populated if available (else Guid.Empty)\n        //            ContactId = contactId,     // nullable\n        //            ButtonIndex = p.bi,\n        //            ButtonTitle = p.bt,\n        //            Destination = safeDest,\n        //            ClickedAt = now,\n        //            Ip = ip,\n        //            UserAgent = ua,\n        //            ClickType = clickType,\n        //            RunId = runId              // ðŸ‘ˆ bind click to the same run/session\n        //        }, ct);\n\n        //        await _db.SaveChangesAsync(ct);\n\n        //        _log.LogInformation(\n        //            \"CLICK WRITE-THROUGH cid={Cid} idx={Idx} type={Type} dest={Dest}\",\n        //            p.cid, p.bi, clickType, safeDest);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Write-through insert failed. cid={Cid}\", p.cid);\n        //    }\n\n        //    // 6) Enqueue for async worker (best effort) â€” keeps existing ClickEvent signature\n        //    try\n        //    {\n        //        var enq = _queue.TryWrite(new ClickEvent(\n        //            CampaignSendLogId: p.cid,\n        //            ButtonIndex: p.bi,\n        //            ButtonTitle: p.bt,\n        //            Destination: safeDest,\n        //            ClickedAtUtc: now,\n        //            Ip: ip,\n        //            UserAgent: ua,\n        //            ClickType: clickType\n        //        ));\n        //        _log.LogInformation(\"CLICK ENQUEUE cid={Cid} idx={Idx} enqueued={Enqueued}\", p.cid, p.bi, enq);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Queue write threw. cid={Cid}\", p.cid);\n        //    }\n\n        //    // 7) First-click fast path (also writes ClickType)\n        //    try\n        //    {\n        //        await _db.Database.ExecuteSqlRawAsync(\n        //            @\"update \"\"CampaignSendLogs\"\"\n        //        set \"\"IsClicked\"\"=TRUE,\n        //            \"\"ClickedAt\"\"=NOW() at time zone 'utc',\n        //            \"\"ClickType\"\"={1}\n        //      where \"\"Id\"\"={0} and \"\"IsClicked\"\"=FALSE;\",\n        //            p.cid, clickType);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogDebug(ex, \"First-click update skipped.\");\n        //    }\n\n        //    // 8) Redirect handling\n        //    if (clickType is \"call\" or \"whatsapp\")\n        //    {\n        //        // Deep link â†’ return an HTML/JS shim to trigger immediately, with a safe fallback link.\n        //        var destHtml = HtmlEnc.Encode(safeDest);\n        //        var destJs = JsEscape(safeDest);\n\n        //        var html = $@\"<!doctype html>\n        //                <html lang=\"\"en\"\">\n        //                <head>\n        //                  <meta charset=\"\"utf-8\"\">\n        //                  <meta http-equiv=\"\"x-ua-compatible\"\" content=\"\"ie=edge\"\">\n        //                  <meta name=\"\"viewport\"\" content=\"\"width=device-width, initial-scale=1\"\">\n        //                  <meta http-equiv=\"\"refresh\"\" content=\"\"0;url={destHtml}\"\">\n        //                  <title>Redirectingâ€¦</title>\n        //                  <style>\n        //                    body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:24px;}}\n        //                    a{{color:#2563eb;text-decoration:underline;}}\n        //                  </style>\n        //                  <script>\n        //                    // Trigger deep link immediately; reveal fallback if blocked by the browser.\n        //                    window.addEventListener('load', function() {{\n        //                      try {{ window.location.replace('{destJs}'); }} catch (e) {{}}\n        //                      setTimeout(function() {{\n        //                        var f = document.getElementById('fallback');\n        //                        if (f) f.style.display = 'inline';\n        //                      }}, 1200);\n        //                    }});\n        //                  </script>\n        //                </head>\n        //                <body>\n        //                  <p>Redirectingâ€¦ If you are not redirected automatically, <a id=\"\"fallback\"\" style=\"\"display:none\"\" href=\"\"{destHtml}\"\">tap here</a>.</p>\n        //                </body>\n        //                </html>\";\n\n        //        Response.Headers[\"Cache-Control\"] = \"no-store, max-age=0\";\n        //        Response.Headers[\"Pragma\"] = \"no-cache\";\n        //        Response.Headers[\"X-Content-Type-Options\"] = \"nosniff\";\n        //        Response.Headers[\"Referrer-Policy\"] = \"no-referrer\";\n        //        Response.Headers[\"X-Frame-Options\"] = \"DENY\";\n        //        Response.Headers[\"Permissions-Policy\"] = \"geolocation=(), microphone=(), camera=()\";\n        //        Response.Headers[\"Content-Security-Policy\"] =\n        //            \"default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; base-uri 'none'; frame-ancestors 'none'\";\n\n        //        return new ContentResult\n        //        {\n        //            Content = html,\n        //            ContentType = \"text/html; charset=utf-8\",\n        //            StatusCode = 200\n        //        };\n        //    }\n\n        //    // Regular web links â†’ normal 302\n        //    return Redirect(safeDest);\n        //}\n\n\n        private static string ClassifyClickType(string normalizedDest, string scheme)\n        {\n            // scheme is pre-normalized by TryNormalizeAllowedDestination\n            if (string.Equals(scheme, \"tel\", StringComparison.OrdinalIgnoreCase)) return \"call\";\n            if (string.Equals(scheme, \"wa\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n            if (string.Equals(scheme, \"whatsapp\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n\n            // http/https â†’ still treat WhatsApp hosts as whatsapp\n            if (normalizedDest.StartsWith(\"https://wa.me/\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n            if (normalizedDest.StartsWith(\"https://api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n\n            return \"web\";\n        }\n\n        private static string JsEscape(string s) =>\n            s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"'\", \"\\\\'\").Replace(\"\\r\", \"\").Replace(\"\\n\", \"\");\n\n        /// <summary>\n        /// Accepts: http/https/tel/wa/whatsapp, plus shorthand wa.me/... and api.whatsapp.com/...\n        /// Returns normalized absolute string and a normalized scheme hint (\"http\",\"https\",\"tel\",\"wa\",\"whatsapp\").\n        /// </summary>\n        private static bool TryNormalizeAllowedDestination(string? input, out string normalized, out string scheme)\n        {\n            normalized = string.Empty;\n            scheme = string.Empty;\n            if (string.IsNullOrWhiteSpace(input)) return false;\n\n            var cleaned = new string(input.Trim().Where(c => !char.IsControl(c)).ToArray());\n\n            // Shorthand WhatsApp hosts without scheme â†’ prefix https://\n            if (!cleaned.Contains(\"://\", StringComparison.Ordinal))\n            {\n                if (cleaned.StartsWith(\"wa.me/\", StringComparison.OrdinalIgnoreCase) ||\n                    cleaned.StartsWith(\"api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var guess = \"https://\" + cleaned;\n                    if (Uri.TryCreate(guess, UriKind.Absolute, out var waAbs))\n                    {\n                        normalized = waAbs.AbsoluteUri;\n                        scheme = \"https\";\n                        return true;\n                    }\n                }\n            }\n\n            // WhatsApp custom schemes (wa:, whatsapp:)\n            if (cleaned.StartsWith(\"wa:\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalized = cleaned; scheme = \"wa\"; return true;\n            }\n            if (cleaned.StartsWith(\"whatsapp:\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalized = cleaned; scheme = \"whatsapp\"; return true;\n            }\n\n            // Absolute URIs\n            if (Uri.TryCreate(cleaned, UriKind.Absolute, out var uri))\n            {\n                // tel:\n                if (uri.Scheme.Equals(\"tel\", StringComparison.OrdinalIgnoreCase))\n                {\n                    normalized = uri.ToString(); scheme = \"tel\"; return true;\n                }\n\n                // http/https (including WhatsApp hosts)\n                if (uri.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    normalized = uri.AbsoluteUri;\n                    scheme = uri.Scheme; // \"http\" or \"https\"\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignLogSummaryDto.cs",
      "sha256": "57aa29e375f6dda32b73602de1a84e9d5e89e3f8bf103914b21bfa14f0b786a9",
      "language": "csharp",
      "size": 415,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignLogSummaryDto\n    {\n        public int TotalSent { get; set; }\n        public int FailedCount { get; set; }\n        public int ClickedCount { get; set; }\n        public DateTime? LastSentAt { get; set; }\n\n        public int Delivered { get; set; }\n        public int Read { get; set; }\n        public int Sent { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignSendLogDto.cs",
      "sha256": "e4401d635c37b8b9990e5b0b8137ffe065550330c45ccf4638e336b803e6c5cf",
      "language": "csharp",
      "size": 1730,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignSendLogDto\n    {\n        public Guid Id { get; set; }\n\n        // ðŸ”— Relationships\n        public Guid CampaignId { get; set; }\n        public Guid? ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactPhone { get; set; }\n\n        public string? RecipientNumber { get; set; }\n        // ðŸ“¤ Message Info\n        public Guid RecipientId { get; set; }\n        public string MessageBody { get; set; }\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        // ðŸ•’ Timestamps\n        public DateTime CreatedAt { get; set; }\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // ðŸŒ Metadata\n        public string? SourceChannel { get; set; }\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n\n        // âœ… Enriched metadata\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // ðŸ“ˆ Click Tracking\n        public bool IsClicked { get; set; }\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // ðŸ” Retry Info\n        public string? RetryStatus { get; set; }     // Pending, Retried, Skipped\n        public int RetryCount { get; set; }\n        public DateTime? LastRetryAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignStatusDashboardDto.cs",
      "sha256": "21979b3b1de98ab2567e6485c9c0e4684b848735d36743226caaca66504e9b7b",
      "language": "csharp",
      "size": 1038,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignStatusDashboardDto\n    {\n        public Guid CampaignId { get; set; }\n\n        // ðŸ“Š Overall Stats\n        public int TotalRecipients { get; set; }\n        public int SentCount { get; set; }\n        public int DeliveredCount { get; set; }\n        public int ReadCount { get; set; }\n        public int FailedCount { get; set; }\n\n        // ðŸ•’ Delivery Timing (optional but insightful)\n        public DateTime? FirstSentAt { get; set; }\n        public DateTime? LastSentAt { get; set; }\n        public DateTime? FirstReadAt { get; set; }\n        public DateTime? LastReadAt { get; set; }\n\n        // ðŸ“‰ Delivery Rates\n        public double DeliveryRate => TotalRecipients == 0 ? 0 : (double)DeliveredCount / TotalRecipients * 100;\n        public double ReadRate => TotalRecipients == 0 ? 0 : (double)ReadCount / TotalRecipients * 100;\n        public double FailureRate => TotalRecipients == 0 ? 0 : (double)FailedCount / TotalRecipients * 100;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/TopCampaignDto.cs",
      "sha256": "deebf224725de4a79f8363405623b0761fed9b776ec86cc8d6a9b05c5f79940e",
      "language": "csharp",
      "size": 295,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class TopCampaignDto\n    {\n        public Guid CampaignId { get; set; }\n        public string CampaignName { get; set; }\n        public double ReadRate { get; set; }\n        public double ClickThroughRate { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/EntityTypeConfigs/CampaignSendLogConfig.cs",
      "sha256": "cf880a46e9114af3187c8c4cd1f11e526a5b0c83fc9894ebc8dc39075e937247",
      "language": "csharp",
      "size": 1967,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore.Metadata.Builders;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.EntityTypeConfigs\n{\n    public class CampaignSendLogConfig : IEntityTypeConfiguration<CampaignSendLog>\n    {\n        public void Configure(EntityTypeBuilder<CampaignSendLog> e)\n        {\n            e.ToTable(\"CampaignSendLogs\"); // your table name\n            e.HasKey(x => x.Id);\n\n            // common lengths to keep COPY happy (adjust if you already have constraints)\n            e.Property(x => x.MessageId).HasMaxLength(128);\n            e.Property(x => x.TemplateId).HasMaxLength(128);\n            e.Property(x => x.SendStatus).HasMaxLength(32);\n            e.Property(x => x.ErrorMessage).HasMaxLength(1024);\n            e.Property(x => x.CreatedBy).HasMaxLength(128);\n            e.Property(x => x.IpAddress).HasMaxLength(64);\n            e.Property(x => x.DeviceInfo).HasMaxLength(256);\n            e.Property(x => x.MacAddress).HasMaxLength(64);\n            e.Property(x => x.SourceChannel).HasMaxLength(64);\n            e.Property(x => x.DeviceType).HasMaxLength(64);\n            e.Property(x => x.Browser).HasMaxLength(64);\n            e.Property(x => x.Country).HasMaxLength(64);\n            e.Property(x => x.City).HasMaxLength(64);\n            e.Property(x => x.ClickType).HasMaxLength(64);\n            e.Property(x => x.LastRetryStatus).HasMaxLength(32);\n\n            // CreatedAt default (UTC) if not set by code\n            e.Property(x => x.CreatedAt).HasDefaultValueSql(\"timezone('utc', now())\");\n\n            // helpful indexes\n            e.HasIndex(x => new { x.BusinessId, x.CampaignId, x.CreatedAt });\n            e.HasIndex(x => new { x.CampaignId, x.SendStatus, x.CreatedAt });\n            e.HasIndex(x => new { x.RecipientId, x.CreatedAt });\n            e.HasIndex(x => x.MessageId);\n            e.HasIndex(x => x.RunId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogFlushWorker.cs",
      "sha256": "b00af09909773fe5a42fec957467b0749da9ef01e66ee094928dde050277ac59",
      "language": "csharp",
      "size": 1106,
      "content": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public class CampaignLogFlushWorker : BackgroundService\n    {\n        private readonly ICampaignLogSink _sink;\n        private readonly ILogger<CampaignLogFlushWorker> _log;\n        private readonly IOptionsMonitor<BatchingOptions> _opts;\n\n        public CampaignLogFlushWorker(ICampaignLogSink sink, ILogger<CampaignLogFlushWorker> log, IOptionsMonitor<BatchingOptions> opts)\n        {\n            _sink = sink; _log = log; _opts = opts;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try { await _sink.FlushAsync(stoppingToken); }\n                catch (Exception ex) { _log.LogError(ex, \"[CampaignLogFlushWorker] flush error\"); }\n                await Task.Delay(TimeSpan.FromMilliseconds(_opts.CurrentValue.CampaignLog.FlushEveryMs), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogRecord.cs",
      "sha256": "777772c74a122cabcaf3c59ae1aac8fd43c7b97b6d562d5c239921ed24c47be5",
      "language": "csharp",
      "size": 1067,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public record CampaignLogRecord(\n        Guid Id,\n        Guid? RunId,\n        string? MessageId,\n        Guid CampaignId,\n        Guid? ContactId,\n        Guid RecipientId,\n        string MessageBody,\n        string? TemplateId,\n        string? SendStatus,\n        string? ErrorMessage,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? SentAt,\n        DateTime? DeliveredAt,\n        DateTime? ReadAt,\n        string? IpAddress,\n        string? DeviceInfo,\n        string? MacAddress,\n        string? SourceChannel,\n        string? DeviceType,\n        string? Browser,\n        string? Country,\n        string? City,\n        bool IsClicked,\n        DateTime? ClickedAt,\n        string? ClickType,\n        int RetryCount,\n        DateTime? LastRetryAt,\n        string? LastRetryStatus,\n        bool AllowRetry,\n        Guid? MessageLogId,\n        Guid BusinessId,\n        Guid? CTAFlowConfigId,\n        Guid? CTAFlowStepId,\n        string? ButtonBundleJson\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogSink.cs",
      "sha256": "1cb036d202b67bf8fdaa1e5f217c0c8c728b1ec98ec090f4bfbcfd40e46f3bc7",
      "language": "csharp",
      "size": 12526,
      "content": "using System.Collections.Concurrent;\nusing Microsoft.EntityFrameworkCore;\nusing System.Linq;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Npgsql;\nusing NpgsqlTypes;\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\nusing xbytechat.api.AuthModule.Models;               // AppDbContext\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public class CampaignLogSink : ICampaignLogSink\n    {\n        private readonly ConcurrentQueue<CampaignLogRecord> _queue = new();\n        private readonly ConcurrentDictionary<Guid, int> _attempts = new();\n        private readonly ILogger<CampaignLogSink> _log;\n        private readonly IServiceProvider _sp;\n        private readonly IOptionsMonitor<BatchingOptions> _opts;\n\n        private const int MaxAttempts = 3;\n\n        public CampaignLogSink(ILogger<CampaignLogSink> log, IServiceProvider sp, IOptionsMonitor<BatchingOptions> opts)\n        {\n            _log = log; _sp = sp; _opts = opts;\n        }\n\n        public void Enqueue(CampaignLogRecord rec) => _queue.Enqueue(rec);\n        public int PendingCount => _queue.Count;\n\n        public async Task FlushAsync(CancellationToken ct = default)\n        {\n            var max = _opts.CurrentValue.CampaignLog.MaxBatchSize;\n            var list = new List<CampaignLogRecord>(Math.Min(_queue.Count, max));\n            while (list.Count < max && _queue.TryDequeue(out var r)) list.Add(r);\n            if (list.Count == 0) return;\n\n            try\n            {\n                // Ensure all referenced MessageLogs exist before inserting send logs\n                var messageLogIds = list\n                    .Select(x => x.MessageLogId)\n                    .Where(id => id.HasValue && id.Value != Guid.Empty)\n                    .Select(id => id!.Value)\n                    .Distinct()\n                    .ToList();\n\n                _log.LogInformation(\n                    \"[CampaignLogSink] Batch size = {BatchCount}, messageLogIds = {IdCount}\",\n                    list.Count, messageLogIds.Count);\n\n                if (messageLogIds.Count > 0)\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var existingIds = await db.MessageLogs\n                        .AsNoTracking()\n                        .Where(m => messageLogIds.Contains(m.Id))\n                        .Select(m => m.Id)\n                        .ToListAsync(ct);\n\n                    var missing = messageLogIds.Except(existingIds).ToList();\n                    if (missing.Count > 0)\n                    {\n                        // Use first record Id as batch key\n                        var batchKey = list[0].Id;\n                        var attempt = _attempts.AddOrUpdate(batchKey, 1, (_, prev) => prev + 1);\n\n                        if (attempt <= MaxAttempts)\n                        {\n                            _log.LogWarning(\n                                \"[CampaignLogSink] Deferring batch (attempt {Attempt}/{Max}) â€“ messageLogIds={Ids} missingCount={MissingCount}\",\n                                attempt, MaxAttempts, string.Join(\",\", messageLogIds), missing.Count);\n                            foreach (var item in list) _queue.Enqueue(item);\n                            return;\n                        }\n\n                        _log.LogError(\n                            \"[CampaignLogSink] Dropping batch after {MaxAttempts} attempts â€“ still missing messageLogIds={Ids}\",\n                            MaxAttempts, string.Join(\",\", messageLogIds));\n                        _attempts.TryRemove(batchKey, out _);\n                        return; // drop to avoid FK violations / infinite loop\n                    }\n\n                    // All required MessageLogs exist; clear attempts for this batch key\n                    _attempts.TryRemove(list[0].Id, out _);\n                }\n\n                if (_opts.CurrentValue.CampaignLog.UseCopy)\n                    await CopyInsertAsync(list, ct);\n                else\n                    await EfInsertAsync(list, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"[CampaignLogSink] COPY failed; falling back to EF\");\n                try { await EfInsertAsync(list, ct); }\n                catch (Exception ex2)\n                {\n                    _log.LogError(ex2, \"[CampaignLogSink] EF fallback failed; requeueing {Count}\", list.Count);\n                    foreach (var rr in list) _queue.Enqueue(rr);\n                }\n            }\n        }\n\n        private static void WriteNullable<T>(NpgsqlBinaryImporter w, T? value, NpgsqlDbType type) where T : struct\n        {\n            if (value.HasValue) w.Write(value.Value, type);\n            else w.WriteNull();\n        }\n\n        private static void WriteNullableText(NpgsqlBinaryImporter w, string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) w.WriteNull();\n            else w.Write(value, NpgsqlDbType.Text);\n        }\n\n        private static void WriteNullableVarchar(NpgsqlBinaryImporter w, string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) w.WriteNull();\n            else w.Write(value, NpgsqlDbType.Varchar);\n        }\n\n        private static void WriteNullableUuid(NpgsqlBinaryImporter w, Guid? value)\n        {\n            if (value.HasValue && value.Value != Guid.Empty) w.Write(value.Value, NpgsqlDbType.Uuid);\n            else w.WriteNull();\n        }\n\n        private async Task CopyInsertAsync(List<CampaignLogRecord> batch, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var connString = db.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            const string sql = @\"\nCOPY \"\"CampaignSendLogs\"\" (\n    \"\"Id\"\",\n    \"\"RunId\"\",\n    \"\"MessageId\"\",\n    \"\"CampaignId\"\",\n    \"\"ContactId\"\",\n    \"\"RecipientId\"\",\n    \"\"MessageBody\"\",\n    \"\"TemplateId\"\",\n    \"\"SendStatus\"\",\n    \"\"ErrorMessage\"\",\n    \"\"CreatedAt\"\",\n    \"\"CreatedBy\"\",\n    \"\"SentAt\"\",\n    \"\"DeliveredAt\"\",\n    \"\"ReadAt\"\",\n    \"\"IpAddress\"\",\n    \"\"DeviceInfo\"\",\n    \"\"MacAddress\"\",\n    \"\"SourceChannel\"\",\n    \"\"DeviceType\"\",\n    \"\"Browser\"\",\n    \"\"Country\"\",\n    \"\"City\"\",\n    \"\"IsClicked\"\",\n    \"\"ClickedAt\"\",\n    \"\"ClickType\"\",\n    \"\"RetryCount\"\",\n    \"\"LastRetryAt\"\",\n    \"\"LastRetryStatus\"\",\n    \"\"AllowRetry\"\",\n    \"\"MessageLogId\"\",\n    \"\"BusinessId\"\",\n    \"\"CTAFlowConfigId\"\",\n    \"\"CTAFlowStepId\"\",\n    \"\"ButtonBundleJson\"\"\n) FROM STDIN (FORMAT BINARY);\";\n\n            try\n            {\n                await using var writer = await conn.BeginBinaryImportAsync(sql, ct);\n\n                foreach (var r in batch)\n                {\n                    await writer.StartRowAsync(ct);\n\n                    // Required IDs\n                    writer.Write(r.Id, NpgsqlDbType.Uuid);\n                    writer.Write(r.RunId, NpgsqlDbType.Uuid);\n\n                    // Strings / nullable fields\n                    WriteNullableVarchar(writer, r.MessageId);\n                    writer.Write(r.CampaignId, NpgsqlDbType.Uuid);\n                    WriteNullableUuid(writer, r.ContactId);\n                    WriteNullableUuid(writer, r.RecipientId);\n\n                    WriteNullableText(writer, r.MessageBody);\n                    WriteNullableVarchar(writer, r.TemplateId);\n                    WriteNullableVarchar(writer, r.SendStatus);\n                    WriteNullableVarchar(writer, r.ErrorMessage);\n\n                    // Timestamps\n                    writer.Write(r.CreatedAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.CreatedBy);\n                    WriteNullable(writer, r.SentAt, NpgsqlDbType.TimestampTz);\n                    WriteNullable(writer, r.DeliveredAt, NpgsqlDbType.TimestampTz);\n                    WriteNullable(writer, r.ReadAt, NpgsqlDbType.TimestampTz);\n\n                    // Device / network\n                    WriteNullableVarchar(writer, r.IpAddress);\n                    WriteNullableVarchar(writer, r.DeviceInfo);\n                    WriteNullableVarchar(writer, r.MacAddress);\n                    WriteNullableVarchar(writer, r.SourceChannel);\n                    WriteNullableVarchar(writer, r.DeviceType);\n                    WriteNullableVarchar(writer, r.Browser);\n                    WriteNullableVarchar(writer, r.Country);\n                    WriteNullableVarchar(writer, r.City);\n\n                    // Click info\n                    writer.Write(r.IsClicked, NpgsqlDbType.Boolean);\n                    WriteNullable(writer, r.ClickedAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.ClickType);\n\n                    // Retry info â€” RetryCount is non-nullable int in your model\n                    writer.Write(r.RetryCount, NpgsqlDbType.Integer);\n                    WriteNullable(writer, r.LastRetryAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.LastRetryStatus);\n                    writer.Write(r.AllowRetry, NpgsqlDbType.Boolean);\n\n                    // FK to MessageLogs may be null initially\n                    WriteNullableUuid(writer, r.MessageLogId);\n\n                    // Remaining Ids\n                    writer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n                    WriteNullableUuid(writer, r.CTAFlowConfigId);\n                    WriteNullableUuid(writer, r.CTAFlowStepId);\n\n                    // Bundle (text/json)\n                    WriteNullableText(writer, r.ButtonBundleJson);\n                }\n\n                await writer.CompleteAsync(ct);\n                _log.LogDebug(\"[CampaignLogSink] COPY inserted {Count} rows\", batch.Count);\n            }\n            catch\n            {\n                throw; // let FlushAsync() handle fallback/requeue\n            }\n        }\n\n        private async Task EfInsertAsync(List<CampaignLogRecord> batch, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n            var entities = batch.Select(r => new CampaignSendLog\n            {\n                Id = r.Id,\n                RunId = r.RunId,\n                MessageId = r.MessageId,\n                CampaignId = r.CampaignId,\n                ContactId = r.ContactId,\n                RecipientId = r.RecipientId,\n                MessageBody = r.MessageBody,\n                TemplateId = r.TemplateId,\n                SendStatus = r.SendStatus,\n                ErrorMessage = r.ErrorMessage,\n                CreatedAt = r.CreatedAt,\n                CreatedBy = r.CreatedBy,\n                SentAt = r.SentAt,\n                DeliveredAt = r.DeliveredAt,\n                ReadAt = r.ReadAt,\n                IpAddress = r.IpAddress,\n                DeviceInfo = r.DeviceInfo,\n                MacAddress = r.MacAddress,\n                SourceChannel = r.SourceChannel,\n                DeviceType = r.DeviceType,\n                Browser = r.Browser,\n                Country = r.Country,\n                City = r.City,\n                IsClicked = r.IsClicked,\n                ClickedAt = r.ClickedAt,\n                ClickType = r.ClickType,\n                RetryCount = r.RetryCount,\n                LastRetryAt = r.LastRetryAt,\n                LastRetryStatus = r.LastRetryStatus,\n                AllowRetry = r.AllowRetry,\n                MessageLogId = r.MessageLogId,\n                BusinessId = r.BusinessId,\n                CTAFlowConfigId = r.CTAFlowConfigId,\n                CTAFlowStepId = r.CTAFlowStepId,\n                ButtonBundleJson = r.ButtonBundleJson\n            }).ToList();\n\n            var prev = db.ChangeTracker.AutoDetectChangesEnabled;\n            db.ChangeTracker.AutoDetectChangesEnabled = false;\n            await db.CampaignSendLogs.AddRangeAsync(entities, ct);\n            await db.SaveChangesAsync(ct);\n            db.ChangeTracker.AutoDetectChangesEnabled = prev;\n        }\n    }\n\n    public class BatchingOptions\n    {\n        public CampaignLogOptions CampaignLog { get; set; } = new();\n        public class CampaignLogOptions\n        {\n            public int FlushEveryMs { get; set; } = 500;\n            public int MaxBatchSize { get; set; } = 500;\n            public bool UseCopy { get; set; } = true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/ICampaignLogSink.cs",
      "sha256": "2bb93f46e441543c54cae578d67d0768ae0a459d621727f54c8eb390ec2cdf38",
      "language": "csharp",
      "size": 303,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public interface ICampaignLogSink\n    {\n        void Enqueue(CampaignLogRecord rec);\n        int PendingCount { get; }\n        Task FlushAsync(CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignClickDailyAgg.cs",
      "sha256": "f73f8e07824860d62b98ba1112933870fd6c223a3a75ca759bccf5899d9e9ffd",
      "language": "csharp",
      "size": 571,
      "content": "// ðŸ“„ Features/CampaignTracking/Models/CampaignClickDailyAgg.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    [Table(\"CampaignClickDailyAgg\")]\n    public class CampaignClickDailyAgg\n    {\n        [Key] public Guid Id { get; set; }\n        public Guid CampaignId { get; set; }\n        public DateTime Day { get; set; } // date-only (store as date in migration)\n        public int ButtonIndex { get; set; }\n        public long Clicks { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignClickLog.cs",
      "sha256": "c955c29fed1ef4d960a247c80426a21493ab53a3b657a4a21083d2f617d309cb",
      "language": "csharp",
      "size": 1205,
      "content": "// ðŸ“„ Features/CampaignTracking/Models/CampaignClickLog.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    [Table(\"CampaignClickLogs\")]\n    public class CampaignClickLog\n    {\n        [Key] public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        // FK through CampaignSendLog to CampaignId & ContactId\n        public Guid CampaignSendLogId { get; set; }\n\n        public Guid CampaignId { get; set; }      // denormalized for fast filtering\n        public Guid? ContactId { get; set; }      // denormalized if available\n\n        public int ButtonIndex { get; set; }\n\n        [MaxLength(120)]\n        public string ButtonTitle { get; set; } = \"\";\n\n        // NEW: \"web\" | \"call\" | \"whatsapp\" (lowercase)\n        [MaxLength(16)]\n        public string ClickType { get; set; } = \"web\";\n\n        [MaxLength(2048)]\n        public string Destination { get; set; } = \"\";\n\n        [MaxLength(64)]\n        public string Ip { get; set; } = \"\";\n\n        [MaxLength(512)]\n        public string UserAgent { get; set; } = \"\";\n\n        public DateTime ClickedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignSendLog.cs",
      "sha256": "a2e627b90aaaa87979a7551588cc2fd8150978b69ff34e6abeddd2d3ab58e1cd",
      "language": "csharp",
      "size": 2937,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Models\n{\n    public class CampaignSendLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        public string? MessageId { get; set; } // Unique WAMID from WhatsApp\n        // ðŸ”— Foreign Keys\n    \n        public Guid CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n \n        public Guid? ContactId { get; set; }\n\n        [Required]\n        public Guid RecipientId { get; set; }\n\n        // ðŸ“© Message Info\n        [Required]\n        public string MessageBody { get; set; } = \"\";\n\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // ðŸŒ Metadata\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n        public string? SourceChannel { get; set; }\n\n        // âœ… UX-Derived\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // ðŸ“Š Click Tracking\n        public bool IsClicked { get; set; } = false;\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // ðŸ” Retry Tracking (ðŸ’¡ New)\n        public int RetryCount { get; set; } = 0;                 // Number of retry attempts\n        public DateTime? LastRetryAt { get; set; }               // When retry last happened\n        public string? LastRetryStatus { get; set; }             // Success / Failed\n        public bool AllowRetry { get; set; } = true;             // Flag to enable/disable retry\n\n        // ðŸ‘ Navigation\n      \n        public Contact? Contact { get; set; }\n        public CampaignRecipient? Recipient { get; set; }\n\n\n        // ðŸ”— MessageLog reference (optional)\n        public Guid? MessageLogId { get; set; }\n        public MessageLog? MessageLog { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        // ðŸ†• Flow context snapshot for deterministic click resolution\n        public Guid? CTAFlowConfigId { get; set; }   // which flow this send belongs to (optional)\n        public Guid? CTAFlowStepId { get; set; }     // the entry step id (optional)\n\n        [Column(TypeName = \"text\")]\n        public string? ButtonBundleJson { get; set; }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignAnalyticsService.cs",
      "sha256": "ee9163439146987bfeebca642b380b914f7a0d5dae6fc4b2468b798b06840b3e",
      "language": "csharp",
      "size": 5226,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n\n\n    public class CampaignAnalyticsService : ICampaignAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n            //_context = context;\n        }\n\n        public async Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId)\n        {\n            var logs = await _context.CampaignSendLogs\n                .Where(l => l.CampaignId == campaignId)\n                .ToListAsync();\n\n            if (!logs.Any()) return null;\n\n            return new CampaignStatusDashboardDto\n            {\n                CampaignId = campaignId,\n                TotalRecipients = logs.Count,\n                SentCount = logs.Count(l => l.SendStatus == \"Sent\"),\n                DeliveredCount = logs.Count(l => l.SendStatus == \"Delivered\"),\n                ReadCount = logs.Count(l => l.SendStatus == \"Read\"),\n                FailedCount = logs.Count(l => l.SendStatus == \"Failed\"),\n                FirstSentAt = logs.Min(l => l.SentAt),\n                LastSentAt = logs.Max(l => l.SentAt),\n                FirstReadAt = logs.Min(l => l.ReadAt),\n                LastReadAt = logs.Max(l => l.ReadAt)\n            };\n        }\n\n        //public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        //{\n        //    var campaignStats = await _context.CampaignSendLogs\n        //        .Where(log => log.BusinessId == businessId)\n        //        .GroupBy(log => log.CampaignId)\n        //        .Select(group => new\n        //        {\n        //            CampaignId = group.Key,\n        //            TotalSent = group.Count(),\n        //            TotalRead = group.Count(l => l.ReadAt != null),\n        //            TotalClicked = group.Count(l => l.ClickedAt != null)\n        //        })\n        //        .Where(s => s.TotalSent > 0)\n        //        .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent)\n        //        .Take(count)\n        //        .ToListAsync();\n\n        //    if (!campaignStats.Any())\n        //    {\n        //        return new List<TopCampaignDto>();\n        //    }\n\n        //    var campaignIds = campaignStats.Select(s => s.CampaignId).ToList();\n        //    var campaigns = await _context.Campaigns\n        //        .Where(c => campaignIds.Contains(c.Id))\n        //        .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n        //    return campaignStats.Select(s => new TopCampaignDto\n        //    {\n        //        CampaignId = s.CampaignId,\n        //        CampaignName = campaigns.GetValueOrDefault(s.CampaignId, \"Unnamed Campaign\"),\n        //        ReadRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalRead / s.TotalSent) * 100, 2) : 0,\n        //        ClickThroughRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalClicked / s.TotalSent) * 100, 2) : 0\n        //    });\n        //}\n\n\n\n        public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        {\n            if (count <= 0) count = 5;\n\n            // If you suspect legacy rows with Guid.Empty, keep the extra filter; otherwise you can drop it.\n            var campaignStats = await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(log => log.BusinessId == businessId /* && log.CampaignId != Guid.Empty */)\n                .GroupBy(log => log.CampaignId) // CampaignId is non-nullable Guid\n                .Select(group => new\n                {\n                    CampaignId = group.Key,\n                    TotalSent = group.Count(),\n                    TotalRead = group.Count(l => l.ReadAt != null),\n                    TotalClicked = group.Count(l => l.ClickedAt != null)\n                })\n                .Where(s => s.TotalSent > 0)\n                .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent) // CTR first\n                .ThenByDescending(s => s.TotalSent)                           // tie-breaker: volume\n                .Take(count)\n                .ToListAsync();\n\n            if (campaignStats.Count == 0)\n                return Array.Empty<TopCampaignDto>();\n\n            var ids = campaignStats.Select(s => s.CampaignId).ToList();\n\n            var names = await _context.Campaigns\n                .AsNoTracking()\n                .Where(c => ids.Contains(c.Id))\n                .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n            var result = campaignStats.Select(s => new TopCampaignDto\n            {\n                CampaignId = s.CampaignId,\n                CampaignName = names.TryGetValue(s.CampaignId, out var n) && !string.IsNullOrWhiteSpace(n)\n                                        ? n\n                                        : \"Unnamed Campaign\",\n                ReadRate = Math.Round((double)s.TotalRead / s.TotalSent * 100, 2),\n                ClickThroughRate = Math.Round((double)s.TotalClicked / s.TotalSent * 100, 2)\n            });\n\n            return result;\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogEnricher.cs",
      "sha256": "6d1155127869663e221b9c1a80e5dce49dd32c3d57d218d8157691ed3bc8edeb",
      "language": "csharp",
      "size": 872,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogEnricher : ICampaignSendLogEnricher\n    {\n        public async Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress)\n        {\n            // ðŸ§  Device Detection (simplified for now)\n            log.DeviceInfo = userAgent;\n\n            // ðŸŒ IP Lookup - Mocked for now\n            if (!string.IsNullOrWhiteSpace(ipAddress))\n            {\n                log.IpAddress = ipAddress;\n                log.SourceChannel = \"API\"; // Example: mark origin\n                // Future: Use IPinfo or GeoLite2 for full location enrichment\n            }\n\n            // âŒ› Simulate async task for compatibility\n            await Task.CompletedTask;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogService.cs",
      "sha256": "719776d788525701507db765a8a42a52f25b080ac4faa6be437690ce774e6345",
      "language": "csharp",
      "size": 13351,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogService : ICampaignSendLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ICampaignSendLogEnricher _enricher;\n\n\n        public CampaignSendLogService(AppDbContext context, ICampaignSendLogEnricher enricher)\n        {\n            _context = context;\n            _enricher = enricher;\n        }\n\n        //public async Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n        //Guid campaignId, string? status, string? search, int page, int pageSize)\n        //{\n        //    // Base query as IQueryable (not IIncludableQueryable)\n        //    IQueryable<CampaignSendLog> query = _context.CampaignSendLogs\n        //        .AsNoTracking()\n        //        .Where(log => log.CampaignId.HasValue && log.CampaignId.Value == campaignId);\n\n        //    if (!string.IsNullOrEmpty(status))\n        //        query = query.Where(log => log.SendStatus == status);\n\n        //    if (!string.IsNullOrEmpty(search))\n        //    {\n        //        var keyword = search.ToLower();\n\n        //        // Safe null checks + server-side case-insensitive matching\n        //        // If you're on PostgreSQL, EF.Functions.ILike is nicer; otherwise use ToLower().\n        //        query = query.Where(log =>\n        //            log.Contact != null &&\n        //           (log.Contact.Name.ToLower().Contains(keyword)\n        //         || log.Contact.PhoneNumber.Contains(keyword)));\n        //    }\n\n        //    // Add Include after filters to keep it IQueryable\n        //    query = query.Include(log => log.Contact);\n\n        //    var totalCount = await query.CountAsync();\n\n        //    var logs = await query\n        //        .OrderByDescending(log => log.CreatedAt)\n        //        .Skip((page - 1) * pageSize)\n        //        .Take(pageSize)\n        //        .Select(log => new CampaignSendLogDto\n        //        {\n        //            Id = log.Id,\n        //            CampaignId = log.CampaignId!.Value,       // unwrap once for DTO Guid\n        //            ContactId = log.ContactId,               // keep Guid? in DTO if CSV-only is allowed\n        //            ContactName = log.Contact != null ? log.Contact.Name : \"N/A\",\n        //            ContactPhone = log.Contact != null ? log.Contact.PhoneNumber : \"-\",\n        //            MessageBody = log.MessageBody,\n        //            TemplateId = log.TemplateId,\n        //            SendStatus = log.SendStatus,\n        //            ErrorMessage = log.ErrorMessage,\n        //            CreatedAt = log.CreatedAt,\n        //            SentAt = log.SentAt,\n        //            DeliveredAt = log.DeliveredAt,\n        //            ReadAt = log.ReadAt,\n        //            SourceChannel = log.SourceChannel,\n        //            IsClicked = log.IsClicked,\n        //            ClickedAt = log.ClickedAt,\n        //            ClickType = log.ClickType\n        //        })\n        //        .ToListAsync();\n\n        //    return new PagedResult<CampaignSendLogDto>\n        //    {\n        //        Items = logs,\n        //        TotalCount = totalCount,\n        //        Page = page,\n        //        PageSize = pageSize\n        //    };\n        //}\n\n\n        //public async Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId)\n        //{\n        //    return await _context.CampaignSendLogs\n        //        .Where(log => log.CampaignId == campaignId && log.ContactId == contactId)\n        //        .Select(log => new CampaignSendLogDto\n        //        {\n        //            Id = log.Id,\n        //            CampaignId = log.CampaignId,\n        //            ContactId = log.ContactId,\n        //            MessageBody = log.MessageBody,\n        //            TemplateId = log.TemplateId,\n        //            SendStatus = log.SendStatus,\n        //            ErrorMessage = log.ErrorMessage,\n        //            CreatedAt = log.CreatedAt,\n        //            SentAt = log.SentAt,\n        //            DeliveredAt = log.DeliveredAt,\n        //            ReadAt = log.ReadAt,\n        //            IpAddress = log.IpAddress,\n        //            DeviceInfo = log.DeviceInfo,\n        //            MacAddress = log.MacAddress,\n        //            SourceChannel = log.SourceChannel,\n        //            IsClicked = log.IsClicked,\n        //            ClickedAt = log.ClickedAt,\n        //            ClickType = log.ClickType\n        //        })\n        //        .ToListAsync();\n        //}\n\n        // ðŸ†• Create a new send log (with enrichment)\n\n        public async Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n       Guid campaignId, string? status, string? search, int page, int pageSize)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0) pageSize = 10;\n\n            // Base (scoped to the campaign)\n            var q =\n                from log in _context.CampaignSendLogs.AsNoTracking()\n                where log.CampaignId == campaignId\n                join ml in _context.MessageLogs.AsNoTracking()\n                     on log.MessageLogId equals ml.Id into g\n                from ml in g.DefaultIfEmpty() // LEFT JOIN\n                select new { log, ml };\n\n            if (!string.IsNullOrWhiteSpace(status))\n                q = q.Where(x => x.log.SendStatus == status);\n\n            if (!string.IsNullOrWhiteSpace(search))\n            {\n                var kw = search.Trim();\n                var kwLike = $\"%{kw}%\";\n\n                q = q.Where(x =>\n                    // match CRM contact name/phone if present\n                    (x.log.Contact != null &&\n                        (EF.Functions.ILike(x.log.Contact.Name!, kwLike) ||\n                         x.log.Contact.PhoneNumber!.Contains(kw)))\n                    ||\n                    // match raw recipient number from message log (CSV-only etc.)\n                    (x.ml.RecipientNumber != null && x.ml.RecipientNumber.Contains(kw))\n                );\n            }\n\n            var total = await q.CountAsync();\n\n            var items = await q\n                .OrderByDescending(x => x.log.CreatedAt)\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .Select(x => new CampaignSendLogDto\n                {\n                    Id = x.log.Id,\n                    // CampaignId = x.log.CampaignId ?? campaignId,\n                    CampaignId = x.log.CampaignId,// âœ… fix\n                    ContactId = x.log.ContactId,\n                    ContactName = x.log.Contact != null ? x.log.Contact.Name : \"N/A\",\n                    ContactPhone = x.log.Contact != null ? x.log.Contact.PhoneNumber : \"-\",\n                    RecipientNumber = x.ml.RecipientNumber,\n                    RecipientId = x.log.RecipientId,\n                    MessageBody = x.log.MessageBody,\n                    TemplateId = x.log.TemplateId,\n                    SendStatus = x.log.SendStatus,\n                    ErrorMessage = x.log.ErrorMessage,\n                    CreatedAt = x.log.CreatedAt,\n                    SentAt = x.log.SentAt,\n                    DeliveredAt = x.log.DeliveredAt,\n                    ReadAt = x.log.ReadAt,\n                    SourceChannel = x.log.SourceChannel,\n                    IsClicked = x.log.IsClicked,\n                    ClickedAt = x.log.ClickedAt,\n                    ClickType = x.log.ClickType\n                })\n                .ToListAsync();\n\n            return new PagedResult<CampaignSendLogDto>\n            {\n                Items = items,\n                TotalCount = total,\n                Page = page,\n                PageSize = pageSize\n            };\n        }\n\n        public async Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId)\n        {\n            return await _context.CampaignSendLogs\n                .AsNoTracking()\n               .Where(log =>\n    log.CampaignId == campaignId &&\n    log.ContactId == contactId)\n                .Select(log => new CampaignSendLogDto\n                {\n                    Id = log.Id,\n                    CampaignId = log.CampaignId,\n                    ContactId = log.ContactId,  // unwrap after HasValue guard\n                    MessageBody = log.MessageBody,\n                    TemplateId = log.TemplateId,\n                    SendStatus = log.SendStatus,\n                    ErrorMessage = log.ErrorMessage,\n                    CreatedAt = log.CreatedAt,\n                    SentAt = log.SentAt,\n                    DeliveredAt = log.DeliveredAt,\n                    ReadAt = log.ReadAt,\n                    IpAddress = log.IpAddress,\n                    DeviceInfo = log.DeviceInfo,\n                    MacAddress = log.MacAddress,\n                    SourceChannel = log.SourceChannel,\n                    IsClicked = log.IsClicked,\n                    ClickedAt = log.ClickedAt,\n                    ClickType = log.ClickType\n                })\n                .ToListAsync();\n        }\n\n\n        public async Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent)\n        {\n            var log = new CampaignSendLog\n            {\n                Id = Guid.NewGuid(),\n                CampaignId = dto.CampaignId,\n                ContactId = dto.ContactId,\n                MessageBody = dto.MessageBody,\n                TemplateId = dto.TemplateId,\n                SendStatus = dto.SendStatus,\n                ErrorMessage = dto.ErrorMessage,\n                CreatedAt = DateTime.UtcNow,\n                SentAt = dto.SentAt,\n                DeliveredAt = dto.DeliveredAt,\n                ReadAt = dto.ReadAt,\n                SourceChannel = dto.SourceChannel,\n                IsClicked = dto.IsClicked,\n                ClickedAt = dto.ClickedAt,\n                ClickType = dto.ClickType,\n                RecipientId = dto.RecipientId\n            };\n\n            // âœ… Use enrichment service\n            await _enricher.EnrichAsync(log, userAgent, ipAddress);\n\n            _context.CampaignSendLogs.Add(log);\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ“¨ Update delivery or read status\n        public async Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.SendStatus = status;\n            log.DeliveredAt = deliveredAt ?? log.DeliveredAt;\n            log.ReadAt = readAt ?? log.ReadAt;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ“ˆ Track click (CTA)\n        public async Task<bool> TrackClickAsync(Guid logId, string clickType)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.IsClicked = true;\n            log.ClickedAt = DateTime.UtcNow;\n            log.ClickType = clickType;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n        public async Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(Guid campaignId)\n        {\n            // This single, efficient query calculates all stats directly in the database.\n            var summary = await _context.CampaignSendLogs\n                .Where(l => l.CampaignId == campaignId)\n                .GroupBy(l => 1) // Group by a constant to aggregate all results\n                .Select(g => new\n                {\n                    TotalRecipients = g.Count(),\n\n                    // CORRECTED LOGIC: A message is \"Sent\" if its status is NOT \"Failed\".\n                    // This correctly includes messages that are \"Sent\", \"Delivered\", or \"Read\".\n                    SentCount = g.Count(l => l.SendStatus != \"Failed\"),\n\n                    FailedCount = g.Count(l => l.SendStatus == \"Failed\"),\n                    ClickedCount = g.Count(l => l.IsClicked),\n                    DeliveredCount = g.Count(l => l.DeliveredAt != null),\n                    ReadCount = g.Count(l => l.ReadAt != null),\n                    LastSentAt = g.Max(l => l.SentAt)\n                })\n                .FirstOrDefaultAsync();\n\n            if (summary == null)\n            {\n                // Return an empty DTO if no logs are found for the campaign\n                return new CampaignLogSummaryDto();\n            }\n\n            return new CampaignLogSummaryDto\n            {\n                TotalSent = summary.TotalRecipients,\n                Sent = summary.SentCount,\n                FailedCount = summary.FailedCount,\n                ClickedCount = summary.ClickedCount,\n                Delivered = summary.DeliveredCount,\n                Read = summary.ReadCount,\n                LastSentAt = summary.LastSentAt\n            };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignTrackingRetryService.cs",
      "sha256": "7b60dddd6aceae08b86da9813190186180881e6fc9efd8dc1190e497b51f9af1",
      "language": "csharp",
      "size": 2935,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignTrackingRetryService : ICampaignTrackingRetryService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignTrackingRetryService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // âœ… Public method: Retry a single failed log\n        public async Task<bool> RetrySingleAsync(Guid logId)\n        {\n            return await RetrySendLogAsync(logId);\n        }\n\n        // âœ… Public method: Retry all failed logs in a campaign\n        public async Task<int> RetryFailedInCampaignAsync(Guid campaignId)\n        {\n            return await RetryAllFailedInCampaignAsync(campaignId);\n        }\n\n        // ðŸ” Private: Retry a specific log\n        private async Task<bool> RetrySendLogAsync(Guid logId)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (log == null || log.SendStatus != \"Failed\" || !log.AllowRetry)\n                return false;\n\n            // ðŸ”„ Simulate re-send (replace with actual IMessageService.SendAsync later)\n            bool sent = SimulateSendMessage(log);\n\n            log.RetryCount += 1;\n            log.LastRetryAt = DateTime.UtcNow;\n            log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n            log.SendStatus = sent ? \"Sent\" : \"Failed\";\n            log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n            await _context.SaveChangesAsync();\n            return sent;\n        }\n\n        // ðŸ” Private: Retry all failed logs in a given campaign\n        private async Task<int> RetryAllFailedInCampaignAsync(Guid campaignId)\n        {\n            var failedLogs = await _context.CampaignSendLogs\n                .Where(log => log.CampaignId == campaignId && log.SendStatus == \"Failed\" && log.AllowRetry)\n                .ToListAsync();\n\n            int successCount = 0;\n\n            foreach (var log in failedLogs)\n            {\n                bool sent = SimulateSendMessage(log);\n\n                log.RetryCount += 1;\n                log.LastRetryAt = DateTime.UtcNow;\n                log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n                log.SendStatus = sent ? \"Sent\" : \"Failed\";\n                log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n                if (sent) successCount++;\n            }\n\n            await _context.SaveChangesAsync();\n            return successCount;\n        }\n\n        // ðŸ”§ Simulated send (replace with actual WhatsApp message logic)\n        private bool SimulateSendMessage(CampaignSendLog log)\n        {\n            return new Random().NextDouble() < 0.9; // 90% success rate\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ClickTokenService.cs",
      "sha256": "b80c48d547509139d45775d1f8447eceeec7d399e27cd9a55c20dc1aecb854fb",
      "language": "csharp",
      "size": 3152,
      "content": "// ðŸ“„ Features/CampaignTracking/Services/ClickTokenService.cs\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public record ClickTokenPayload(\n        Guid cid,            // CampaignSendLogId\n        int bi,              // button index\n        string bt,           // button title (optional)\n        string to,           // destination absolute URL\n        long iat,            // issued at (unix seconds)\n        long exp             // expiry (unix seconds)\n    );\n\n    public interface IClickTokenService\n    {\n        string Create(ClickTokenPayload payload);\n        bool TryValidate(string token, out ClickTokenPayload? payload, out string? error);\n    }\n\n    public class ClickTokenService : IClickTokenService\n    {\n        private readonly byte[] _key;\n\n        public ClickTokenService(IOptions<TrackingOptions> opt)\n        {\n            _key = Encoding.UTF8.GetBytes(opt.Value.Secret ?? throw new ArgumentNullException(nameof(opt.Value.Secret)));\n        }\n\n        public string Create(ClickTokenPayload payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var data = Encoding.UTF8.GetBytes(json);\n            var body = WebEncoders.Base64UrlEncode(data);\n\n            var sig = ComputeHmac(body);\n            return $\"{body}.{sig}\";\n        }\n\n        public bool TryValidate(string token, out ClickTokenPayload? payload, out string? error)\n        {\n            payload = null;\n            error = null;\n\n            var parts = token.Split('.');\n            if (parts.Length != 2) { error = \"format\"; return false; }\n\n            var body = parts[0];\n            var sig = parts[1];\n\n            var expected = ComputeHmac(body);\n            // timing-safe compare\n            if (!CryptographicOperations.FixedTimeEquals(Encoding.UTF8.GetBytes(sig), Encoding.UTF8.GetBytes(expected)))\n            { error = \"bad-signature\"; return false; }\n\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(body);\n                var obj = JsonSerializer.Deserialize<ClickTokenPayload>(bytes);\n                if (obj is null) { error = \"decode\"; return false; }\n\n                var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n                if (now > obj.exp) { error = \"expired\"; return false; }\n\n                // minimal URL sanity check\n                if (!Uri.TryCreate(obj.to, UriKind.Absolute, out var _)) { error = \"bad-destination\"; return false; }\n\n                payload = obj;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                error = \"exception:\" + ex.GetType().Name;\n                return false;\n            }\n        }\n\n        private string ComputeHmac(string body)\n        {\n            using var h = new HMACSHA256(_key);\n            var sig = h.ComputeHash(Encoding.UTF8.GetBytes(body));\n            return WebEncoders.Base64UrlEncode(sig);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignAnalyticsService.cs",
      "sha256": "c4c188f0eba3b537c076a7fc42ef62094de1ced491abcaecb619097e40debb8b",
      "language": "csharp",
      "size": 437,
      "content": "using xbytechat.api.Features.CampaignTracking.DTOs;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignAnalyticsService\n    {\n       // Task<CampaignStatusDashboardDto> GetStatusDashboardAsync(Guid businessId);\n        Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5);\n        Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId);\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogEnricher.cs",
      "sha256": "9204a2182522e06e53fe6beb21100820231943995d044f01feb200bdcaa521de",
      "language": "csharp",
      "size": 290,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogEnricher\n    {\n        Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogService.cs",
      "sha256": "2be8275d1874b38f88f5395552b8a10412b7949d360e6abb4f12f10fdfa504f9",
      "language": "csharp",
      "size": 1276,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogService\n    {\n        // This is the NEW signature that matches your updated service and controller\n        Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n            Guid campaignId, string? status, string? search, int page, int pageSize);\n        // ðŸ“ Get logs for a specific contact in a campaign\n        Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId);\n\n        // ðŸ†• Add a new send log entry with enrichment (IP, User-Agent)\n        Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent);\n\n        // ðŸ“¨ Update delivery or read status\n        Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt);\n\n        // ðŸ“ˆ Track CTA click (e.g., BuyNow, ViewDetails)\n        Task<bool> TrackClickAsync(Guid logId, string clickType);\n        // ðŸ“Š Get summary of campaign logs\n        Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(Guid campaignId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignTrackingRetryService.cs",
      "sha256": "0ea3dd070b8b87ab800873972e6200421e942c4e4536a316a8623bd7108e72ec",
      "language": "csharp",
      "size": 554,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignTrackingRetryService\n    {\n\n        // Retry a single failed message log by its ID.\n        // will be used when user clicks \"Retry Now\" on a log row.\n        Task<bool> RetrySingleAsync(Guid logId);\n\n\n        // Retry all failed messages in a campaign where retry is allowed.\n        // will support \"Retry All Failed\" button from Campaign logs.\n        Task<int> RetryFailedInCampaignAsync(Guid campaignId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickEvent.cs",
      "sha256": "feba0a8efef3e111690aeca876198178018024d5c39d3415d1cb3db163a8e52e",
      "language": "csharp",
      "size": 380,
      "content": "// Features/CampaignTracking/Worker/ClickEvent.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed record ClickEvent(\n        Guid CampaignSendLogId,\n        int ButtonIndex,\n        string ButtonTitle,\n        string Destination,\n        DateTime ClickedAtUtc,\n        string Ip,\n        string UserAgent,\n         string ClickType\n         \n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickLogWorker.cs",
      "sha256": "6c5f66aa812a1532420b44d66e9a0d9b72234af71077dbb32151c78d78d30a97",
      "language": "csharp",
      "size": 8009,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class ClickLogWorker : BackgroundService\n    {\n        private readonly ILogger<ClickLogWorker> _log;\n        private readonly IClickEventQueue _queue;\n        private readonly IServiceScopeFactory _scopeFactory;\n\n        public ClickLogWorker(\n            ILogger<ClickLogWorker> log,\n            IClickEventQueue queue,\n            IServiceScopeFactory scopeFactory)\n        {\n            _log = log;\n            _queue = queue;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _log.LogInformation(\"ClickLogWorker started\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                List<ClickEvent> batch;\n                try\n                {\n                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n                    if (batch.Count == 0) continue;\n\n                    // quick visibility: confirm we are ingesting call/whatsapp/web events\n                    var byType = batch.GroupBy(e => e.ClickType ?? \"web\")\n                                      .Select(g => $\"{g.Key}:{g.Count()}\")\n                                      .ToArray();\n                    _log.LogInformation(\"WORKER processing {Count} events [{Kinds}]\",\n                        batch.Count, string.Join(\", \", byType));\n                }\n                catch (OperationCanceledException)\n                {\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Queue read failed; retrying\");\n                    try { await Task.Delay(500, stoppingToken); } catch { /* ignore */ }\n                    continue;\n                }\n\n                // nothing to do\n                if (batch.Count == 0) continue;\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    // Prefetch CampaignId for this batch (we only need CampaignId for the aggregates)\n                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n                    if (sendIds.Count == 0) continue;\n\n                    var sendMap = await db.CampaignSendLogs\n                        .Where(s => sendIds.Contains(s.Id))\n                        .Select(s => new { s.Id, s.CampaignId })\n                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n                    // Prepare aggregate groups: (CampaignId, Day, ButtonIndex) -> count\n                    var groups = batch\n                        .Select(e =>\n                        {\n                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n                        })\n                        .Where(x => x.CampaignId != Guid.Empty)\n                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n                        .ToList();\n\n                    if (groups.Count == 0) continue;\n\n                    foreach (var g in groups)\n                    {\n                        await db.Database.ExecuteSqlRawAsync(@\"\n                    insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n                    values ({0}, {1}, {2}, {3})\n                    on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n                    do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Aggregate update failed; skipped this batch.\");\n                }\n            }\n\n            _log.LogInformation(\"ClickLogWorker stopped\");\n        }\n    }\n}\n\n\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n\n//namespace xbytechat.api.Features.CampaignTracking.Worker\n//{\n//    public sealed class ClickLogWorker : BackgroundService\n//    {\n//        private readonly ILogger<ClickLogWorker> _log;\n//        private readonly IClickEventQueue _queue;\n//        private readonly IServiceScopeFactory _scopeFactory;\n\n//        public ClickLogWorker(\n//            ILogger<ClickLogWorker> log,\n//            IClickEventQueue queue,\n//            IServiceScopeFactory scopeFactory)\n//        {\n//            _log = log;\n//            _queue = queue;\n//            _scopeFactory = scopeFactory;\n//        }\n\n//        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//        {\n//            _log.LogInformation(\"ClickLogWorker started\");\n\n//            while (!stoppingToken.IsCancellationRequested)\n//            {\n//                List<ClickEvent> batch;\n//                try\n//                {\n//                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n//                    if (batch.Count == 0) continue;\n//                    _log.LogInformation(\"WORKER processing {Count} events (aggregates only)\", batch.Count);\n//                }\n//                catch (OperationCanceledException) { break; }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Queue read failed; retrying\");\n//                    try { await Task.Delay(500, stoppingToken); } catch { }\n//                    continue;\n//                }\n\n//                try\n//                {\n//                    using var scope = _scopeFactory.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//                    // Prefetch CampaignId for this batch\n//                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n//                    var sendMap = await db.CampaignSendLogs\n//                        .Where(s => sendIds.Contains(s.Id))\n//                        .Select(s => new { s.Id, s.CampaignId })\n//                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n//                    // Build aggregate groups\n//                    var groups = batch\n//                        .Select(e =>\n//                        {\n//                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n//                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n//                        })\n//                        .Where(x => x.CampaignId != Guid.Empty)\n//                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n//                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n//                        .ToList();\n\n//                    foreach (var g in groups)\n//                    {\n//                        await db.Database.ExecuteSqlRawAsync(@\"\n//insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n//values ({0}, {1}, {2}, {3})\n//on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n//do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n//                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n//                    }\n//                }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Aggregate update failed; skipped.\");\n//                }\n//            }\n\n//            _log.LogInformation(\"ClickLogWorker stopped\");\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/IClickEventQueue.cs",
      "sha256": "a0e8a3bbb51c949024de93f0d4794c3ed494cc047e0b7dafdabe4cf696dad89c",
      "language": "csharp",
      "size": 304,
      "content": "// Features/CampaignTracking/Worker/IClickEventQueue.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public interface IClickEventQueue\n    {\n        bool TryWrite(ClickEvent evt);\n        Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/InProcessClickEventQueue.cs",
      "sha256": "8344c869f22df147598c7b1db117ba72d4c518901138838f7fed724201392009",
      "language": "csharp",
      "size": 1254,
      "content": "using System.Threading.Channels;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class InProcessClickEventQueue : IClickEventQueue\n    {\n        private readonly Channel<ClickEvent> _ch;\n\n        public InProcessClickEventQueue(int capacity = 20_000)\n        {\n            _ch = Channel.CreateBounded<ClickEvent>(new BoundedChannelOptions(capacity)\n            {\n                // keep newest; never block redirect\n                FullMode = BoundedChannelFullMode.DropOldest,\n                SingleReader = true,\n                SingleWriter = false\n            });\n        }\n\n        public bool TryWrite(ClickEvent evt) => _ch.Writer.TryWrite(evt);\n\n        public async Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct)\n        {\n            var list = new List<ClickEvent>(maxItems);\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            cts.CancelAfter(wait);\n\n            while (list.Count < maxItems && await _ch.Reader.WaitToReadAsync(cts.Token))\n            {\n                while (list.Count < maxItems && _ch.Reader.TryRead(out var item))\n                    list.Add(item);\n            }\n            return list;\n        }\n    }\n}\n"
    }
  ]
}
