{
  "name": "xbytechat-api/Features/ChatInbox",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs",
      "sha256": "a4d7703060f27a3527a15f3159f436e52c46728ed6d1fa07570a4e002bcc0e0f",
      "language": "csharp",
      "size": 7002,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Services;\n\nnamespace xbytechat.api.Features.ChatInbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/chat-inbox\")]\n    public sealed class ChatInboxController : ControllerBase\n    {\n        private readonly IChatInboxQueryService _queryService;\n        private readonly IChatInboxCommandService _commandService;\n\n        public ChatInboxController(\n            IChatInboxQueryService queryService,\n            IChatInboxCommandService commandService)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _commandService = commandService ?? throw new ArgumentNullException(nameof(commandService));\n        }\n\n        // üö© Conversations list\n        [HttpGet(\"conversations\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxConversationDto>), 200)]\n        public async Task<IActionResult> GetConversations(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? currentUserId,\n            [FromQuery] string? tab,\n            [FromQuery] string? numberId,\n            [FromQuery] string? search,\n            [FromQuery] int? limit,\n            CancellationToken cancellationToken)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            var filter = new ChatInboxFilterDto\n            {\n                BusinessId = businessId,\n                CurrentUserId = currentUserId,\n                Tab = tab,\n                NumberId = string.IsNullOrWhiteSpace(numberId) ? null : numberId,\n                SearchTerm = string.IsNullOrWhiteSpace(search) ? null : search,\n                Limit = limit.GetValueOrDefault(50),\n            };\n\n            switch (tab?.ToLowerInvariant())\n            {\n                case \"unassigned\":\n                    filter.OnlyUnassigned = true;\n                    break;\n                case \"my\":\n                    filter.OnlyAssignedToMe = true;\n                    break;\n            }\n\n            var result = await _queryService.GetConversationsAsync(filter, cancellationToken);\n            return Ok(result);\n        }\n\n        // üí¨ Messages for a conversation\n        [HttpGet(\"messages\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxMessageDto>), 200)]\n        public async Task<ActionResult<IReadOnlyList<ChatInboxMessageDto>>> GetMessages(\n            [FromQuery] Guid businessId,\n            [FromQuery] string contactPhone,\n            [FromQuery] int limit = 50,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n            {\n                return BadRequest(\"contactPhone is required.\");\n            }\n\n            var messages = await _queryService.GetMessagesForConversationAsync(\n                businessId,\n                contactPhone,\n                limit,\n                ct);\n\n            return Ok(messages);\n        }\n\n        // üì§ Send a message from agent ‚Üí customer (used by Chat Inbox middle panel)\n        [HttpPost(\"send-message\")]\n        [ProducesResponseType(typeof(ChatInboxMessageDto), 200)]\n        public async Task<ActionResult<ChatInboxMessageDto>> SendMessage(\n            [FromBody] ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            var result = await _commandService.SendAgentMessageAsync(request, ct);\n            return Ok(result);\n        }\n\n        // ‚úÖ Mark conversation as read for current user\n        [HttpPost(\"mark-read\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> MarkRead(\n            [FromBody] ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            await _commandService.MarkConversationAsReadAsync(request, ct);\n            return NoContent();\n        }\n\n        // üë§ Assign conversation to an agent\n        [HttpPost(\"assign\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> Assign(\n            [FromBody] ChatInboxAssignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            await _commandService.AssignConversationAsync(request, ct);\n            return NoContent();\n        }\n\n        // üö´ Unassign conversation\n        [HttpPost(\"unassign\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> Unassign(\n            [FromBody] ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId and ContactId are required.\");\n            }\n\n            await _commandService.UnassignConversationAsync(request, ct);\n            return NoContent();\n        }\n\n        [HttpPost(\"status\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> ChangeStatus(\n            [FromBody] ChatInboxChangeStatusRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId and ContactId are required.\");\n            }\n\n            await _commandService.ChangeConversationStatusAsync(request, ct);\n            return NoContent();\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs",
      "sha256": "1070b71e595443da5bb86c5ae223123d517333fd06193925c55359d7d2e869ae",
      "language": "csharp",
      "size": 1156,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for assigning a conversation (contact) to a specific user.\n    /// </summary>\n    public sealed class ChatInboxAssignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Agent/user who will own this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n    }\n\n    /// <summary>\n    /// Request payload for unassigning a conversation.\n    /// </summary>\n    public sealed class ChatInboxUnassignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs",
      "sha256": "272eac87602469cf471a8599cfe4fecc87e11b2cb22b59c430a28de6e1296a39",
      "language": "csharp",
      "size": 923,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Command payload for changing the status of an Inbox conversation.\n    /// Internally this maps to Contact.IsArchived / IsActive.\n    /// </summary>\n    public sealed class ChatInboxChangeStatusRequestDto\n    {\n        /// <summary>\n        /// Tenant / business id (required).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact whose conversation we want to change (required).\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Target status: \"Open\" | \"Closed\" (case-insensitive).\n        /// We also accept \"New\"/\"Pending\" but treat them as Open internally.\n        /// </summary>\n        public string? TargetStatus { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs",
      "sha256": "76991e3473373fb2fb8f90fbb2191461275be41a786a6b5e04dbf02ac32b3668",
      "language": "csharp",
      "size": 2451,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Lightweight conversation summary for the Chat Inbox UI.\n    /// Mirrors the front-end ConversationSummary model.\n    /// </summary>\n    public sealed class ChatInboxConversationDto\n    {\n        /// <summary>\n        /// Conversation identifier for the UI.\n        /// For v1 this can be derived from (ContactId + NumberId).\n        /// In the future, if you create an InboxConversation table,\n        /// use its primary key here.\n        /// </summary>\n        public string Id { get; set; } = default!;\n\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } = string.Empty;\n        public string ContactPhone { get; set; } = string.Empty;\n\n        public string LastMessagePreview { get; set; } = string.Empty;\n        public DateTime LastMessageAt { get; set; }\n\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// \"New\" | \"Open\" | \"Pending\" | \"Closed\"\n        /// </summary>\n        public string Status { get; set; } = \"New\";\n\n        /// <summary>\n        /// WhatsApp number id (e.g. wa-num-1).\n        /// Later you may map this to WhatsAppPhoneNumber.Id.\n        /// </summary>\n        public string NumberId { get; set; } = string.Empty;\n\n        public string NumberLabel { get; set; } = string.Empty;\n\n        /// <summary>\n        /// True if within 24h messaging window (WhatsApp session).\n        /// </summary>\n        public bool Within24h { get; set; }\n\n        public string? AssignedToUserId { get; set; }\n        public string? AssignedToUserName { get; set; }\n        public bool IsAssignedToMe { get; set; }\n\n        /// <summary>\n        /// \"automation\" | \"agent\"\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// \"AutoReply\" | \"Campaign\" | \"Manual\" | \"Unknown\"\n        /// </summary>\n        public string SourceType { get; set; } = \"Unknown\";\n\n        /// <summary>\n        /// Campaign name / AutoReply flow name / other source label.\n        /// </summary>\n        public string? SourceName { get; set; }\n\n        public DateTime? FirstSeenAt { get; set; }\n        public int TotalMessages { get; set; }\n\n        public DateTime? LastAgentReplyAt { get; set; }\n        public DateTime? LastAutomationAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs",
      "sha256": "edeb9ca6d210c4107c4f2982f08c387f6350b04fd2bf31bfbe643f36b2b97729",
      "language": "csharp",
      "size": 1707,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Filters used by the Chat Inbox conversation list endpoint.\n    /// This matches the UI needs: tab, number, search, \"my\" vs \"unassigned\".\n    /// </summary>\n    public sealed class ChatInboxFilterDto\n    {\n        /// <summary>\n        /// Business Id (tenant). Mandatory for multi-tenant isolation.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Currently logged-in user id (for \"my\" filter).\n        /// Optional: if null, \"my\" filter is ignored.\n        /// </summary>\n        public Guid? CurrentUserId { get; set; }\n\n        /// <summary>\n        /// \"live\" | \"history\" | \"unassigned\" | \"my\"\n        /// </summary>\n        public string? Tab { get; set; }\n\n        /// <summary>\n        /// WhatsApp number id, e.g. \"wa-num-1\". If null or \"all\", no filter.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Free text search over name, phone, and last message preview.\n        /// </summary>\n        public string? SearchTerm { get; set; }\n\n        /// <summary>\n        /// Max number of conversations to return. Hard-capped to 200.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n\n        /// <summary>\n        /// If true: only conversations without AssignedToUserId.\n        /// </summary>\n        public bool OnlyUnassigned { get; set; }\n\n        /// <summary>\n        /// If true: only conversations assigned to CurrentUserId.\n        /// </summary>\n        public bool OnlyAssignedToMe { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs",
      "sha256": "9375b5c5b9178604658d3f966c53db98de8d656c7eef85e219477f817cd16df8",
      "language": "csharp",
      "size": 1031,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for marking a conversation as \"read\"\n    /// for a given user in the Chat Inbox.\n    /// </summary>\n    public sealed class ChatInboxMarkReadRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id whose messages are being marked as read.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// The user (agent) that just read this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n\n        /// <summary>\n        /// Optional timestamp for \"last read\". If not supplied,\n        /// the server will use DateTime.UtcNow.\n        /// </summary>\n        public DateTime? LastReadAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs",
      "sha256": "c75975d0670537a2936e7dd5a8e79c9bd7bdbed9de88fc166b02e78200c61c45",
      "language": "csharp",
      "size": 1804,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Single message in a Chat Inbox conversation.\n    /// Kept intentionally simple and stable so the React UI\n    /// can bind to it without worrying about provider details.\n    /// </summary>\n    public sealed class ChatInboxMessageDto\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// \"in\"  = message came from customer to us.\n        /// \"out\" = message we sent to customer.\n        /// For now we only have reliable data for \"out\"; we keep\n        /// the string type so we can extend it later without schema changes.\n        /// </summary>\n        public string Direction { get; set; } = \"out\";\n\n        /// <summary>\n        /// Channel identifier (e.g. \"whatsapp\") ‚Äì future-proofing.\n        /// </summary>\n        public string Channel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Rendered text content for the bubble.\n        /// For templates we‚Äôll store the final rendered body.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n\n        /// <summary>\n        /// When we created/sent the message (UTC).\n        /// If SentAt is missing, falls back to CreatedAt.\n        /// </summary>\n        public DateTime SentAtUtc { get; set; }\n\n        /// <summary>\n        /// Provider / delivery status (‚ÄúSent‚Äù, ‚ÄúDelivered‚Äù, ‚ÄúRead‚Äù, ‚ÄúFailed‚Äù, etc.),\n        /// mapped from MessageLog.Status.\n        /// </summary>\n        public string? Status { get; set; }\n\n        /// <summary>\n        /// For failed messages, a short error string from MessageLog.ErrorMessage.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs",
      "sha256": "2b73973de1d335932a58540ba4a31877247732c77d7ddc345d910b40883913af",
      "language": "csharp",
      "size": 1554,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for sending an agent reply from the Chat Inbox.\n    /// This is what the React ChatInbox.jsx will POST.\n    /// </summary>\n    public sealed class ChatInboxSendMessageRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Conversation id from the UI. For v1 this is typically ContactId.ToString().\n        /// Mainly for tracing; not mandatory for the send logic.\n        /// </summary>\n        public string? ConversationId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id for this chat (preferred for lookups).\n        /// </summary>\n        public Guid? ContactId { get; set; }\n\n        /// <summary>\n        /// Target phone number (normalized WhatsApp number).\n        /// Same as selectedConversation.contactPhone in the UI.\n        /// </summary>\n        public string To { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optional: which WhatsApp number we are sending from\n        /// (e.g. \"wa-1\"). Useful when you support multiple WABA numbers.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Message body typed by the agent.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ConversationSummaryDto.cs",
      "sha256": "8d4800233670cbca833d145eba5da1a64e0b2a520e5f5bfc65ea5a36c2c9ce86",
      "language": "csharp",
      "size": 2421,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Read model used by the Chat Inbox to show the left-hand conversation list.\n    /// Mirrors the shape used in ChatInbox.jsx (INITIAL_CONVERSATIONS).\n    /// </summary>\n    public class ConversationSummaryDto\n    {\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Primary display name (CRM contact name).\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (normalized).\n        /// </summary>\n        public string PhoneNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Latest WhatsApp profile.name we saw.\n        /// </summary>\n        public string? ProfileName { get; set; }\n\n        /// <summary>\n        /// Short preview of the last message in this conversation.\n        /// </summary>\n        public string? LastMessagePreview { get; set; }\n\n        /// <summary>\n        /// When the last message was seen/sent.\n        /// </summary>\n        public DateTime? LastMessageAt { get; set; }\n\n        /// <summary>\n        /// Count of unread inbound messages for this contact.\n        /// </summary>\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// Priority like \"Hot\", \"Warm\", \"Cold\" (CRM-driven, optional).\n        /// </summary>\n        public string? Priority { get; set; }\n\n        /// <summary>\n        /// True if this contact is treated as VIP or important.\n        /// </summary>\n        public bool IsVip { get; set; }\n\n        /// <summary>\n        /// Conversation mode: \"automation\" or \"agent\".\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// Name of the assigned agent (if any).\n        /// </summary>\n        public string? AssignedAgentName { get; set; }\n\n        /// <summary>\n        /// CRM tags as chips for quick context (e.g. VIP, Lead, Follow-up).\n        /// </summary>\n        public List<string> Tags { get; set; } = new();\n\n        /// <summary>\n        /// Text like \"3 notes ‚Ä¢ 1 reminder today\".\n        /// </summary>\n        public string? LastActivitySummary { get; set; }\n\n        /// <summary>\n        /// Text like \"Next follow-up tomorrow at 11:30 AM\".\n        /// </summary>\n        public string? TaskSummary { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs",
      "sha256": "7dc0c8eb585a5b0432d326d952073ca870913b850b774b051dedc0d077c3e409",
      "language": "csharp",
      "size": 11813,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Default write-side handler for Chat Inbox actions.\n    /// Delegates the actual send to the central MessagesEngine so that\n    /// MessageLogs / provider calls stay consistent across the app.\n    /// Also manages per-user read state (ContactReads) and assignment.\n    /// </summary>\n    public sealed class ChatInboxCommandService : IChatInboxCommandService\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n\n        public ChatInboxCommandService(\n            AppDbContext db,\n            IMessageEngineService messageEngine)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n        }\n\n        public async Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.To))\n                throw new ArgumentException(\"Target phone (To) is required.\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.Text))\n                throw new ArgumentException(\"Text is required.\", nameof(request));\n\n            var businessId = request.BusinessId;\n            var phone = request.To.Trim();\n\n            // üîé Resolve contact:\n            Guid? contactId = request.ContactId;\n\n            if (!contactId.HasValue)\n            {\n                var contact = await _db.Contacts\n                    .AsNoTracking()\n                    .Where(c => c.BusinessId == businessId && c.PhoneNumber == phone)\n                    .FirstOrDefaultAsync(ct)\n                    .ConfigureAwait(false);\n\n                contactId = contact?.Id;\n            }\n\n            var effectiveContactId = contactId ?? Guid.Empty;\n\n            // üì® Build the DTO expected by MessagesEngine text pipeline.\n            var textDto = new TextMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = phone,\n                TextContent = request.Text,\n                ContactId = effectiveContactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId)\n                    ? null\n                    : request.NumberId.Trim(),\n                Provider = null,         // let engine resolve default provider/number\n                Source = \"agent\"         // so analytics can separate human replies\n            };\n\n            // üß† Delegate to the central MessagesEngine.\n            var result = await _messageEngine\n                .SendTextDirectAsync(textDto)\n                .ConfigureAwait(false);\n\n            // Try to load the MessageLog row so we can return a rich bubble DTO.\n            MessageLog? log = null;\n            if (result.LogId.HasValue)\n            {\n                log = await _db.MessageLogs\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(m => m.Id == result.LogId.Value, ct)\n                    .ConfigureAwait(false);\n            }\n\n            var nowUtc = DateTime.UtcNow;\n            var sentAt = nowUtc;\n            var bubbleText = request.Text;\n            string? status = null;\n            string? errorMessage = null;\n            Guid bubbleId;\n\n            if (log != null)\n            {\n                bubbleId = log.Id;\n                bubbleText = log.MessageContent ?? request.Text;\n\n                var ts = log.SentAt ?? log.CreatedAt;\n                sentAt = ts.Kind == DateTimeKind.Utc ? ts : ts.ToUniversalTime();\n\n                status = log.Status;\n                errorMessage = log.ErrorMessage;\n            }\n            else\n            {\n                bubbleId = Guid.NewGuid();\n                sentAt = nowUtc;\n                status = result.Success ? \"Sent\" : \"Failed\";\n                errorMessage = result.Success ? null : result.Message;\n            }\n\n            // üß± Map to ChatInboxMessageDto so the UI can render the bubble immediately.\n            var dto = new ChatInboxMessageDto\n            {\n                Id = bubbleId,\n                Direction = \"out\",           // agent ‚Üí customer\n                Channel = \"whatsapp\",\n                Text = bubbleText,\n                SentAtUtc = sentAt,\n                Status = status,\n                ErrorMessage = errorMessage\n            };\n\n            return dto;\n        }\n\n        public async Task MarkConversationAsReadAsync(\n            ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            if (request.UserId == Guid.Empty)\n                throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n            var businessId = request.BusinessId;\n            var contactId = request.ContactId;\n            var userId = request.UserId;\n            var nowUtc = DateTime.UtcNow;\n\n            var lastReadAt = request.LastReadAtUtc.HasValue\n                ? (request.LastReadAtUtc.Value.Kind == DateTimeKind.Utc\n                    ? request.LastReadAtUtc.Value\n                    : request.LastReadAtUtc.Value.ToUniversalTime())\n                : nowUtc;\n\n            // Either insert or update ContactReads row.\n            var existing = await _db.ContactReads\n                .FirstOrDefaultAsync(\n                    r => r.BusinessId == businessId\n                         && r.ContactId == contactId\n                         && r.UserId == userId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (existing == null)\n            {\n                var entity = new ContactRead\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    UserId = userId,\n                    LastReadAt = lastReadAt\n                };\n\n                await _db.ContactReads.AddAsync(entity, ct).ConfigureAwait(false);\n            }\n            else\n            {\n                // Only move forward in time; never move LastReadAt backwards.\n                if (existing.LastReadAt < lastReadAt)\n                {\n                    existing.LastReadAt = lastReadAt;\n                    _db.ContactReads.Update(existing);\n                }\n            }\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task AssignConversationAsync(\n            ChatInboxAssignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            if (request.UserId == Guid.Empty)\n                throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for assignment.\");\n            }\n\n            contact.AssignedAgentId = request.UserId;\n            _db.Contacts.Update(contact);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task UnassignConversationAsync(\n            ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for unassign.\");\n            }\n\n            contact.AssignedAgentId = null;\n            _db.Contacts.Update(contact);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task ChangeConversationStatusAsync(\n           ChatInboxChangeStatusRequestDto request,\n           CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            var rawStatus = request.TargetStatus ?? string.Empty;\n            var normalized = rawStatus.Trim();\n\n            if (string.IsNullOrEmpty(normalized))\n                throw new ArgumentException(\"TargetStatus is required.\", nameof(request));\n\n            normalized = normalized.ToLowerInvariant();\n\n            // We accept: \"open\", \"closed\", \"new\", \"pending\"\n            var close = normalized switch\n            {\n                \"closed\" => true,\n                \"open\" => false,\n                \"new\" => false,\n                \"pending\" => false,\n                _ => throw new ArgumentException(\n                    \"TargetStatus must be one of: Open, Closed, New, Pending.\",\n                    nameof(request))\n            };\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for status change.\");\n            }\n\n            if (close)\n            {\n                contact.IsArchived = true;\n                contact.IsActive = false;\n            }\n            else\n            {\n                contact.IsArchived = false;\n                contact.IsActive = true;\n            }\n\n            _db.Contacts.Update(contact);\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs",
      "sha256": "d5a3d95f42b211f1232fd16ff6d0868ae3ec2d9f8ecf9751c385d08bbdd828dc",
      "language": "csharp",
      "size": 17553,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Models; // AppDbContext\n// We avoid referencing MessageLog / Contact types by name so we don't fight namespaces.\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Default implementation of IChatInboxQueryService.\n    /// \n    /// v1 implementation:\n    ///  - Groups MessageLogs by ContactId for a Business.\n    ///  - Joins Contacts for display name / phone.\n    ///  - Computes last message, unread count (per user), 24h window, assignment flags.\n    ///  - Applies tab filters (\"live\", \"history\", \"unassigned\", \"my\") and search.\n    /// \n    /// This is intentionally conservative and can be optimized later\n    /// (server-side aggregates, better indexes, source-type mapping, etc.).\n    /// </summary>\n    public sealed class ChatInboxQueryService : IChatInboxQueryService\n    {\n        private readonly AppDbContext _db;\n\n        public ChatInboxQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            if (filter == null) throw new ArgumentNullException(nameof(filter));\n            if (filter.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(filter));\n\n            // Hard cap to avoid insane result sets\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 200) limit = 200;\n\n            var businessId = filter.BusinessId;\n            var currentUserId = filter.CurrentUserId;\n\n            // Base query: all message logs for this business that are linked to a contact.\n            // NOTE: we rely on AppDbContext.MessageLogs and ContactId being non-null for chat contacts.\n            var baseMessagesQuery = _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.ContactId != null);\n\n            // --- 1) Aggregate per contact: last message, first seen, total count ---\n            // This is done server-side; we only bring down a small projection.\n            var convoAggregates = await baseMessagesQuery\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => new\n                {\n                    ContactId = g.Key,\n                    LastMessageAt = g.Max(m => m.CreatedAt),\n                    FirstSeenAt = g.Min(m => m.CreatedAt),\n                    TotalMessages = g.Count()\n                })\n                .OrderByDescending(x => x.LastMessageAt)\n                .Take(limit)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            if (convoAggregates.Count == 0)\n            {\n                return Array.Empty<ChatInboxConversationDto>();\n            }\n\n            var contactIds = convoAggregates.Select(x => x.ContactId).ToList();\n\n            // --- 2) Load contacts for those ids (CRM) ---\n            // We assume AppDbContext.Contacts exists and has basic fields we need.\n            var contacts = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && contactIds.Contains(c.Id))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var contactsById = contacts.ToDictionary(c => c.Id, c => c);\n\n            // --- 3) Load last messages for preview (one per contact) ---\n            // We re-query MessageLogs but only for the selected contactIds.\n            var lastMessages = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId\n                            && m.ContactId != null\n                            && contactIds.Contains(m.ContactId.Value))\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => g\n                    .OrderByDescending(m => m.CreatedAt)\n                    .FirstOrDefault())\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var lastMessageByContactId = lastMessages\n                .Where(m => m != null && m.ContactId != null)\n                .ToDictionary(m => m!.ContactId!.Value, m => m!);\n\n            // --- 4) Compute unread counts for the current user (if any) ---\n            var unreadCounts = new Dictionary<Guid, int>();\n\n            if (currentUserId.HasValue)\n            {\n                // ContactReads for this user + business\n                var reads = await _db.ContactReads\n                    .AsNoTracking()\n                    .Where(r => r.BusinessId == businessId\n                                && r.UserId == currentUserId.Value\n                                && contactIds.Contains(r.ContactId))\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                var lastReadByContact = reads.ToDictionary(r => r.ContactId, r => r.LastReadAt);\n\n                // Inbound messages for those contacts\n                var inboundMessages = await _db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => m.BusinessId == businessId\n                                && m.ContactId != null\n                                && contactIds.Contains(m.ContactId.Value)\n                                && m.IsIncoming)\n                    .Select(m => new { m.ContactId, m.CreatedAt })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                foreach (var group in inboundMessages.GroupBy(x => x.ContactId!.Value))\n                {\n                    var cid = group.Key;\n                    DateTime? lastRead = null;\n                    if (lastReadByContact.TryGetValue(cid, out var value))\n                    {\n                        lastRead = value;\n                    }\n\n                    var count = lastRead.HasValue\n                        ? group.Count(x => x.CreatedAt > lastRead.Value)\n                        : group.Count();\n\n                    unreadCounts[cid] = count;\n                }\n            }\n\n            // --- 5) Load session state for \"mode\" (automation vs agent), if available ---\n            // We assume ChatSessionStates table exists and tracks Mode + last touch.\n            var sessionStates = await _db.ChatSessionStates\n                .AsNoTracking()\n                .Where(s => s.BusinessId == businessId && contactIds.Contains(s.ContactId))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var sessionByContactId = sessionStates.ToDictionary(s => s.ContactId, s => s);\n\n            // --- 6) Build DTOs in memory ---\n            var nowUtc = DateTime.UtcNow;\n            var results = new List<ChatInboxConversationDto>(convoAggregates.Count);\n\n            foreach (var agg in convoAggregates)\n            {\n                if (!contactsById.TryGetValue(agg.ContactId, out var contact))\n                {\n                    // Contact might have been hard-deleted. Skip for now.\n                    continue;\n                }\n\n                lastMessageByContactId.TryGetValue(agg.ContactId, out var lastMsg);\n\n                var preview = lastMsg?.RenderedBody ?? lastMsg?.MessageContent ?? string.Empty;\n                if (preview.Length > 140)\n                {\n                    preview = preview.Substring(0, 140) + \"‚Ä¶\";\n                }\n\n                var unread = unreadCounts.TryGetValue(agg.ContactId, out var count) ? count : 0;\n\n                var within24h = (nowUtc - agg.LastMessageAt).TotalHours <= 24;\n\n                // Conversation status heuristic:\n                // - Archived / inactive contact => Closed\n                // - Else if unread > 0 => Open\n                // - Else => Pending\n                var status =\n                    (contact.IsArchived || !contact.IsActive) ? \"Closed\"\n                    : unread > 0 ? \"Open\"\n                    : \"Pending\";\n\n                // Assignment\n                var assignedUserId = contact.AssignedAgentId;\n                var assignedUserIdString = assignedUserId?.ToString();\n                var isAssignedToMe =\n                    currentUserId.HasValue &&\n                    assignedUserId.HasValue &&\n                    assignedUserId.Value == currentUserId.Value;\n\n                // Mode: if we have ChatSessionState, use that; else infer from last message.\n                string mode = \"automation\";\n                if (sessionByContactId.TryGetValue(agg.ContactId, out var session))\n                {\n                    // Assuming session.Mode is an enum or string; normalize to lower-case string.\n                    mode = session.Mode?.ToString().ToLowerInvariant() ?? \"automation\";\n                }\n                else if (lastMsg != null)\n                {\n                    // Fallback: if last message is an outgoing \"agent\" message\n                    // we treat it as agent mode; otherwise automation.\n                    // (This depends on how you store Source; adjust later.)\n                    if (!lastMsg.IsIncoming && string.Equals(lastMsg.Source, \"agent\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        mode = \"agent\";\n                    }\n                }\n\n                // For v1 we don't yet decode exact SourceType / SourceName from Campaign / AutoReply / CTAFlow.\n                // We'll set \"Unknown\" and fill this later when we wire analytics.\n                var dto = new ChatInboxConversationDto\n                {\n                    // For v1 we use the ContactId as conversation id.\n                    Id = agg.ContactId.ToString(),\n\n                    ContactId = agg.ContactId,\n                    ContactName = string.IsNullOrWhiteSpace(contact.Name)\n                        ? (contact.ProfileName ?? contact.PhoneNumber)\n                        : contact.Name,\n                    ContactPhone = contact.PhoneNumber,\n\n                    LastMessagePreview = preview,\n                    LastMessageAt = agg.LastMessageAt,\n\n                    UnreadCount = unread,\n                    Status = status,\n\n                    // NumberId/NumberLabel: for now we leave empty.\n                    // Once WhatsApp phone mapping is wired, we can fill these.\n                    NumberId = string.Empty,\n                    NumberLabel = string.Empty,\n\n                    Within24h = within24h,\n\n                    AssignedToUserId = assignedUserIdString,\n                    AssignedToUserName = null,  // will be filled in v2 by joining Users table\n                    IsAssignedToMe = isAssignedToMe,\n\n                    Mode = mode,\n                    SourceType = \"Unknown\",\n                    SourceName = null,\n\n                    FirstSeenAt = agg.FirstSeenAt,\n                    TotalMessages = agg.TotalMessages,\n\n                    LastAgentReplyAt = null,     // can be filled later via MessageLogs aggregate\n                    LastAutomationAt = null      // same as above\n                };\n\n                results.Add(dto);\n            }\n\n            // --- 7) Apply tab filters (\"live\", \"history\", \"unassigned\", \"my\") + number + search ---\n\n            IEnumerable<ChatInboxConversationDto> filtered = results;\n\n            if (!string.IsNullOrWhiteSpace(filter.Tab))\n            {\n                var tab = filter.Tab.ToLowerInvariant();\n                switch (tab)\n                {\n                    case \"live\":\n                        filtered = filtered.Where(c => c.Within24h);\n                        break;\n                    case \"history\":\n                        filtered = filtered.Where(c => !c.Within24h);\n                        break;\n                    // \"unassigned\" and \"my\" were already mapped to flags in the controller,\n                    // but we double-check here too (harmless).\n                    case \"unassigned\":\n                        filtered = filtered.Where(c => string.IsNullOrEmpty(c.AssignedToUserId));\n                        break;\n                    case \"my\":\n                        if (currentUserId.HasValue)\n                        {\n                            filtered = filtered.Where(c => c.IsAssignedToMe);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            if (filter.OnlyUnassigned)\n            {\n                filtered = filtered.Where(c => string.IsNullOrEmpty(c.AssignedToUserId));\n            }\n\n            if (filter.OnlyAssignedToMe && currentUserId.HasValue)\n            {\n                filtered = filtered.Where(c => c.IsAssignedToMe);\n            }\n\n            // NumberId filter: for now we don't yet know which number a conversation belongs to.\n            // Once MessageLogs have NumberId / PhoneNumberId we can populate dto.NumberId and filter here.\n            if (!string.IsNullOrWhiteSpace(filter.NumberId)\n                && !string.Equals(filter.NumberId, \"all\", StringComparison.OrdinalIgnoreCase))\n            {\n                filtered = filtered.Where(c => string.Equals(c.NumberId, filter.NumberId, StringComparison.OrdinalIgnoreCase));\n            }\n\n            // Search: name, phone, last message preview (case-insensitive)\n            if (!string.IsNullOrWhiteSpace(filter.SearchTerm))\n            {\n                var term = filter.SearchTerm.Trim();\n                var termLower = term.ToLowerInvariant();\n\n                filtered = filtered.Where(c =>\n                    (!string.IsNullOrEmpty(c.ContactName) && c.ContactName.ToLowerInvariant().Contains(termLower)) ||\n                    (!string.IsNullOrEmpty(c.ContactPhone) && c.ContactPhone.Contains(term)) ||\n                    (!string.IsNullOrEmpty(c.LastMessagePreview) && c.LastMessagePreview.ToLowerInvariant().Contains(termLower)));\n            }\n\n            // Final cap (defensive)\n            var finalList = filtered\n                .OrderByDescending(c => c.LastMessageAt)\n                .Take(limit)\n                .ToList();\n\n            return finalList;\n        }\n\n        // üí¨ Messages for a single conversation (center pane)\n        // inside ChatInboxQueryService\n\n        // üí¨ Messages for a single conversation (center pane)\n        // inside ChatInboxQueryService\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"Contact phone is required.\", nameof(contactPhone));\n\n            if (limit <= 0)\n                limit = 50;\n            if (limit > 500)\n                limit = 500;\n\n            var trimmedPhone = contactPhone.Trim();\n\n            // üü¢ Step 1: resolve ContactId from phone number for this business\n            var contactId = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && c.PhoneNumber == trimmedPhone)\n                .Select(c => (Guid?)c.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (contactId == null)\n            {\n                // No such contact ‚Üí no messages\n                return Array.Empty<ChatInboxMessageDto>();\n            }\n\n            // üü¢ Step 2: fetch all messages for this contact (both directions)\n            var query = _db.MessageLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId &&\n                            x.ContactId == contactId.Value);\n\n            // Newest first\n            query = query\n                .OrderByDescending(x => x.SentAt ?? x.CreatedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit);\n\n            var rows = await query\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            // Map to DTOs (newest ‚Üí oldest; UI can reverse if needed).\n            var list = rows\n                .Select(x =>\n                {\n                    var instant = x.SentAt ?? x.CreatedAt;\n                    var utcInstant = instant.Kind == DateTimeKind.Utc\n                        ? instant\n                        : instant.ToUniversalTime();\n\n                    return new ChatInboxMessageDto\n                    {\n                        Id = x.Id,\n\n                        // ‚úÖ Use MessageLog.IsIncoming to decide bubble side\n                        Direction = x.IsIncoming ? \"in\" : \"out\",\n\n                        Channel = \"whatsapp\",\n\n                        // Prefer rendered template body when available\n                        Text = x.RenderedBody ?? x.MessageContent ?? string.Empty,\n\n                        SentAtUtc = utcInstant,\n                        Status = x.Status,\n                        ErrorMessage = x.ErrorMessage\n                    };\n                })\n                .ToList();\n\n            return list;\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs",
      "sha256": "4741408b7d2642c02f2c810518a363a0a18086afbf5fe1dbd5a30b8c66936951",
      "language": "csharp",
      "size": 1165,
      "content": "using xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxCommandService\n    {\n        /// <summary>\n        /// Sends an agent-authored text message to a contact from the Chat Inbox\n        /// and returns the resulting message DTO for the UI bubble.\n        /// </summary>\n        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default);\n        Task MarkConversationAsReadAsync(\n            ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default);\n\n        Task AssignConversationAsync(\n           ChatInboxAssignRequestDto request,\n           CancellationToken ct = default);\n\n        /// <summary>\n        /// Unassigns a conversation (sets AssignedAgentId to null).\n        /// </summary>\n        Task UnassignConversationAsync(\n            ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default);\n\n        Task ChangeConversationStatusAsync(\n           ChatInboxChangeStatusRequestDto request,\n           CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs",
      "sha256": "12fea9a47aa0deb5812b81de304846b9de47b8d4ed1cda7b11eb159a7353ac13",
      "language": "csharp",
      "size": 870,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Read-only query service for Chat Inbox conversations.\n    /// This is a pure \"read model\" projection over MessageLogs + CRM.\n    /// </summary>\n    public interface IChatInboxQueryService\n    {\n        Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default);\n    }\n    \n}\n"
    }
  ]
}
