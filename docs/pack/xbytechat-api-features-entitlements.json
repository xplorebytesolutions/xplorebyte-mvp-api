{
  "name": "xbytechat-api/Features/Entitlements",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/EntitlementsController.cs",
      "sha256": "0c435fe50cb96bd08c30f57eb23775a506bd85d7555798508742e38ecc668977",
      "language": "csharp",
      "size": 3151,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Helpers; // âœ… Use shared helpers for claims\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    [ApiController]\n    [Route(\"api/entitlements\")]\n    [Authorize]\n    public sealed class EntitlementsController : ControllerBase\n    {\n        private readonly IQuotaService _quota;\n\n        // Roles are stored lower-case in JWT (JwtTokenService),\n        // so we treat \"admin\" and \"superadmin\" as global admins.\n        private const string AdminRoleAdmin = \"admin\";\n        private const string AdminRoleSuperAdmin = \"superadmin\";\n\n        public EntitlementsController(IQuotaService quota)\n        {\n            _quota = quota;\n        }\n\n        // Helpers\n        private Guid? TryGetCallerBusinessId()\n        {\n            // Centralized logic: reads \"businessId\" claim.\n            var id = UserContextHelper.GetBusinessId(User);\n            return id == Guid.Empty ? (Guid?)null : id;\n        }\n\n        private bool IsAdmin()\n        {\n            return User.IsInRole(AdminRoleAdmin) || User.IsInRole(AdminRoleSuperAdmin);\n        }\n\n        private bool IsAuthorizedFor(Guid targetBusinessId)\n        {\n            if (IsAdmin()) return true;\n\n            var callerBiz = TryGetCallerBusinessId();\n            return callerBiz.HasValue && callerBiz.Value == targetBusinessId;\n        }\n\n        // GET /api/entitlements/{businessId}\n        [HttpGet(\"{businessId:guid}\")]\n        public async Task<ActionResult<EntitlementsSnapshotDto>> GetSnapshot(\n            Guid businessId,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            var dto = await _quota.GetSnapshotAsync(businessId, ct);\n            return Ok(dto);\n        }\n\n        // POST /api/entitlements/{businessId}/check\n        [HttpPost(\"{businessId:guid}/check\")]\n        public async Task<ActionResult<EntitlementResultDto>> Check(\n            Guid businessId,\n            [FromBody] EntitlementCheckDto? req,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            if (req is null)\n                return BadRequest(\"Request body is required.\");\n\n            if (string.IsNullOrWhiteSpace(req.QuotaKey))\n                return BadRequest(\"QuotaKey required.\");\n\n            var amount = Math.Max(1, req.Amount);\n\n            var result = req.ConsumeOnSuccess\n                ? await _quota.CheckAndConsumeAsync(businessId, req.QuotaKey, amount, ct)\n                : await _quota.CheckAsync(businessId, req.QuotaKey, amount, ct);\n\n            if (!result.Allowed)\n                // 429 payload shape is already what your axios interceptor expects:\n                // { allowed:false, quotaKey, limit, remaining, message }\n                return StatusCode(429, result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/PlanQuotasAdminController.cs",
      "sha256": "615f8f0b670d3e8aef239a57b9a5125959a2a63e18f417e08a8b52d2b99da7c3",
      "language": "csharp",
      "size": 5876,
      "content": "// ðŸ“„ Features/Entitlements/Controllers/PlanQuotasAdminController.cs\n#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    /// <summary>\n    /// Admin endpoints to manage default quotas per plan.\n    /// These are the rows in PlanQuotas table.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/plans/{planId:guid}/quotas\")]\n    [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n    public sealed class PlanQuotasAdminController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public PlanQuotasAdminController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // GET /admin/plans/{planId}/quotas\n        [HttpGet]\n        public async Task<ActionResult<List<PlanQuotaDto>>> GetForPlan(\n            Guid planId,\n            CancellationToken ct)\n        {\n            // Validate plan exists (defensive)\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var quotas = await _db.PlanQuotas\n                .AsNoTracking()\n                .Where(q => q.PlanId == planId)\n                .OrderBy(q => q.QuotaKey)\n                .Select(q => new PlanQuotaDto\n                {\n                    Id = q.Id,\n                    PlanId = q.PlanId,\n                    QuotaKey = q.QuotaKey,\n                    Limit = q.Limit,\n                    Period = q.Period,\n                    DenialMessage = q.DenialMessage\n                })\n                .ToListAsync(ct);\n\n            return Ok(quotas);\n        }\n\n        // PUT /admin/plans/{planId}/quotas\n        //\n        // Simple \"upsert by QuotaKey\" semantics:\n        // - Existing PlanQuota with same PlanId + QuotaKey is updated\n        // - New QuotaKey rows are inserted\n        // - Quotas not present in payload are kept (no destructive delete here)\n        [HttpPut]\n        public async Task<IActionResult> UpsertForPlan(\n            Guid planId,\n            [FromBody] List<PlanQuotaDto> payload,\n            CancellationToken ct)\n        {\n            if (payload is null)\n                return BadRequest(new { message = \"Payload is required\" });\n\n            // Normalize keys to upper-case for comparisons (used only in-memory)\n            static string Normalize(string key) =>\n                (key ?? string.Empty).Trim().ToUpperInvariant();\n\n            // Ensure plan exists\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var incoming = payload\n                .Where(p => !string.IsNullOrWhiteSpace(p.QuotaKey))\n                .Select(p => new\n                {\n                    Raw = p,\n                    NormalizedKey = Normalize(p.QuotaKey!)\n                })\n                .ToList();\n\n            if (!incoming.Any())\n                return BadRequest(new { message = \"At least one quota with a QuotaKey is required.\" });\n\n            var keys = incoming\n                .Select(i => i.NormalizedKey)\n                .Distinct()\n                .ToList();\n\n            // âœ… IMPORTANT: bring data into memory first, then call Normalize\n            var existingAllForPlan = await _db.PlanQuotas\n                .Where(q => q.PlanId == planId)\n                .ToListAsync(ct);\n\n            // optional: only keep rows whose normalized key is in payload keys\n            var existing = existingAllForPlan\n                .Where(q => keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n            // ðŸ‘‰ NEW: delete quotas that are no longer present in the payload\n            var toDelete = existingAllForPlan\n                .Where(q => !keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n\n            if (toDelete.Count > 0)\n            {\n                _db.PlanQuotas.RemoveRange(toDelete);\n            }\n\n            foreach (var item in incoming)\n            {\n                var dto = item.Raw;\n                var normalizedKey = item.NormalizedKey;\n\n                var entity = existing\n                    .FirstOrDefault(q => Normalize(q.QuotaKey) == normalizedKey);\n\n                if (entity is null)\n                {\n                    // Insert new row\n                    entity = new PlanQuota\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        QuotaKey = normalizedKey,\n                        Limit = dto.Limit,\n                        Period = dto.Period,\n                        DenialMessage = dto.DenialMessage,\n                        CreatedAt = DateTime.UtcNow,\n                        UpdatedAt = DateTime.UtcNow\n                    };\n\n                    _db.PlanQuotas.Add(entity);\n                    existing.Add(entity); // keep in local list too\n                }\n                else\n                {\n                    // Update existing row\n                    entity.QuotaKey = normalizedKey;\n                    entity.Limit = dto.Limit;\n                    entity.Period = dto.Period;\n                    entity.DenialMessage = dto.DenialMessage;\n                    entity.UpdatedAt = DateTime.UtcNow;\n                }\n            }\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/EntitlementCheckDto.cs",
      "sha256": "e3c6863b705bec9193d677f8cf0d408345f812e955b06ffd375f8ef38d9fcb4f",
      "language": "csharp",
      "size": 1422,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class EntitlementCheckDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public long Amount { get; set; } = 1;\n        public bool ConsumeOnSuccess { get; set; } = true;\n    }\n\n    public sealed class EntitlementResultDto\n    {\n        public bool Allowed { get; set; }\n        public string QuotaKey { get; set; } = default!;\n        public long? Limit { get; set; }           // null if unlimited\n        public long? Remaining { get; set; }       // null if unlimited\n        public string? Message { get; set; }\n    }\n\n    public sealed class EntitlementsSnapshotDto\n    {\n        public IEnumerable<string> GrantedPermissions { get; set; } = new List<string>();\n        public IEnumerable<QuotaSnapshotItemDto> Quotas { get; set; } = new List<QuotaSnapshotItemDto>();\n    }\n\n    public sealed class QuotaSnapshotItemDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public string Period { get; set; } = default!; // \"Daily\"/\"Monthly\"/\"Lifetime\"\n        public long? Limit { get; set; }               // null => unlimited\n        public long Consumed { get; set; }\n        public long? Remaining { get; set; }           // null => unlimited\n        public string? DenialMessage { get; set; }\n        public string WindowStartUtc { get; set; } = default!;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/PlanQuotaDto.cs",
      "sha256": "eb3560e2218f3b7d2750e2a68fdf6a3f140f99a35665bf31e9d34671ad1611e3",
      "language": "csharp",
      "size": 738,
      "content": "// ðŸ“„ Features/Entitlements/DTOs/PlanQuotaDto.cs\nusing System;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    /// <summary>\n    /// Admin-facing DTO for default quotas configured per plan.\n    /// </summary>\n    public sealed class PlanQuotaDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n\n        // Canonical key, e.g. \"MESSAGES_PER_MONTH\"\n        public string QuotaKey { get; set; } = string.Empty;\n\n        // -1 => unlimited\n        public long Limit { get; set; }\n\n        public QuotaPeriod Period { get; set; }\n\n        // Optional UX text used when quota is denied\n        public string? DenialMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessQuotaOverride.cs",
      "sha256": "b1f87eedb2763fc2bb19f50e1a992e2d4adb2e86477ab1f04f0b3bd6f9a17fb6",
      "language": "csharp",
      "size": 848,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessQuotaOverrides\")]\n    public sealed class BusinessQuotaOverride\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!; // same key as PlanQuota\n\n        public long? Limit { get; set; }     // null => fallback to plan\n        public bool? IsUnlimited { get; set; } // true => unlimited regardless of plan\n\n        public DateTime? ExpiresAt { get; set; } // null => permanent\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessUsageCounter.cs",
      "sha256": "85f37a61b7bf3227782bc452a7088746e129334cf37722d55a788faac363a1fc",
      "language": "csharp",
      "size": 928,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessUsageCounters\")]\n    public sealed class BusinessUsageCounter\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public QuotaPeriod Period { get; set; }\n\n        // To support resets, store the window start for this counter.\n        public DateTime WindowStartUtc { get; set; }\n\n        // Current consumed units within the window.\n        public long Consumed { get; set; }\n\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/PlanQuota.cs",
      "sha256": "215c4b1b07bd49b5499c1f3f1435739fd47ce44cc493aca1925d91e20c441573",
      "language": "csharp",
      "size": 989,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"PlanQuotas\")]\n    public sealed class PlanQuota\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid PlanId { get; set; } // FK to AccessControl Plan\n\n        // Case-insensitive programmatic key, e.g., \"MessagesPerMonth\"\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public long Limit { get; set; }            // -1 => unlimited\n        public QuotaPeriod Period { get; set; }    // Daily/Monthly/Lifetime\n\n        // Optional UX copy shown to user on denial\n        [MaxLength(256)]\n        public string? DenialMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/QuotaPeriod.cs",
      "sha256": "375d8f9e16fc912410137ae6208999b6580602bb4635bd5180e67f40ca8a1da7",
      "language": "csharp",
      "size": 189,
      "content": "namespace xbytechat.api.Features.Entitlements.Models\n{\n    public enum QuotaPeriod\n    {\n        Lifetime = 0,  // never resets automatically\n        Daily = 1,\n        Monthly = 2\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/QuotaKeys.cs",
      "sha256": "14149e987392ec3d22e757e52540d860518860a40a594846459035ec0428eec6",
      "language": "csharp",
      "size": 591,
      "content": "// ðŸ“„ Features/Entitlements/QuotaKeys.cs\nnamespace xbytechat.api.Features.Entitlements\n{\n\n    public static class QuotaKeys\n    {\n        // How many messages a business can send in a given period (usually Monthly)\n        public const string MessagesPerMonth = \"MESSAGES_PER_MONTH\";\n\n        public const string MessagesPerDay = \"MESSAGES_PER_DAY\";\n        // How many campaigns can be sent per day\n        public const string CampaignsPerDay = \"CAMPAIGNS_PER_DAY\";\n\n        // How many templates can exist in total\n        public const string TemplatesTotal = \"TEMPLATES_TOTAL\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Seed/EntitlementsSeeder.cs",
      "sha256": "39a6c25c6d3cda63542eea996b67df2e21973a2afb10a93da008b33613f626d5",
      "language": "csharp",
      "size": 1273,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Entitlements.Seed\n{\n    public static class EntitlementsSeeder\n    {\n        public static async Task SeedAsync(AppDbContext db, Guid planId)\n        {\n            var defaults = new[]\n            {\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"MESSAGES_PER_MONTH\", Limit = 10000, Period = QuotaPeriod.Monthly, DenialMessage = \"Monthly message limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"CAMPAIGNS_PER_DAY\",   Limit = 10,    Period = QuotaPeriod.Daily,   DenialMessage = \"Daily campaign limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"TEMPLATES_TOTAL\",     Limit = -1,    Period = QuotaPeriod.Lifetime } // unlimited\n            };\n\n            foreach (var q in defaults)\n            {\n                var exists = await db.PlanQuotas.AnyAsync(p => p.PlanId == planId && p.QuotaKey.ToUpper() == q.QuotaKey.ToUpper());\n                if (!exists) db.PlanQuotas.Add(q);\n            }\n            await db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/IQuotaService.cs",
      "sha256": "55c9229cb163efbc7ef1621a7f2fa061a1299f8b85046402a2e3708327f41648",
      "language": "csharp",
      "size": 784,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.DTOs;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public interface IQuotaService\n    {\n        Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n        Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n\n        Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct);\n\n        // Utility to ensure counters are on the correct window (creates or rolls window if needed)\n        Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/QuotaService.cs",
      "sha256": "bf77b3fee43d514c4d28b81732cd41857fc8afd29afe72f5f6b05f5cdf81af76",
      "language": "csharp",
      "size": 13906,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Features.AccessControl.Models; // your Plan/PlanPermission namespace as applicable\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public sealed class QuotaService : IQuotaService\n    {\n        private readonly AppDbContext _db;\n\n        public QuotaService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // Normalize keys to uppercase to keep lookups stable on non-CI collations\n        private static string NK(string key) => key.Trim().ToUpperInvariant();\n\n        private static DateTime CurrentWindowStartUtc(QuotaPeriod p, DateTime nowUtc)\n        {\n            return p switch\n            {\n                QuotaPeriod.Daily => new DateTime(nowUtc.Year, nowUtc.Month, nowUtc.Day, 0, 0, 0, DateTimeKind.Utc),\n                QuotaPeriod.Monthly => new DateTime(nowUtc.Year, nowUtc.Month, 1, 0, 0, 0, DateTimeKind.Utc),\n                _ => DateTime.UnixEpoch\n            };\n        }\n\n        private async Task<(QuotaPeriod Period, long? Limit, string? Denial)> ResolveEffectiveLimitAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n\n            // resolve business planId\n            var business = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => new { b.Id, b.PlanId })\n                .FirstOrDefaultAsync(ct);\n\n            if (business is null)\n                return (QuotaPeriod.Lifetime, 0, \"Business not found.\");\n\n            // override first\n            var ovr = await _db.BusinessQuotaOverrides\n                .AsNoTracking()\n                .Where(o => o.BusinessId == businessId && o.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (ovr is not null && (ovr.ExpiresAt == null || ovr.ExpiresAt > DateTime.UtcNow))\n            {\n                if (ovr.IsUnlimited == true)\n                    return (QuotaPeriod.Lifetime, null, null); // unlimited\n\n                if (ovr.Limit.HasValue)\n                {\n                    // Need period: fall back to plan period (must exist)\n                    var pq = await _db.PlanQuotas.AsNoTracking()\n                        .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                        .Select(p => new { p.Period, p.DenialMessage })\n                        .FirstOrDefaultAsync(ct);\n\n                    if (pq is null)\n                        return (QuotaPeriod.Lifetime, ovr.Limit!.Value, null); // custom limit without period -> treat as lifetime\n\n                    return (pq.Period, ovr.Limit!.Value, pq.DenialMessage);\n                }\n                // if override exists but no limit/isUnlimited set, fall back to plan\n            }\n\n            // plan default\n            var planQuota = await _db.PlanQuotas.AsNoTracking()\n                .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (planQuota is null)\n                return (QuotaPeriod.Lifetime, 0, \"Quota not defined for plan.\"); // deny by default\n\n            if (planQuota.Limit < 0)\n                return (planQuota.Period, null, planQuota.DenialMessage); // unlimited\n\n            return (planQuota.Period, planQuota.Limit, planQuota.DenialMessage);\n        }\n\n        private async Task<BusinessUsageCounter> GetOrCreateCounterAsync(Guid businessId, string quotaKey, QuotaPeriod period, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            var counter = await _db.BusinessUsageCounters.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                     c.Period == period && c.WindowStartUtc == winStart, ct);\n\n            if (counter is not null) return counter;\n\n            counter = new BusinessUsageCounter\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                QuotaKey = quotaKey,\n                Period = period,\n                WindowStartUtc = winStart,\n                Consumed = 0,\n                CreatedAt = now,\n                UpdatedAt = now\n            };\n            _db.BusinessUsageCounters.Add(counter);\n\n            try\n            {\n                await _db.SaveChangesAsync(ct);\n                return counter;\n            }\n            catch (DbUpdateException)\n            {\n                // Another thread created it; fetch the existing row\n                return await _db.BusinessUsageCounters.FirstAsync(\n                    c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                         c.Period == period && c.WindowStartUtc == winStart, ct);\n            }\n        }\n\n        public async Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            var (period, _, _) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n            await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n        }\n\n        public async Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                return new EntitlementResultDto\n                {\n                    Allowed = true,\n                    QuotaKey = quotaKey,\n                    Limit = null,\n                    Remaining = null\n                };\n            }\n\n            var counter = await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n\n            var remaining = limit.Value - counter.Consumed;\n            var allowed = remaining >= amount;\n\n            return new EntitlementResultDto\n            {\n                Allowed = allowed,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, remaining),\n                Message = allowed ? null : (denial ?? \"Quota limit reached.\")\n            };\n        }\n\n        public async Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                // No increment needed; still return success\n                return new EntitlementResultDto { Allowed = true, QuotaKey = quotaKey, Limit = null, Remaining = null };\n            }\n\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            // Atomic consume in a single SQL statement\n            // UPDATE ... SET Consumed = Consumed + @amount WHERE ... AND Consumed + @amount <= @limit\n            var updated = await _db.BusinessUsageCounters\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart &&\n                    c.Consumed + amount <= limit.Value)\n                .ExecuteUpdateAsync(up =>\n                    up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                      .SetProperty(c => c.UpdatedAt, _ => now), ct);\n\n            if (updated == 0)\n            {\n                // Ensure the row exists; if missing, create and retry once\n                var existed = await _db.BusinessUsageCounters.AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart, ct);\n\n                if (!existed)\n                {\n                    var counter = new BusinessUsageCounter\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        QuotaKey = quotaKey,\n                        Period = period,\n                        WindowStartUtc = winStart,\n                        Consumed = 0,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n                    _db.BusinessUsageCounters.Add(counter);\n                    await _db.SaveChangesAsync(ct);\n\n                    // retry atomic consume\n                    updated = await _db.BusinessUsageCounters\n                        .Where(c =>\n                            c.BusinessId == businessId &&\n                            c.QuotaKey.ToUpper() == quotaKey &&\n                            c.Period == period &&\n                            c.WindowStartUtc == winStart &&\n                            c.Consumed + amount <= limit.Value)\n                        .ExecuteUpdateAsync(up =>\n                            up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                              .SetProperty(c => c.UpdatedAt, _ => now), ct);\n                }\n            }\n\n            if (updated == 0)\n            {\n                // Denied\n                var current = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c =>\n                        c.BusinessId == businessId &&\n                        c.QuotaKey.ToUpper() == quotaKey &&\n                        c.Period == period &&\n                        c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                var remaining = Math.Max(0, limit.Value - current);\n\n                return new EntitlementResultDto\n                {\n                    Allowed = false,\n                    QuotaKey = quotaKey,\n                    Limit = limit.Value,\n                    Remaining = remaining,\n                    Message = denial ?? \"Quota limit reached.\"\n                };\n            }\n\n            // Success pathâ€”fetch updated consumed to compute remaining\n            var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart)\n                .Select(c => c.Consumed)\n                .FirstAsync(ct);\n\n            return new EntitlementResultDto\n            {\n                Allowed = true,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, limit.Value - consumed)\n            };\n        }\n\n        public async Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct)\n        {\n            // Resolve plan once\n            var planId = await _db.Businesses.AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => b.PlanId)\n                .FirstAsync(ct);\n\n            // Permission codes for this plan\n            var grantedPerms = await _db.PlanPermissions\n                .AsNoTracking()\n                .Where(pp => pp.PlanId == planId && pp.IsActive && pp.Permission.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync(ct);\n\n            // Quotas â€“ sequential to avoid DbContext concurrency issues\n            var planQuotas = await _db.PlanQuotas.AsNoTracking()\n                .Where(pq => pq.PlanId == planId)\n                .ToListAsync(ct);\n\n            var overrides = await _db.BusinessQuotaOverrides.AsNoTracking()\n                .Where(o => o.BusinessId == businessId &&\n                            (o.ExpiresAt == null || o.ExpiresAt > DateTime.UtcNow))\n                .ToListAsync(ct);\n\n            var now = DateTime.UtcNow;\n\n            var items = new List<QuotaSnapshotItemDto>();\n\n            foreach (var pq in planQuotas)\n            {\n                var key = NK(pq.QuotaKey);\n\n                long? limit = overrides.FirstOrDefault(o => NK(o.QuotaKey) == key) is { } o\n                    ? (o.IsUnlimited == true ? null : o.Limit ?? (pq.Limit < 0 ? (long?)null : pq.Limit))\n                    : (pq.Limit < 0 ? (long?)null : pq.Limit);\n\n                var winStart = CurrentWindowStartUtc(pq.Period, now);\n\n                var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c => c.BusinessId == businessId &&\n                                c.QuotaKey.ToUpper() == key &&\n                                c.Period == pq.Period &&\n                                c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                items.Add(new QuotaSnapshotItemDto\n                {\n                    QuotaKey = key,\n                    Period = pq.Period.ToString(),\n                    Limit = limit,\n                    Consumed = consumed,\n                    Remaining = limit is null ? null : Math.Max(0, limit.Value - consumed),\n                    DenialMessage = pq.DenialMessage,\n                    WindowStartUtc = winStart.ToString(\"u\")\n                });\n            }\n\n            return new EntitlementsSnapshotDto\n            {\n                GrantedPermissions = grantedPerms,\n                Quotas = items\n            };\n        }\n\n\n    }\n}\n"
    }
  ]
}
