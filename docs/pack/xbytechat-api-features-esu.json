{
  "name": "xbytechat-api/Features/ESU",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IEsuStatusService.cs",
      "sha256": "825a494d506b60064b1f3811f94cece207f3feb402079cf5371171bb0752d168",
      "language": "csharp",
      "size": 420,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    public interface IEsuStatusService\n    {\n        Task<EsuStatusDto> GetStatusAsync(Guid businessId, CancellationToken ct = default);\n        Task DeauthorizeAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IEsuTokenStore.cs",
      "sha256": "19575329bfc016c7842b626d8c6403ee75cb77797bf8caad98b983aa2eed6af2",
      "language": "csharp",
      "size": 517,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Models;\n\npublic interface IEsuTokenStore\n{\n    Task<EsuToken?> GetAsync(Guid businessId, string provider, CancellationToken ct);\n    Task UpsertAsync(Guid businessId, string provider, string token, DateTime? expiresAtUtc, CancellationToken ct);\n    Task RevokeAsync(Guid businessId, string provider, CancellationToken ct);\n\n    Task DeleteAsync(Guid biz, string provider, CancellationToken ct = default);\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookGraphClient.cs",
      "sha256": "448400005f2e87088712cdae60bb312c7a1474b18d8702fb89188c8bbf6cee4a",
      "language": "csharp",
      "size": 421,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    public interface IFacebookGraphClient\n    {\n        Task<T> GetAsync<T>(\n            Guid businessId,\n            string path,\n            IDictionary<string, string?>? query = null,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookOauthClient.cs",
      "sha256": "aa56a723ee19e25ace745f273354e63ff103c42ebeb81e8d32fd05ad55db8301",
      "language": "csharp",
      "size": 737,
      "content": "#nullable enable\nusing System.Threading;\nusing System.Threading.Tasks;\nusing FbContracts = xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    /// <summary>Handles the OAuth \"code → access_token\" exchanges with Facebook Graph API.</summary>\n    public interface IFacebookOauthClient\n    {\n        Task<FbContracts.FacebookTokenResponse> ExchangeCodeAsync(string code, CancellationToken ct = default);\n\n        /// <summary>Swap short-lived token for a ~60-day long-lived token.</summary>\n        Task<FbContracts.FacebookTokenResponse> ExchangeForLongLivedAsync(\n            FbContracts.FacebookTokenResponse shortToken,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookTokenService.cs",
      "sha256": "1f2bd9d86694df46bd6f415d4246e249ebca0ad878762d4ec30a27f251e4d270",
      "language": "csharp",
      "size": 1029,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    /// <summary>Retrieves a Facebook access token for a business with expiry checks and caching.</summary>\n    public interface IFacebookTokenService\n    {\n        /// <summary>\n        /// Returns a stored token if it exists and is not near expiry. Returns null if missing/expired.\n        /// </summary>\n        Task<FacebookStoredToken?> TryGetValidAsync(Guid businessId, CancellationToken ct = default);\n\n        /// <summary>\n        /// Throws if missing/expired. Use when a valid token is required for an operation.\n        /// </summary>\n        Task<FacebookStoredToken> GetRequiredAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<string?> GetAccessTokenAsync(Guid businessId, CancellationToken ct = default);\n        Task InvalidateAsync(Guid businessId, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/FacebookGraphClient.cs",
      "sha256": "c96cd6ce910b95deff6df835e53329da4603f69b2230d7e5f149a92aa2451ca9",
      "language": "csharp",
      "size": 3678,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.Options;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    internal sealed class FacebookGraphClient : IFacebookGraphClient\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web)\n        { PropertyNameCaseInsensitive = true, WriteIndented = false };\n\n        private readonly HttpClient _http;\n        private readonly ILogger<FacebookGraphClient> _log;\n        private readonly FacebookOauthOptions _opt;\n        private readonly IFacebookTokenService _tokens;\n\n        public FacebookGraphClient(\n            HttpClient http,\n            IOptions<FacebookOauthOptions> opt,\n            IFacebookTokenService tokens,\n            ILogger<FacebookGraphClient> log)\n        {\n            _http = http;\n            _opt = opt.Value;\n            _tokens = tokens;\n            _log = log;\n        }\n\n        public async Task<T> GetAsync<T>(\n            Guid businessId,\n            string path,\n            IDictionary<string, string?>? query = null,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new ArgumentException(\"businessId is required\", nameof(businessId));\n            if (string.IsNullOrWhiteSpace(path)) throw new ArgumentException(\"path is required\", nameof(path));\n\n            // 1) Get (valid) token\n            var token = await _tokens.GetRequiredAsync(businessId, ct).ConfigureAwait(false);\n\n            // 2) Build URL\n            var baseUrl = _opt.GraphBaseUrl.TrimEnd('/');\n            var ver = _opt.GraphApiVersion.Trim('/');\n            var url = $\"{baseUrl}/{ver}/{path.TrimStart('/')}\";\n\n            var finalUrl = query is null ? url : QueryHelpers.AddQueryString(url, query);\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, finalUrl);\n            req.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token.AccessToken);\n\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FacebookErrorResponse? err = null;\n                try { err = JsonSerializer.Deserialize<FacebookErrorResponse>(raw, JsonOpts); } catch { /* ignore */ }\n\n                var msg = err?.Error?.Message ?? $\"Graph GET {path} failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Graph error: {Msg}. Raw: {Raw}\", msg, Truncate(raw, 1000));\n\n                throw new FacebookGraphException(\n                    msg, err?.Error?.Type, err?.Error?.Code, err?.Error?.SubCode, err?.Error?.TraceId);\n            }\n\n            try\n            {\n                return JsonSerializer.Deserialize<T>(raw, JsonOpts)\n                       ?? throw new InvalidOperationException(\"Graph response was empty.\");\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse Graph response for {Path}. Raw: {Raw}\", path, Truncate(raw, 1200));\n                throw;\n            }\n        }\n\n        private static string Truncate(string s, int max) => s.Length <= max ? s : s[..max];\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Clients/FacebookOauthClient.cs",
      "sha256": "d1b8fc306fc457f35cb0045bda912fd55b330abf64ba8de608dd26551ac3292a",
      "language": "csharp",
      "size": 7536,
      "content": "#nullable enable\nusing System;\nusing System.Net.Http;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing FbContracts = xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Clients\n{\n    internal sealed class FacebookOauthClient : IFacebookOauthClient\n    {\n        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web)\n        { PropertyNameCaseInsensitive = true, WriteIndented = false };\n\n        private readonly HttpClient _http;\n        private readonly ILogger<FacebookOauthClient> _log;\n        private readonly FacebookOauthOptions _opt;\n\n        public FacebookOauthClient(HttpClient http, IOptions<FacebookOauthOptions> opt, ILogger<FacebookOauthClient> log)\n        {\n            _http = http ?? throw new ArgumentNullException(nameof(http));\n            _log = log ?? throw new ArgumentNullException(nameof(log));\n            _opt = opt?.Value ?? throw new ArgumentNullException(nameof(opt));\n        }\n\n        public async Task<FbContracts.FacebookTokenResponse> ExchangeCodeAsync(string code, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(code))\n                throw new ArgumentException(\"Authorization code must be provided.\", nameof(code));\n\n            var baseUri = _opt.GraphBaseUrl.TrimEnd('/');\n            var version = _opt.GraphApiVersion.Trim('/');\n            var path = $\"{baseUri}/{version}/oauth/access_token\";\n\n            var uri = new UriBuilder(path)\n            {\n                Query =\n                    $\"client_id={Uri.EscapeDataString(_opt.AppId)}\" +\n                    $\"&redirect_uri={Uri.EscapeDataString(_opt.RedirectUri)}\" +\n                    $\"&client_secret={Uri.EscapeDataString(_opt.AppSecret)}\" +\n                    $\"&code={Uri.EscapeDataString(code)}\"\n            }.Uri;\n\n            _log.LogInformation(\"Exchanging Facebook OAuth code for token via {Uri}\", uri.GetLeftPart(UriPartial.Path));\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, uri);\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FbContracts.FacebookErrorResponse? fbErr = null;\n                try { fbErr = JsonSerializer.Deserialize<FbContracts.FacebookErrorResponse>(raw, JsonOpts); } catch { }\n\n                var message = fbErr?.Error?.Message ?? $\"Facebook token exchange failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Facebook OAuth error: {Message}. Raw: {Raw}\", message, Truncate(raw, 1000));\n                throw new InvalidOperationException(\n                    $\"Facebook OAuth error: {message} (type={fbErr?.Error?.Type}, code={fbErr?.Error?.Code}, subcode={fbErr?.Error?.SubCode})\");\n            }\n\n            FbContracts.FacebookTokenResponse? token;\n            try { token = JsonSerializer.Deserialize<FbContracts.FacebookTokenResponse>(raw, JsonOpts); }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse Facebook token response. Raw: {Raw}\", Truncate(raw, 1000));\n                throw;\n            }\n\n            if (token is null || string.IsNullOrWhiteSpace(token.AccessToken))\n            {\n                _log.LogError(\"Facebook token response missing access_token. Raw: {Raw}\", Truncate(raw, 1000));\n                throw new InvalidOperationException(\"Facebook token response missing access_token.\");\n            }\n\n            // attach raw JSON for auditing\n            token = new FbContracts.FacebookTokenResponse\n            {\n                AccessToken = token.AccessToken,\n                TokenType = token.TokenType,\n                ExpiresInSeconds = token.ExpiresInSeconds,\n                RawJson = raw\n            };\n\n            _log.LogInformation(\"Facebook OAuth token exchange succeeded. ExpiresIn(s)={Expires}\", token.ExpiresInSeconds);\n            return token;\n        }\n        public async Task<FbContracts.FacebookTokenResponse> ExchangeForLongLivedAsync(\n      FbContracts.FacebookTokenResponse shortToken,\n      CancellationToken ct = default)\n        {\n            if (shortToken is null || string.IsNullOrWhiteSpace(shortToken.AccessToken))\n                throw new ArgumentException(\"Short-lived token is required.\", nameof(shortToken));\n\n            var baseUri = _opt.GraphBaseUrl.TrimEnd('/');\n            var version = _opt.GraphApiVersion.Trim('/'); // e.g., v20.0\n            var path = $\"{baseUri}/{version}/oauth/access_token\";\n\n            var uri = new UriBuilder(path)\n            {\n                Query =\n                    \"grant_type=fb_exchange_token\" +\n                    $\"&client_id={Uri.EscapeDataString(_opt.AppId)}\" +\n                    $\"&client_secret={Uri.EscapeDataString(_opt.AppSecret)}\" +\n                    $\"&fb_exchange_token={Uri.EscapeDataString(shortToken.AccessToken)}\"\n            }.Uri;\n\n            _log.LogInformation(\"Exchanging short-lived token for long-lived via {Uri}\", uri.GetLeftPart(UriPartial.Path));\n\n            using var req = new HttpRequestMessage(HttpMethod.Get, uri);\n            using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct).ConfigureAwait(false);\n            var raw = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);\n\n            if (!res.IsSuccessStatusCode)\n            {\n                FbContracts.FacebookErrorResponse? fbErr = null;\n                try { fbErr = JsonSerializer.Deserialize<FbContracts.FacebookErrorResponse>(raw, JsonOpts); } catch { }\n\n                var message = fbErr?.Error?.Message ?? $\"Facebook long-lived exchange failed with HTTP {(int)res.StatusCode}\";\n                _log.LogWarning(\"Facebook OAuth long-lived error: {Message}. Raw: {Raw}\", message, Truncate(raw, 1000));\n                throw new InvalidOperationException(\n                    $\"Facebook OAuth error: {message} (type={fbErr?.Error?.Type}, code={fbErr?.Error?.Code}, subcode={fbErr?.Error?.SubCode})\");\n            }\n\n            FbContracts.FacebookTokenResponse? token;\n            try { token = JsonSerializer.Deserialize<FbContracts.FacebookTokenResponse>(raw, JsonOpts); }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to parse long-lived token response. Raw: {Raw}\", Truncate(raw, 1000));\n                throw;\n            }\n\n            if (token is null || string.IsNullOrWhiteSpace(token.AccessToken))\n            {\n                _log.LogError(\"Long-lived token response missing access_token. Raw: {Raw}\", Truncate(raw, 1000));\n                throw new InvalidOperationException(\"Invalid long-lived token response.\");\n            }\n\n            return new FbContracts.FacebookTokenResponse\n            {\n                AccessToken = token.AccessToken,\n                TokenType = token.TokenType,\n                ExpiresInSeconds = token.ExpiresInSeconds, // usually ~5,184,000 (60 days)\n                RawJson = raw\n            };\n        }\n\n\n        private static string Truncate(string input, int max) => input.Length <= max ? input : input[..max];\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookErrorResponse.cs",
      "sha256": "f926a14540f2cfeb9204abd7da5046f80824812f167638f1a935bd3c1fa249bd",
      "language": "csharp",
      "size": 715,
      "content": "#nullable enable\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookErrorResponse\n    {\n        [JsonPropertyName(\"error\")]\n        public FacebookError? Error { get; init; }\n\n        public sealed class FacebookError\n        {\n            [JsonPropertyName(\"message\")] public string? Message { get; init; }\n            [JsonPropertyName(\"type\")] public string? Type { get; init; }\n            [JsonPropertyName(\"code\")] public int? Code { get; init; }\n            [JsonPropertyName(\"error_subcode\")] public int? SubCode { get; init; }\n            [JsonPropertyName(\"fbtrace_id\")] public string? TraceId { get; init; }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookGraphException.cs",
      "sha256": "7f619349143ee1664ce94386c6fba760d79178fc8375d46b6c42b53c1642f95d",
      "language": "csharp",
      "size": 582,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookGraphException : Exception\n    {\n        public string? Type { get; }\n        public int? Code { get; }\n        public int? SubCode { get; }\n        public string? TraceId { get; }\n\n        public FacebookGraphException(string message, string? type, int? code, int? subCode, string? traceId)\n            : base(message)\n        {\n            Type = type;\n            Code = code;\n            SubCode = subCode;\n            TraceId = traceId;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookStoredToken.cs",
      "sha256": "031120808108409a860a5faca499217c7d28d4547972f394e95403f36e6f41d6",
      "language": "csharp",
      "size": 906,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookStoredToken\n    {\n        public string AccessToken { get; init; } = string.Empty;\n        public DateTime? ExpiresAtUtc { get; init; }      // null = unknown\n        public string? RawJson { get; init; }             // audit/debug snapshot\n\n        /// <summary>Consider token invalid if it expires within this window (default 5 minutes).</summary>\n        public bool WillExpireSoon(TimeSpan? skew = null)\n        {\n            if (ExpiresAtUtc is null) return false; // unknown -> assume fine, caller may decide stricter behavior\n            var s = skew ?? TimeSpan.FromMinutes(5);\n            return DateTime.UtcNow.Add(s) >= ExpiresAtUtc.Value;\n        }\n\n        public bool IsExpired()\n            => ExpiresAtUtc is not null && DateTime.UtcNow >= ExpiresAtUtc.Value;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Contracts/FacebookTokenResponse.cs",
      "sha256": "59dd8f7c04fcffa382ee1f0c0b0e9f8cbef52cb1c8b8331d41e7026504e78c02",
      "language": "csharp",
      "size": 634,
      "content": "#nullable enable\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Contracts\n{\n    public sealed class FacebookTokenResponse\n    {\n        [JsonPropertyName(\"access_token\")]\n        public string AccessToken { get; init; } = string.Empty;\n\n        [JsonPropertyName(\"token_type\")]\n        public string TokenType { get; init; } = \"bearer\";\n\n        [JsonPropertyName(\"expires_in\")]\n        public int ExpiresInSeconds { get; init; }\n\n        /// <summary>Raw JSON payload as returned by Facebook for auditing/debugging.</summary>\n        public string RawJson { get; init; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookEsuController.cs",
      "sha256": "9aa5b244ade37733dfe54746bfb4b6c40b9700ddcf24b07402b4d56a1b399fa7",
      "language": "csharp",
      "size": 6781,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.RateLimiting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Features.ESU.Facebook.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook\")]\n    [Authorize] // all endpoints below require authenticated workspace\n    public sealed class FacebookEsuController : ControllerBase\n    {\n        private readonly IFacebookEsuService _service;\n        private readonly IEsuStatusService _status;\n        private readonly ILogger<FacebookEsuController> _log;\n        private readonly string _uiBase;\n\n        public FacebookEsuController(\n            IFacebookEsuService service,\n            IEsuStatusService status,\n            ILogger<FacebookEsuController> log,\n            IConfiguration cfg)\n        {\n            _service = service;\n            _status = status;\n            _log = log;\n            _uiBase = (cfg[\"Ui:PublicBaseUrl\"] ?? \"http://localhost:3000/\").TrimEnd('/');\n        }\n\n        [HttpGet(\"health\")]\n        [AllowAnonymous]\n        public IActionResult Health()\n            => Ok(new { module = \"ESU\", provider = \"FACEBOOK\", status = \"OK\" });\n\n        // -------- START / RESTART ESU --------\n\n        [HttpPost(\"start\")]\n        [DisableRateLimiting] // ESU handshake must not be throttled\n        public async Task<IActionResult> Start(\n            [FromBody] FacebookEsuStartRequestDto? dto,\n            CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                var res = await _service.StartAsync(businessId, dto?.ReturnUrlAfterSuccess, ct);\n\n                _log.LogInformation(\n                    \"ESU start issued for business={BusinessId}, state={State}, expires={Expires}\",\n                    businessId, res.State, res.ExpiresAtUtc);\n\n                return Ok(new\n                {\n                    ok = true,\n                    data = new\n                    {\n                        authUrl = res.LaunchUrl,\n                        state = res.State,\n                        expiresAtUtc = res.ExpiresAtUtc\n                    }\n                });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU start failed.\");\n                return StatusCode(500, new { ok = false, message = \"Failed to start Meta Embedded Signup.\" });\n            }\n        }\n\n        // -------- OAUTH CALLBACK (PUBLIC) --------\n\n        [HttpGet(\"callback\")]\n        [AllowAnonymous]\n        [DisableRateLimiting]\n        public async Task<IActionResult> Callback(\n            [FromQuery] string? code,\n            [FromQuery] string? state,\n            CancellationToken ct)\n        {\n            Response.Headers[\"Cache-Control\"] = \"no-store, no-cache, must-revalidate, max-age=0\";\n            Response.Headers[\"Pragma\"] = \"no-cache\";\n\n            string Target(string q) => $\"{_uiBase}/app/welcomepage{q}\";\n\n            if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(state))\n            {\n                _log.LogWarning(\"ESU callback missing parameters. codeNull={CodeNull} stateNull={StateNull}\",\n                    string.IsNullOrWhiteSpace(code), string.IsNullOrWhiteSpace(state));\n                return Redirect(Target(\"?error=missing_code_or_state\"));\n            }\n\n            try\n            {\n                await _service.HandleCallbackAsync(code!, state!, ct);\n                _log.LogInformation(\"ESU callback success for state={State}\", state);\n                return Redirect(Target(\"?connected=1\"));\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU callback failed for state={State}\", state);\n                return Redirect(Target(\"?error=oauth_exchange_failed\"));\n            }\n        }\n\n        // -------- DISCONNECT (FULL DEAUTHORIZE) --------\n\n        [HttpDelete(\"disconnect\")]\n        public async Task<IActionResult> Disconnect(CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                await _service.DisconnectAsync(businessId, ct);\n                return Ok(new { ok = true });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU disconnect failed.\");\n                return StatusCode(500, new\n                {\n                    ok = false,\n                    message = \"Failed to disconnect WhatsApp for this workspace.\"\n                });\n            }\n        }\n\n        // -------- STATUS --------\n\n        [HttpGet(\"status\")]\n        public async Task<IActionResult> GetStatus(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty)\n                return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n            var dto = await _status.GetStatusAsync(businessId, ct);\n\n            // FE already supports both plain DTO and { ok, data }\n            return Ok(new { ok = true, data = dto });\n        }\n\n        // inside FacebookEsuController\n\n        [HttpDelete(\"hard-delete-full-account\")]\n        public async Task<IActionResult> DeleteAccountAndData(CancellationToken ct)\n        {\n            try\n            {\n                var businessId = User.GetBusinessId();\n                if (businessId == Guid.Empty)\n                    return Unauthorized(new { ok = false, message = \"Business context missing in token.\" });\n\n                await _service.FullDeleteAsync(businessId, ct);\n\n                return Ok(new\n                {\n                    ok = true,\n                    message = \"WhatsApp Business API connection and related onboarding data have been deleted for this workspace.\"\n                });\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"ESU account/data delete failed.\");\n                return StatusCode(500, new\n                {\n                    ok = false,\n                    message = \"Failed to delete WhatsApp onboarding data for this workspace.\"\n                });\n            }\n        }\n\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookEsuDebugController.cs",
      "sha256": "278b72c0ade6b0335b5f61adde7aeaaad008423cf574b477aa161d365adacad2",
      "language": "csharp",
      "size": 5179,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic; // <-- needed for the /me call\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Infrastructure;\nusing xbytechat.api.Shared; // AppDbContext\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook/debug\")]\n   // [Authorize(Roles = \"SuperAdmin\")] // ⚠️ TEMPORARY for verification; lock down/remove after testing\n    public sealed class FacebookEsuDebugController : ControllerBase\n    {\n        private readonly IFacebookTokenService _tokenService;\n        private readonly AppDbContext _db;\n        private readonly ILogger<FacebookEsuDebugController> _log;\n        private readonly IFacebookGraphClient _graph;\n        private readonly IEsuStatusService _status;\n        public FacebookEsuDebugController(\n            IFacebookTokenService tokenService,\n            AppDbContext db,\n            ILogger<FacebookEsuDebugController> log,\n            IFacebookGraphClient graph,\n            IEsuStatusService status)\n        {\n            _tokenService = tokenService;\n            _db = db;\n            _log = log;\n            _graph = graph;\n            _status = status;\n        }\n\n        // GET /api/esu/facebook/debug/token?businessId=...\n        [HttpGet(\"token\")]\n        public async Task<IActionResult> GetToken([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var t = await _tokenService.TryGetValidAsync(businessId, ct);\n            if (t is null)\n            {\n                return Ok(new\n                {\n                    ok = false,\n                    message = \"No valid token found (missing or expired). Re-run ESU.\"\n                });\n            }\n\n            return Ok(new\n            {\n                ok = true,\n                tokenPreview = Mask(t.AccessToken),\n                expiresAtUtc = t.ExpiresAtUtc,\n                willExpireSoon = t.WillExpireSoon(),  // default 5m skew\n                rawJsonLength = t.RawJson?.Length ?? 0\n            });\n        }\n\n        [HttpGet(\"status\")]\n        [Authorize]\n        public async Task<ActionResult<EsuStatusDto>> GetStatus(CancellationToken ct)\n        {\n            // Uses the \"businessId\" claim from JWT (lowercase)\n            var businessId = User.GetBusinessId();\n\n            var dto = await _status.GetStatusAsync(businessId, ct);\n\n            // Keep it simple; frontend already normalizes shape\n            return Ok(dto);\n        }\n\n\n        [HttpPost(\"deauthorize\")]\n        public async Task<IActionResult> Deauthorize([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n            await _status.DeauthorizeAsync(businessId, ct);\n            return Ok(new { ok = true });\n        }\n\n\n        // GET /api/esu/facebook/debug/flags?businessId=...\n        [HttpGet(\"flags\")]\n        public async Task<IActionResult> ListFlags([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            // Your IntegrationFlags model is the single-row, column-style model\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row is null)\n            {\n                return Ok(new { ok = true, count = 0, items = Array.Empty<object>() });\n            }\n\n            // Box each element as object so the array can be typed object[]\n            var items = new object[]\n            {\n                new { key = \"FACEBOOK_ESU_COMPLETED\",value = row.FacebookEsuCompleted ? \"true\" : \"false\" }\n    \n            };\n\n            return Ok(new { ok = true, count = items.Length, items });\n        }\n\n        private static string Mask(string? s)\n        {\n            if (string.IsNullOrEmpty(s)) return \"\";\n            if (s.Length <= 10) return new string('*', s.Length);\n            return $\"{s.Substring(0, 6)}…{s.Substring(s.Length - 4)}\";\n        }\n\n        private static string? Preview(string? s, int max)\n        {\n            if (string.IsNullOrEmpty(s)) return null;\n            return s.Length <= max ? s : s.Substring(0, max) + \"…\";\n        }\n\n        // GET /api/esu/facebook/debug/me?businessId=...\n        [HttpGet(\"me\")]\n        public async Task<IActionResult> GetMe([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            if (businessId == Guid.Empty) return BadRequest(\"businessId is required.\");\n\n            var me = await _graph.GetAsync<dynamic>(businessId, \"me\", new Dictionary<string, string?>\n            {\n                [\"fields\"] = \"id,name\"\n            }, ct);\n\n            return Ok(me);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/FacebookWebhookController.cs",
      "sha256": "37c83b8128f59e8e6aeb523db8f7e1d1070e5e13c91fff4e0554f64150b95b16",
      "language": "csharp",
      "size": 1636,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Options;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"api/esu/facebook/webhook\")]\n    public sealed class FacebookWebhookController : ControllerBase\n    {\n        private readonly string _verifyToken;\n\n        public FacebookWebhookController(IOptions<FacebookOptions> opts)\n        {\n            _verifyToken = opts.Value.VerifyToken ?? string.Empty;\n        }\n\n        // GET verify: echo hub.challenge if token matches\n        [HttpGet]\n        public IActionResult Verify([FromQuery(Name = \"hub.mode\")] string? mode,\n                                    [FromQuery(Name = \"hub.verify_token\")] string? token,\n                                    [FromQuery(Name = \"hub.challenge\")] string? challenge)\n        {\n            if (string.Equals(mode, \"subscribe\", StringComparison.OrdinalIgnoreCase) &&\n                !string.IsNullOrWhiteSpace(token) &&\n                token == _verifyToken &&\n                !string.IsNullOrWhiteSpace(challenge))\n            {\n                return Content(challenge!, \"text/plain\");\n            }\n            return Forbid();\n        }\n\n        // POST stub: logs or routes ESU-related events (optional for App Review)\n        [HttpPost]\n        public async Task<IActionResult> Receive()\n        {\n            using var reader = new StreamReader(Request.Body);\n            var body = await reader.ReadToEndAsync();\n            // TODO: route event to your logger/queue if needed\n            return Ok(new { ok = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Controllers/MetaComplianceController.cs",
      "sha256": "179bb937008d85aeeb49895c0daad03b0e73b79b136c13d93cd3a1e9c5487183",
      "language": "csharp",
      "size": 4673,
      "content": "#nullable enable\nusing System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Facebook.Services;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Controllers\n{\n    [ApiController]\n    [Route(\"meta\")]\n    public sealed class MetaComplianceController : ControllerBase\n    {\n        private readonly IFacebookEsuService _esuService;\n        private readonly IOptions<FacebookOauthOptions> _fbOpts;\n        private readonly ILogger<MetaComplianceController> _log;\n\n        public MetaComplianceController(\n            IFacebookEsuService esuService,\n            IOptions<FacebookOauthOptions> fbOpts,\n            ILogger<MetaComplianceController> log)\n        {\n            _esuService = esuService;\n            _fbOpts = fbOpts;\n            _log = log;\n        }\n\n        // Configure this URL in Meta's \"Data Deletion\" settings.\n        // Meta sends `signed_request` (base64url.header.payload, HMAC-SHA256 with AppSecret).\n        [HttpPost(\"data-deletion\")]\n        public async Task<IActionResult> HandleDataDeletion([FromForm] string signed_request, CancellationToken ct)\n        {\n            if (string.IsNullOrWhiteSpace(signed_request))\n                return BadRequest(new { status = \"error\", message = \"missing signed_request\" });\n\n            var (ok, payloadJson) = TryValidateSignedRequest(signed_request);\n            if (!ok)\n                return BadRequest(new { status = \"error\", message = \"invalid signed_request\" });\n\n            // Payload typically contains user_id or similar identifiers.\n            // You must map that to your BusinessId based on how you tied ESU sessions to businesses.\n            // For now we assume you store mapping elsewhere and resolve it here.\n            var businessId = ResolveBusinessIdFromPayload(payloadJson);\n            if (businessId == Guid.Empty)\n            {\n                _log.LogInformation(\"Meta data-deletion: no matching business for payload={Payload}\", payloadJson);\n                return Ok(new { status = \"ignored\" });\n            }\n\n            _log.LogInformation(\"Meta data-deletion: biz={BusinessId}\", businessId);\n\n            // Canonical cleanup: same as manual disconnect\n            await _esuService.DisconnectAsync(businessId, ct);\n\n            // Optional: enqueue deeper anonymization/purge if your policy requires.\n            return Ok(new\n            {\n                status = \"success\",\n                reference_id = businessId\n            });\n        }\n\n        private (bool ok, string payloadJson) TryValidateSignedRequest(string signedRequest)\n        {\n            var parts = signedRequest.Split('.', 2);\n            if (parts.Length != 2) return (false, \"\");\n\n            var providedSig = Base64UrlDecode(parts[0]);\n            var payloadBytes = Base64UrlDecode(parts[1]);\n\n            var appSecret = _fbOpts.Value.AppSecret;\n            if (string.IsNullOrWhiteSpace(appSecret))\n                return (false, \"\");\n\n            using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(appSecret));\n            var expectedSig = hmac.ComputeHash(Encoding.UTF8.GetBytes(parts[1]));\n\n            // Constant-time compare\n            if (!CryptographicOperations.FixedTimeEquals(providedSig, expectedSig))\n                return (false, \"\");\n\n            var payloadJson = Encoding.UTF8.GetString(payloadBytes);\n            return (true, payloadJson);\n        }\n\n        private static byte[] Base64UrlDecode(string input)\n        {\n            input = input.Replace('-', '+').Replace('_', '/');\n            switch (input.Length % 4)\n            {\n                case 2: input += \"==\"; break;\n                case 3: input += \"=\"; break;\n            }\n            return Convert.FromBase64String(input);\n        }\n\n        // TODO: implement this mapping based on your stored ESU context.\n        private Guid ResolveBusinessIdFromPayload(string payloadJson)\n        {\n            using var doc = JsonDocument.Parse(payloadJson);\n            var root = doc.RootElement;\n\n            // Example: if you store mapping from Meta user_id/page_id/WABA to BusinessId.\n            // This is intentionally left for your existing infra.\n            // Return Guid.Empty when no mapping found.\n\n            // var userId = root.GetProperty(\"user_id\").GetString();\n            // lookup Biz by userId...\n\n            return Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/DTOs/EsuStatusDto.cs",
      "sha256": "be3d1a688e116493a86a42f37a85e56b8272814585a32e7a16dbebad767a5295",
      "language": "csharp",
      "size": 621,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.DTOs\n{\n    public sealed class EsuStatusDto\n    {\n        public bool Connected { get; init; }             // true = ESU-complete + valid token\n        public bool HasEsuFlag { get; init; }            // IntegrationFlags row + FacebookEsuCompleted\n        public bool HasValidToken { get; init; }         // from TryGetValidAsync\n        public DateTime? TokenExpiresAtUtc { get; init; }\n        public bool WillExpireSoon { get; init; }\n        public DateTime UpdatedAtUtc { get; init; }\n        public string? Debug { get; init; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/DTOs/FacebookEsuDtos.cs",
      "sha256": "de4844f0acab828a681671d348d4dd9d6be053b2b699fb06b83ac96b9b2c6462",
      "language": "csharp",
      "size": 872,
      "content": "using System;\n\nnamespace xbytechat.api.Features.ESU.Facebook.DTOs\n{\n    // Request from FE to start ESU. BusinessId now comes from header X-Business-Id.\n    public sealed class FacebookEsuStartRequestDto\n    {\n        public string? ReturnUrlAfterSuccess { get; set; }   // optional FE page to navigate to after success\n    }\n\n    // Service-layer response; controller will wrap this into the envelope.\n    public sealed class FacebookEsuStartResponseDto\n    {\n        public string LaunchUrl { get; set; } = string.Empty;\n        public string State { get; set; } = string.Empty;    // returned for debugging/telemetry if needed\n        public DateTime ExpiresAtUtc { get; set; }           // when the state will expire on server\n    }\n\n    public sealed class FacebookEsuCallbackResponseDto\n    {\n        public string RedirectTo { get; set; } = \"/esu/success\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Models/EsuToken.cs",
      "sha256": "0cf53a8e94d8023a166f4b195f7d061d6cb4427fc9bba788de58c8aba2ae5aef",
      "language": "csharp",
      "size": 849,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Models\n{\n    [Table(\"EsuTokens\")]\n    public sealed class EsuToken\n    {\n        [Key] public Guid Id { get; set; } = Guid.NewGuid();\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(50)]\n        public string Provider { get; set; } = \"META_CLOUD\"; // UPPERCASE canonical\n\n        [Required, MaxLength(4096)]\n        public string AccessToken { get; set; } = null!;\n\n        public DateTime? ExpiresAtUtc { get; set; }\n        [MaxLength(512)] public string? Scope { get; set; }\n        public bool IsRevoked { get; set; }\n\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Models/IntegrationFlags.cs",
      "sha256": "cf6cb21691fbbdd8355439ead561d4c93ab07f8caa3f8d434a2f80b86ba71fe2",
      "language": "csharp",
      "size": 1068,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Models\n{\n    /// <summary>\n    /// One row per Business capturing lightweight “connected” flags\n    /// and optional token metadata for ESU-style integrations.\n    /// </summary>\n    [Table(\"IntegrationFlags\")]\n    public sealed class IntegrationFlags\n    {   \n        [Key]\n        public Guid BusinessId { get; set; }\n\n        // --- Facebook ESU ---\n        public bool FacebookEsuCompleted { get; set; }\n\n        // Optional: store a short-lived user token value/expiry if you plan follow-up Graph calls.\n        // Keep nullable; app can run just with the completion flag.\n        //[MaxLength(2048)]\n        //public string? FacebookAccessToken { get; set; }\n\n        //public DateTime? FacebookTokenExpiresAtUtc { get; set; }\n\n        // housekeeping\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Options/FacebookOauthOptions.cs",
      "sha256": "add7b7d980d29b73a36f0a74b24314435d9a01fc1c840cdec28c57b3afc5ff11",
      "language": "csharp",
      "size": 461,
      "content": "#nullable enable\n\nnamespace xbytechat.api.Features.ESU.Facebook.Options\n{\n    public sealed class FacebookOauthOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string AppSecret { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n        public string GraphBaseUrl { get; set; } = \"https://graph.facebook.com\";\n        public string GraphApiVersion { get; set; } = \"v22.0\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Options/FacebookOptions.cs",
      "sha256": "b89d5e57d74ac7192083b906ada684a584f86663a53303bfa970df7221033891",
      "language": "csharp",
      "size": 599,
      "content": "namespace xbytechat.api.Features.ESU.Facebook.Options\n{\n    public sealed class FacebookOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string AppSecret { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n\n        // add these if not present\n        public string? Scopes { get; set; }\n        public string? GraphBaseUrl { get; set; }\n        public string? GraphApiVersion { get; set; }\n        public int StateTtlMinutes { get; set; } = 20;\n\n        // NEW:\n        public string? VerifyToken { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/EsuStatusService.cs",
      "sha256": "391819ddd8908f1ae59a4a2c952b8f1c0c51f2c4548f72626008167e7293b13f",
      "language": "csharp",
      "size": 5918,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Infrastructure;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    public sealed class EsuStatusService : IEsuStatusService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly AppDbContext _db;\n        private readonly IFacebookTokenService _tokenService;\n        private readonly IEsuTokenStore _tokens;\n        private readonly ILogger<EsuStatusService> _log;\n\n        public EsuStatusService(\n            AppDbContext db,\n            IFacebookTokenService tokenService,\n            IEsuTokenStore tokens,\n            ILogger<EsuStatusService> log)\n        {\n            _db = db;\n            _tokenService = tokenService;\n            _tokens = tokens;\n            _log = log;\n        }\n\n        //public async Task<EsuStatusDto> GetStatusAsync(Guid businessId, CancellationToken ct = default)\n        //{\n        //    if (businessId == Guid.Empty)\n        //        throw new ArgumentException(\"businessId is required.\", nameof(businessId));\n\n        //    var row = await _db.IntegrationFlags\n        //        .AsNoTracking()\n        //        .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n        //    if (row is null)\n        //    {\n        //        return new EsuStatusDto\n        //        {\n        //            Connected = false,\n        //            TokenExpiresAtUtc = null,\n        //            WillExpireSoon = false,\n        //            UpdatedAtUtc = DateTime.UtcNow,\n        //            Debug = \"no-row\"\n        //        };\n        //    }\n\n        //    DateTime? expiresAt = null;\n\n        //    bool willExpireSoon = false;\n        //    try\n        //    {\n        //        var tok = await _tokenService.TryGetValidAsync(businessId, ct);\n        //        if (tok is not null)\n        //        {\n        //            expiresAt = tok.ExpiresAtUtc;\n        //            willExpireSoon = tok.WillExpireSoon();\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogDebug(ex, \"Status check token probe failed for {Biz}\", businessId);\n        //    }\n\n        //    return new EsuStatusDto\n        //    {\n        //        Connected = row.FacebookEsuCompleted && expiresAt.HasValue && !willExpireSoon,\n        //        HasEsuFlag = row.FacebookEsuCompleted,\n        //        HasValidToken = expiresAt.HasValue && !willExpireSoon,\n        //        TokenExpiresAtUtc = expiresAt,\n        //        WillExpireSoon = willExpireSoon,\n        //        UpdatedAtUtc = row.UpdatedAtUtc,\n        //        Debug = null\n        //    };\n        //}\n\n        public async Task<EsuStatusDto> GetStatusAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required.\", nameof(businessId));\n\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row is null)\n            {\n                return new EsuStatusDto\n                {\n                    Connected = false,\n                    HasEsuFlag = false,\n                    HasValidToken = false,\n                    TokenExpiresAtUtc = null,\n                    WillExpireSoon = false,\n                    UpdatedAtUtc = DateTime.UtcNow,\n                    Debug = \"no-row\"\n                };\n            }\n\n            DateTime? expiresAt = null;\n            bool hasValidToken = false;\n            bool willExpireSoon = false;\n\n            try\n            {\n                // TryGetValidAsync already enforces \"not expired\" and \"not expiring soon\" for sending.\n                var tok = await _tokenService.TryGetValidAsync(businessId, ct);\n                if (tok is not null)\n                {\n                    expiresAt = tok.ExpiresAtUtc;\n                    // In current implementation this will always be false,\n                    // but we keep it for future-proofing.\n                    willExpireSoon = tok.WillExpireSoon();\n                    hasValidToken = true;\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"Status check token probe failed for {Biz}\", businessId);\n            }\n\n            return new EsuStatusDto\n            {\n                Connected = row.FacebookEsuCompleted && hasValidToken,\n                HasEsuFlag = row.FacebookEsuCompleted,\n                HasValidToken = hasValidToken,\n                TokenExpiresAtUtc = expiresAt,      // may be null (Meta didn’t send expiry)\n                WillExpireSoon = willExpireSoon,  // currently always false, but kept for contract\n                UpdatedAtUtc = row.UpdatedAtUtc,\n                Debug = null\n            };\n        }\n\n        public async Task DeauthorizeAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required.\", nameof(businessId));\n\n            // 1) Clear UX flag\n            var row = await _db.IntegrationFlags.SingleOrDefaultAsync(x => x.BusinessId == businessId, ct);\n            if (row is not null)\n            {\n                row.FacebookEsuCompleted = false;\n                row.UpdatedAtUtc = DateTime.UtcNow;\n                await _db.SaveChangesAsync(ct);\n            }\n\n            // 2) Revoke token (EsuTokens) + 3) drop from cache\n            await _tokens.RevokeAsync(businessId, Provider, ct);\n           \n            await _tokenService.InvalidateAsync(businessId, ct);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/EsuTokenStore.cs",
      "sha256": "a241632aaf4b68f5cf874f010a82bb73d3fe65d14c695d8fba2c29b06bb0cac5",
      "language": "csharp",
      "size": 2256,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.ESU.Facebook.Models;\nusing xbytechat.api.Infrastructure;\n\npublic sealed class EsuTokenStore : IEsuTokenStore\n{\n    private readonly AppDbContext _db;\n    public EsuTokenStore(AppDbContext db) => _db = db;\n\n    public Task<EsuToken?> GetAsync(Guid biz, string provider, CancellationToken ct)\n        => _db.Set<EsuToken>().AsNoTracking()\n              .FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n\n    public async Task UpsertAsync(Guid biz, string provider, string token, DateTime? exp, CancellationToken ct)\n    {\n        provider = provider.ToUpperInvariant();\n\n        var row = await _db.Set<EsuToken>()\n            .FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n\n        if (row is null)\n        {\n            _db.Add(new EsuToken\n            {\n                BusinessId = biz,\n                Provider = provider,\n                AccessToken = token,\n                ExpiresAtUtc = exp,\n                IsRevoked = string.IsNullOrWhiteSpace(token) // treat empty as revoked\n            });\n        }\n        else\n        {\n            row.AccessToken = token;\n            row.ExpiresAtUtc = exp;\n            row.IsRevoked = string.IsNullOrWhiteSpace(token) ? true : false;\n            row.UpdatedAtUtc = DateTime.UtcNow;\n        }\n\n        await _db.SaveChangesAsync(ct);\n    }\n\n\n    public async Task RevokeAsync(Guid biz, string provider, CancellationToken ct)\n    {\n        var row = await _db.Set<EsuToken>().FirstOrDefaultAsync(x => x.BusinessId == biz && x.Provider == provider, ct);\n        if (row is null) return;\n        row.IsRevoked = true; row.UpdatedAtUtc = DateTime.UtcNow;\n        await _db.SaveChangesAsync(ct);\n    }\n\n    // FILE: Features/ESU/Facebook/Services/EsuTokenStore.cs\n\n    public async Task DeleteAsync(Guid biz, string provider, CancellationToken ct = default)\n    {\n        var set = _db.Set<EsuToken>();\n\n        var rows = await set\n            .Where(x => x.BusinessId == biz && x.Provider == provider)\n            .ToListAsync(ct);\n\n        if (rows.Count == 0)\n            return;\n\n        set.RemoveRange(rows);\n        await _db.SaveChangesAsync(ct);\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/FacebookEsuService.cs",
      "sha256": "efafc10f229c22974539ddfc0a11bf96cbac1fa0cc66774a3a83d6e9500a7d66",
      "language": "csharp",
      "size": 31623,
      "content": "using System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Security.Cryptography;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\nusing xbytechat.api.Features.ESU.Facebook.Options;\nusing xbytechat.api.Features.ESU.Shared;\nusing xbytechat.api.Features.WhatsAppSettings.Services;\nusing xbytechat_api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    internal sealed class FacebookEsuService : IFacebookEsuService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly IOptions<EsuOptions> _options;\n        private readonly IOptions<FacebookOauthOptions> _oauthOpts;\n        private readonly IEsuStateStore _stateStore;\n        private readonly IEsuFlagStore _flagStore;\n        private readonly IFacebookOauthClient _oauth;\n        private readonly IEsuTokenStore _tokens;\n        private readonly IFacebookTokenService _fbTokens;\n        private readonly IWhatsAppSettingsService _waSettings;\n        private readonly IWhatsAppPhoneNumberService _waPhones;\n        private readonly ILogger<FacebookEsuService> _log;\n        private readonly IEsuStatusService _esuStatus;\n        public FacebookEsuService(\n            IOptions<EsuOptions> options,\n            IEsuStateStore stateStore,\n            IEsuFlagStore flagStore,\n            IFacebookOauthClient oauth,\n            IEsuTokenStore tokens,\n            IFacebookTokenService fbTokens,\n            IWhatsAppSettingsService waSettings,\n            IWhatsAppPhoneNumberService waPhones,\n            IOptions<FacebookOauthOptions> oauthOpts,\n            ILogger<FacebookEsuService> log,\n            IEsuStatusService esuStatus)\n        {\n            _options = options;\n            _stateStore = stateStore;\n            _flagStore = flagStore;\n            _oauth = oauth;\n            _tokens = tokens;\n            _fbTokens = fbTokens;\n            _waSettings = waSettings;\n            _waPhones = waPhones;\n            _oauthOpts = oauthOpts;\n            _log = log;\n            _esuStatus = esuStatus;\n        }\n\n        // =======================\n        // ESU START\n        // =======================\n        public async Task<FacebookEsuStartResponseDto> StartAsync(\n            Guid businessId,\n            string? returnUrl,\n            CancellationToken ct = default)\n        {\n            var cfg = _options.Value.Facebook;\n\n            if (string.IsNullOrWhiteSpace(cfg.AppId))\n                throw new InvalidOperationException(\"ESU.Facebook.AppId is not configured.\");\n            if (string.IsNullOrWhiteSpace(cfg.RedirectUri))\n                throw new InvalidOperationException(\"ESU.Facebook.RedirectUri is not configured.\");\n            if (string.IsNullOrWhiteSpace(cfg.ConfigId))\n                throw new InvalidOperationException(\"ESU.Facebook.ConfigId is not configured.\");\n\n            var state = CreateStateToken(businessId, returnUrl);\n            var ttl = TimeSpan.FromMinutes(Math.Max(1, cfg.StateTtlMinutes));\n\n            await _stateStore.StoreAsync(state, businessId, ttl);\n\n            var dialogVersion = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n            var dialogBase = $\"https://www.facebook.com/{dialogVersion}/dialog/oauth\";\n\n            var query = new System.Collections.Generic.Dictionary<string, string?>\n            {\n                [\"client_id\"] = cfg.AppId,\n                [\"redirect_uri\"] = cfg.RedirectUri,\n                [\"state\"] = state,\n                [\"response_type\"] = \"code\",\n                [\"config_id\"] = cfg.ConfigId\n            };\n\n            var launchUrl = QueryHelpers.AddQueryString(dialogBase, query);\n\n            _log.LogInformation(\n                 \"ESU Start: biz={BusinessId}, statePrefix={StatePrefix}, url={Url}\",\n                 businessId,\n                 state.Length > 16 ? state[..16] : state,\n                 launchUrl);\n\n\n            return new FacebookEsuStartResponseDto\n            {\n                LaunchUrl = launchUrl,\n                State = state,\n                ExpiresAtUtc = DateTime.UtcNow.Add(ttl)\n            };\n        }\n\n        // =======================\n        // ESU CALLBACK\n        // =======================\n        public async Task<FacebookEsuCallbackResponseDto> HandleCallbackAsync(\n            string code,\n            string state,\n            CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(code))\n                throw new InvalidOperationException(\"OAuth failed: missing 'code'.\");\n            if (string.IsNullOrWhiteSpace(state))\n                throw new InvalidOperationException(\"OAuth failed: missing 'state'.\");\n\n            var (found, businessId) = await _stateStore.TryConsumeAsync(state);\n            if (!found || businessId == Guid.Empty)\n                throw new InvalidOperationException(\"Invalid or expired state.\");\n\n            _log.LogInformation(\n                \"ESU Callback: biz={BusinessId}, statePrefix={StatePrefix}\",\n                businessId,\n                state.Length > 16 ? state[..16] : state);\n\n            // 1) Exchange short-lived → long-lived token\n            var token = await _oauth.ExchangeCodeAsync(code, ct);\n            if (string.IsNullOrWhiteSpace(token?.AccessToken))\n                throw new InvalidOperationException(\"OAuth exchange did not return an access token.\");\n\n            token = await _oauth.ExchangeForLongLivedAsync(token, ct);\n\n            var accessToken = token.AccessToken;\n            DateTime? expiresAtUtc = (token.ExpiresInSeconds > 0)\n                ? DateTime.UtcNow.AddSeconds(token.ExpiresInSeconds)\n                : (DateTime?)null;\n\n            _log.LogInformation(\n                \"ESU Callback: received long-lived token for biz={BusinessId}, expiresAt={ExpiresAt}\",\n                businessId,\n                expiresAtUtc?.ToString(\"O\") ?? \"<none>\");\n\n            await _tokens.UpsertAsync(\n                businessId,\n                Provider,\n                accessToken,\n                expiresAtUtc,\n                ct);\n\n            _log.LogDebug(\n                \"ESU Callback: token upserted for biz={BusinessId}, provider={Provider}\",\n                businessId,\n                Provider);\n\n            await _fbTokens.InvalidateAsync(businessId, ct);\n\n            var graphBase = _oauthOpts.Value.GraphBaseUrl?.TrimEnd('/') ?? \"https://graph.facebook.com\";\n            var graphVer = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n            var apiBase = $\"{graphBase}/{graphVer}\";\n\n            // 2) WABA DISCOVERY\n            string? wabaId = null;\n\n            try\n            {\n                var oauthCfg = _oauthOpts.Value;\n\n                if (!string.IsNullOrWhiteSpace(oauthCfg.AppId) &&\n                    !string.IsNullOrWhiteSpace(oauthCfg.AppSecret))\n                {\n                    var viaDebug = await TryGetWabaFromDebugTokenAsync(\n                        graphBase,\n                        accessToken,\n                        oauthCfg.AppId,\n                        oauthCfg.AppSecret,\n                        ct);\n\n                    if (!string.IsNullOrWhiteSpace(viaDebug))\n                    {\n                        wabaId = viaDebug;\n                        _log.LogInformation(\n                            \"ESU Callback: WABA discovered via debug_token: {WabaId} (biz={BusinessId})\",\n                            wabaId,\n                            businessId);\n                    }\n                    else\n                    {\n                        _log.LogWarning(\n                            \"ESU Callback: debug_token did not yield WABA for biz={BusinessId}\",\n                            businessId);\n                    }\n                }\n                else\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: AppId/AppSecret missing in FacebookOauthOptions, skipping debug_token WABA discovery (biz={BusinessId})\",\n                        businessId);\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    wabaId = await TryGetWabaFromMeAccountsAsync(apiBase, accessToken, ct);\n                    if (!string.IsNullOrWhiteSpace(wabaId))\n                    {\n                        _log.LogInformation(\n                            \"ESU Callback: WABA discovered via /me/whatsapp_business_accounts: {WabaId} (biz={BusinessId})\",\n                            wabaId,\n                            businessId);\n                    }\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    wabaId = await TryGetWabaFromBusinessesAsync(apiBase, accessToken, ct);\n                    if (!string.IsNullOrWhiteSpace(wabaId))\n                    {\n                        _log.LogInformation(\n                            \"ESU Callback: WABA discovered via /me/businesses: {WabaId} (biz={BusinessId})\",\n                            wabaId,\n                            businessId);\n                    }\n                }\n\n                if (string.IsNullOrWhiteSpace(wabaId))\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: No WABA discovered for biz={BusinessId}. Token scopes or ESU config may be incomplete.\",\n                        businessId);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"ESU Callback: Error during WABA discovery for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 3) SAVE GLOBAL SETTINGS\n            try\n            {\n                var dto = new SaveWhatsAppSettingDto\n                {\n                    BusinessId = businessId,\n                    Provider = Provider,\n                    ApiUrl = apiBase,\n                    ApiKey = accessToken,\n                    WabaId = string.IsNullOrWhiteSpace(wabaId) ? null : wabaId,\n                    SenderDisplayName = null,\n                    WebhookSecret = null,\n                    WebhookVerifyToken = null,\n                    WebhookCallbackUrl = null,\n                    IsActive = true\n                };\n\n                _log.LogDebug(\n                    \"ESU Callback: Saving WhatsApp settings for biz={BusinessId}: Provider={Provider}, ApiUrl={ApiUrl}, HasToken={HasToken}, WabaId={WabaId}\",\n                    businessId,\n                    dto.Provider,\n                    dto.ApiUrl,\n                    !string.IsNullOrWhiteSpace(dto.ApiKey),\n                    dto.WabaId ?? \"<none>\");\n\n                await _waSettings.SaveOrUpdateSettingAsync(dto);\n\n                _log.LogInformation(\n                    \"ESU Callback: Global WhatsApp settings saved for biz={BusinessId}, provider={Provider}, hasWaba={HasWaba}\",\n                    businessId,\n                    Provider,\n                    !string.IsNullOrWhiteSpace(wabaId));\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"ESU Callback: Failed to save WhatsApp settings for biz={BusinessId}\",\n                    businessId);\n                // do NOT throw; ESU UI finished. FE will see missing config if save failed.\n            }\n\n            // 4) SYNC PHONE NUMBERS (best-effort, but logged)\n            try\n            {\n                var setting = await _waSettings.GetSettingsByBusinessIdAsync(businessId);\n                if (setting?.Provider?.Equals(Provider, StringComparison.OrdinalIgnoreCase) == true &&\n                    !string.IsNullOrWhiteSpace(setting.WabaId) &&\n                    !string.IsNullOrWhiteSpace(setting.ApiKey))\n                {\n                    _log.LogDebug(\n                        \"ESU Callback: Starting phone sync for biz={BusinessId} using WabaId={WabaId}\",\n                        businessId,\n                        setting.WabaId);\n\n                    var (added, updated, total) =\n                        await _waPhones.SyncFromProviderAsync(businessId, setting, Provider, ct);\n\n                    _log.LogInformation(\n                        \"ESU Callback: Phone sync complete for biz={BusinessId}. Added={Added}, Updated={Updated}, Total={Total}\",\n                        businessId, added, updated, total);\n                }\n                else\n                {\n                    _log.LogWarning(\n                        \"ESU Callback: Skipping phone sync for biz={BusinessId} (provider={Provider}, WabaId={WabaId}, HasApiKey={HasKey})\",\n                        businessId,\n                        setting?.Provider,\n                        setting?.WabaId ?? \"<none>\",\n                        !string.IsNullOrWhiteSpace(setting?.ApiKey));\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"ESU Callback: Error during phone sync for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 5) FLAG AS COMPLETED\n            try\n            {\n                var payloadJson = JsonSerializer.Serialize(new\n                {\n                    completed = true,\n                    provider = Provider,\n                    expires_at_utc = expiresAtUtc\n                });\n\n                await _flagStore.UpsertAsync(\n                    businessId,\n                    key: \"facebook.esu\",\n                    value: \"completed\",\n                    jsonPayload: payloadJson,\n                    ct: ct);\n\n                _log.LogInformation(\n                    \"ESU Callback: ESU completion flag set for biz={BusinessId}\",\n                    businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"ESU Callback: Failed to write ESU completion flag for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 6) FINAL REDIRECT\n            var returnUrl = TryGetReturnUrlFromState(state);\n            var redirectBase = string.IsNullOrWhiteSpace(returnUrl)\n                ? \"/welcomepage\"\n                : returnUrl!;\n            var redirect = redirectBase.Contains(\"?\")\n                ? $\"{redirectBase}&connected=1\"\n                : $\"{redirectBase}?connected=1\";\n\n            _log.LogInformation(\n                \"ESU Callback: Redirecting biz={BusinessId} to {Redirect}\",\n                businessId,\n                redirect);\n\n            return new FacebookEsuCallbackResponseDto { RedirectTo = redirect };\n        }\n\n        // =======================\n        // DISCONNECT (unchanged semantics)\n        // =======================\n\n        public async Task DisconnectAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            _log.LogInformation(\"ESU Disconnect: biz={BusinessId}\", businessId);\n\n            // 0) Check current ESU status so we don't resurrect flags after a hard delete\n            bool hadEsuOrToken = false;\n\n            try\n            {\n                var status = await _esuStatus.GetStatusAsync(businessId, ct);\n\n                if (status is not null)\n                {\n                    hadEsuOrToken =\n                        status.Connected ||\n                        status.HasEsuFlag ||\n                        status.HasValidToken;\n                }\n            }\n            catch (Exception ex)\n            {\n                // If status lookup fails, be conservative and allow disconnect pipeline to run.\n                _log.LogWarning(ex,\n                    \"ESU Disconnect: failed to read status for biz={BusinessId}; continuing with disconnect.\",\n                    businessId);\n            }\n\n            // If there is no ESU flag, no valid token, no connection, treat as already clean.\n            // This is the case after a successful hard delete: do NOT recreate IntegrationFlags / EsuTokens.\n            if (!hadEsuOrToken)\n            {\n                _log.LogInformation(\n                    \"ESU Disconnect: nothing to disconnect for biz={BusinessId} (no ESU flags/tokens/settings).\",\n                    businessId);\n                return;\n            }\n\n            // 1) Remote revoke (best-effort)\n            try\n            {\n                var t = await _tokens.GetAsync(businessId, Provider, ct);\n                if (t is not null && !string.IsNullOrWhiteSpace(t.AccessToken) && !t.IsRevoked)\n                {\n                    var graphBase = _oauthOpts.Value.GraphBaseUrl?.TrimEnd('/') ?? \"https://graph.facebook.com\";\n                    var graphVer = _oauthOpts.Value.GraphApiVersion?.Trim('/') ?? \"v20.0\";\n                    var apiBase = $\"{graphBase}/{graphVer}\";\n\n                    using var http = new HttpClient();\n                    http.DefaultRequestHeaders.Authorization =\n                        new AuthenticationHeaderValue(\"Bearer\", t.AccessToken);\n\n                    var resp = await http.DeleteAsync($\"{apiBase}/me/permissions\", ct);\n                    if (!resp.IsSuccessStatusCode)\n                    {\n                        _log.LogWarning(\n                            \"ESU Disconnect: remote revoke returned {Status} for biz={BusinessId}\",\n                            resp.StatusCode,\n                            businessId);\n                    }\n                    else\n                    {\n                        _log.LogInformation(\n                            \"ESU Disconnect: remote revoke succeeded for biz={BusinessId}\",\n                            businessId);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU Disconnect: error during remote revoke for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 2) Canonical local deauthorize (flags + EsuTokens + cache) via status service\n            try\n            {\n                await _esuStatus.DeauthorizeAsync(businessId, ct);\n\n                _log.LogInformation(\n                    \"ESU Disconnect: local deauthorize completed for biz={BusinessId}\",\n                    businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"ESU Disconnect: error during local deauthorize for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 3) Deactivate WhatsApp settings for META_CLOUD\n            try\n            {\n                await _waSettings.SaveOrUpdateSettingAsync(new SaveWhatsAppSettingDto\n                {\n                    BusinessId = businessId,\n                    Provider = Provider,\n                    ApiUrl = null,\n                    ApiKey = null,\n                    WabaId = null,\n                    SenderDisplayName = null,\n                    WebhookSecret = null,\n                    WebhookVerifyToken = null,\n                    WebhookCallbackUrl = null,\n                    IsActive = false\n                });\n\n                _log.LogInformation(\n                    \"ESU Disconnect: WhatsApp settings deactivated for biz={BusinessId}\",\n                    businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"ESU Disconnect: error deactivating WhatsApp settings for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 4) UX flag: mark as \"disconnected\" ONLY for businesses that previously had ESU/Token\n            try\n            {\n                await _flagStore.UpsertAsync(\n                    businessId,\n                    key: \"facebook.esu\",\n                    value: \"disconnected\",\n                    jsonPayload: \"{\\\"completed\\\":false}\",\n                    ct: ct);\n\n                _log.LogInformation(\n                    \"ESU Disconnect: ESU flag updated to 'disconnected' for biz={BusinessId}\",\n                    businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU Disconnect: failed to update ESU 'disconnected' flag for biz={BusinessId}\",\n                    businessId);\n            }\n        }\n\n        // =======================\n        // HELPERS\n        // =======================\n\n        private static string CreateStateToken(Guid businessId, string? returnUrl)\n        {\n            Span<byte> random = stackalloc byte[16];\n            RandomNumberGenerator.Fill(random);\n            var payload =\n                $\"{businessId:N}|{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}|{Convert.ToHexString(random)}|{(returnUrl ?? \"\")}\";\n            var bytes = System.Text.Encoding.UTF8.GetBytes(payload);\n            return WebEncoders.Base64UrlEncode(bytes);\n        }\n\n        private static string? TryGetReturnUrlFromState(string state)\n        {\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(state);\n                var payload = System.Text.Encoding.UTF8.GetString(bytes);\n                var parts = payload.Split('|', 4, StringSplitOptions.None);\n                if (parts.Length == 4)\n                {\n                    var url = parts[3];\n                    return string.IsNullOrWhiteSpace(url) ? null : url;\n                }\n            }\n            catch\n            {\n                // ignore malformed state\n            }\n            return null;\n        }\n\n        private async Task<string?> TryGetWabaFromDebugTokenAsync(\n            string graphBase,\n            string inputToken,\n            string appId,\n            string appSecret,\n            CancellationToken ct)\n        {\n            try\n            {\n                var appToken = $\"{appId}|{appSecret}\";\n                var url = $\"{graphBase.TrimEnd('/')}/debug_token\" +\n                          $\"?input_token={Uri.EscapeDataString(inputToken)}\" +\n                          $\"&access_token={Uri.EscapeDataString(appToken)}\";\n\n                using var http = new HttpClient();\n                var json = await http.GetStringAsync(url, ct);\n\n                _log.LogDebug(\"ESU debug_token raw={Body}\", Truncate(json));\n\n                using var doc = JsonDocument.Parse(json);\n                var root = doc.RootElement;\n                if (!root.TryGetProperty(\"data\", out var data)) return null;\n\n                if (data.TryGetProperty(\"granular_scopes\", out var scopes) &&\n                    scopes.ValueKind == JsonValueKind.Array)\n                {\n                    foreach (var s in scopes.EnumerateArray())\n                    {\n                        var scope = s.TryGetProperty(\"scope\", out var se) ? se.GetString() : null;\n                        if (string.IsNullOrWhiteSpace(scope)) continue;\n\n                        if (scope.StartsWith(\"whatsapp_business_\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (s.TryGetProperty(\"target_ids\", out var targets) &&\n                                targets.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var t in targets.EnumerateArray())\n                                {\n                                    var id = t.GetString();\n                                    if (!string.IsNullOrWhiteSpace(id))\n                                        return id;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return null;\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"ESU debug_token WABA discovery failed.\");\n                return null;\n            }\n        }\n\n        private async Task<string?> TryGetWabaFromMeAccountsAsync(\n            string apiBase,\n            string accessToken,\n            CancellationToken ct)\n        {\n            var url = $\"{apiBase}/me/whatsapp_business_accounts?fields=id,name\";\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var res = await http.GetAsync(url, ct);\n            var body = await res.Content.ReadAsStringAsync(ct);\n\n            _log.LogDebug(\"ESU me/whatsapp_business_accounts: {Status} {Body}\",\n                (int)res.StatusCode,\n                Truncate(body));\n\n            if (!res.IsSuccessStatusCode) return null;\n\n            using var doc = JsonDocument.Parse(body);\n            if (!doc.RootElement.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array)\n                return null;\n\n            foreach (var it in arr.EnumerateArray())\n            {\n                if (it.TryGetProperty(\"id\", out var idp))\n                {\n                    var id = idp.GetString();\n                    if (!string.IsNullOrWhiteSpace(id))\n                        return id;\n                }\n            }\n\n            return null;\n        }\n\n        private async Task<string?> TryGetWabaFromBusinessesAsync(\n            string apiBase,\n            string accessToken,\n            CancellationToken ct)\n        {\n            var url =\n                $\"{apiBase}/me/businesses?fields=owned_whatsapp_business_accounts{{id}},client_whatsapp_business_accounts{{id}}\";\n\n            using var http = new HttpClient();\n            http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);\n\n            var res = await http.GetAsync(url, ct);\n            var body = await res.Content.ReadAsStringAsync(ct);\n\n            _log.LogDebug(\"ESU me/businesses: {Status} {Body}\",\n                (int)res.StatusCode,\n                Truncate(body));\n\n            if (!res.IsSuccessStatusCode) return null;\n\n            using var doc = JsonDocument.Parse(body);\n            var root = doc.RootElement;\n\n            if (!root.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array)\n                return null;\n\n            foreach (var biz in arr.EnumerateArray())\n            {\n                if (TryPickWabaId(biz, \"owned_whatsapp_business_accounts\", out var ow) &&\n                    !string.IsNullOrWhiteSpace(ow))\n                    return ow;\n\n                if (TryPickWabaId(biz, \"client_whatsapp_business_accounts\", out var cl) &&\n                    !string.IsNullOrWhiteSpace(cl))\n                    return cl;\n            }\n\n            return null;\n        }\n\n        private static string Truncate(string? s, int max = 600)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n            s = s.Replace(\"\\r\", \" \").Replace(\"\\n\", \" \");\n            return s.Length <= max ? s : s[..max] + \"...\";\n        }\n\n        private static bool TryPickWabaId(JsonElement biz, string prop, out string? wabaId)\n        {\n            wabaId = null;\n            if (!biz.TryGetProperty(prop, out var block)) return false;\n            if (!block.TryGetProperty(\"data\", out var arr) || arr.ValueKind != JsonValueKind.Array) return false;\n\n            foreach (var it in arr.EnumerateArray())\n            {\n                if (it.TryGetProperty(\"id\", out var idp))\n                {\n                    wabaId = idp.GetString();\n                    if (!string.IsNullOrWhiteSpace(wabaId))\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n\n        public async Task FullDeleteAsync(Guid businessId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(businessId));\n\n            _log.LogInformation(\"ESU FullDelete: start for biz={BusinessId}\", businessId);\n\n            // 1) Run normal disconnect pipeline (best-effort)\n            try\n            {\n                await DisconnectAsync(businessId, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU FullDelete: DisconnectAsync failed or partial for biz={BusinessId}. Continuing with local cleanup.\",\n                    businessId);\n            }\n\n            // 2) Delete ESU tokens for this business/provider\n            try\n            {\n                await _tokens.DeleteAsync(businessId, Provider, ct);\n\n                _log.LogInformation(\n                    \"ESU FullDelete: EsuTokens deleted for biz={BusinessId}\",\n                    businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU FullDelete: failed to delete EsuTokens for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 3) Delete WhatsApp settings (already in your code)\n            try\n            {\n                var deleted = await _waSettings.DeleteSettingsAsync(businessId);\n                _log.LogInformation(\n                    \"ESU FullDelete: WhatsApp settings delete={Deleted} for biz={BusinessId}\",\n                    deleted,\n                    businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU FullDelete: failed to delete WhatsApp settings for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 4) Delete WhatsApp phone numbers\n            try\n            {\n                var numbers = await _waPhones.ListAsync(businessId, Provider, ct);\n                foreach (var n in numbers)\n                {\n                    await _waPhones.DeleteAsync(businessId, Provider, n.Id);\n                }\n\n                _log.LogInformation(\n                    \"ESU FullDelete: {Count} WhatsApp phone numbers deleted for biz={BusinessId}\",\n                    numbers.Count,\n                    businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU FullDelete: failed to delete WhatsApp phone numbers for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 5) Delete IntegrationFlags row so /status can never say ESU connected\n            try\n            {\n                await _flagStore.DeleteAsync(businessId, ct);\n\n                _log.LogInformation(\n                    \"ESU FullDelete: IntegrationFlags row deleted for biz={BusinessId}\",\n                    businessId);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex,\n                    \"ESU FullDelete: failed to delete IntegrationFlags for biz={BusinessId}\",\n                    businessId);\n            }\n\n            // 6) Also nuke any cached token/status\n            try\n            {\n                await _fbTokens.InvalidateAsync(businessId, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex,\n                    \"ESU FullDelete: token cache invalidate failed for biz={BusinessId}\",\n                    businessId);\n            }\n\n            _log.LogInformation(\"ESU FullDelete: completed for biz={BusinessId}\", businessId);\n        }\n\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/FacebookTokenService.cs",
      "sha256": "5b18d40ad124b1d99c057272bfcbb9b6290b68e45fddc41db8b9ae2e80ac9871",
      "language": "csharp",
      "size": 4146,
      "content": "using System;\nusing System.Collections.Concurrent;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.ESU.Facebook.Abstractions;\nusing xbytechat.api.Features.ESU.Facebook.Contracts;\nusing xbytechat.api.Infrastructure;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    /// <summary>\n    /// Centralized reader for Facebook tokens stored in EsuTokens.\n    /// Includes in-memory caching and per-key locking to avoid stampedes.\n    /// </summary>\n    public sealed class FacebookTokenService : IFacebookTokenService\n    {\n        private const string Provider = \"META_CLOUD\";\n\n        private readonly AppDbContext _db;\n        private readonly IMemoryCache _cache;\n        private readonly ILogger<FacebookTokenService> _log;\n\n        private static readonly ConcurrentDictionary<string, SemaphoreSlim> _locks = new();\n\n        public FacebookTokenService(AppDbContext db, IMemoryCache cache, ILogger<FacebookTokenService> log)\n        {\n            _db = db;\n            _cache = cache;\n            _log = log;\n        }\n\n        private static string CacheKey(Guid biz) => $\"esu:fbtoken:{biz:N}\";\n        private static SemaphoreSlim GetLock(string key) => _locks.GetOrAdd(key, _ => new SemaphoreSlim(1, 1));\n\n        // --- existing methods (TryGetValidAsync, GetRequiredAsync, InvalidateAsync) stay as-is ---\n\n        public async Task<FacebookStoredToken?> TryGetValidAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var key = CacheKey(businessId);\n\n            if (_cache.TryGetValue<FacebookStoredToken?>(key, out var cached) &&\n                cached is not null && !cached.IsExpired() && !cached.WillExpireSoon())\n                return cached;\n\n            var gate = GetLock(key);\n            await gate.WaitAsync(ct).ConfigureAwait(false);\n            try\n            {\n                if (_cache.TryGetValue<FacebookStoredToken?>(key, out cached) &&\n                    cached is not null && !cached.IsExpired() && !cached.WillExpireSoon())\n                    return cached;\n\n                var row = await _db.EsuTokens\n                    .AsNoTracking()\n                    .SingleOrDefaultAsync(x => x.BusinessId == businessId && x.Provider == Provider && !x.IsRevoked, ct)\n                    .ConfigureAwait(false);\n\n                if (row is null || string.IsNullOrWhiteSpace(row.AccessToken)) return null;\n\n                var token = new FacebookStoredToken { AccessToken = row.AccessToken!, ExpiresAtUtc = row.ExpiresAtUtc };\n                if (token.IsExpired() || token.WillExpireSoon()) return null;\n\n                var ttl = token.ExpiresAtUtc.HasValue\n                    ? TimeSpan.FromMinutes(Math.Min(5, Math.Max(1, (token.ExpiresAtUtc.Value - DateTime.UtcNow).TotalMinutes - 1)))\n                    : TimeSpan.FromMinutes(5);\n\n                _cache.Set(key, token, new MemoryCacheEntryOptions { AbsoluteExpirationRelativeToNow = ttl, Size = 1 });\n                return token;\n            }\n            finally { gate.Release(); }\n        }\n\n        public async Task<FacebookStoredToken> GetRequiredAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var token = await TryGetValidAsync(businessId, ct).ConfigureAwait(false);\n            if (token is null) throw new InvalidOperationException(\"Facebook token missing or expired. Please reconnect ESU.\");\n            return token;\n        }\n\n        // ✅ NEW: implement the interface member that the compiler is asking for\n        public async Task<string?> GetAccessTokenAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var token = await TryGetValidAsync(businessId, ct).ConfigureAwait(false);\n            return token?.AccessToken;\n        }\n\n        // keep invalidate async so callers can await it consistently\n        public Task InvalidateAsync(Guid businessId, CancellationToken ct = default)\n        {\n            _cache.Remove(CacheKey(businessId));\n            return Task.CompletedTask;\n        }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Services/IFacebookEsuService.cs",
      "sha256": "b50c18a1cdb24bb703b2a9653a8ee0fac77d996f36d59dfc719e924e83861154",
      "language": "csharp",
      "size": 635,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Services\n{\n    public interface IFacebookEsuService\n    {\n        Task<FacebookEsuStartResponseDto> StartAsync(Guid businessId, string? returnUrl, CancellationToken ct = default);\n        Task<FacebookEsuCallbackResponseDto> HandleCallbackAsync(string code, string state, CancellationToken ct = default);\n        Task DisconnectAsync(Guid businessId, CancellationToken ct = default);\n        Task FullDeleteAsync(Guid businessId, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuFlagCacheOptions.cs",
      "sha256": "2837ccf8cd261897691aa7e4d329811449724b84e176977ed3393062c0394605",
      "language": "csharp",
      "size": 536,
      "content": "#nullable enable\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    /// <summary>Cache knobs for ESU flag reads.</summary>\n    public sealed class EsuFlagCacheOptions\n    {\n        /// <summary>Default TTL for positive cache hits (seconds). Keep short; flags change rarely but we want quick propagation.</summary>\n        public int TtlSeconds { get; set; } = 30;\n\n        /// <summary>TTL for negative lookups (misses). Prevents hammering DB when a flag is absent.</summary>\n        public int MissTtlSeconds { get; set; } = 5;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuFlagStore.cs",
      "sha256": "7dfa5cdbfaf4138039fc02aad6f584c3715c9ddd4cc0c5ac6b9c6d3d593b0bf7",
      "language": "csharp",
      "size": 5072,
      "content": "#nullable enable\nusing System;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.ESU.Facebook.Models; // IntegrationFlags (plural)\nusing xbytechat.api.Infrastructure;               // AppDbContext\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n\n    public sealed class EsuFlagStore : IEsuFlagStore\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<EsuFlagStore> _log;\n        private readonly IMemoryCache _cache;\n        private readonly EsuFlagCacheOptions _cacheOpts;\n\n        public EsuFlagStore(\n            AppDbContext db,\n            ILogger<EsuFlagStore> log,\n            IMemoryCache cache,\n            IOptions<EsuFlagCacheOptions> cacheOpts)\n        {\n            _db = db;\n            _log = log;\n            _cache = cache;\n            _cacheOpts = cacheOpts.Value;\n        }\n\n        // ---- cache helpers ---------------------------------------------------\n        private static string CacheKey(Guid businessId) => $\"esu:intflags:{businessId:N}\";\n        private void Invalidate(Guid businessId) => _cache.Remove(CacheKey(businessId));\n\n        private async Task<IntegrationFlags?> GetRowAsync(Guid businessId, CancellationToken ct)\n        {\n            if (_cache.TryGetValue<IntegrationFlags?>(CacheKey(businessId), out var cached))\n                return cached;\n\n            var row = await _db.IntegrationFlags\n                .AsNoTracking()\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct)\n                .ConfigureAwait(false);\n\n            var ttl = row is null\n                ? TimeSpan.FromSeconds(_cacheOpts.MissTtlSeconds)\n                : TimeSpan.FromSeconds(_cacheOpts.TtlSeconds);\n\n            _cache.Set(CacheKey(businessId), row, ttl);\n            return row;\n        }\n\n        // ---- legacy-shaped APIs (kept for back-compat) ----------------------\n\n        public async Task<IntegrationFlags?> GetAsync(Guid businessId, string key, CancellationToken ct = default)\n            => await GetRowAsync(businessId, ct).ConfigureAwait(false);\n\n        public async Task<string?> GetValueAsync(Guid businessId, string key, CancellationToken ct = default)\n        {\n            var row = await GetRowAsync(businessId, ct).ConfigureAwait(false);\n            if (row is null) return null;\n\n            if (string.Equals(key, \"FACEBOOK_ESU_COMPLETED\", StringComparison.OrdinalIgnoreCase))\n                return row.FacebookEsuCompleted ? \"true\" : \"false\";\n\n            return null; // unknown legacy key in the explicit-column model\n        }\n\n\n        public async Task UpsertAsync(\n      Guid businessId,\n      string key,\n      string value,\n      string? jsonPayload = null,   // kept for API compatibility; ignored for flags\n      CancellationToken ct = default)\n        {\n            // Load/create the per-business row\n            var row = await _db.IntegrationFlags\n                .AsTracking()\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId, ct);\n\n            if (row == null)\n            {\n                row = new IntegrationFlags\n                {\n                    BusinessId = businessId,\n                    CreatedAtUtc = DateTime.UtcNow\n                };\n                _db.IntegrationFlags.Add(row);\n            }\n\n            // 🚫 No secret handling here. Tokens live in EsuTokens only.\n\n            // Mark ESU completed when we get the canonical key/value\n            // (do not flip it back to false if someone passes another value later)\n            if (string.Equals(key, \"facebook.esu\", StringComparison.OrdinalIgnoreCase) &&\n                string.Equals(value, \"completed\", StringComparison.OrdinalIgnoreCase))\n            {\n                row.FacebookEsuCompleted = true;\n            }\n\n            // Touch timestamp; interceptors may also update this\n            row.UpdatedAtUtc = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            // Clear any in-process caches (IMemoryCache Remove is sync)\n            Invalidate(businessId);\n        }\n\n       \n\n        public async Task<bool> IsFacebookEsuCompletedAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var row = await GetRowAsync(businessId, ct).ConfigureAwait(false);\n            return row?.FacebookEsuCompleted == true;\n        }\n\n        // FILE: Features/ESU/Facebook/Services/EsuFlagStore.cs\n\n        public async Task DeleteAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var row = await _db.IntegrationFlags\n                .SingleOrDefaultAsync(x => x.BusinessId == businessId, ct)\n                .ConfigureAwait(false);\n\n            if (row is null)\n                return;\n\n            _db.IntegrationFlags.Remove(row);\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n\n            Invalidate(businessId);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/EsuOptions.cs",
      "sha256": "daad5788b2778e66de306a92ae3bfcbe0e9f88e2db36e65cf429b713d960678d",
      "language": "csharp",
      "size": 546,
      "content": "namespace xbytechat.api.Features.ESU.Shared\n{\n    public sealed class EsuOptions\n    {\n        public FacebookEsuOptions Facebook { get; set; } = new();\n    }\n\n    public sealed class FacebookEsuOptions\n    {\n        public string AppId { get; set; } = string.Empty;\n        public string RedirectUri { get; set; } = string.Empty;\n        public string Scopes { get; set; } = \"whatsapp_business_management,whatsapp_business_messaging\";\n        public int StateTtlMinutes { get; set; } = 20;\n\n        public string? ConfigId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/IEsuFlagStore.cs",
      "sha256": "99df740f3203b19df93ebb5b4c4263b361e58edd8184a2c7b248798330f617b9",
      "language": "csharp",
      "size": 498,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public interface IEsuFlagStore\n    {\n     \n\n        Task<bool> IsFacebookEsuCompletedAsync(\n            Guid businessId,\n            CancellationToken ct = default);\n\n        Task UpsertAsync(Guid businessId, string key, string value, string? jsonPayload = null, CancellationToken ct = default);\n        Task DeleteAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/IEsuStateStore.cs",
      "sha256": "6bfa023f2023e81813d00ec67d788ee6a8ebd543a62de6b52eac954afbfc082b",
      "language": "csharp",
      "size": 286,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public interface IEsuStateStore\n    {\n        Task StoreAsync(string state, Guid businessId, TimeSpan ttl);\n        Task<(bool Found, Guid BusinessId)> TryConsumeAsync(string state);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/Infrastructure/UpdatedAtUtcInterceptor.cs",
      "sha256": "bdaaa5ba5896c90fa6e316bd63ac4d7fe00a6b0d2897f430fc0e250d91ebe2c3",
      "language": "csharp",
      "size": 1737,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore.Diagnostics;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Models; // IntegrationFlags\n\nnamespace xbytechat.api.Features.ESU.Shared.Infrastructure\n{\n    public sealed class UpdatedAtUtcInterceptor : SaveChangesInterceptor\n    {\n        private static readonly Type[] _trackedTypes = new[]\n        {\n            typeof(IntegrationFlags),\n            // add other entities if you want auto-bump later\n        };\n\n        private static bool ShouldTrack(object entity)\n            => _trackedTypes.Contains(entity.GetType());\n\n        public override InterceptionResult<int> SavingChanges(\n            DbContextEventData eventData, InterceptionResult<int> result)\n        {\n            Touch(eventData.Context);\n            return base.SavingChanges(eventData, result);\n        }\n\n        public override ValueTask<InterceptionResult<int>> SavingChangesAsync(\n            DbContextEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)\n        {\n            Touch(eventData.Context);\n            return base.SavingChangesAsync(eventData, result, cancellationToken);\n        }\n\n        private static void Touch(DbContext? ctx)\n        {\n            if (ctx == null) return;\n\n            var now = DateTime.UtcNow;\n\n            foreach (var entry in ctx.ChangeTracker.Entries())\n            {\n                if (entry.State == EntityState.Modified && ShouldTrack(entry.Entity))\n                {\n                    var prop = entry.Property(\"UpdatedAtUtc\");\n                    if (prop != null) prop.CurrentValue = now;\n                }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/MemoryEsuStateStore.cs",
      "sha256": "dde73ec812d607f3d5d5443041bfb0f703210131f014abae66678c931667f677",
      "language": "csharp",
      "size": 885,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Caching.Memory;\n\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    internal sealed class MemoryEsuStateStore : IEsuStateStore\n    {\n        private readonly IMemoryCache _cache;\n        public MemoryEsuStateStore(IMemoryCache cache) => _cache = cache;\n\n        public Task StoreAsync(string state, Guid businessId, TimeSpan ttl)\n        {\n            _cache.Set(state, businessId, ttl);\n            return Task.CompletedTask;\n        }\n\n        public Task<(bool Found, Guid BusinessId)> TryConsumeAsync(string state)\n        {\n            if (_cache.TryGetValue<Guid>(state, out var businessId))\n            {\n                _cache.Remove(state); // one-time use\n                return Task.FromResult((true, businessId));\n            }\n            return Task.FromResult((false, Guid.Empty));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Shared/UiOptions.cs",
      "sha256": "e3c5bde4a1db7df8037e8ab7daf415886c4cd94c606ddc3a26fa58f4af6b0edb",
      "language": "csharp",
      "size": 162,
      "content": "#nullable enable\nnamespace xbytechat.api.Features.ESU.Shared\n{\n    public sealed class UiOptions\n    {\n        public string? PublicBaseUrl { get; set; }\n    }\n}\n"
    }
  ]
}
