{
  "name": "xbytechat-api/Features/MessageLogging",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/IMessageLogSink.cs",
      "sha256": "280e1b16e5989b3a0f91f1bd6cc41fc9efce73fa0d89328db4cf1e0bd76926c4",
      "language": "csharp",
      "size": 205,
      "content": "namespace xbytechat.api.Features.MessageLogging.Services\n{\n    /// Fire-and-forget enqueue API for MessageLog rows.\n    public interface IMessageLogSink\n    {\n        void Enqueue(MessageLog row);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/MessageLogSink.cs",
      "sha256": "a6981361a8c0176c508a4e6d7a15cb7dd9d5feeac16393073ae13d0115802757",
      "language": "csharp",
      "size": 1911,
      "content": "using System.Threading.Channels;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.MessageLogging.Services \n{\n    /// Background batch writer for MessageLogs.\n    public sealed class MessageLogSink : BackgroundService, IMessageLogSink\n    {\n        private readonly Channel<MessageLog> _channel =\n            Channel.CreateBounded<MessageLog>(new BoundedChannelOptions(20_000)\n            {\n                SingleReader = false,\n                SingleWriter = false,\n                FullMode = BoundedChannelFullMode.DropOldest\n            });\n\n        private readonly IServiceProvider _sp;\n        private const int BatchSize = 1000;\n\n        public MessageLogSink(IServiceProvider sp) => _sp = sp;\n\n        public void Enqueue(MessageLog row) => _channel.Writer.TryWrite(row);\n\n        protected override async Task ExecuteAsync(CancellationToken ct)\n        {\n            var batch = new List<MessageLog>(BatchSize);\n\n            while (!ct.IsCancellationRequested)\n            {\n                try\n                {\n                    while (batch.Count < BatchSize && _channel.Reader.TryRead(out var x))\n                        batch.Add(x);\n\n                    if (batch.Count == 0)\n                    {\n                        var first = await _channel.Reader.ReadAsync(ct);\n                        batch.Add(first);\n                    }\n\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    db.ChangeTracker.AutoDetectChangesEnabled = false;\n\n                    await db.MessageLogs.AddRangeAsync(batch, ct);\n                    await db.SaveChangesAsync(ct);\n                    batch.Clear();\n                }\n                catch (TaskCanceledException) { /* shutdown */ }\n                catch { await Task.Delay(200, ct); }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/MessageLogSinkOptions.cs",
      "sha256": "cf616a6c8a74f14ef5d9d26196a18cc97784dc052238edf6129917208b04fc3b",
      "language": "csharp",
      "size": 344,
      "content": "namespace xbytechat.api.Features.MessageLogging.Services;\n\npublic sealed class MessageLogSinkOptions\n{\n    // rows per COPY\n    public int BatchSize { get; set; } = 1000;\n\n    // flush if idle for this long (ms)\n    public int FlushIntervalMs { get; set; } = 800;\n\n    // fallback to EF if false\n    public bool UseCopy { get; set; } = true;\n}\n"
    },
    {
      "path": "xbytechat-api/Features/MessageLogging/Services/PostgresCopyMessageLogSink.cs",
      "sha256": "fe78bbf90598a27b691d735d18e3ca1d26497ea25e818d9c392249c67ccb4433",
      "language": "csharp",
      "size": 11384,
      "content": "using System.Threading.Channels;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Npgsql;\nusing NpgsqlTypes;\nusing xbytechat.api.Features.CampaignTracking.Models; // MessageLog\nusing xbytechat.api.AuthModule.Models;               // AppDbContext\n\nnamespace xbytechat.api.Features.MessageLogging.Services;\n\n/// <summary>\n/// Background sink that batches MessageLogs and writes with COPY BINARY into Postgres.\n/// Falls back to EF AddRange on error or when UseCopy=false.\n/// </summary>\npublic sealed class PostgresCopyMessageLogSink : BackgroundService, IMessageLogSink\n{\n    private readonly IServiceProvider _sp;\n    private readonly ILogger<PostgresCopyMessageLogSink> _log;\n    private readonly MessageLogSinkOptions _opt;\n    private readonly Channel<MessageLog> _ch;\n\n    public PostgresCopyMessageLogSink(\n        IServiceProvider sp,\n        ILogger<PostgresCopyMessageLogSink> log,\n        IOptions<MessageLogSinkOptions> opt)\n    {\n        _sp = sp;\n        _log = log;\n        _opt = opt?.Value ?? new MessageLogSinkOptions();\n\n        _ch = Channel.CreateBounded<MessageLog>(new BoundedChannelOptions(capacity: 50_000)\n        {\n            SingleReader = true,\n            SingleWriter = false,\n            FullMode = BoundedChannelFullMode.Wait\n        });\n\n        _log.LogInformation(\"MessageLog sink initialized (BatchSize={Batch}, FlushIntervalMs={Flush}, UseCopy={UseCopy})\",\n            _opt.BatchSize, _opt.FlushIntervalMs, _opt.UseCopy);\n    }\n\n    public void Enqueue(MessageLog row)\n    {\n        // Fast path: try non-blocking write.\n        if (!_ch.Writer.TryWrite(row))\n        {\n            // Channel is full or not ready: enqueue asynchronously without blocking the caller.\n            _ = _ch.Writer.WriteAsync(row);\n        }\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        var batch = new List<MessageLog>(_opt.BatchSize);\n        var flushDelay = TimeSpan.FromMilliseconds(Math.Max(100, _opt.FlushIntervalMs));\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                // Wait for either new data or idle timeout to flush partial batches\n                var readTask = _ch.Reader.WaitToReadAsync(stoppingToken).AsTask();\n                var delayTask = Task.Delay(flushDelay, stoppingToken);\n                var winner = await Task.WhenAny(readTask, delayTask);\n\n                if (winner == readTask && await readTask)\n                {\n                    while (_ch.Reader.TryRead(out var row))\n                    {\n                        batch.Add(row);\n                        if (batch.Count >= _opt.BatchSize)\n                        {\n                            await FlushAsync(batch, stoppingToken);\n                            batch.Clear();\n                        }\n                    }\n                }\n\n                // Idle flush if timer fired and we have pending rows\n                if (winner == delayTask && batch.Count > 0)\n                {\n                    await FlushAsync(batch, stoppingToken);\n                    batch.Clear();\n                }\n            }\n            catch (OperationCanceledException) { /* shutdown */ }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"[MessageLogSink] loop error\");\n                await Task.Delay(500, stoppingToken);\n            }\n        }\n\n        // final drain\n        try\n        {\n            if (batch.Count > 0) await FlushAsync(batch, CancellationToken.None);\n        }\n        catch (Exception ex)\n        {\n            _log.LogError(ex, \"[MessageLogSink] final flush failed\");\n        }\n    }\n\n    private async Task FlushAsync(List<MessageLog> rows, CancellationToken ct)\n    {\n        if (rows.Count == 0) return;\n\n        using var scope = _sp.CreateScope();\n        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n        _log.LogInformation(\n            \"[MessageLogSink] Flushing {Count} logs. FirstIds={Ids}\",\n            rows.Count,\n            string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n\n        if (_opt.UseCopy && db.Database.IsNpgsql())\n        {\n            var connString = db.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            // ✅ Align with table: both IsChargeable and IsIncoming are present (in this order)\n            const string copySql = @\"\n        COPY \"\"MessageLogs\"\" (\n            \"\"Id\"\",\n            \"\"BusinessId\"\",\n            \"\"CampaignId\"\",\n            \"\"RecipientNumber\"\",\n            \"\"MessageContent\"\",\n            \"\"MediaUrl\"\",\n            \"\"Status\"\",\n            \"\"MessageId\"\",\n            \"\"ErrorMessage\"\",\n            \"\"RawResponse\"\",\n            \"\"CreatedAt\"\",\n            \"\"SentAt\"\",\n            \"\"Source\"\",\n            \"\"RunId\"\",\n            \"\"Provider\"\",\n            \"\"ProviderMessageId\"\",\n            \"\"IsChargeable\"\",\n            \"\"IsIncoming\"\"\n        ) FROM STDIN (FORMAT BINARY);\";\n\n            try\n            {\n                await using var importer = await conn.BeginBinaryImportAsync(copySql, ct);\n\n                foreach (var r in rows)\n                {\n                    await importer.StartRowAsync(ct);\n\n                    importer.Write(r.Id, NpgsqlDbType.Uuid);\n                    importer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n                    importer.Write(r.CampaignId, NpgsqlDbType.Uuid);\n\n                    if (string.IsNullOrWhiteSpace(r.RecipientNumber)) importer.WriteNull();\n                    else importer.Write(r.RecipientNumber, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.MessageContent)) importer.WriteNull();\n                    else importer.Write(r.MessageContent, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.MediaUrl)) importer.WriteNull();\n                    else importer.Write(r.MediaUrl, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.Status)) importer.WriteNull();\n                    else importer.Write(r.Status, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.MessageId)) importer.WriteNull();\n                    else importer.Write(r.MessageId, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.ErrorMessage)) importer.WriteNull();\n                    else importer.Write(r.ErrorMessage, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.RawResponse)) importer.WriteNull();\n                    else importer.Write(r.RawResponse, NpgsqlDbType.Text);\n\n                    importer.Write(r.CreatedAt, NpgsqlDbType.TimestampTz);\n                    if (r.SentAt.HasValue) importer.Write(r.SentAt.Value, NpgsqlDbType.TimestampTz);\n                    else importer.WriteNull();\n\n                    if (string.IsNullOrWhiteSpace(r.Source)) importer.WriteNull();\n                    else importer.Write(r.Source, NpgsqlDbType.Text);\n\n                    importer.Write(r.RunId, NpgsqlDbType.Uuid);\n\n                    if (string.IsNullOrWhiteSpace(r.Provider)) importer.WriteNull();\n                    else importer.Write(r.Provider, NpgsqlDbType.Text);\n\n                    if (string.IsNullOrWhiteSpace(r.ProviderMessageId)) importer.WriteNull();\n                    else importer.Write(r.ProviderMessageId, NpgsqlDbType.Text);\n\n                    // ✅ keep order in sync with COPY list\n                    importer.Write(r.IsChargeable, NpgsqlDbType.Boolean);\n                    importer.Write(r.IsIncoming, NpgsqlDbType.Boolean);\n                }\n\n                await importer.CompleteAsync(ct);\n                _log.LogDebug(\"[MessageLogSink] COPY inserted {Count} rows\", rows.Count);\n                return;\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex,\n                    \"[MessageLogSink] COPY failed, falling back to EF for {Count} rows. FirstIds={Ids}\",\n                    rows.Count,\n                    string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n                // fall through to EF path\n            }\n        }\n\n        // Fallback EF insert\n        db.ChangeTracker.AutoDetectChangesEnabled = false;\n        try\n        {\n            var written = await db.BulkInsertMessageLogsAsync(rows, ct);\n            var ids = rows.Select(x => x.Id).ToList();\n\n            if (written != rows.Count)\n            {\n                _log.LogError(\n                    \"[MessageLogSink] EF insert wrote {Written}/{Count} rows. FirstIds={Ids}\",\n                    written, rows.Count, string.Join(\",\", ids.Take(5)));\n            }\n\n            // Verify all IDs are present; if not, try once more for missing rows\n            var existingIds = await db.MessageLogs\n                .AsNoTracking()\n                .Where(m => ids.Contains(m.Id))\n                .Select(m => m.Id)\n                .ToListAsync(ct);\n\n            var missing = ids.Except(existingIds).ToList();\n            if (missing.Count > 0)\n            {\n                _log.LogError(\n                    \"[MessageLogSink] EF verification missing {Missing} rows. MissingIds={Ids}\",\n                    missing.Count, string.Join(\",\", missing));\n\n                var missingRows = rows.Where(r => missing.Contains(r.Id)).ToList();\n                db.MessageLogs.AddRange(missingRows);\n                var retryWritten = await db.SaveChangesAsync(ct);\n\n                var retryExisting = await db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => ids.Contains(m.Id))\n                    .Select(m => m.Id)\n                    .ToListAsync(ct);\n\n                var stillMissing = ids.Except(retryExisting).ToList();\n                if (stillMissing.Count > 0)\n                {\n                    _log.LogError(\n                        \"[MessageLogSink] EF insert retry still missing {Missing} rows. MissingIds={Ids}\",\n                        stillMissing.Count, string.Join(\",\", stillMissing));\n                    throw new InvalidOperationException(\"MessageLogSink failed to persist MessageLogs: \" + string.Join(\",\", stillMissing));\n                }\n\n                _log.LogInformation(\n                    \"[MessageLogSink] EF retry inserted missing rows. Written={Written} RetryWritten={RetryWritten}\",\n                    written, retryWritten);\n            }\n            else\n            {\n                _log.LogInformation(\n                    \"[MessageLogSink] EF insert succeeded for {Count} rows. FirstIds={Ids}\",\n                    rows.Count, string.Join(\",\", ids.Take(5)));\n            }\n        }\n        catch (Exception ex)\n        {\n            _log.LogError(ex,\n                \"[MessageLogSink] EF insert failed for {Count} rows. FirstIds={Ids}\",\n                rows.Count,\n                string.Join(\",\", rows.Take(5).Select(x => x.Id)));\n            throw;\n        }\n    }\n\n}\n\n/// <summary>\n/// Small EF helper for fallback insert path (kept here for locality).\n/// </summary>\ninternal static class MessageLogEfFallback\n{\n    public static async Task<int> BulkInsertMessageLogsAsync(this AppDbContext db, IEnumerable<MessageLog> rows, CancellationToken ct)\n    {\n        db.MessageLogs.AddRange(rows);\n        return await db.SaveChangesAsync(ct);\n    }\n}\n"
    }
  ]
}
