{
  "name": "xbytechat-api/Features/Payment",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Payment/Controllers/AdminCouponController.cs",
      "sha256": "a7250e3bdf4896eec0bce059b867b23414630af93fb4a0bc64be94aeab683195",
      "language": "csharp",
      "size": 3449,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Controllers\n{\n    /// <summary>\n    /// Minimal admin-only APIs to manage coupons.\n    /// Protect via role/policy in your auth setup.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/payment/coupons\")]\n    [Authorize(Roles = \"SuperAdmin\")] // adjust to your actual role system\n    public sealed class AdminCouponController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public AdminCouponController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll(CancellationToken ct)\n        {\n            var items = await _db.Coupons\n                .OrderByDescending(c => c.ValidFromUtc ?? DateTime.MinValue)\n                .ToListAsync(ct);\n\n            return Ok(new { ok = true, data = items });\n        }\n\n        public sealed class UpsertCouponRequest\n        {\n            public string Code { get; set; } = string.Empty;\n            public string? Description { get; set; }\n            public DiscountType DiscountType { get; set; }\n            public decimal DiscountValue { get; set; }\n            public DateTime? ValidFromUtc { get; set; }\n            public DateTime? ValidToUtc { get; set; }\n            public bool IsActive { get; set; } = true;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] UpsertCouponRequest req, CancellationToken ct)\n        {\n            if (string.IsNullOrWhiteSpace(req.Code))\n                return BadRequest(new { ok = false, message = \"Code is required.\" });\n\n            var exists = await _db.Coupons.AnyAsync(c => c.Code == req.Code, ct);\n            if (exists)\n                return Conflict(new { ok = false, message = \"Coupon code already exists.\" });\n\n            var coupon = new Coupon\n            {\n                Id = Guid.NewGuid(),\n                Code = req.Code,\n                Description = req.Description,\n                DiscountType = req.DiscountType,\n                DiscountValue = req.DiscountValue,\n                ValidFromUtc = req.ValidFromUtc,\n                ValidToUtc = req.ValidToUtc,\n                IsActive = req.IsActive\n            };\n\n            _db.Coupons.Add(coupon);\n            await _db.SaveChangesAsync(ct);\n\n            return Ok(new { ok = true, data = coupon });\n        }\n\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] UpsertCouponRequest req, CancellationToken ct)\n        {\n            var coupon = await _db.Coupons.FirstOrDefaultAsync(c => c.Id == id, ct);\n            if (coupon is null)\n                return NotFound(new { ok = false, message = \"Coupon not found.\" });\n\n            coupon.Description = req.Description;\n            coupon.DiscountType = req.DiscountType;\n            coupon.DiscountValue = req.DiscountValue;\n            coupon.ValidFromUtc = req.ValidFromUtc;\n            coupon.ValidToUtc = req.ValidToUtc;\n            coupon.IsActive = req.IsActive;\n\n            await _db.SaveChangesAsync(ct);\n\n            return Ok(new { ok = true, data = coupon });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Controllers/AdminPaymentMaintenanceController.cs",
      "sha256": "c9aaa1660f210e61a4e34834ffeea027655539cc02ce774b08f977728521cb15",
      "language": "csharp",
      "size": 1197,
      "content": "#nullable enable\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Payment.Services;\n\nnamespace xbytechat.api.Features.Payment.Controllers\n{\n    /// <summary>\n    /// Admin-only endpoints for running payment/subscription maintenance tasks.\n    /// In production, prefer a scheduled job instead of manual calling.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/payment/maintenance\")]\n    [Authorize(Roles = \"SuperAdmin\")] // adjust to your actual admin role\n    public sealed class AdminPaymentMaintenanceController : ControllerBase\n    {\n        private readonly SubscriptionLifecycleService _lifecycle;\n\n        public AdminPaymentMaintenanceController(SubscriptionLifecycleService lifecycle)\n        {\n            _lifecycle = lifecycle;\n        }\n\n        /// <summary>\n        /// Runs subscription lifecycle sync manually.\n        /// </summary>\n        [HttpPost(\"run-lifecycle\")]\n        public async Task<IActionResult> RunLifecycle(CancellationToken ct)\n        {\n            await _lifecycle.RunAsync(ct);\n            return Ok(new { ok = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Controllers/PaymentController.cs",
      "sha256": "23dfec21d19333100bc4131f346e12e04cc1afed552b2909c199d79444029a98",
      "language": "csharp",
      "size": 7219,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Services;\nusing xbytechat.api.Shared; // assuming User.GetBusinessId() lives here or similar\n\nnamespace xbytechat.api.Features.Payment.Controllers\n{\n    [ApiController]\n    [Route(\"api/payment\")]\n    [Authorize] // must be authenticated\n    public sealed class PaymentController : ControllerBase\n    {\n        private readonly ISubscriptionService _subscriptions;\n        private readonly IInvoiceService _invoices;\n        private readonly ICouponService _coupons;\n        private readonly IPaymentGatewayService _gateway;\n        private readonly ISubscriptionCheckoutService _checkout;\n        private readonly PaymentOverviewService _overview;\n        public PaymentController(\n            ISubscriptionService subscriptions,\n            IInvoiceService invoices,\n            ICouponService coupons,\n            IPaymentGatewayService gateway,\n            ISubscriptionCheckoutService checkout,\n            PaymentOverviewService overview)\n        {\n            _subscriptions = subscriptions;\n            _invoices = invoices;\n            _coupons = coupons;\n            _gateway = gateway;\n            _checkout = checkout;\n            _overview = overview;\n        }\n\n        /// <summary>\n        /// Returns the current subscription for the logged-in business.\n        /// </summary>\n        [HttpGet(\"subscription\")]\n        public async Task<IActionResult> GetCurrentSubscription(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId(); // your existing extension\n            var sub = await _subscriptions.GetCurrentForBusinessAsync(businessId, ct);\n            return Ok(new { ok = true, data = sub });\n        }\n\n        /// <summary>\n        /// Creates or updates subscription for the logged-in business.\n        /// NOTE:\n        /// - For MVP this directly activates.\n        /// - Later, call only after payment confirmation.\n        /// </summary>\n        [HttpPost(\"subscription\")]\n        public async Task<IActionResult> CreateOrUpdateSubscription(\n            [FromBody] CreateSubscriptionRequestDto request,\n            CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var sub = await _subscriptions.CreateOrUpdateSubscriptionAsync(businessId, request, ct);\n            return Ok(new { ok = true, data = sub });\n        }\n\n        /// <summary>\n        /// Marks the current subscription to cancel at period end.\n        /// </summary>\n        [HttpPost(\"subscription/cancel-at-period-end\")]\n        public async Task<IActionResult> CancelAtPeriodEnd(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var ok = await _subscriptions.MarkCancelAtPeriodEndAsync(businessId, ct);\n            return Ok(new { ok });\n        }\n\n        /// <summary>\n        /// Reactivates auto-renew for the current subscription.\n        /// </summary>\n        [HttpPost(\"subscription/reactivate\")]\n        public async Task<IActionResult> Reactivate(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var ok = await _subscriptions.ReactivateAutoRenewAsync(businessId, ct);\n            return Ok(new { ok });\n        }\n\n        /// <summary>\n        /// Returns all invoices for the logged-in business.\n        /// </summary>\n        [HttpGet(\"invoices\")]\n        public async Task<IActionResult> GetInvoices(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var items = await _invoices.GetInvoicesForBusinessAsync(businessId, ct);\n            return Ok(new { ok = true, data = items });\n        }\n\n        /// <summary>\n        /// Returns a specific invoice.\n        /// </summary>\n        [HttpGet(\"invoices/{invoiceId:guid}\")]\n        public async Task<IActionResult> GetInvoice(Guid invoiceId, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var invoice = await _invoices.GetInvoiceAsync(businessId, invoiceId, ct);\n            if (invoice is null)\n                return NotFound(new { ok = false, message = \"Invoice not found.\" });\n\n            return Ok(new { ok = true, data = invoice });\n        }\n\n        /// <summary>\n        /// Validates a coupon code for the current context (e.g. before checkout).\n        /// </summary>\n        [HttpGet(\"coupon/validate\")]\n        public async Task<IActionResult> ValidateCoupon(\n            [FromQuery] string code,\n            [FromQuery] string currency = \"INR\",\n            CancellationToken ct = default)\n        {\n            var coupon = await _coupons.ValidateCouponAsync(code, currency, ct);\n            if (coupon is null)\n                return Ok(new { ok = false, message = \"Invalid or expired coupon.\" });\n\n            return Ok(new { ok = true, data = coupon });\n        }\n\n        /// <summary>\n        /// Creates a payment session for the given invoice and returns redirect info.\n        /// Frontend should call this before opening Razorpay checkout.\n        /// </summary>\n        [HttpPost(\"invoices/{invoiceId:guid}/checkout\")]\n        public async Task<IActionResult> CreateCheckoutForInvoice(\n            Guid invoiceId,\n            [FromBody] CreatePaymentSessionRequestDto body,\n            CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n\n            if (body.InvoiceId.HasValue && body.InvoiceId.Value != invoiceId)\n            {\n                return BadRequest(new { ok = false, message = \"Invoice id mismatch.\" });\n            }\n\n            var session = await _gateway.CreatePaymentSessionForInvoiceAsync(\n                businessId,\n                invoiceId,\n                body.CouponCode,\n                ct);\n\n            return Ok(new { ok = true, data = session });\n        }\n        /// <summary>\n        /// Starts subscription checkout for a selected plan:\n        /// - Creates invoice with coupon+GST\n        /// - Creates Razorpay order\n        /// - Returns session/redirect info for frontend.\n        /// </summary>\n        [HttpPost(\"subscribe/checkout\")]\n        public async Task<IActionResult> StartSubscriptionCheckout(\n            [FromBody] CreateSubscriptionRequestDto request,\n            CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n\n            var session = await _checkout.StartSubscriptionCheckoutAsync(\n                businessId,\n                request,\n                ct);\n\n            return Ok(new { ok = true, data = session });\n        }\n        /// <summary>\n        /// Returns a compact payment overview for the logged-in business.\n        /// Intended for Billing page + Account Insights integration.\n        /// </summary>\n        [HttpGet(\"overview\")]\n        public async Task<IActionResult> GetOverview(CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            var data = await _overview.GetAsync(businessId, ct);\n            return Ok(new { ok = true, data });\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Controllers/PaymentWebhookController.cs",
      "sha256": "9e6af3395a6e0c4478a6573d677c7bc86b012c5d544459cf7b73eba9f43ae88f",
      "language": "csharp",
      "size": 6922,
      "content": "#nullable enable\nusing System;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.Payment.Options;\nusing xbytechat.api.Features.Payment.Services;\n\nnamespace xbytechat.api.Features.Payment.Controllers\n{\n    [ApiController]\n    [Route(\"api/payment/webhook/razorpay\")]\n    public sealed class PaymentWebhookController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly RazorpayOptions _opts;\n        private readonly ISubscriptionService _subscriptions;\n\n        public PaymentWebhookController(\n            AppDbContext db,\n            IOptions<RazorpayOptions> opts,\n            ISubscriptionService subscriptions)\n        {\n            _db = db;\n            _opts = opts.Value;\n            _subscriptions = subscriptions;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Handle(CancellationToken ct)\n        {\n            // 1. Read body\n            string body;\n            using (var reader = new StreamReader(Request.Body, Encoding.UTF8))\n            {\n                body = await reader.ReadToEndAsync(ct);\n            }\n\n            // 2. Verify signature\n            var signature = Request.Headers[\"X-Razorpay-Signature\"].ToString();\n            if (!VerifySignature(body, signature, _opts.WebhookSecret))\n            {\n                return Unauthorized();\n            }\n\n            // 3. Parse minimal fields\n            using var doc = JsonDocument.Parse(body);\n            var root = doc.RootElement;\n\n            // Webhook schema differs by event; we read what we need:\n            // payment.captured / payment.failed etc.\n            var eventType = root.GetProperty(\"event\").GetString();\n\n            if (string.IsNullOrWhiteSpace(eventType))\n                return Ok(); // ignore unknown\n\n            if (eventType.StartsWith(\"payment.\"))\n            {\n                var payload = root.GetProperty(\"payload\").GetProperty(\"payment\").GetProperty(\"entity\");\n                var paymentId = payload.GetProperty(\"id\").GetString();\n                var orderId = payload.TryGetProperty(\"order_id\", out var oidEl) ? oidEl.GetString() : null;\n                var status = payload.GetProperty(\"status\").GetString();\n\n                if (!string.IsNullOrWhiteSpace(orderId))\n                {\n                    var tx = await _db.PaymentTransactions\n                        .FirstOrDefaultAsync(t => t.GatewayOrderId == orderId, ct);\n\n                    if (tx != null)\n                    {\n                        await ApplyPaymentStatusAsync(tx, paymentId, status, ct);\n                    }\n                }\n            }\n\n            // You may also handle order.paid events similarly.\n\n            return Ok();\n        }\n\n        private static bool VerifySignature(string body, string signature, string secret)\n        {\n            if (string.IsNullOrWhiteSpace(signature) || string.IsNullOrWhiteSpace(secret))\n                return false;\n\n            var keyBytes = Encoding.UTF8.GetBytes(secret);\n            var bodyBytes = Encoding.UTF8.GetBytes(body);\n\n            using var hmac = new HMACSHA256(keyBytes);\n            var hash = hmac.ComputeHash(bodyBytes);\n            var generated = BitConverter.ToString(hash).Replace(\"-\", \"\").ToLowerInvariant();\n\n            return string.Equals(generated, signature, StringComparison.OrdinalIgnoreCase);\n        }\n\n        private async Task ApplyPaymentStatusAsync(\n            PaymentTransaction tx,\n            string? paymentId,\n            string? paymentStatus,\n            CancellationToken ct)\n        {\n            // Normalize\n            paymentStatus = paymentStatus?.ToLowerInvariant();\n\n            if (paymentStatus == \"captured\" || paymentStatus == \"authorized\" || paymentStatus == \"paid\")\n            {\n                // ---- SUCCESS ----\n                tx.Status = PaymentStatus.Success;\n                tx.GatewayPaymentId = paymentId;\n                tx.CompletedAtUtc = DateTime.UtcNow;\n\n                var invoice = await _db.Invoices\n                    .Include(i => i.Plan)\n                    .FirstOrDefaultAsync(i => i.Id == tx.InvoiceId, ct);\n\n                if (invoice != null)\n                {\n                    invoice.Status = InvoiceStatus.Paid;\n                    invoice.PaidAtUtc = DateTime.UtcNow;\n                }\n\n                // If this invoice is for a subscription (has PlanId + BillingCycle),\n                // we activate/update subscription via SubscriptionService.\n                if (invoice?.PlanId != null && invoice.BillingCycle != null)\n                {\n                    await _subscriptions.CreateOrUpdateSubscriptionAsync(\n                        tx.BusinessId,\n                        new DTOs.CreateSubscriptionRequestDto\n                        {\n                            PlanId = invoice.PlanId.Value,\n                            BillingCycle = invoice.BillingCycle.Value,\n                            // Coupon already baked into invoice; no need to send here.\n                            CouponCode = null\n                        },\n                        ct);\n                }\n            }\n            else if (paymentStatus == \"failed\")\n            {\n                // ---- FAILURE ----\n                tx.Status = PaymentStatus.Failed;\n                tx.GatewayPaymentId = paymentId;\n                tx.CompletedAtUtc = DateTime.UtcNow;\n\n                var invoice = await _db.Invoices\n                    .FirstOrDefaultAsync(i => i.Id == tx.InvoiceId, ct);\n\n                if (invoice != null)\n                {\n                    // Keep invoice open for retry / dunning if it was draft.\n                    if (invoice.Status == InvoiceStatus.Draft)\n                    {\n                        invoice.Status = InvoiceStatus.Open;\n                    }\n\n                    // If this was a renewal / subscription-linked invoice,\n                    // mark subscription as PastDue so AccessGuard can block.\n                    if (invoice.SubscriptionId != null)\n                    {\n                        var sub = await _db.Subscriptions\n                            .FirstOrDefaultAsync(s => s.Id == invoice.SubscriptionId.Value, ct);\n\n                        if (sub != null &&\n                            (sub.Status == SubscriptionStatus.Active ||\n                             sub.Status == SubscriptionStatus.Grace))\n                        {\n                            sub.Status = SubscriptionStatus.PastDue;\n                        }\n                    }\n                }\n            }\n\n            await _db.SaveChangesAsync(ct);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/CouponDto.cs",
      "sha256": "41bbaafa2e7c60f2756dc4bf42958e2a72e070a171b411b7f9d313534cd3e94f",
      "language": "csharp",
      "size": 562,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public class CouponDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; } = string.Empty;\n        public string? Description { get; set; }\n\n        public DiscountType DiscountType { get; set; }\n        public decimal DiscountValue { get; set; }\n\n        public bool IsActive { get; set; }\n        public DateTime? ValidFromUtc { get; set; }\n        public DateTime? ValidToUtc { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/CreatePaymentSessionRequestDto.cs",
      "sha256": "9455eaa06f4ae1ebbc9df4bde78baa270d1261b9314f5e4227ea6162563180b8",
      "language": "csharp",
      "size": 836,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    /// <summary>\n    /// Request to start a payment for a subscription or invoice.\n    /// Maps to a gateway checkout / payment link.\n    /// </summary>\n    public class CreatePaymentSessionRequestDto\n    {\n        /// <summary>\n        /// Optional: target subscription change (upgrade/downgrade/renewal).\n        /// </summary>\n        public Guid? SubscriptionId { get; set; }\n\n        /// <summary>\n        /// Optional: invoice to pay. If null, backend can construct\n        /// a new invoice based on plan selection.\n        /// </summary>\n        public Guid? InvoiceId { get; set; }\n\n        /// <summary>\n        /// Optional coupon code to apply at time of payment.\n        /// </summary>\n        public string? CouponCode { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/CreateSubscriptionRequestDto.cs",
      "sha256": "a6fa013d724c01c7ceb8a165e931c3722e74e4637072483a2ede13ccf46530ba",
      "language": "csharp",
      "size": 807,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    /// <summary>\n    /// Request to start or change a subscription for the current business.\n    /// Payment authorization will be handled via a separate payment flow.\n    /// </summary>\n    public class CreateSubscriptionRequestDto\n    {\n        /// <summary>\n        /// Target plan to subscribe to.\n        /// </summary>\n        public Guid PlanId { get; set; }\n\n        /// <summary>\n        /// Selected billing cycle (Monthly / Yearly).\n        /// </summary>\n        public BillingCycle BillingCycle { get; set; }\n\n        /// <summary>\n        /// Optional coupon code the user wants to apply.\n        /// </summary>\n        public string? CouponCode { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/InvoiceDto.cs",
      "sha256": "9f69933f3b4e85863294c4806e684a8bc1b513c1ba62cb13a3920eaad9c95f95",
      "language": "csharp",
      "size": 983,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public class InvoiceDto\n    {\n        public Guid Id { get; set; }\n        public string InvoiceNumber { get; set; } = string.Empty;\n\n        public Guid BusinessId { get; set; }\n        public Guid? SubscriptionId { get; set; }\n\n        public InvoiceStatus Status { get; set; }\n\n        public decimal SubtotalAmount { get; set; }\n        public decimal DiscountAmount { get; set; }\n        public decimal TaxAmount { get; set; }\n        public decimal TotalAmount { get; set; }\n\n        public string Currency { get; set; } = \"INR\";\n        public string? AppliedCouponCode { get; set; }\n\n        public DateTime IssuedAtUtc { get; set; }\n        public DateTime? DueAtUtc { get; set; }\n        public DateTime? PaidAtUtc { get; set; }\n\n        public List<InvoiceLineItemDto> LineItems { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/InvoiceLineItemDto.cs",
      "sha256": "903f7a64b848f9c8d215a83e90a855a76e27818c57c23ecabb47c9eeb1203668",
      "language": "csharp",
      "size": 371,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public class InvoiceLineItemDto\n    {\n        public Guid Id { get; set; }\n        public string Description { get; set; } = string.Empty;\n        public decimal Quantity { get; set; }\n        public decimal UnitPrice { get; set; }\n        public decimal LineTotal { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/PaymentOverviewDto.cs",
      "sha256": "dabb719741973867fa712fad3ea28e7ef6a4aeee44d2b8950671fee9cadce0df",
      "language": "csharp",
      "size": 648,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public sealed class PaymentOverviewDto\n    {\n        public SubscriptionDto? CurrentSubscription { get; set; }\n\n        public decimal? LastInvoiceAmount { get; set; }\n        public DateTime? LastInvoicePaidAtUtc { get; set; }\n\n        public decimal? NextInvoiceEstimatedAmount { get; set; }\n        public DateTime? CurrentPeriodEndUtc { get; set; }\n\n        public bool CanUseCoreFeatures { get; set; }\n\n        public List<InvoiceDto> RecentInvoices { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/PaymentSessionResponseDto.cs",
      "sha256": "7a5d87a6170743bc39d51094df42be0d45c03ed96fd09015a3c52f073bea6177",
      "language": "csharp",
      "size": 656,
      "content": "#nullable enable\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    /// <summary>\n    /// Response containing info needed by the frontend to redirect the user\n    /// to the payment gateway (hosted page, popup, etc.).\n    /// </summary>\n    public class PaymentSessionResponseDto\n    {\n        /// <summary>\n        /// Internal id for tracking this session/intent.\n        /// </summary>\n        public string SessionId { get; set; } = string.Empty;\n\n        /// <summary>\n        /// URL to redirect the user to (Razorpay Checkout, Stripe Checkout, etc.).\n        /// </summary>\n        public string RedirectUrl { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/PaymentTransactionDto.cs",
      "sha256": "89a71e90b7c469709d0ef2a6f79dd885fc8a74021c427949cd88476f1449f5f6",
      "language": "csharp",
      "size": 828,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    public class PaymentTransactionDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? SubscriptionId { get; set; }\n        public Guid? InvoiceId { get; set; }\n\n        public decimal Amount { get; set; }\n        public string Currency { get; set; } = \"INR\";\n\n        public PaymentStatus Status { get; set; }\n        public string Gateway { get; set; } = string.Empty;\n        public string? GatewayPaymentId { get; set; }\n        public string? GatewayOrderId { get; set; }\n\n        public string? FailureReason { get; set; }\n        public DateTime CreatedAtUtc { get; set; }\n        public DateTime? CompletedAtUtc { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/DTOs/SubscriptionDto.cs",
      "sha256": "436fc732e13a70d4003832129b9324c5f880ed8876f3f97e1af5426cd9a553b1",
      "language": "csharp",
      "size": 951,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.DTOs\n{\n    /// <summary>\n    /// Read model for exposing subscription info to UI / API.\n    /// </summary>\n    public class SubscriptionDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid PlanId { get; set; }\n\n        public string PlanName { get; set; } = string.Empty;\n        public SubscriptionStatus Status { get; set; }\n        public BillingCycle BillingCycle { get; set; }\n\n        public DateTime CurrentPeriodStartUtc { get; set; }\n        public DateTime CurrentPeriodEndUtc { get; set; }\n        public DateTime? TrialEndsAtUtc { get; set; }\n\n        public bool AutoRenew { get; set; }\n        public bool CancelAtPeriodEnd { get; set; }\n\n        public string? GatewayCustomerId { get; set; }\n        public string? GatewaySubscriptionId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/BillingCycle.cs",
      "sha256": "9cb8996565e691a52d0699158ee47db0492cd78d7cde8f8cdd369e9658afa428",
      "language": "csharp",
      "size": 268,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// How often a subscription renews.\n    /// </summary>\n    public enum BillingCycle\n    {\n        Monthly = 1,\n        Yearly = 2\n        // Add Quarterly or other cycles later if needed.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/DiscountType.cs",
      "sha256": "567a3ce46956929d0715e847858ef74a1c7f10788dcfaba8c5dc450127da8991",
      "language": "csharp",
      "size": 415,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// Defines how a discount value should be applied.\n    /// </summary>\n    public enum DiscountType\n    {\n        /// <summary>\n        /// Fixed amount off (e.g. ₹500 off).\n        /// </summary>\n        FixedAmount = 1,\n\n        /// <summary>\n        /// Percentage off (e.g. 20% off).\n        /// </summary>\n        Percentage = 2\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/InvoiceStatus.cs",
      "sha256": "74e0b1ffe3e333aa1c9937858e5c3f004e1b473df0fda25363636e6134afce89",
      "language": "csharp",
      "size": 256,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// State of an invoice in the billing lifecycle.\n    /// </summary>\n    public enum InvoiceStatus\n    {\n        Draft = 0,\n        Open = 1,\n        Paid = 2,\n        Void = 3\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/PaymentStatus.cs",
      "sha256": "7655e3b36f220768e7ebee978d19075ef1481a80511d6f14a01ae6a7bdc10acc",
      "language": "csharp",
      "size": 815,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// Status of a single payment transaction with a gateway.\n    /// </summary>\n    public enum PaymentStatus\n    {\n        /// <summary>\n        /// Initiated but not confirmed yet (checkout created, awaiting gateway result).\n        /// </summary>\n        Pending = 0,\n\n        /// <summary>\n        /// Successfully captured/confirmed by the gateway.\n        /// </summary>\n        Success = 1,\n\n        /// <summary>\n        /// Failed/declined; no funds captured.\n        /// </summary>\n        Failed = 2,\n\n        /// <summary>\n        /// Refunded (partial or full).\n        /// </summary>\n        Refunded = 3,\n\n        /// <summary>\n        /// Chargeback/dispute or manual reversal.\n        /// </summary>\n        Reversed = 4\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Enums/SubscriptionStatus.cs",
      "sha256": "cce65de55c8f3cc221dead81b2dae70a372d248393d2095257ebd12ecee41d74",
      "language": "csharp",
      "size": 1312,
      "content": "namespace xbytechat.api.Features.Payment.Enums\n{\n    /// <summary>\n    /// Represents the lifecycle state of a business account's subscription.\n    /// This will drive access control and account insights.\n    /// </summary>\n    public enum SubscriptionStatus\n    {\n        /// <summary>\n        /// Newly created trial, within the active trial window.\n        /// </summary>\n        Trial = 0,\n\n        /// <summary>\n        /// Active and fully paid. All subscribed features are enabled.\n        /// </summary>\n        Active = 1,\n\n        /// <summary>\n        /// Payment failed or not received; retry / dunning in progress.\n        /// </summary>\n        PastDue = 2,\n\n        /// <summary>\n        /// In grace window before hard suspension.\n        /// </summary>\n        Grace = 3,\n\n        /// <summary>\n        /// Marked to cancel at the end of the current billing period.\n        /// </summary>\n        CancelAtPeriodEnd = 4,\n\n        /// <summary>\n        /// Fully cancelled with no future renewals.\n        /// </summary>\n        Cancelled = 5,\n\n        /// <summary>\n        /// Access blocked due to non-payment / policy violation.\n        /// </summary>\n        Suspended = 6,\n\n        /// <summary>\n        /// Trial ended without activation.\n        /// </summary>\n        Expired = 7\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Filters/RequireActiveSubscriptionAttribute.cs",
      "sha256": "d47615d45bb8244c929876afa5c4fa1bcae07a84a306c22a99231ca705825d3e",
      "language": "csharp",
      "size": 2129,
      "content": "#nullable enable\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing xbytechat.api.Features.Payment.Services;\nusing xbytechat.api.Shared; // for User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Payment.Filters\n{\n    /// <summary>\n    /// Use [RequireActiveSubscription] on controllers/actions that should be accessible\n    /// only when the business has an allowed subscription state.\n    /// \n    /// Logic is delegated to IAccessGuard so rules stay centralized.\n    /// </summary>\n    public sealed class RequireActiveSubscriptionAttribute : TypeFilterAttribute\n    {\n        public RequireActiveSubscriptionAttribute()\n            : base(typeof(RequireActiveSubscriptionFilter))\n        {\n        }\n\n        private sealed class RequireActiveSubscriptionFilter : IAsyncActionFilter\n        {\n            private readonly IAccessGuard _accessGuard;\n\n            public RequireActiveSubscriptionFilter(IAccessGuard accessGuard)\n            {\n                _accessGuard = accessGuard;\n            }\n\n            public async Task OnActionExecutionAsync(\n     ActionExecutingContext context,\n     ActionExecutionDelegate next)\n            {\n                var user = context.HttpContext.User;\n\n                // Let [Authorize] handle unauthenticated cases.\n                if (user?.Identity is null || !user.Identity.IsAuthenticated)\n                {\n                    await next();\n                    return;\n                }\n\n                var businessId = user.GetBusinessId();\n\n                var result = await _accessGuard.CheckAsync(businessId);\n\n                if (!result.Allowed)\n                {\n                    context.Result = new ObjectResult(new\n                    {\n                        ok = false,\n                        status = result.Status?.ToString(),\n                        message = result.Message\n                    })\n                    {\n                        StatusCode = 403\n                    };\n\n                    return;\n                }\n\n                await next();\n            }\n\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/Coupon.cs",
      "sha256": "49fd7b2d4f6b5ca068b32f6cf499b9eb2c0b35936b119bcc6763c81108a8640c",
      "language": "csharp",
      "size": 2301,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents a promotional coupon that can apply discounts\n    /// on subscriptions or invoices (like big players do).\n    /// </summary>\n    public class Coupon\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Unique code entered by the user, e.g. \"LAUNCH20\".\n        /// </summary>\n        public string Code { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Human-friendly description for admins.\n        /// </summary>\n        public string? Description { get; set; }\n\n        /// <summary>\n        /// How the discount is calculated (fixed / percentage).\n        /// </summary>\n        public DiscountType DiscountType { get; set; }\n\n        /// <summary>\n        /// Discount value:\n        /// - If Percentage: 10 = 10%\n        /// - If FixedAmount: absolute amount in invoice currency (e.g. 500 = ₹500).\n        /// </summary>\n        public decimal DiscountValue { get; set; }\n\n        /// <summary>\n        /// Optional: limit total number of times the coupon can be used globally.\n        /// Null = unlimited.\n        /// </summary>\n        public int? MaxRedemptions { get; set; }\n\n        /// <summary>\n        /// Optional: limit per business usage count.\n        /// Null = no per-business cap.\n        /// </summary>\n        public int? MaxRedemptionsPerBusiness { get; set; }\n\n        /// <summary>\n        /// Optional: apply only to a specific plan.\n        /// Null = can apply to any eligible plan.\n        /// </summary>\n        public Guid? PlanId { get; set; }\n\n        /// <summary>\n        /// Start time of coupon validity (UTC).\n        /// </summary>\n        public DateTime? ValidFromUtc { get; set; }\n\n        /// <summary>\n        /// End time of coupon validity (UTC).\n        /// </summary>\n        public DateTime? ValidToUtc { get; set; }\n\n        /// <summary>\n        /// Whether this coupon is currently active (admin toggle).\n        /// </summary>\n        public bool IsActive { get; set; } = true;\n\n        /// <summary>\n        /// Optional metadata or rules (JSON) for future logic.\n        /// </summary>\n        public string? MetaJson { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/Invoice.cs",
      "sha256": "dad830cfae5ab10bc3d1cdac0dfcbeb4b0b5c1124bb064985edf72679a3f9eac",
      "language": "csharp",
      "size": 3293,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents a bill issued to a business for a period, plan, or usage.\n    /// Can be mapped to one or more payment transactions.\n    /// </summary>\n    public class Invoice\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Business this invoice belongs to.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional related subscription for recurring charges.\n        /// </summary>\n        public Guid? SubscriptionId { get; set; }\n\n        /// <summary>\n        /// Human-readable invoice number (e.g. \"XP-2025-000123\").\n        /// </summary>\n        public string InvoiceNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Current status of the invoice (Draft/Open/Paid/Void).\n        /// </summary>\n        public InvoiceStatus Status { get; set; }\n\n        /// <summary>\n        /// Total before tax.\n        /// </summary>\n        public decimal SubtotalAmount { get; set; }\n\n        /// <summary>\n        /// Total tax amount (GST/VAT etc.) if applicable.\n        /// </summary>\n        public decimal TaxAmount { get; set; }\n\n        /// <summary>\n        /// Grand total (Subtotal + Tax - Discounts).\n        /// </summary>\n        public decimal TotalAmount { get; set; }\n\n        /// <summary>\n        /// ISO currency code, e.g. \"INR\".\n        /// </summary>\n        public string Currency { get; set; } = \"INR\";\n\n        /// <summary>\n        /// When invoice was issued (UTC).\n        /// </summary>\n        public DateTime IssuedAtUtc { get; set; }\n\n        /// <summary>\n        /// When payment is due (UTC).\n        /// </summary>\n        public DateTime? DueAtUtc { get; set; }\n\n        /// <summary>\n        /// When invoice was fully paid (UTC).\n        /// </summary>\n        public DateTime? PaidAtUtc { get; set; }\n\n        /// <summary>\n        /// Optional free-form notes (e.g., terms, adjustments).\n        /// </summary>\n        public string? Notes { get; set; }\n\n        public string? AppliedCouponCode { get; set; }\n\n        /// <summary>\n        /// Total discount amount applied on this invoice (>= 0).\n        /// </summary>\n        public decimal DiscountAmount { get; set; }\n\n        public string? TaxBreakdownJson { get; set; }\n\n\n        /// <summary>\n        /// Optional: plan this invoice refers to (for subscription charges).\n        /// </summary>\n        public Guid? PlanId { get; set; }\n\n        /// <summary>\n        /// Optional: billing cycle for this invoice's subscription charge.\n        /// </summary>\n        public BillingCycle? BillingCycle { get; set; }\n        // ---- Navigation ----\n\n        public Business? Business { get; set; }\n        public Subscription? Subscription { get; set; }\n\n        public ICollection<InvoiceLineItem> LineItems { get; set; } = new List<InvoiceLineItem>();\n        public ICollection<PaymentTransaction> Payments { get; set; } = new List<PaymentTransaction>();\n\n        public Plan? Plan { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/InvoiceLineItem.cs",
      "sha256": "7a577bfd7803d7492400518e9efb53c110d0128b947e2fa14c66cf780bb4fa6d",
      "language": "csharp",
      "size": 1364,
      "content": "#nullable enable\nusing System;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents a single line item on an invoice\n    /// (plan fee, add-on, usage charge, discount as negative, etc.).\n    /// </summary>\n    public class InvoiceLineItem\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Parent invoice.\n        /// </summary>\n        public Guid InvoiceId { get; set; }\n\n        /// <summary>\n        /// Short description shown on the invoice.\n        /// e.g. \"Pro Plan - Monthly\", \"WhatsApp Usage - Jan 2025\"\n        /// </summary>\n        public string Description { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Logical quantity (months, message blocks, add-ons).\n        /// </summary>\n        public decimal Quantity { get; set; } = 1m;\n\n        /// <summary>\n        /// Price per unit (before tax).\n        /// </summary>\n        public decimal UnitPrice { get; set; }\n\n        /// <summary>\n        /// Computed total for this line (Quantity * UnitPrice).\n        /// </summary>\n        public decimal LineTotal { get; set; }\n\n        /// <summary>\n        /// Optional metadata (JSON) for internal reconciliation.\n        /// </summary>\n        public string? MetaJson { get; set; }\n\n        // ---- Navigation ----\n\n        public Invoice? Invoice { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/PaymentTransaction.cs",
      "sha256": "f8cc2aed683bd8ea7a9c9221d67d87057ad649df9daae02e7373146611ad9f9f",
      "language": "csharp",
      "size": 3043,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents a single payment interaction with a gateway\n    /// (checkout session, order, capture, refund, etc.).\n    /// </summary>\n    public class PaymentTransaction\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Business that owns this transaction.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional related subscription (plan change, renewal, etc.).\n        /// </summary>\n        public Guid? SubscriptionId { get; set; }\n\n        /// <summary>\n        /// Optional related invoice (if this payment settles a specific invoice).\n        /// </summary>\n        public Guid? InvoiceId { get; set; }\n\n        /// <summary>\n        /// Total amount in smallest currency unit or decimal depending on your standard.\n        /// Use decimal for INR and similar.\n        /// </summary>\n        public decimal Amount { get; set; }\n\n        /// <summary>\n        /// ISO currency code, e.g. \"INR\", \"USD\".\n        /// </summary>\n        public string Currency { get; set; } = \"INR\";\n\n        /// <summary>\n        /// Current status of the transaction (pending, success, failed, etc.).\n        /// </summary>\n        public PaymentStatus Status { get; set; }\n\n        /// <summary>\n        /// Gateway name/provider identifier (e.g. \"Razorpay\", \"Stripe\").\n        /// Kept as string for flexibility; can be enum'ed later.\n        /// </summary>\n        public string Gateway { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Payment/charge id from the gateway.\n        /// </summary>\n        public string? GatewayPaymentId { get; set; }\n\n        /// <summary>\n        /// Order/checkout/session id from the gateway (if applicable).\n        /// </summary>\n        public string? GatewayOrderId { get; set; }\n\n        /// <summary>\n        /// Optional gateway signature or verification token (for validation).\n        /// </summary>\n        public string? GatewaySignature { get; set; }\n\n        /// <summary>\n        /// In case of failure, store short reason for debugging / UI.\n        /// </summary>\n        public string? FailureReason { get; set; }\n\n        /// <summary>\n        /// Any extra metadata (JSON) for debugging or support audits.\n        /// </summary>\n        public string? MetaJson { get; set; }\n\n        /// <summary>\n        /// When this record was created (UTC).\n        /// </summary>\n        public DateTime CreatedAtUtc { get; set; }\n\n        /// <summary>\n        /// When transaction was completed (success/failure/refund), if known (UTC).\n        /// </summary>\n        public DateTime? CompletedAtUtc { get; set; }\n\n        // ---- Navigation ----\n        public Business? Business { get; set; }\n        public Subscription? Subscription { get; set; }\n        public Invoice? Invoice { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Models/Subscription.cs",
      "sha256": "dc53299428c492d66865c3bf0d2760f65ca0a62124181ac4bcb23c1d82b4aab6",
      "language": "csharp",
      "size": 3244,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.Payment.Models\n{\n    /// <summary>\n    /// Represents the subscription of a Business to a specific plan.\n    /// Drives access control, trials, renewals, and suspension.\n    /// </summary>\n    public class Subscription\n    {\n        /// <summary>\n        /// Primary key for the subscription.\n        /// </summary>\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// The business (account) this subscription belongs to.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// The plan the business is subscribed to.\n        /// This should reference your PlanManagement module.\n        /// </summary>\n        public Guid PlanId { get; set; }\n\n        /// <summary>\n        /// Current lifecycle state of the subscription.\n        /// </summary>\n        public SubscriptionStatus Status { get; set; }\n\n        /// <summary>\n        /// Billing frequency (e.g. Monthly / Yearly).\n        /// </summary>\n        public BillingCycle BillingCycle { get; set; }\n\n        /// <summary>\n        /// When the current billing period starts (UTC).\n        /// </summary>\n        public DateTime CurrentPeriodStartUtc { get; set; }\n\n        /// <summary>\n        /// When the current billing period ends (UTC).\n        /// </summary>\n        public DateTime CurrentPeriodEndUtc { get; set; }\n\n        /// <summary>\n        /// Optional trial end (UTC). When passed and not activated -> Expired.\n        /// </summary>\n        public DateTime? TrialEndsAtUtc { get; set; }\n\n        /// <summary>\n        /// If true, subscription will auto-renew at the end of each period.\n        /// </summary>\n        public bool AutoRenew { get; set; } = true;\n\n        /// <summary>\n        /// If true, subscription will be cancelled when the current period ends.\n        /// </summary>\n        public bool CancelAtPeriodEnd { get; set; }\n\n        /// <summary>\n        /// Gateway specific customer id (Stripe, Razorpay, etc) for this business.\n        /// Stored here so multiple subscriptions can still share mapping if needed.\n        /// </summary>\n        public string? GatewayCustomerId { get; set; }\n\n        /// <summary>\n        /// Gateway specific subscription id, if managed on the gateway side.\n        /// </summary>\n        public string? GatewaySubscriptionId { get; set; }\n\n        /// <summary>\n        /// Optional internal notes (manual overrides, special deals, etc.).\n        /// </summary>\n        public string? Notes { get; set; }\n\n        // ---- Navigation properties ----\n\n        public Business? Business { get; set; }          // from BusinessModule\n        public Plan? Plan { get; set; }                  // from PlanManagement\n        public ICollection<PaymentTransaction> Payments { get; set; } = new List<PaymentTransaction>();\n        public ICollection<Invoice> Invoices { get; set; } = new List<Invoice>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Options/RazorpayOptions.cs",
      "sha256": "b3955ae606e837242a71718a7365f4a068a66ab5c960000deb52d03867f4d313",
      "language": "csharp",
      "size": 738,
      "content": "#nullable enable\nnamespace xbytechat.api.Features.Payment.Options\n{\n    /// <summary>\n    /// Razorpay configuration bound from appsettings.\n    /// Never hard-code secrets in code.\n    /// </summary>\n    public sealed class RazorpayOptions\n    {\n        public string KeyId { get; set; } = string.Empty;\n        public string KeySecret { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Secret for validating Razorpay webhooks.\n        /// </summary>\n        public string WebhookSecret { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Base URL of your frontend where you handle success/failure (if needed).\n        /// </summary>\n        public string FrontendBaseUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Options/SubscriptionLifecycleOptions.cs",
      "sha256": "acd4cdaf003dbabe03e8a2e81e657e7307201d0202953f31faf345a42dca66e3",
      "language": "csharp",
      "size": 453,
      "content": "#nullable enable\n\nnamespace xbytechat.api.Features.Payment.Options\n{\n    /// <summary>\n    /// Configuration for automatic subscription status transitions.\n    /// Values are in days unless noted.\n    /// </summary>\n    public sealed class SubscriptionLifecycleOptions\n    {\n        /// <summary>\n        /// After this many days in PastDue, move to Suspended.\n        /// </summary>\n        public int PastDueToSuspendedDays { get; set; } = 7;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/AccessCheckResult.cs",
      "sha256": "4f45881a7c082c9bac19582823676a818e765eb340cbd47cfd917316b6827bcf",
      "language": "csharp",
      "size": 416,
      "content": "#nullable enable\nusing xbytechat.api.Features.Payment.Enums;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Result of an access check for core, billable features.\n    /// </summary>\n    public sealed class AccessCheckResult\n    {\n        public bool Allowed { get; init; }\n        public SubscriptionStatus? Status { get; init; }\n        public string? Message { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/AccessGuard.cs",
      "sha256": "d961c3456ef2fb78fb80341a4eaa6af91dc2cd92179c1a3634c046d9f9da0bf4",
      "language": "csharp",
      "size": 5346,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Subscription-based access control:\n    /// decides if core features (like messaging, campaigns) are allowed.\n    /// All rules centralized here.\n    /// </summary>\n    public sealed class AccessGuard : IAccessGuard\n    {\n        private readonly AppDbContext _db;\n\n        public AccessGuard(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<bool> CanUseCoreFeaturesAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var result = await CheckAsync(businessId, ct);\n            return result.Allowed;\n        }\n\n        public async Task<AccessCheckResult> CheckAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var now = DateTime.UtcNow;\n\n            var sub = await _db.Subscriptions\n                .Where(s => s.BusinessId == businessId)\n                .OrderByDescending(s => s.CurrentPeriodStartUtc)\n                .FirstOrDefaultAsync(ct);\n\n            // Case: no subscription at all\n            if (sub is null)\n            {\n                return new AccessCheckResult\n                {\n                    Allowed = false,\n                    Status = null,\n                    Message = \"You don’t have an active plan. Choose a plan in Billing to start using messaging and campaigns.\"\n                };\n            }\n\n            var status = sub.Status;\n\n            switch (status)\n            {\n                case SubscriptionStatus.Active:\n                    return new AccessCheckResult\n                    {\n                        Allowed = true,\n                        Status = status\n                    };\n\n                case SubscriptionStatus.Trial:\n                    // Trial active\n                    if (sub.TrialEndsAtUtc is null || sub.TrialEndsAtUtc > now)\n                    {\n                        return new AccessCheckResult\n                        {\n                            Allowed = true,\n                            Status = status\n                        };\n                    }\n\n                    // Trial expired\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = SubscriptionStatus.Expired,\n                        Message = \"Your trial has ended. Choose a plan in Billing to continue using messaging and campaigns.\"\n                    };\n\n                case SubscriptionStatus.Grace:\n                    // Grace = still allowed; show banner via UI if you want\n                    return new AccessCheckResult\n                    {\n                        Allowed = true,\n                        Status = status\n                    };\n\n                case SubscriptionStatus.PastDue:\n                    // Payment failed / due date passed\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = status,\n                        Message = \"Your subscription payment is overdue. Please clear the pending invoice in Billing to restore access.\"\n                    };\n\n                case SubscriptionStatus.CancelAtPeriodEnd:\n                    if (sub.CurrentPeriodEndUtc > now)\n                    {\n                        // Still in paid period\n                        return new AccessCheckResult\n                        {\n                            Allowed = true,\n                            Status = status\n                        };\n                    }\n\n                    // Period ended -> treat as cancelled\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = SubscriptionStatus.Cancelled,\n                        Message = \"Your subscription has ended. Select a plan in Billing to continue using your account.\"\n                    };\n\n                case SubscriptionStatus.Cancelled:\n                case SubscriptionStatus.Expired:\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = status,\n                        Message = \"Your subscription is no longer active. Select a plan in Billing to continue using your account.\"\n                    };\n\n                case SubscriptionStatus.Suspended:\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = status,\n                        Message = \"Your account has been suspended due to payment issues. Update your payment method or contact support to restore access.\"\n                    };\n\n                default:\n                    return new AccessCheckResult\n                    {\n                        Allowed = false,\n                        Status = status,\n                        Message = \"Your subscription status does not allow access. Please check Billing or contact support.\"\n                    };\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/CouponPricingHelper.cs",
      "sha256": "606ce2e78f72f5929451312374fd656e0521436252e69f3eb70c99c1acd16275",
      "language": "csharp",
      "size": 1158,
      "content": "#nullable enable\nusing System;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Small helper to apply coupon math consistently.\n    /// This does not check validity windows or max usage - that stays in CouponService.\n    /// </summary>\n    internal static class CouponPricingHelper\n    {\n        public static (decimal discountAmount, decimal finalAmount) ApplyCoupon(\n            Coupon coupon,\n            decimal subtotal)\n        {\n            if (subtotal <= 0 || !coupon.IsActive)\n                return (0m, subtotal);\n\n            decimal discount = coupon.DiscountType switch\n            {\n                DiscountType.Percentage =>\n                    Math.Round(subtotal * (coupon.DiscountValue / 100m), 2, MidpointRounding.AwayFromZero),\n\n                DiscountType.FixedAmount =>\n                    Math.Min(coupon.DiscountValue, subtotal),\n\n                _ => 0m\n            };\n\n            var final = subtotal - discount;\n            if (final < 0) final = 0;\n\n            return (discount, final);\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/CouponService.cs",
      "sha256": "6885d6873aaa667ac68883aab998bed6b3f967e3a772e80b5a568577e5f06406",
      "language": "csharp",
      "size": 1990,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Minimal coupon validator:\n    /// - checks code, active flag, date range.\n    /// - does NOT yet enforce redemption limits.\n    /// </summary>\n    public sealed class CouponService : ICouponService\n    {\n        private readonly AppDbContext _db;\n\n        public CouponService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<CouponDto?> ValidateCouponAsync(\n            string code,\n            string currency,\n            CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(code))\n                return null;\n\n            var now = DateTime.UtcNow;\n            var coupon = await _db.Coupons\n                .AsNoTracking()\n                .FirstOrDefaultAsync(c =>\n                        c.IsActive &&\n                        c.Code == code &&\n                        (c.ValidFromUtc == null || c.ValidFromUtc <= now) &&\n                        (c.ValidToUtc == null || c.ValidToUtc >= now),\n                    ct);\n\n            if (coupon is null)\n                return null;\n\n            // Future:\n            // - Validate currency, plan scope, usage limits.\n            // - For now we trust currency compatibility implicitly.\n\n            return new CouponDto\n            {\n                Id = coupon.Id,\n                Code = coupon.Code,\n                Description = coupon.Description,\n                DiscountType = coupon.DiscountType,\n                DiscountValue = coupon.DiscountValue,\n                IsActive = coupon.IsActive,\n                ValidFromUtc = coupon.ValidFromUtc,\n                ValidToUtc = coupon.ValidToUtc\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/IAccessGuard.cs",
      "sha256": "a396a820f8282d2bc56f43fad75de0341d2f2c2c89371f96137bc5a834d9ee1c",
      "language": "csharp",
      "size": 492,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Central guard to decide if a business is allowed to use billable features.\n    /// </summary>\n    public interface IAccessGuard\n    {\n        Task<bool> CanUseCoreFeaturesAsync(Guid businessId, CancellationToken ct = default);\n        Task<AccessCheckResult> CheckAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/ICouponService.cs",
      "sha256": "e9762a2227164503e672c3b167224efe6147864859ca5c11671e7f4fb52dc1e9",
      "language": "csharp",
      "size": 507,
      "content": "#nullable enable\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Validates coupons and exposes safe coupon info.\n    /// Admin management can be a separate module.\n    /// </summary>\n    public interface ICouponService\n    {\n        Task<CouponDto?> ValidateCouponAsync(\n            string code,\n            string currency,\n            CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/IInvoiceService.cs",
      "sha256": "585437bb5981309ae50ba8e00a4647199330efb4e2ea638769db662857c68e70",
      "language": "csharp",
      "size": 677,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Creates and retrieves invoices for businesses.\n    /// Actual tax/coupon/usage logic will be implemented inside.\n    /// </summary>\n    public interface IInvoiceService\n    {\n        Task<IReadOnlyList<InvoiceDto>> GetInvoicesForBusinessAsync(\n            Guid businessId,\n            CancellationToken ct = default);\n\n        Task<InvoiceDto?> GetInvoiceAsync(Guid businessId, Guid invoiceId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/InvoiceService.cs",
      "sha256": "c2186e5a30552a96ae94d0251d272d8957dfffb61a0741029438b92fb0b20be3",
      "language": "csharp",
      "size": 2779,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Read-only invoice service for now.\n    /// Future:\n    /// - generation based on subscriptions & usage\n    /// - GST-compliant export.\n    /// </summary>\n    public sealed class InvoiceService : IInvoiceService\n    {\n        private readonly AppDbContext _db;\n\n        public InvoiceService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<IReadOnlyList<InvoiceDto>> GetInvoicesForBusinessAsync(\n            Guid businessId,\n            CancellationToken ct = default)\n        {\n            var invoices = await _db.Invoices\n                .Include(i => i.LineItems)\n                .Where(i => i.BusinessId == businessId)\n                .OrderByDescending(i => i.IssuedAtUtc)\n                .ToListAsync(ct);\n\n            return invoices.Select(MapToDto).ToList();\n        }\n\n        public async Task<InvoiceDto?> GetInvoiceAsync(\n            Guid businessId,\n            Guid invoiceId,\n            CancellationToken ct = default)\n        {\n            var invoice = await _db.Invoices\n                .Include(i => i.LineItems)\n                .FirstOrDefaultAsync(i => i.Id == invoiceId && i.BusinessId == businessId, ct);\n\n            return invoice is null ? null : MapToDto(invoice);\n        }\n\n        private static InvoiceDto MapToDto(Invoice invoice)\n        {\n            return new InvoiceDto\n            {\n                Id = invoice.Id,\n                InvoiceNumber = invoice.InvoiceNumber,\n                BusinessId = invoice.BusinessId,\n                SubscriptionId = invoice.SubscriptionId,\n                Status = invoice.Status,\n                SubtotalAmount = invoice.SubtotalAmount,\n                DiscountAmount = invoice.DiscountAmount,\n                TaxAmount = invoice.TaxAmount,\n                TotalAmount = invoice.TotalAmount,\n                Currency = invoice.Currency,\n                AppliedCouponCode = invoice.AppliedCouponCode,\n                IssuedAtUtc = invoice.IssuedAtUtc,\n                DueAtUtc = invoice.DueAtUtc,\n                PaidAtUtc = invoice.PaidAtUtc,\n                LineItems = invoice.LineItems.Select(li => new InvoiceLineItemDto\n                {\n                    Id = li.Id,\n                    Description = li.Description,\n                    Quantity = li.Quantity,\n                    UnitPrice = li.UnitPrice,\n                    LineTotal = li.LineTotal\n                }).ToList()\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/IPaymentGatewayService.cs",
      "sha256": "409d1d87341a931f5ea4a5129b75d859144e06166146b1964e22084cd3310470",
      "language": "csharp",
      "size": 804,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Abstraction over the underlying payment provider (Razorpay, Stripe, etc.).\n    /// Implementation will:\n    /// - create checkout/payment sessions\n    /// - verify signatures\n    /// - map webhooks to PaymentTransaction updates.\n    /// </summary>\n    public interface IPaymentGatewayService\n    {\n        Task<PaymentSessionResponseDto> CreatePaymentSessionForInvoiceAsync(\n            Guid businessId,\n            Guid invoiceId,\n            string? couponCode,\n            CancellationToken ct = default);\n\n        // We will add webhook-handling signatures later when wiring gateway.\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/ISubscriptionCheckoutService.cs",
      "sha256": "70caced3708db2d78510dbc7a306b90d3cbf5928ad2de27a3915b5a5fab1dd73",
      "language": "csharp",
      "size": 563,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Orchestrates plan selection -> invoice -> payment session for subscriptions.\n    /// </summary>\n    public interface ISubscriptionCheckoutService\n    {\n        Task<PaymentSessionResponseDto> StartSubscriptionCheckoutAsync(\n            Guid businessId,\n            CreateSubscriptionRequestDto request,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/ISubscriptionService.cs",
      "sha256": "bb311c9360309f2f785913b2edf1fee96d7a66bbcc0784ec59392e3cc5718845",
      "language": "csharp",
      "size": 879,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Payment.DTOs;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Handles business-facing subscription lifecycle:\n    /// trial, activation, upgrade/downgrade, cancellation.\n    /// </summary>\n    public interface ISubscriptionService\n    {\n        Task<SubscriptionDto?> GetCurrentForBusinessAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<SubscriptionDto> CreateOrUpdateSubscriptionAsync(\n            Guid businessId,\n            CreateSubscriptionRequestDto request,\n            CancellationToken ct = default);\n\n        Task<bool> MarkCancelAtPeriodEndAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<bool> ReactivateAutoRenewAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/PaymentOverviewService.cs",
      "sha256": "90fc29922281ffee1c3c6140193d81efce9c482132b8ed63aebc9b269c4b546e",
      "language": "csharp",
      "size": 2140,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Lightweight read service to power Billing/Insights UI.\n    /// Aggregates subscription + invoices + access flag.\n    /// </summary>\n    public sealed class PaymentOverviewService\n    {\n        private readonly AppDbContext _db;\n        private readonly ISubscriptionService _subscriptions;\n        private readonly IInvoiceService _invoices;\n        private readonly IAccessGuard _accessGuard;\n\n        public PaymentOverviewService(\n            AppDbContext db,\n            ISubscriptionService subscriptions,\n            IInvoiceService invoices,\n            IAccessGuard accessGuard)\n        {\n            _db = db;\n            _subscriptions = subscriptions;\n            _invoices = invoices;\n            _accessGuard = accessGuard;\n        }\n\n        public async Task<PaymentOverviewDto> GetAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var sub = await _subscriptions.GetCurrentForBusinessAsync(businessId, ct);\n            var invoices = await _invoices.GetInvoicesForBusinessAsync(businessId, ct);\n\n            var lastPaid = invoices\n                .Where(i => i.Status == InvoiceStatus.Paid)\n                .OrderByDescending(i => i.PaidAtUtc ?? i.IssuedAtUtc)\n                .FirstOrDefault();\n\n            var canUse = await _accessGuard.CanUseCoreFeaturesAsync(businessId, ct);\n\n            return new PaymentOverviewDto\n            {\n                CurrentSubscription = sub,\n                LastInvoiceAmount = lastPaid?.TotalAmount,\n                LastInvoicePaidAtUtc = lastPaid?.PaidAtUtc,\n                CurrentPeriodEndUtc = sub?.CurrentPeriodEndUtc,\n                CanUseCoreFeatures = canUse,\n                RecentInvoices = invoices\n                    .Take(10)\n                    .ToList()\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/RazorpayPaymentGatewayService.cs",
      "sha256": "bbc11c906ea24283a7a891f205a389e6d72ca9fdf01f7dda65c50a6633d090eb",
      "language": "csharp",
      "size": 5962,
      "content": "#nullable enable\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.Payment.Options;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Razorpay-based implementation of IPaymentGatewayService.\n    /// This is a minimal skeleton:\n    /// - Creates a Razorpay Order for an existing Invoice.\n    /// - Persists a Pending PaymentTransaction.\n    /// - Returns data for frontend to open Razorpay Checkout.\n    ///\n    /// Webhook handling that marks success/failure is done separately.\n    /// </summary>\n    public sealed class RazorpayPaymentGatewayService : IPaymentGatewayService\n    {\n        private readonly AppDbContext _db;\n        private readonly HttpClient _http;\n        private readonly RazorpayOptions _opts;\n        private readonly ILogger<RazorpayPaymentGatewayService> _log;\n\n        public RazorpayPaymentGatewayService(\n            AppDbContext db,\n            HttpClient httpClient,\n            IOptions<RazorpayOptions> opts,\n            ILogger<RazorpayPaymentGatewayService> log)\n        {\n            _db = db;\n            _http = httpClient;\n            _opts = opts.Value;\n            _log = log;\n\n            if (!string.IsNullOrWhiteSpace(_opts.KeyId) &&\n                !string.IsNullOrWhiteSpace(_opts.KeySecret))\n            {\n                var authToken = Convert.ToBase64String(\n                    Encoding.UTF8.GetBytes($\"{_opts.KeyId}:{_opts.KeySecret}\"));\n\n                _http.BaseAddress ??= new Uri(\"https://api.razorpay.com/v1/\");\n                _http.DefaultRequestHeaders.Authorization =\n                    new AuthenticationHeaderValue(\"Basic\", authToken);\n            }\n        }\n\n        /// <summary>\n        /// Creates a payment session (Razorpay Order) for the given invoice.\n        /// Assumes:\n        /// - Invoice is already created with TotalAmount & Currency.\n        /// - BusinessId already validated by caller.\n        /// </summary>\n        public async Task<PaymentSessionResponseDto> CreatePaymentSessionForInvoiceAsync(\n            Guid businessId,\n            Guid invoiceId,\n            string? couponCode,\n            CancellationToken ct = default)\n        {\n            var invoice = await _db.Invoices\n                .FirstOrDefaultAsync(i => i.Id == invoiceId && i.BusinessId == businessId, ct);\n\n            if (invoice is null)\n                throw new InvalidOperationException(\"Invoice not found for this business.\");\n\n            if (invoice.Status is InvoiceStatus.Paid or InvoiceStatus.Void)\n                throw new InvalidOperationException(\"Invoice is already closed.\");\n\n            if (invoice.TotalAmount <= 0)\n                throw new InvalidOperationException(\"Invoice total must be greater than zero.\");\n\n            // ---- Create PaymentTransaction record (Pending) ----\n            var tx = new PaymentTransaction\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                InvoiceId = invoice.Id,\n                SubscriptionId = invoice.SubscriptionId,\n                Amount = invoice.TotalAmount,\n                Currency = invoice.Currency,\n                Status = PaymentStatus.Pending,\n                Gateway = \"Razorpay\",\n                CreatedAtUtc = DateTime.UtcNow,\n                MetaJson = null\n            };\n\n            _db.PaymentTransactions.Add(tx);\n            await _db.SaveChangesAsync(ct);\n\n            // ---- Call Razorpay Orders API ----\n            // amount in paise for INR (multiply by 100)\n            var amountInMinor = (int)(invoice.TotalAmount * 100m);\n\n            var payload = new\n            {\n                amount = amountInMinor,\n                currency = invoice.Currency,\n                receipt = invoice.InvoiceNumber,\n                payment_capture = 1 // auto-capture\n            };\n\n            var json = JsonSerializer.Serialize(payload);\n            var content = new StringContent(json, Encoding.UTF8, \"application/json\");\n\n            HttpResponseMessage resp;\n            try\n            {\n                resp = await _http.PostAsync(\"orders\", content, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Error calling Razorpay Orders API\");\n                throw new InvalidOperationException(\"Unable to create payment order at this time.\");\n            }\n\n            if (!resp.IsSuccessStatusCode)\n            {\n                var body = await resp.Content.ReadAsStringAsync(ct);\n                _log.LogError(\"Razorpay order failed: {Status} {Body}\", resp.StatusCode, body);\n                throw new InvalidOperationException(\"Failed to create payment order.\");\n            }\n\n            using var stream = await resp.Content.ReadAsStreamAsync(ct);\n            using var doc = await JsonDocument.ParseAsync(stream, cancellationToken: ct);\n\n            var orderId = doc.RootElement.GetProperty(\"id\").GetString();\n\n            // Save order id on transaction\n            tx.GatewayOrderId = orderId;\n            tx.MetaJson = json;\n            await _db.SaveChangesAsync(ct);\n\n            // ---- Return session info for frontend ----\n            // Frontend will:\n            // - Use Razorpay JS with key_id + order_id + customer info\n            // - On success, webhook will confirm and we update DB.\n            var session = new PaymentSessionResponseDto\n            {\n                SessionId = tx.Id.ToString(),\n                RedirectUrl = $\"{_opts.FrontendBaseUrl}/billing/checkout?orderId={orderId}&txId={tx.Id}\"\n            };\n\n            return session;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/SubscriptionCheckoutService.cs",
      "sha256": "48af43a4143fe1c6dae9034239311fb59a206b94fd914453c3f690300017c59e",
      "language": "csharp",
      "size": 7681,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.PlanManagement.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Handles the \"subscribe to plan\" flow:\n    /// - Validates plan & coupon\n    /// - Creates invoice with coupon + GST\n    /// - Creates payment session via gateway.\n    /// </summary>\n    public sealed class SubscriptionCheckoutService : ISubscriptionCheckoutService\n    {\n        private readonly AppDbContext _db;\n        private readonly ICouponService _coupons;\n        private readonly IPaymentGatewayService _gateway;\n\n        public SubscriptionCheckoutService(\n            AppDbContext db,\n            ICouponService coupons,\n            IPaymentGatewayService gateway)\n        {\n            _db = db;\n            _coupons = coupons;\n            _gateway = gateway;\n        }\n\n        public async Task<PaymentSessionResponseDto> StartSubscriptionCheckoutAsync(\n            Guid businessId,\n            CreateSubscriptionRequestDto request,\n            CancellationToken ct = default)\n        {\n            var plan = await _db.Set<Plan>()\n                .AsNoTracking()\n                .FirstOrDefaultAsync(p => p.Id == request.PlanId, ct)\n                ?? throw new InvalidOperationException(\"Plan not found.\");\n\n            // Resolve base price from plan & cycle (adjust property names to your Plan model).\n            var (price, currency) = GetPlanPrice(plan, request.BillingCycle);\n            if (price <= 0)\n                throw new InvalidOperationException(\"Plan price is not configured.\");\n\n            var subtotal = price;\n\n            // ---- Apply coupon if present ----\n            string? appliedCode = null;\n            decimal discountAmount = 0m;\n\n            if (!string.IsNullOrWhiteSpace(request.CouponCode))\n            {\n                var coupon = await _coupons.ValidateCouponAsync(request.CouponCode, currency, ct);\n                if (coupon != null)\n                {\n                    // Load full Coupon entity to use in helper\n                    var fullCoupon = await _db.Coupons\n                        .FirstAsync(c => c.Id == coupon.Id, ct);\n\n                    var (disc, finalAfterDisc) = CouponPricingHelper.ApplyCoupon(fullCoupon, subtotal);\n                    discountAmount = disc;\n                    subtotal = finalAfterDisc;\n                    appliedCode = coupon.Code;\n                }\n            }\n\n            // ---- Apply GST (India) ----\n            // For now assume intra-state = false/true via a simple flag or config.\n            // You can later compute based on Business address vs your GST registration.\n            var (taxAmount, taxBreakdownJson) =\n                TaxCalculator.CalculateGstForIndianCustomer(subtotal, isInterState: true);\n\n            var total = subtotal + taxAmount;\n\n            // ---- Create Invoice ----\n            var invoice = new Invoice\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                SubscriptionId = null,                // will be linked on success\n                PlanId = plan.Id,\n                BillingCycle = request.BillingCycle,\n                InvoiceNumber = GenerateInvoiceNumber(),\n                Status = InvoiceStatus.Open,\n                SubtotalAmount = price,\n                DiscountAmount = discountAmount,\n                TaxAmount = taxAmount,\n                TotalAmount = total,\n                Currency = currency,\n                AppliedCouponCode = appliedCode,\n                TaxBreakdownJson = taxBreakdownJson,\n                IssuedAtUtc = DateTime.UtcNow,\n                DueAtUtc = null\n            };\n\n            // Single line item: \"Plan - cycle\"\n            invoice.LineItems.Add(new InvoiceLineItem\n            {\n                Id = Guid.NewGuid(),\n                InvoiceId = invoice.Id,\n                Description = $\"{plan.Name} - {request.BillingCycle}\",\n                Quantity = 1,\n                UnitPrice = price,\n                LineTotal = price\n            });\n\n            _db.Invoices.Add(invoice);\n            await _db.SaveChangesAsync(ct);\n\n            // ---- Create payment session via gateway ----\n            var session = await _gateway.CreatePaymentSessionForInvoiceAsync(\n                businessId,\n                invoice.Id,\n                appliedCode,\n                ct);\n\n            return session;\n        }\n\n        private static (decimal price, string currency) GetPlanPrice(Plan plan, BillingCycle cycle)\n        {\n            // We don't hardcode your Plan schema here.\n            // Instead, we try common property names via reflection so this compiles\n            // even if your Plan model is different. Later you can replace this\n            // with a strict implementation once pricing fields are finalized.\n\n            var type = plan.GetType();\n\n            // 1) Currency: try common names, fallback to INR\n            var currencyProp =\n                type.GetProperty(\"Currency\") ??\n                type.GetProperty(\"DefaultCurrency\") ??\n                type.GetProperty(\"PlanCurrency\");\n\n            var currency =\n                (currencyProp?.GetValue(plan) as string)\n                ?? \"INR\";\n\n            // 2) Price: prefer cycle-specific fields if they exist\n            string[] yearlyNames = { \"YearlyPrice\", \"PriceYearly\", \"YearlyAmount\", \"AnnualPrice\" };\n            string[] monthlyNames = { \"MonthlyPrice\", \"PriceMonthly\", \"MonthlyAmount\" };\n\n            decimal price = 0m;\n\n            if (cycle == BillingCycle.Yearly)\n            {\n                foreach (var name in yearlyNames)\n                {\n                    var p = type.GetProperty(name);\n                    if (p != null && p.PropertyType == typeof(decimal))\n                    {\n                        price = (decimal)(p.GetValue(plan) ?? 0m);\n                        if (price > 0) break;\n                    }\n                }\n            }\n            else\n            {\n                foreach (var name in monthlyNames)\n                {\n                    var p = type.GetProperty(name);\n                    if (p != null && p.PropertyType == typeof(decimal))\n                    {\n                        price = (decimal)(p.GetValue(plan) ?? 0m);\n                        if (price > 0) break;\n                    }\n                }\n            }\n\n            // 3) Fallback: single generic price property if cycle-specific not found\n            if (price <= 0)\n            {\n                var singlePriceProp =\n                    type.GetProperty(\"Price\") ??\n                    type.GetProperty(\"Amount\") ??\n                    type.GetProperty(\"BasePrice\");\n\n                if (singlePriceProp != null && singlePriceProp.PropertyType == typeof(decimal))\n                {\n                    price = (decimal)(singlePriceProp.GetValue(plan) ?? 0m);\n                }\n            }\n\n            // At this point:\n            // - If price is still 0 => your Plan doesn't have any of the expected fields.\n            //   That’s a config/contract decision, not a runtime crash.\n            return (price, currency);\n        }\n\n        private static string GenerateInvoiceNumber()\n        {\n            // Primitive; replace with your own sequence if needed.\n            return \"XP-\" + DateTime.UtcNow.ToString(\"yyyyMMddHHmmssfff\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/SubscriptionLifecycleService.cs",
      "sha256": "51355740e1dc5177760bd770f8d1d2486b75eefe83436373792dacce2653f1d8",
      "language": "csharp",
      "size": 3768,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.Payment.Options;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Runs periodic maintenance to keep subscription statuses in sync with time & invoices.\n    /// Should be called by a scheduled job (e.g. daily).\n    /// </summary>\n    public sealed class SubscriptionLifecycleService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<SubscriptionLifecycleService> _log;\n        private readonly SubscriptionLifecycleOptions _options;\n\n        public SubscriptionLifecycleService(\n            AppDbContext db,\n            IOptions<SubscriptionLifecycleOptions> options,\n            ILogger<SubscriptionLifecycleService> log)\n        {\n            _db = db;\n            _log = log;\n            _options = options.Value;\n        }\n\n        /// <summary>\n        /// Run lifecycle sync for all subscriptions.\n        /// Safe to run daily (or more often).\n        /// </summary>\n        public async Task RunAsync(CancellationToken ct = default)\n        {\n            var now = DateTime.UtcNow;\n            var pastDueCutoff = now.AddDays(-_options.PastDueToSuspendedDays);\n\n            // Load subs in one go; for huge scale you'd batch.\n            var subs = await _db.Subscriptions\n                .AsTracking()\n                .ToListAsync(ct);\n\n            foreach (var sub in subs)\n            {\n                try\n                {\n                    switch (sub.Status)\n                    {\n                        case SubscriptionStatus.Trial:\n                            if (sub.TrialEndsAtUtc is not null &&\n                                sub.TrialEndsAtUtc.Value < now)\n                            {\n                                sub.Status = SubscriptionStatus.Expired;\n                            }\n                            break;\n\n                        case SubscriptionStatus.CancelAtPeriodEnd:\n                            if (sub.CurrentPeriodEndUtc < now)\n                            {\n                                sub.Status = SubscriptionStatus.Cancelled;\n                            }\n                            break;\n\n                        case SubscriptionStatus.PastDue:\n                            // If there is an unpaid invoice older than cutoff,\n                            // we suspend the subscription.\n                            var hasOldUnpaid = await _db.Invoices\n                                .AnyAsync(i =>\n                                    i.SubscriptionId == sub.Id &&\n                                    i.Status != InvoiceStatus.Paid &&\n                                    (i.DueAtUtc ?? i.IssuedAtUtc) < pastDueCutoff,\n                                    ct);\n\n                            if (hasOldUnpaid)\n                            {\n                                sub.Status = SubscriptionStatus.Suspended;\n                            }\n                            break;\n\n                        default:\n                            // Active, Grace, Suspended, Cancelled, Expired:\n                            // no automatic change here for now.\n                            break;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex,\n                        \"Error processing lifecycle for subscription {SubscriptionId}\", sub.Id);\n                }\n            }\n\n            await _db.SaveChangesAsync(ct);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/SubscriptionService.cs",
      "sha256": "1b95797bd39279882a472d47da6b09c5470847fe9e3ea58d17742c0f7fe2d9ae",
      "language": "csharp",
      "size": 7200,
      "content": "#nullable enable\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Payment.DTOs;\nusing xbytechat.api.Features.Payment.Enums;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.Payment.Services;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Default implementation for managing business subscriptions.\n    /// NOTE:\n    /// - For now we assume \"backend-approved\" calls (e.g. after payment success or admin action).\n    /// - Later we will tighten this to be driven purely by gateway webhooks.\n    /// </summary>\n    public sealed class SubscriptionService : ISubscriptionService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<SubscriptionService> _log;\n\n        public SubscriptionService(AppDbContext db, ILogger<SubscriptionService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        /// <summary>\n        /// Gets the latest subscription for a business (if any).\n        /// </summary>\n        public async Task<SubscriptionDto?> GetCurrentForBusinessAsync(\n            Guid businessId,\n            CancellationToken ct = default)\n        {\n            var sub = await _db.Subscriptions\n                .Include(s => s.Plan)\n                .Where(s => s.BusinessId == businessId)\n                .OrderByDescending(s => s.CurrentPeriodStartUtc)\n                .FirstOrDefaultAsync(ct);\n\n            if (sub is null) return null;\n\n            return MapToDto(sub);\n        }\n\n        /// <summary>\n        /// Creates or updates a subscription for a business.\n        /// IMPORTANT:\n        /// - This is a logical operation; real activation should be tied to payment success later.\n        /// - For MVP we mark as Active immediately (assuming external validation).\n        /// </summary>\n        public async Task<SubscriptionDto> CreateOrUpdateSubscriptionAsync(\n            Guid businessId,\n            CreateSubscriptionRequestDto request,\n            CancellationToken ct = default)\n        {\n            var business = await _db.Set<Business>()\n                .AsNoTracking()\n                .FirstOrDefaultAsync(b => b.Id == businessId, ct)\n                ?? throw new InvalidOperationException(\"Business not found.\");\n\n            var plan = await _db.Set<Plan>()\n                .AsNoTracking()\n                .FirstOrDefaultAsync(p => p.Id == request.PlanId, ct)\n                ?? throw new InvalidOperationException(\"Plan not found.\");\n\n            var now = DateTime.UtcNow;\n\n            // Simple: 1 active subscription per business (latest wins).\n            var existing = await _db.Subscriptions\n                .Where(s => s.BusinessId == businessId\n                            && s.Status != SubscriptionStatus.Cancelled\n                            && s.Status != SubscriptionStatus.Expired)\n                .OrderByDescending(s => s.CurrentPeriodStartUtc)\n                .FirstOrDefaultAsync(ct);\n\n            var periodEnd = request.BillingCycle switch\n            {\n                BillingCycle.Yearly => now.AddYears(1),\n                _ => now.AddMonths(1)\n            };\n\n            if (existing is null)\n            {\n                var sub = new Subscription\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    PlanId = plan.Id,\n                    Status = SubscriptionStatus.Active,   // later: controlled by payment result\n                    BillingCycle = request.BillingCycle,\n                    CurrentPeriodStartUtc = now,\n                    CurrentPeriodEndUtc = periodEnd,\n                    AutoRenew = true,\n                    CancelAtPeriodEnd = false,\n                    TrialEndsAtUtc = null\n                };\n\n                _db.Subscriptions.Add(sub);\n                await _db.SaveChangesAsync(ct);\n\n                return MapToDto(sub, plan.Name);\n            }\n            else\n            {\n                // Update existing into new plan / cycle.\n                existing.PlanId = plan.Id;\n                existing.BillingCycle = request.BillingCycle;\n                existing.Status = SubscriptionStatus.Active;\n                existing.AutoRenew = true;\n                existing.CancelAtPeriodEnd = false;\n                existing.CurrentPeriodStartUtc = now;\n                existing.CurrentPeriodEndUtc = periodEnd;\n\n                await _db.SaveChangesAsync(ct);\n\n                return MapToDto(existing, plan.Name);\n            }\n        }\n\n        public async Task<bool> MarkCancelAtPeriodEndAsync(\n            Guid businessId,\n            CancellationToken ct = default)\n        {\n            var sub = await _db.Subscriptions\n                .Where(s => s.BusinessId == businessId &&\n                            (s.Status == SubscriptionStatus.Active || s.Status == SubscriptionStatus.Trial))\n                .OrderByDescending(s => s.CurrentPeriodStartUtc)\n                .FirstOrDefaultAsync(ct);\n\n            if (sub is null) return false;\n\n            sub.CancelAtPeriodEnd = true;\n            sub.Status = SubscriptionStatus.CancelAtPeriodEnd;\n\n            await _db.SaveChangesAsync(ct);\n            return true;\n        }\n\n        public async Task<bool> ReactivateAutoRenewAsync(\n            Guid businessId,\n            CancellationToken ct = default)\n        {\n            var sub = await _db.Subscriptions\n                .Where(s => s.BusinessId == businessId &&\n                            (s.Status == SubscriptionStatus.CancelAtPeriodEnd ||\n                             s.Status == SubscriptionStatus.Active))\n                .OrderByDescending(s => s.CurrentPeriodStartUtc)\n                .FirstOrDefaultAsync(ct);\n\n            if (sub is null) return false;\n\n            sub.CancelAtPeriodEnd = false;\n            if (sub.Status == SubscriptionStatus.CancelAtPeriodEnd)\n            {\n                sub.Status = SubscriptionStatus.Active;\n            }\n\n            await _db.SaveChangesAsync(ct);\n            return true;\n        }\n\n        private static SubscriptionDto MapToDto(Subscription sub, string? planNameOverride = null)\n        {\n            return new SubscriptionDto\n            {\n                Id = sub.Id,\n                BusinessId = sub.BusinessId,\n                PlanId = sub.PlanId,\n                PlanName = planNameOverride ?? sub.Plan?.Name ?? string.Empty,\n                Status = sub.Status,\n                BillingCycle = sub.BillingCycle,\n                CurrentPeriodStartUtc = sub.CurrentPeriodStartUtc,\n                CurrentPeriodEndUtc = sub.CurrentPeriodEndUtc,\n                TrialEndsAtUtc = sub.TrialEndsAtUtc,\n                AutoRenew = sub.AutoRenew,\n                CancelAtPeriodEnd = sub.CancelAtPeriodEnd,\n                GatewayCustomerId = sub.GatewayCustomerId,\n                GatewaySubscriptionId = sub.GatewaySubscriptionId\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Payment/Services/TaxCalculator.cs",
      "sha256": "fc3592dc1f9909a3402d232a7c85f4e0fa28adcdf2b29679f06c5d69de52003a",
      "language": "csharp",
      "size": 1602,
      "content": "#nullable enable\nusing System;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.Payment.Services\n{\n    /// <summary>\n    /// Central place for GST/tax math so rules can be updated without touching many files.\n    /// This is intentionally simple for now.\n    /// </summary>\n    public static class TaxCalculator\n    {\n        // For now: default 18% GST (update via config/feature flags later).\n        private const decimal DefaultGstRate = 0.18m;\n\n        public static (decimal taxAmount, string? breakdownJson) CalculateGstForIndianCustomer(\n            decimal taxableAmount,\n            bool isInterState)\n        {\n            if (taxableAmount <= 0)\n                return (0m, null);\n\n            var totalGst = Math.Round(taxableAmount * DefaultGstRate, 2, MidpointRounding.AwayFromZero);\n\n            // Simple split:\n            if (isInterState)\n            {\n                var igst = totalGst;\n                var breakdown = new\n                {\n                    type = \"IGST\",\n                    rate = 18,\n                    igst\n                };\n                return (totalGst, JsonSerializer.Serialize(breakdown));\n            }\n            else\n            {\n                var half = Math.Round(totalGst / 2m, 2, MidpointRounding.AwayFromZero);\n                var breakdown = new\n                {\n                    type = \"CGST_SGST\",\n                    rate = 18,\n                    cgst = half,\n                    sgst = half\n                };\n                return (totalGst, JsonSerializer.Serialize(breakdown));\n            }\n        }\n    }\n}\n\n"
    }
  ]
}
