{
  "name": "xbytechat-api/Features/Webhooks",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookAutoCleanupWorker.cs",
      "sha256": "5149c73a4fbcb11d9e501321407b1c7ae7ee660b8f7d612eca136b528f0467f2",
      "language": "csharp",
      "size": 1212,
      "content": "using xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.BackgroundWorkers\n{\n    public class WebhookAutoCleanupWorker : BackgroundService\n    {\n        private readonly ILogger<WebhookAutoCleanupWorker> _logger;\n        private readonly IServiceProvider _services;\n\n        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)\n        {\n            _services = services;\n            _logger = logger;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                using var scope = _services.CreateScope();\n                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();\n\n                if (await maintenanceService.IsAutoCleanupEnabledAsync())\n                {\n                    var count = await maintenanceService.RunCleanupAsync();\n                    _logger.LogInformation($\"üßπ Auto-cleaned {count} old webhook logs.\");\n                }\n\n                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookQueueWorker.cs",
      "sha256": "6c5ccb3f7da951f63b0828ac144f12392faabc37def6561ecfcad5a7aa253edc",
      "language": "csharp",
      "size": 3263,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\npublic class WebhookQueueWorker : BackgroundService\n{\n    private readonly IWebhookQueueService _queueService;\n    private readonly IServiceScopeFactory _scopeFactory;\n    private readonly ILogger<WebhookQueueWorker> _logger;\n\n    public WebhookQueueWorker(\n        IWebhookQueueService queueService,\n        IServiceScopeFactory scopeFactory,\n        ILogger<WebhookQueueWorker> logger)\n    {\n        _queueService = queueService;\n        _scopeFactory = scopeFactory;\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        _logger.LogInformation(\"üöÄ Webhook Queue Worker started.\");\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                // Dequeue and clone once at the edge\n                var payload = await _queueService.DequeueAsync(stoppingToken);\n                var cloned = payload.Clone(); // keep independent of pooled reader\n                var rawJson = cloned.GetRawText(); // üëà capture raw JSON up-front\n\n                using var scope = _scopeFactory.CreateScope();\n\n                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();\n                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                try\n                {\n                    await dispatcher.DispatchAsync(cloned);\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"‚ùå Error while dispatching webhook payload.\");\n                    // Persist the full raw JSON so we can replay/debug later\n                    var fallback = new FailedWebhookLogDto\n                    {\n                        SourceModule = \"WebhookQueueWorker\",\n                        FailureType = \"DispatchError\",\n                        ErrorMessage = ex.Message,\n                        RawJson = string.IsNullOrWhiteSpace(rawJson) ? \"{}\" : rawJson,\n                        CreatedAt = DateTime.UtcNow\n                    };\n                    try\n                    {\n                        await failureLogger.LogFailureAsync(fallback);\n                    }\n                    catch (Exception innerEx)\n                    {\n                        _logger.LogError(innerEx, \"‚ö†Ô∏è Failed to write to FailedWebhookLogs.\");\n                    }\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogInformation(\"üõë Graceful shutdown requested.\");\n                break;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Queue loop error (will retry shortly).\");\n                try { await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken); } catch { /* ignore */ }\n            }\n        }\n\n        _logger.LogInformation(\"üõë Webhook Queue Worker stopped.\");\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/FailedWebhookLogsController.cs",
      "sha256": "f16ada5c238d2293688a73b0c4428da7f91567d1ca100da1809f0b95ea65c2fc",
      "language": "csharp",
      "size": 1018,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/failed-webhooks\")]\n    public class FailedWebhookLogsController : ControllerBase\n    {\n        private readonly IFailedWebhookLogService _service;\n\n        public FailedWebhookLogsController(IFailedWebhookLogService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllAsync()\n        {\n            var logs = await _service.GetAllAsync();\n            return Ok(logs);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var log = await _service.GetByIdAsync(id);\n            if (log == null)\n                return NotFound();\n\n            return Ok(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/MaintenanceController.cs",
      "sha256": "2936737cca434f20b27184b1885f94a5a90a6a94453b29dc0a597b264cc6325d",
      "language": "csharp",
      "size": 3242,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks\")]\n    public class MaintenanceController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n        private readonly IMaintenanceService _maintenance;\n\n        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)\n        {\n            _context = context;\n            _maintenance = maintenance;\n        }\n\n        // ‚úÖ Injected Test Log for Dev Testing\n        [HttpPost(\"inject-test-log\")]\n        public async Task<IActionResult> InjectTestLog()\n        {\n            var testLog = new FailedWebhookLog\n            {\n                SourceModule = \"WebhookQueueWorker\",\n                FailureType = \"DispatchError\",\n                ErrorMessage = \"üß™ Simulated webhook dispatch failure for testing.\",\n                RawJson = \"{\\\"sample\\\":\\\"test_payload\\\",\\\"reason\\\":\\\"unit_test\\\"}\",\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.FailedWebhookLogs.Add(testLog);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = \"‚úÖ Injected test log successfully.\" });\n        }\n\n        // ‚úÖ Manual Cleanup Trigger\n        [HttpPost(\"cleanup-now\")]\n        public async Task<IActionResult> CleanupNow()\n        {\n            var cutoff = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(x => x.CreatedAt < cutoff)\n                .ToListAsync();\n\n            if (!oldLogs.Any())\n                return Ok(new { message = \"‚úÖ No logs to delete.\" });\n\n            _context.FailedWebhookLogs.RemoveRange(oldLogs);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = $\"‚úÖ Deleted {oldLogs.Count} old logs.\" });\n        }\n\n        // ‚úÖ Count of all failed logs\n        [HttpGet(\"failed/count\")]\n        public async Task<IActionResult> GetFailedCount()\n        {\n            var count = await _context.FailedWebhookLogs.CountAsync();\n            return Ok(count);\n        }\n\n        // ‚úÖ Cleanup Setting Status\n             [HttpGet(\"settings\")]\n        public async Task<IActionResult> GetCleanupStatus()\n        {\n            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();\n            var lastRun = await _maintenance.GetLastCleanupTimeAsync();\n\n            return Ok(new\n            {\n                enabled,\n                lastCleanupAt = lastRun\n            });\n        }\n\n        // ‚úÖ Enable Auto Cleanup\n        [HttpPost(\"enable-cleanup\")]\n        public async Task<IActionResult> EnableCleanup()\n        {\n            await _maintenance.EnableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup enabled.\" });\n        }\n\n        // ‚úÖ Disable Auto Cleanup\n        [HttpPost(\"disable-cleanup\")]\n        public async Task<IActionResult> DisableCleanup()\n        {\n            await _maintenance.DisableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup disabled.\" });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookCallback.cs",
      "sha256": "0353a97ed4f6c1349262de94a5e68f37d87955d3b6735e595aedc13f2b2f7365",
      "language": "csharp",
      "size": 2481,
      "content": "// üìÑ File: Features/Webhooks/Controllers/WebhookCallbackController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhookcallback\")]\n    public class WebhookCallbackController : ControllerBase\n    {\n        private readonly ILogger<WebhookCallbackController> _logger;\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookCallbackController(\n            ILogger<WebhookCallbackController> logger,\n            IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _queue = queue;\n        }\n\n        // ‚úÖ Single POST endpoint: Pinnacle (and others) send responses here\n        [HttpPost]\n        [Consumes(\"application/json\")]\n        [Produces(\"application/json\")]\n        public IActionResult Post([FromBody] JsonElement payload, CancellationToken ct)\n        {\n            if (!Request.HasJsonContentType())\n            {\n                return BadRequest(new { error = \"Content-Type must be application/json\" });\n            }\n\n            try\n            {\n                var raw = payload.GetRawText();\n                _logger.LogInformation(\"üì• Webhook received. bytes={Len}\", raw.Length);\n\n                // Clone JsonElement before queueing\n                _queue.Enqueue(payload.Clone());\n\n                // Return 200 OK so Pinnacle won‚Äôt retry unnecessarily\n                return Ok(new { received = true });\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Webhook processing cancelled by client.\");\n                return StatusCode(499);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue webhook payload.\");\n                // 500 lets BSP retry later\n                return StatusCode(500, new { error = \"webhook_enqueue_failed\" });\n            }\n        }\n    }\n\n    // Small helper for JSON content-type\n    internal static class HttpRequestContentTypeExtensions\n    {\n        public static bool HasJsonContentType(this HttpRequest request)\n        {\n            if (request?.ContentType is null) return false;\n            return request.ContentType.StartsWith(\"application/json\", StringComparison.OrdinalIgnoreCase);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookTestController.cs",
      "sha256": "d3d3ac0e403d42baaa151d62e86135b71a0116ed7231d86c04b87bbd4ae6ac61",
      "language": "csharp",
      "size": 1569,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/test\")]\n    public class WebhookTestController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookTestController(IWebhookQueueService queue)\n        {\n            _queue = queue;\n        }\n\n        [HttpPost(\"simulate-failure\")]\n        public IActionResult SimulateWebhookFailure()\n        {\n            var fakePayload = new\n            {\n                entry = new[]\n                {\n                    new\n                    {\n                        changes = new[]\n                        {\n                            new\n                            {\n                                value = new\n                                {\n                                    // This will cause dispatcher to throw due to invalid structure\n                                    unexpected = \"üß™ Simulated bad structure\"\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n\n            var json = JsonSerializer.Serialize(fakePayload);\n            var element = JsonDocument.Parse(json).RootElement;\n\n            _queue.Enqueue(element);\n\n            return Ok(new\n            {\n                message = \"‚úÖ Test payload enqueued to simulate failure.\",\n                enqueued = true\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WhatsAppWebhookController.cs",
      "sha256": "6a489fa99a12af0a31187296c8092809b55d45ab785448366a202341263b705f",
      "language": "csharp",
      "size": 5165,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp\")]\n    public class WhatsAppWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppWebhookController> _logger;\n        private readonly IConfiguration _config;\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IWebhookQueueService _queue;\n\n        public WhatsAppWebhookController(\n            ILogger<WhatsAppWebhookController> logger,\n            IConfiguration config,\n            AppDbContext context,\n            IWhatsAppWebhookService webhookService,\n            IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _config = config;\n            _context = context;\n            _webhookService = webhookService;\n            _queue = queue;\n        }\n\n        // ‚úÖ Step 1: Meta verification endpoint (GET)\n        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge\n        [HttpGet]\n        public IActionResult VerifyWebhook(\n            [FromQuery(Name = \"hub.mode\")] string mode,\n            [FromQuery(Name = \"hub.verify_token\")] string token,\n            [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            _logger.LogInformation(\n                \"üîé WhatsApp webhook verification request received. mode={Mode}, tokenLength={TokenLength}\",\n                mode,\n                string.IsNullOrEmpty(token) ? 0 : token.Length);\n\n            // üîê Load your secret token from config or environment.\n            // Support multiple keys for safety/backward-compat:\n            //  - WhatsApp:MetaVerifyToken  (matches your appsettings)\n            //  - WhatsApp:MetaToken        (older name)\n            //  - WhatsApp:VerifyWebHookToken (what this code was using)\n            var expectedToken = _config[\"WhatsApp:VerifyWebHookToken\"];\n\n            if (string.IsNullOrWhiteSpace(expectedToken))\n            {\n                _logger.LogError(\n                    \"‚ùå WhatsApp webhook verification failed: no verify token configured. \" +\n                    \"Set WhatsApp:MetaVerifyToken (or WhatsApp:MetaToken / WhatsApp:VerifyWebHookToken) in configuration.\");\n                return Forbid(\"Server verify token not configured.\");\n            }\n\n            if (mode == \"subscribe\" && token == expectedToken)\n            {\n                _logger.LogInformation(\"‚úÖ WhatsApp webhook verified successfully.\");\n                return Ok(challenge); // Meta expects a 200 OK with the challenge value\n            }\n\n            _logger.LogWarning(\n                \"‚ùå WhatsApp webhook verification failed. Mode={Mode}, token did not match configured value.\",\n                mode);\n            return Forbid(\"Token mismatch.\");\n        }\n\n        //[HttpPost]\n        //public IActionResult HandleStatus([FromBody] JsonElement payload)\n        //{\n        //    try\n        //    {\n        //        // Log that we actually got a POST. This is what we care about for inbound messages.\n        //        var bodyString = payload.ToString();\n        //        _logger.LogInformation(\n        //            \"üì• WhatsApp webhook POST received at controller. Payload length={Length} chars.\",\n        //            bodyString?.Length ?? 0);\n\n        //        // Important: clone before enqueue\n        //        var cloned = payload.Clone();\n        //        _queue.Enqueue(cloned);\n\n        //        _logger.LogInformation(\"üì• Webhook payload enqueued successfully.\");\n        //        return Ok(new { received = true });\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"‚ùå Failed to enqueue WhatsApp webhook payload.\");\n        //        return StatusCode(500, new { error = \"Webhook queue failed\" });\n        //    }\n        //}\n\n        [HttpPost]\n        public IActionResult HandleStatus([FromBody] JsonElement payload)\n        {\n            try\n            {\n                var bodyString = payload.ToString();\n\n                _logger.LogInformation(\n                    \"üì• WhatsApp webhook POST received. Path={Path}, Query={Query}, Length={Length} chars.\",\n                    HttpContext.Request.Path,\n                    HttpContext.Request.QueryString.ToString(),\n                    bodyString?.Length ?? 0\n                );\n\n                var cloned = payload.Clone();\n                _queue.Enqueue(cloned);\n\n                _logger.LogInformation(\"üì• Webhook payload enqueued successfully.\");\n                return Ok(new { received = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue WhatsApp webhook payload.\");\n                return StatusCode(500, new { error = \"Webhook queue failed\" });\n            }\n        }\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/IProviderDirectory.cs",
      "sha256": "9c5e07f8d7488efd67624a5d0b04fe85acf0163688ba6a704f500383e17210d4",
      "language": "csharp",
      "size": 995,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// Resolves BusinessId from provider-specific webhook identifiers.\n    /// </summary>\n    public interface IProviderDirectory\n    {\n        /// <param name=\"provider\">\"meta\" or \"pinnacle\" (lowercase preferred)</param>\n        /// <param name=\"phoneNumberId\">Meta/Pinnacle phone_number_id (strongest key)</param>\n        /// <param name=\"displayPhoneNumber\">Formatted sending number (e.g. \"+91XXXXXXXXXX\")</param>\n        /// <param name=\"wabaId\">WhatsApp Business Account ID (Meta)</param>\n        /// <param name=\"waId\">Optional WA ID (recipient); used only as a last-ditch heuristic</param>\n        Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/ProviderDirectory.cs",
      "sha256": "1cecb32490d67fedaecdd7772fac54b530f8ac1d2225f7889c32c43c5584df2b",
      "language": "csharp",
      "size": 6767,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// EF-backed resolver for mapping provider identifiers to BusinessId, with a short cache.\n    /// </summary>\n    public class ProviderDirectory : IProviderDirectory\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ProviderDirectory> _logger;\n        private readonly IMemoryCache _cache;\n\n        // reduce DB hits during webhook bursts\n        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(2);\n\n        public ProviderDirectory(AppDbContext db, ILogger<ProviderDirectory> logger, IMemoryCache cache)\n        {\n            _db = db;\n            _logger = logger;\n            _cache = cache;\n        }\n        private static string NormalizeProviderKey(string? raw)\n        {\n            var p = (raw ?? \"\").Trim().ToLowerInvariant();\n            return p switch\n            {\n                \"meta\" or \"meta-cloud\" or \"meta_cloud\" => \"meta_cloud\",\n                \"pinnacle\" => \"pinnacle\",\n                _ => p\n            };\n        }\n        public async Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default)\n        {\n            provider = NormalizeProviderKey(provider);\n            if (provider is \"meta\" or \"meta-cloud\") provider = \"meta_cloud\";\n            var cacheKey = $\"provdir:{provider}:{phoneNumberId}:{Normalize(displayPhoneNumber)}:{wabaId}\";\n            if (_cache.TryGetValue<Guid?>(cacheKey, out var cached))\n                return cached;\n\n            try\n            {\n                // ‚öì 1) Strongest match: provider + phone_number_id\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var hit = await QueryByAsync(provider, phoneNumberId: phoneNumberId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ‚öì 2) Next: provider + display_phone_number (normalized)\n                var normalizedDisplay = Normalize(displayPhoneNumber);\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(normalizedDisplay))\n                {\n                    var hit = await QueryByAsync(provider, displayPhoneNumber: normalizedDisplay, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ‚öì 3) Next: provider + wabaId (Meta)\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(wabaId))\n                {\n                    var hit = await QueryByAsync(provider, wabaId: wabaId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                _logger.LogWarning(\n                    \"ProviderDirectory: No match for provider={Provider}, pnid={PhoneId}, disp={Display}, waba={Waba}\",\n                    provider, phoneNumberId, normalizedDisplay, wabaId\n                );\n                return CacheAndReturn(cacheKey, null);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ProviderDirectory lookup failed.\");\n                return null;\n            }\n        }\n\n        private Guid? CacheAndReturn(string key, Guid? value)\n        {\n            _cache.Set(key, value, CacheTtl);\n            return value;\n        }\n\n        /// <summary>\n        /// Centralized query; now materializes candidates so Normalize() runs in-memory.\n        /// </summary>\n        private async Task<Guid?> QueryByAsync(\n         string provider,\n         string? phoneNumberId = null,\n         string? displayPhoneNumber = null,\n         string? wabaId = null,\n         CancellationToken ct = default)\n        {\n            // Canonical provider (we always store in DB as CAPS)\n            provider = (provider ?? string.Empty)\n                .Trim()\n                .Replace(\"-\", \"_\")\n                .Replace(\" \", \"_\")\n                .ToUpperInvariant();\n\n            if (provider is not (\"PINNACLE\" or \"META_CLOUD\"))\n                return null;\n\n            var normDisp = Normalize(displayPhoneNumber); // your existing normalization (digits-only etc.)\n\n            // 1) Prefer exact match by sender (PhoneNumberId or display number) from WhatsAppPhoneNumbers\n            if (!string.IsNullOrWhiteSpace(phoneNumberId) || !string.IsNullOrWhiteSpace(normDisp))\n            {\n                var byNumber = await _db.WhatsAppPhoneNumbers\n                    .AsNoTracking()\n                    .Where(n => n.Provider == provider)\n                    .Where(n =>\n                        (!string.IsNullOrWhiteSpace(phoneNumberId) && n.PhoneNumberId == phoneNumberId) ||\n                        (!string.IsNullOrWhiteSpace(normDisp) && Normalize(n.WhatsAppBusinessNumber) == normDisp))\n                    .OrderByDescending(n => n.IsDefault)\n                    .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                    .Select(n => (Guid?)n.BusinessId)\n                    .FirstOrDefaultAsync(ct);\n\n                if (byNumber.HasValue)\n                    return byNumber;\n            }\n\n            // 2) Fallback: match by WABA on the settings row (still lives on settings)\n            if (!string.IsNullOrWhiteSpace(wabaId))\n            {\n                var byWaba = await _db.WhatsAppSettings\n                    .AsNoTracking()\n                    .Where(s => s.IsActive\n                                && s.Provider.ToUpper() == provider\n                                && s.WabaId == wabaId)\n                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                    .Select(s => (Guid?)s.BusinessId)\n                    .FirstOrDefaultAsync(ct);\n\n                if (byWaba.HasValue)\n                    return byWaba;\n            }\n\n            return null;\n        }\n\n        /// <summary>\n        /// Normalize phone formatting for robust comparisons.\n        /// </summary>\n        private static string? Normalize(string? phone)\n        {\n            if (string.IsNullOrWhiteSpace(phone)) return null;\n            var trimmed = phone.Trim();\n            var hasPlus = trimmed.StartsWith(\"+\");\n            var digits = new string(trimmed.Where(char.IsDigit).ToArray());\n            return hasPlus ? \"+\" + digits : digits;\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/DTOs/FailedWebhookLogDto.cs",
      "sha256": "6b14d817a983f7eb6626a70cc5aceedd50b164ce0e0282dcf155a1d6eb4b5a51",
      "language": "csharp",
      "size": 391,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.DTOs\n{\n    public class FailedWebhookLogDto\n    {\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; }\n        public string? FailureType { get; set; }\n        public string RawJson { get; set; } = string.Empty;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/MakeDump.bat",
      "sha256": "1f0c8a79e7859146dab81f8a13dcdf495c12b54b888024e8500fefb4abd58a9e",
      "language": "bat",
      "size": 1618,
      "content": "@echo off\nREM This script will find relevant source files and output their names and contents into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh and write a small header\n> \"%outputFile%\" (\n    echo Folder and File Content Report\n    echo Root folder: %cd%\n    echo Generated at: %date% %time%\n)\necho. >> \"%outputFile%\"\n\nREM NOTE:\nREM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)\nREM This keeps the file smaller and much easier to review.\n\nREM Loop through all relevant files in the current directory and subdirectories\nREM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML\nfor /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (\n\n    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)\n    echo \"%%F\" | findstr /I /C:\"\\node_modules\\\" /C:\"\\bin\\\" /C:\"\\obj\\\" /C:\"\\.git\\\" /C:\"\\dist\\\" /C:\"\\.vs\\\" >nul\n    if errorlevel 1 (\n        echo ====================================================== >> \"%outputFile%\"\n        echo FILE: %%F >> \"%outputFile%\"\n        echo ====================================================== >> \"%outputFile%\"\n        echo. >> \"%outputFile%\"\n        type \"%%F\" >> \"%outputFile%\" 2>nul\n        echo. >> \"%outputFile%\"\n        echo. >> \"%outputFile%\"\n    )\n)\n\necho Finished! All content has been extracted to %outputFile%\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/FailedWebhookLog.cs",
      "sha256": "549e466af9a80b67809dd9e25d2bf5b9b5991ce11754225bda46dac4df1e6da6",
      "language": "csharp",
      "size": 624,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.Models\n{\n    public class FailedWebhookLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üß† Debug Metadata\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor\n        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED\n\n        // üì¶ Raw Data Snapshot\n        public string RawJson { get; set; } = string.Empty;\n\n        // üïí Timeline\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/WebhookSettings.cs",
      "sha256": "c0eeeaa5e14f839b159f28d337450f595c7604994690c66fa7df82a56c6a3093",
      "language": "csharp",
      "size": 267,
      "content": "namespace xbytechat.api.Features.Webhooks.Models\n{\n    public class WebhookSettings\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public bool AutoCleanupEnabled { get; set; } = true;\n        public DateTime? LastCleanupAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Controllers/PinnacleWebhookController.cs",
      "sha256": "347412f9e7ce91e2e2852339fcb267da0f2153f38df4bfe8902a1f0b4a678ca8",
      "language": "csharp",
      "size": 1235,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Controllers\n{\n    [ApiController]\n    [Route(\"api/pinnacle/callback\")]\n    public sealed class PinnacleWebhookController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n        private readonly IPinnacleToMetaAdapter _adapter;\n        private readonly ILogger<PinnacleWebhookController> _logger;\n\n        public PinnacleWebhookController(IWebhookQueueService queue, IPinnacleToMetaAdapter adapter, ILogger<PinnacleWebhookController> logger)\n        {\n            _queue = queue;\n            _adapter = adapter;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        public IActionResult Post([FromBody] JsonElement body)\n        {\n            // Transform to the envelope WhatsAppWebhookDispatcher already expects\n            var metaEnvelope = _adapter.ToMetaEnvelope(body);\n            _queue.Enqueue(metaEnvelope);\n            _logger.LogInformation(\"üì® Pinnacle payload transformed and enqueued.\");\n            return Ok(new { received = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/IPinnacleToMetaAdapter.cs",
      "sha256": "7daf100e2d244ce83b0c3f91f8e006bce5359eddf8fe6f7cf2b046f9e071c17b",
      "language": "csharp",
      "size": 364,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters\n{\n    public interface IPinnacleToMetaAdapter\n    {\n        /// <summary>Converts provider-native payload to Meta-like envelope:\n        /// { \"entry\":[{ \"changes\":[{ \"value\": { ... } }]}] }</summary>\n        JsonElement ToMetaEnvelope(JsonElement pinnPayload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/PinnacleToMetaAdapter.cs",
      "sha256": "38b4863c5f4881b2196ae42ce86a47b8d92904a61daad400ab8d1e7e5db2d289",
      "language": "csharp",
      "size": 9751,
      "content": "using System.Buffers;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\n\npublic sealed class PinnacleToMetaAdapter : IPinnacleToMetaAdapter\n{\n    public JsonElement ToMetaEnvelope(JsonElement p)\n    {\n        var buf = new ArrayBufferWriter<byte>();\n        using var w = new Utf8JsonWriter(buf);\n\n        w.WriteStartObject();\n        w.WritePropertyName(\"entry\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // entry[0]\n        w.WritePropertyName(\"changes\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // changes[0]\n        w.WritePropertyName(\"value\");\n        w.WriteStartObject();\n\n        // NEW: try to emit metadata up-front (harmless if not found)\n        WriteMetadata(p, w);\n\n        if (!TryMapStatuses(p, w) && !TryMapMessages(p, w))\n        {\n            w.WritePropertyName(\"provider_raw\");\n            p.WriteTo(w);\n        }\n\n        w.WriteEndObject(); // value\n        w.WriteEndObject(); // change\n        w.WriteEndArray();  // changes\n        w.WriteEndObject(); // entry[0]\n        w.WriteEndArray();  // entry\n        w.WriteEndObject(); // root\n        w.Flush();\n\n        var ros = new ReadOnlySequence<byte>(buf.WrittenMemory);\n        using var doc = JsonDocument.Parse(ros);\n        return doc.RootElement.Clone();\n    }\n\n    // ---- NEW ----\n    // Best-effort extraction; tolerate any Pinnacle layout you have.\n    // We only write fields if we can resolve them.\n    private static void WriteMetadata(JsonElement p, Utf8JsonWriter w)\n    {\n        string? displayPhone = null;\n        string? phoneNumberId = null;\n        string? wabaId = null;\n\n        // common guesses; add/rename to match your Pinnacle payload\n        // 1) flat\n        if (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) displayPhone = d1.GetString();\n        if (p.TryGetProperty(\"phone_number_id\", out var pid1) && pid1.ValueKind == JsonValueKind.String) phoneNumberId = pid1.GetString();\n        if (p.TryGetProperty(\"waba_id\", out var wa1) && wa1.ValueKind == JsonValueKind.String) wabaId = wa1.GetString();\n\n        // 2) channel\n        if (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && ch.TryGetProperty(\"display_phone_number\", out var d2) && d2.ValueKind == JsonValueKind.String) displayPhone = d2.GetString();\n            if (displayPhone is null && ch.TryGetProperty(\"phone\", out var d3) && d3.ValueKind == JsonValueKind.String) displayPhone = d3.GetString();\n\n            if (phoneNumberId is null && ch.TryGetProperty(\"phone_number_id\", out var pid2) && pid2.ValueKind == JsonValueKind.String) phoneNumberId = pid2.GetString();\n            if (phoneNumberId is null && ch.TryGetProperty(\"id\", out var pid3) && pid3.ValueKind == JsonValueKind.String) phoneNumberId = pid3.GetString();\n\n            if (wabaId is null && ch.TryGetProperty(\"waba_id\", out var wa2) && wa2.ValueKind == JsonValueKind.String) wabaId = wa2.GetString();\n        }\n\n        // 3) meta-style wrapper\n        if (p.TryGetProperty(\"metadata\", out var meta) && meta.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && meta.TryGetProperty(\"display_phone_number\", out var d4) && d4.ValueKind == JsonValueKind.String) displayPhone = d4.GetString();\n            if (phoneNumberId is null && meta.TryGetProperty(\"phone_number_id\", out var pid4) && pid4.ValueKind == JsonValueKind.String) phoneNumberId = pid4.GetString();\n            if (wabaId is null && meta.TryGetProperty(\"waba_id\", out var wa3) && wa3.ValueKind == JsonValueKind.String) wabaId = wa3.GetString();\n        }\n\n        if (displayPhone is null && p.TryGetProperty(\"business\", out var biz) && biz.ValueKind == JsonValueKind.Object)\n        {\n            if (biz.TryGetProperty(\"phone\", out var d5) && d5.ValueKind == JsonValueKind.String) displayPhone = d5.GetString();\n            if (biz.TryGetProperty(\"phone_id\", out var pid5) && pid5.ValueKind == JsonValueKind.String) phoneNumberId = pid5.GetString();\n        }\n\n        // Only emit if we have at least one of them.\n        if (displayPhone is not null || phoneNumberId is not null || wabaId is not null)\n        {\n            w.WritePropertyName(\"metadata\");\n            w.WriteStartObject();\n            if (displayPhone is not null) w.WriteString(\"display_phone_number\", displayPhone);\n            if (phoneNumberId is not null) w.WriteString(\"phone_number_id\", phoneNumberId);\n            if (wabaId is not null) w.WriteString(\"waba_id\", wabaId);\n            w.WriteEndObject();\n        }\n    }\n    // ---- NEW END ----\n\n    private static bool TryMapStatuses(JsonElement p, Utf8JsonWriter w)\n    {\n        string? id = null, status = null;\n        long? ts = null;\n\n        if (p.TryGetProperty(\"messageId\", out var mid) && mid.ValueKind == JsonValueKind.String) id = mid.GetString();\n        if (p.TryGetProperty(\"id\", out var pid) && pid.ValueKind == JsonValueKind.String) id ??= pid.GetString();\n        if (p.TryGetProperty(\"status\", out var st) && st.ValueKind == JsonValueKind.String) status = st.GetString();\n\n        if (p.TryGetProperty(\"timestamp\", out var t))\n        {\n            if (t.ValueKind == JsonValueKind.Number) ts = t.GetInt64();\n            else if (t.ValueKind == JsonValueKind.String && long.TryParse(t.GetString(), out var n)) ts = n;\n        }\n\n        if (p.TryGetProperty(\"data\", out var d) && d.ValueKind == JsonValueKind.Object)\n        {\n            if (id is null && d.TryGetProperty(\"id\", out var did) && did.ValueKind == JsonValueKind.String) id = did.GetString();\n            if (status is null && d.TryGetProperty(\"status\", out var ds) && ds.ValueKind == JsonValueKind.String) status = ds.GetString();\n            if (ts is null && d.TryGetProperty(\"ts\", out var dts) && dts.ValueKind == JsonValueKind.Number) ts = dts.GetInt64();\n        }\n\n        if (id is null || status is null) return false;\n\n        w.WritePropertyName(\"statuses\");\n        w.WriteStartArray();\n        w.WriteStartObject();\n        w.WriteString(\"id\", id);\n        w.WriteString(\"status\", status);\n        if (ts.HasValue) w.WriteNumber(\"timestamp\", ts.Value);\n        w.WriteEndObject();\n        w.WriteEndArray();\n        return true;\n    }\n\n    \n    private static bool TryMapMessages(JsonElement p, Utf8JsonWriter w)\n    {\n        // { \"click\": { \"title\":\"Flow Test\", \"contextId\":\"wamid..\", \"from\":\"<biz_phone?>\" , \"user\":\"<customer_wa_id?>\" } }\n        if (p.TryGetProperty(\"click\", out var c) && c.ValueKind == JsonValueKind.Object)\n        {\n            var title = c.TryGetProperty(\"title\", out var t) ? t.GetString() : null;\n            var ctxId = c.TryGetProperty(\"contextId\", out var ctx) ? ctx.GetString() : null;\n\n            // customer who clicked\n            var customerFrom = c.TryGetProperty(\"user\", out var u) && u.ValueKind == JsonValueKind.String\n                ? u.GetString()\n                : (c.TryGetProperty(\"from\", out var f1) && f1.ValueKind == JsonValueKind.String ? f1.GetString() : null);\n\n            // **business** number that sent the message (Meta provides this as context.from)\n            var businessFrom =\n                (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) ? d1.GetString() :\n                (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object &&\n                 ch.TryGetProperty(\"phone\", out var d2) && d2.ValueKind == JsonValueKind.String) ? d2.GetString() :\n                (c.TryGetProperty(\"from\", out var f2) && f2.ValueKind == JsonValueKind.String ? f2.GetString() : null); // last resort\n\n            if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(ctxId))\n            {\n                w.WritePropertyName(\"messages\");\n                w.WriteStartArray();\n                w.WriteStartObject();\n                w.WriteString(\"type\", \"button\");\n                w.WriteString(\"from\", customerFrom ?? \"\");          // customer wa_id\n                w.WritePropertyName(\"button\");\n                w.WriteStartObject();\n                w.WriteString(\"text\", title!);\n                w.WriteEndObject();\n                w.WritePropertyName(\"context\");\n                w.WriteStartObject();\n                w.WriteString(\"id\", ctxId!);\n                if (!string.IsNullOrWhiteSpace(businessFrom))\n                    w.WriteString(\"from\", businessFrom!);           // **important for directory resolution**\n                w.WriteEndObject();\n                w.WriteEndObject();\n                w.WriteEndArray();\n                return true;\n            }\n        }\n\n        // { \"message\": { \"from\":\"<customer_wa_id>\", \"body\":\"hi\", \"type\":\"text\" }, \"channel\":{ \"phone\":\"<biz_phone>\" } }\n        if (p.TryGetProperty(\"message\", out var m) && m.ValueKind == JsonValueKind.Object)\n        {\n            var type = m.TryGetProperty(\"type\", out var tp) ? tp.GetString() : \"text\";\n            var from = m.TryGetProperty(\"from\", out var fr) ? fr.GetString() : \"\";\n\n            w.WritePropertyName(\"messages\");\n            w.WriteStartArray();\n            w.WriteStartObject();\n            w.WriteString(\"type\", type ?? \"text\");\n            w.WriteString(\"from\", from ?? \"\");\n            if ((type ?? \"text\") == \"text\")\n            {\n                var body = m.TryGetProperty(\"body\", out var bd) ? bd.GetString() : \"\";\n                w.WritePropertyName(\"text\");\n                w.WriteStartObject();\n                w.WriteString(\"body\", body ?? \"\");\n                w.WriteEndObject();\n            }\n            w.WriteEndObject();\n            w.WriteEndArray();\n            return true;\n        }\n\n        return false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogCleanupService.cs",
      "sha256": "c826dbce9f60dfadb71a401a0ce48f0f5e9039181f5a18b115be558e0be38b9e",
      "language": "csharp",
      "size": 3798,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    /// <summary>\n    /// Periodic cleanup of old failed webhook logs.\n    /// Runs as a background service and exits cleanly on shutdown.\n    /// </summary>\n    public sealed class FailedWebhookLogCleanupService : BackgroundService\n    {\n        private readonly ILogger<FailedWebhookLogCleanupService> _logger;\n        private readonly IServiceScopeFactory _scopeFactory;\n        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run\n\n        public FailedWebhookLogCleanupService(\n            ILogger<FailedWebhookLogCleanupService> logger,\n            IServiceScopeFactory scopeFactory)\n        {\n            _logger = logger;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _logger.LogInformation(\"üßπ FailedWebhookLogCleanupService started.\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    // If shutdown requested, bail out before touching DI / DbContext\n                    stoppingToken.ThrowIfCancellationRequested();\n\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var cutoff = DateTime.UtcNow.AddDays(-7);\n\n                    var oldLogs = await db.FailedWebhookLogs\n                        .Where(x => x.CreatedAt < cutoff)\n                        .ToListAsync(stoppingToken);\n\n                    if (oldLogs.Count > 0)\n                    {\n                        db.FailedWebhookLogs.RemoveRange(oldLogs);\n                        await db.SaveChangesAsync(stoppingToken);\n                        _logger.LogInformation(\n                            \"üßπ Deleted {Count} old failed webhook logs.\",\n                            oldLogs.Count\n                        );\n                    }\n                }\n                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)\n                {\n                    // Normal shutdown ‚Äì just break the loop\n                    _logger.LogDebug(\n                        \"FailedWebhookLogCleanupService cancellation requested, exiting loop.\"\n                    );\n                    break;\n                }\n                catch (ObjectDisposedException) when (stoppingToken.IsCancellationRequested)\n                {\n                    // DI container / DbContext got disposed during shutdown; safe to ignore\n                    _logger.LogDebug(\n                        \"AppDbContext/ServiceProvider disposed during shutdown in FailedWebhookLogCleanupService.\"\n                    );\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"‚ùå Failed to clean up old webhook logs.\");\n                }\n\n                try\n                {\n                    await Task.Delay(_interval, stoppingToken);\n                }\n                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)\n                {\n                    _logger.LogDebug(\n                        \"FailedWebhookLogCleanupService delay cancelled, exiting loop.\"\n                    );\n                    break;\n                }\n            }\n\n            _logger.LogInformation(\"üõë FailedWebhookLogCleanupService stopped.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogService.cs",
      "sha256": "3da6a5ad043773f7684b6ea9bc208441cbc36a7e53f01eacdd7c17848118c2af",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogService : IFailedWebhookLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<FailedWebhookLogService> _logger;\n\n        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogFailureAsync(FailedWebhookLogDto dto)\n        {\n            try\n            {\n                var log = new FailedWebhookLog\n                {\n                    ErrorMessage = dto.ErrorMessage,\n                    SourceModule = dto.SourceModule,\n                    FailureType = dto.FailureType,\n                    RawJson = dto.RawJson,\n                    CreatedAt = dto.CreatedAt\n                };\n\n                await _context.FailedWebhookLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to persist webhook error log\");\n            }\n        }\n\n        public async Task<List<FailedWebhookLog>> GetAllAsync()\n        {\n            return await _context.FailedWebhookLogs\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100) // prevent DB overload\n                .ToListAsync();\n        }\n\n        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)\n        {\n            return await _context.FailedWebhookLogs.FindAsync(id);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IFailedWebhookLogService.cs",
      "sha256": "9366c7a087317049e7dee346a65f7ea81a76fe95fb98fe21ca457e0ed5db6a7c",
      "language": "csharp",
      "size": 396,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IFailedWebhookLogService\n    {\n        Task LogFailureAsync(FailedWebhookLogDto dto);\n        Task<List<FailedWebhookLog>> GetAllAsync();\n        Task<FailedWebhookLog?> GetByIdAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IMaintenanceService.cs",
      "sha256": "76ef1df941e3536bbdce5e7213554b593e6431592ba6527334cf274c78357e26",
      "language": "csharp",
      "size": 323,
      "content": "namespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IMaintenanceService\n    {\n        Task<bool> IsAutoCleanupEnabledAsync();\n        Task EnableAutoCleanupAsync();\n        Task DisableAutoCleanupAsync();\n        Task<DateTime?> GetLastCleanupTimeAsync();\n        Task<int> RunCleanupAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWebhookQueueService.cs",
      "sha256": "34e2e37f5ba5da57159852cecd9adde2f085640e1eb55a67116b5381ffa2e4b0",
      "language": "csharp",
      "size": 333,
      "content": "using System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWebhookQueueService\n    {\n        void Enqueue(JsonElement payload);\n        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);\n        int GetQueueLength();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookDispatcher.cs",
      "sha256": "844865d879bca5e59aa9d82cf7fabfb3ac241233391ca0544922a8902eed4a88",
      "language": "csharp",
      "size": 219,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookDispatcher\n    {\n        Task DispatchAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookService.cs",
      "sha256": "98275195ef353afc44e2ca27e1d7568450de21c0389a303b863809eee790fa99",
      "language": "csharp",
      "size": 302,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookService\n    {\n        Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default);\n   \n    \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/MaintenanceService.cs",
      "sha256": "c8c7e803e34fb97d2edfbaaf824d332f8de8b1483327e364e63d68dd0082a20e",
      "language": "csharp",
      "size": 2411,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class MaintenanceService : IMaintenanceService\n    {\n        private readonly AppDbContext _context;\n\n        public MaintenanceService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> IsAutoCleanupEnabledAsync()\n        {\n            var setting = await _context.WebhookSettings\n                .AsNoTracking()\n                .FirstOrDefaultAsync();\n\n            return setting?.AutoCleanupEnabled ?? false;\n        }\n\n        public async Task<DateTime?> GetLastCleanupTimeAsync()\n        {\n            return await _context.WebhookSettings\n                .AsNoTracking()\n                .Select(s => s.LastCleanupAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task EnableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = true;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task DisableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = false;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<int> RunCleanupAsync()\n        {\n            var threshold = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(l => l.CreatedAt < threshold)\n                .ToListAsync();\n\n            if (oldLogs.Any())\n                _context.FailedWebhookLogs.RemoveRange(oldLogs);\n\n            var setting = await GetOrCreateAsync();\n            setting.LastCleanupAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return oldLogs.Count;\n        }\n\n        private async Task<WebhookSettings> GetOrCreateAsync()\n        {\n            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();\n            if (setting == null)\n            {\n                setting = new WebhookSettings\n                {\n                    AutoCleanupEnabled = false,\n                    LastCleanupAt = null\n                };\n                _context.WebhookSettings.Add(setting);\n                await _context.SaveChangesAsync();\n            }\n            return setting;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ClickWebhookProcessor.cs",
      "sha256": "d671d0c6e0db79b3904b2158458240996c68de79a8be159c0788011d48b1ddf3",
      "language": "csharp",
      "size": 76214,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO.Pipelines;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.CustomeApi.Models;\nusing xbytechat.api.Features.CustomeApi.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared.TrackingUtils;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class ClickWebhookProcessor : IClickWebhookProcessor\n    {\n        private readonly ILogger<ClickWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly ITrackingService _trackingService;\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ICTAFlowService _flowService;\n        private readonly IFlowRuntimeService _flowRuntime;\n        private readonly IContactProfileService _contactProfile;\n        private readonly ICtaJourneyPublisher _journeyPublisher;\n        public ClickWebhookProcessor(\n            ILogger<ClickWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            ITrackingService trackingService,\n            AppDbContext context,\n            IMessageEngineService messageEngine,\n            ICTAFlowService flowService,\n                        IFlowRuntimeService flowRuntime,\n                         IContactProfileService contactProfile,\n                          ICtaJourneyPublisher journeyPublisher\n            )\n        {\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _trackingService = trackingService;\n            _context = context;\n            _messageEngine = messageEngine;\n            _flowService = flowService;\n            _flowRuntime = flowRuntime;\n            _contactProfile = contactProfile;\n            _journeyPublisher = journeyPublisher;\n\n        }\n\n        // working code\n\n        //public async Task ProcessClickAsync(JsonElement value)\n        //{\n        //    _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n        //    try\n        //    {\n        //        if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n        //            return;\n\n        //        static string Norm(string? s)\n        //        {\n        //            if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n        //            return string.Join(' ', s.Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries))\n        //                         .Trim()\n        //                         .ToLowerInvariant();\n        //        }\n\n        //        // ‚úÖ Canonical phone: keep only digits (matches how we store & search contacts)\n        //        static string NormalizePhone(string? raw)\n        //            => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());\n\n        //        // ‚úÖ contacts[0].profile.name (Meta shape)\n        //        static string? TryGetProfileName(JsonElement root)\n        //        {\n        //            if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n        //                contactsEl.ValueKind == JsonValueKind.Array &&\n        //                contactsEl.GetArrayLength() > 0)\n        //            {\n        //                var c0 = contactsEl[0];\n        //                if (c0.TryGetProperty(\"profile\", out var profEl) &&\n        //                    profEl.ValueKind == JsonValueKind.Object &&\n        //                    profEl.TryGetProperty(\"name\", out var nameEl) &&\n        //                    nameEl.ValueKind == JsonValueKind.String)\n        //                {\n        //                    var n = nameEl.GetString();\n        //                    return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n        //                }\n        //            }\n        //            return null;\n        //        }\n\n        //        // >>> BEGIN MOD: helpers for CTAJourney key + botId extraction\n        //        static string ToKey(string? s)\n        //        {\n        //            if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n        //            var t = s.Trim().ToLowerInvariant();\n        //            var sb = new System.Text.StringBuilder(t.Length);\n        //            foreach (var ch in t)\n        //            {\n        //                if (char.IsLetterOrDigit(ch)) sb.Append(ch);\n        //                else if (char.IsWhiteSpace(ch) || ch == '-' || ch == '_' || ch == '.') sb.Append('_');\n        //            }\n        //            var k = sb.ToString().Trim('_');\n        //            return string.IsNullOrEmpty(k) ? \"unknown\" : k;\n        //        }\n\n        //        // read WA display number once (used as botId)\n        //        string botIdFromWebhook = \"\";\n        //        if (value.TryGetProperty(\"metadata\", out var md) &&\n        //            md.TryGetProperty(\"display_phone_number\", out var dpnEl) &&\n        //            dpnEl.ValueKind == JsonValueKind.String)\n        //        {\n        //            botIdFromWebhook = NormalizePhone(dpnEl.GetString());\n        //        }\n        //        // >>> END MOD\n\n        //        foreach (var msg in messages.EnumerateArray())\n        //        {\n        //            if (!msg.TryGetProperty(\"type\", out var typeProp))\n        //                continue;\n\n        //            var type = typeProp.GetString();\n\n        //            string? clickMessageId = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n        //            string? originalMessageId = msg.TryGetProperty(\"context\", out var ctx) && ctx.TryGetProperty(\"id\", out var ctxId)\n        //                ? ctxId.GetString()\n        //                : null;\n        //            var fromRaw = msg.TryGetProperty(\"from\", out var fromProp) ? (fromProp.GetString() ?? \"\") : \"\";\n        //            var fromDigits = NormalizePhone(fromRaw);\n\n        //            // ‚Äî‚Äî‚Äî button label extraction\n        //            string? buttonText = null;\n        //            if (string.Equals(type, \"button\", StringComparison.OrdinalIgnoreCase))\n        //            {\n        //                buttonText = msg.TryGetProperty(\"button\", out var btn) &&\n        //                             btn.TryGetProperty(\"text\", out var textProp)\n        //                               ? textProp.GetString()?.Trim()\n        //                               : null;\n        //            }\n        //            else if (string.Equals(type, \"interactive\", StringComparison.OrdinalIgnoreCase) &&\n        //                     msg.TryGetProperty(\"interactive\", out var interactive))\n        //            {\n        //                if (interactive.TryGetProperty(\"type\", out var intrType) &&\n        //                    string.Equals(intrType.GetString(), \"button_reply\", StringComparison.OrdinalIgnoreCase) &&\n        //                    interactive.TryGetProperty(\"button_reply\", out var br) &&\n        //                    br.TryGetProperty(\"title\", out var titleProp))\n        //                {\n        //                    buttonText = titleProp.GetString()?.Trim();\n        //                }\n        //                else if (interactive.TryGetProperty(\"list_reply\", out var lr) &&\n        //                         lr.TryGetProperty(\"title\", out var listTitleProp))\n        //                {\n        //                    buttonText = listTitleProp.GetString()?.Trim();\n        //                }\n        //            }\n\n        //            if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))\n        //            {\n        //                _logger.LogDebug(\"‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}\", type);\n        //                continue;\n        //            }\n\n        //            _logger.LogInformation(\"üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n        //                fromDigits, clickMessageId, originalMessageId, buttonText);\n\n        //            // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)\n        //            var origin = await _context.MessageLogs\n        //                .AsNoTracking()\n        //                .FirstOrDefaultAsync(m =>\n        //                    m.MessageId == originalMessageId &&\n        //                    m.CTAFlowConfigId != null &&\n        //                    m.CTAFlowStepId != null);\n\n        //            Guid businessId;\n        //            Guid flowId;\n        //            Guid stepId;\n        //            string? bundleJson = null;\n        //            int? flowVersion = null;\n\n        //            Guid? campaignSendLogId = null; // link the click to the shown message\n        //            Guid? runId = null;             // copy from parent CSL when available\n\n        //            if (origin != null)\n        //            {\n        //                businessId = origin.BusinessId;\n        //                flowId = origin.CTAFlowConfigId!.Value;\n        //                stepId = origin.CTAFlowStepId!.Value;\n        //                bundleJson = origin.ButtonBundleJson;\n        //                flowVersion = origin.FlowVersion;\n\n        //                // Map back to CSL via MessageLogId or WAMID and fetch RunId\n        //                var cslInfo = await _context.CampaignSendLogs\n        //                    .AsNoTracking()\n        //                    .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))\n        //                    .OrderByDescending(csl => csl.CreatedAt)\n        //                    .Select(csl => new { csl.Id, csl.RunId })\n        //                    .FirstOrDefaultAsync();\n\n        //                campaignSendLogId = cslInfo?.Id;\n        //                runId = cslInfo?.RunId;\n        //            }\n        //            else\n        //            {\n        //                // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)\n        //                var sendLog = await _context.CampaignSendLogs\n        //                    .Include(sl => sl.Campaign)\n        //                    .AsNoTracking()\n        //                    .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);\n\n        //                if (sendLog == null)\n        //                {\n        //                    _logger.LogWarning(\"‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                businessId = sendLog.BusinessId != Guid.Empty\n        //                    ? sendLog.BusinessId\n        //                    : (sendLog.Campaign?.BusinessId ?? Guid.Empty);\n\n        //                if (businessId == Guid.Empty)\n        //                {\n        //                    _logger.LogWarning(\"‚ùå Could not resolve BusinessId for WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                campaignSendLogId = sendLog.Id;\n        //                runId = sendLog.RunId;\n\n        //                if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)\n        //                {\n        //                    flowId = sendLog.CTAFlowConfigId.Value;\n        //                    stepId = sendLog.CTAFlowStepId.Value;\n        //                }\n        //                else if (sendLog.Campaign?.CTAFlowConfigId != null)\n        //                {\n        //                    flowId = sendLog.Campaign.CTAFlowConfigId.Value;\n\n        //                    var entry = await _context.CTAFlowSteps\n        //                        .Where(s => s.CTAFlowConfigId == flowId)\n        //                        .OrderBy(s => s.StepOrder)\n        //                        .Select(s => s.Id)\n        //                        .FirstOrDefaultAsync();\n\n        //                    if (entry == Guid.Empty)\n        //                    {\n        //                        _logger.LogWarning(\"‚ùå No entry step found for flow {Flow}\", flowId);\n        //                        continue;\n        //                    }\n\n        //                    stepId = entry;\n        //                }\n        //                else\n        //                {\n        //                    _logger.LogWarning(\"‚ùå No flow context on CampaignSendLog for WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                bundleJson = sendLog.ButtonBundleJson;\n        //            }\n\n        //            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //            // ‚úÖ UPSERT PROFILE NAME (create-or-update) *before* next step\n        //            //    and make sure we look up by digits-only phone.\n        //            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //            try\n        //            {\n        //                var profileName = TryGetProfileName(value);\n        //                if (!string.IsNullOrWhiteSpace(profileName))\n        //                {\n        //                    var now = DateTime.UtcNow;\n        //                    var contact = await _context.Contacts\n        //                        .FirstOrDefaultAsync(c => c.BusinessId == businessId &&\n        //                                                  (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));\n\n        //                    if (contact == null)\n        //                    {\n        //                        profileName = profileName ?? \"User\";\n        //                        contact = new Contact\n        //                        {\n        //                            Id = Guid.NewGuid(),\n        //                            BusinessId = businessId,\n        //                            PhoneNumber = fromDigits, // store canonical\n        //                            Name = profileName,\n        //                            ProfileName = profileName,\n        //                            ProfileNameUpdatedAt = now,\n        //                            CreatedAt = now,\n        //                        };\n        //                        _context.Contacts.Add(contact);\n        //                        await _context.SaveChangesAsync();\n        //                        _logger.LogInformation(\"üë§ Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})\",\n        //                            profileName, fromDigits, businessId);\n        //                    }\n        //                    else\n        //                    {\n        //                        var changed = false;\n\n        //                        if (!string.Equals(contact.ProfileName, profileName, StringComparison.Ordinal))\n        //                        {\n        //                            contact.ProfileName = profileName;\n        //                            contact.ProfileNameUpdatedAt = now;\n        //                            changed = true;\n        //                        }\n\n        //                        if (string.IsNullOrWhiteSpace(contact.Name) ||\n        //                            contact.Name == \"WhatsApp User\" ||\n        //                            contact.Name == contact.PhoneNumber)\n        //                        {\n        //                            if (!string.Equals(contact.Name, profileName, StringComparison.Ordinal))\n        //                            {\n        //                                contact.Name = profileName;\n        //                                changed = true;\n        //                            }\n        //                        }\n\n        //                        if (changed)\n        //                        {\n        //                            contact.ProfileNameUpdatedAt = now;\n        //                            await _context.SaveChangesAsync();\n        //                            _logger.LogInformation(\"üë§ Updated WA profile name to '{Name}' for {Phone} (biz {Biz})\",\n        //                                profileName, fromDigits, businessId);\n        //                        }\n        //                    }\n        //                }\n        //            }\n        //            catch (Exception exProf)\n        //            {\n        //                _logger.LogWarning(exProf, \"‚ö†Ô∏è Failed to upsert WA profile name on click webhook.\");\n        //            }\n\n        //            // ‚Äî‚Äî Map clicked text -> button index via the shown bundle\n        //            short? buttonIndex = null;\n        //            FlowBtnBundleNode? hit = null;\n\n        //            if (!string.IsNullOrWhiteSpace(bundleJson))\n        //            {\n        //                try\n        //                {\n        //                    var nodes = System.Text.Json.JsonSerializer\n        //                        .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();\n\n        //                    hit = nodes.FirstOrDefault(n =>\n        //                              string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n        //                          ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));\n\n        //                    if (hit != null)\n        //                        buttonIndex = (short)hit.i;\n        //                }\n        //                catch (Exception ex)\n        //                {\n        //                    _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to parse ButtonBundleJson\");\n        //                }\n        //            }\n\n        //            // ‚Äî‚Äî Fallback: find link by TEXT for this step\n        //            FlowButtonLink? linkMatchedByText = null;\n        //            if (buttonIndex == null)\n        //            {\n        //                var stepLinks = await _context.FlowButtonLinks\n        //                    .Where(l => l.CTAFlowStepId == stepId)\n        //                    .OrderBy(l => l.ButtonIndex)\n        //                    .ToListAsync();\n\n        //                if (stepLinks.Count > 0)\n        //                {\n        //                    linkMatchedByText = stepLinks.FirstOrDefault(l =>\n        //                        string.Equals(l.ButtonText ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n        //                        ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));\n\n        //                    if (linkMatchedByText == null && stepLinks.Count == 1)\n        //                    {\n        //                        linkMatchedByText = stepLinks[0];\n        //                        _logger.LogInformation(\"üü® Falling back to single available link for step {Step}\", stepId);\n        //                    }\n\n        //                    if (linkMatchedByText != null)\n        //                    {\n        //                        buttonIndex = (short?)linkMatchedByText.ButtonIndex;\n        //                        _logger.LogInformation(\"‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})\",\n        //                            buttonIndex, flowId, stepId);\n        //                    }\n        //                }\n        //            }\n\n        //            if (buttonIndex == null)\n        //            {\n        //                _logger.LogInformation(\"üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'\",\n        //                    originalMessageId, buttonText);\n        //                continue;\n        //            }\n\n        //            // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link\n        //            var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)\n        //                       ?? linkMatchedByText;\n\n        //            if (link == null)\n        //            {\n        //                _logger.LogInformation(\"üü° No button link for (flow={Flow}, step={Step}, idx={Idx})\",\n        //                    flowId, stepId, buttonIndex);\n        //                continue;\n        //            }\n\n        //            // ‚Äî‚Äî Resolve index + step name (for logging)\n        //            short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);\n        //            var stepName = await _context.CTAFlowSteps\n        //                .Where(s => s.Id == stepId)\n        //                .Select(s => s.TemplateToSend)\n        //                .FirstOrDefaultAsync() ?? string.Empty;\n\n        //            // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n        //            // üìù WRITE CLICK LOG (always, even if terminal)\n        //            // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n        //            try\n        //            {\n        //                var clickExec = new FlowExecutionLog\n        //                {\n        //                    Id = Guid.NewGuid(),\n        //                    BusinessId = businessId,\n        //                    FlowId = flowId,\n        //                    StepId = stepId,\n        //                    StepName = stepName,\n        //                    CampaignSendLogId = campaignSendLogId,\n        //                    MessageLogId = origin?.Id,\n        //                    ContactPhone = fromDigits,      // ‚úÖ digits-only, consistent\n        //                    ButtonIndex = resolvedIndex,\n        //                    TriggeredByButton = buttonText,\n        //                    TemplateName = null,\n        //                    TemplateType = \"quick_reply\",\n        //                    Success = true,\n        //                    ExecutedAt = DateTime.UtcNow,\n        //                    RequestId = Guid.NewGuid(),\n        //                    RunId = runId\n        //                };\n\n        //                _context.FlowExecutionLogs.Add(clickExec);\n        //                await _context.SaveChangesAsync();\n        //            }\n        //            catch (Exception exSave)\n        //            {\n        //                _logger.LogWarning(exSave, \"‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶\");\n        //            }\n        //            // ===== RUNNING CTA JOURNEY STATE UPSERT (ONLY IF THIS BIZ IS CONFIGURED) =====\n        //            string runningJourney;\n\n        //            // Check once if this business is configured to receive CTAJourney.\n        //            // If not, we won't touch ContactJourneyStates at all.\n        //            bool shouldTrackState = await _context.CustomerWebhookConfigs\n        //                .AsNoTracking()\n        //                .AnyAsync(x => x.BusinessId == businessId && x.IsActive);\n\n        //            if (shouldTrackState)\n        //            {\n        //                try\n        //                {\n        //                    // load current state for (business, flow, phone)\n        //                    var state = await _context.ContactJourneyStates\n        //                        .SingleOrDefaultAsync(s =>\n        //                            s.BusinessId == businessId &&\n        //                            s.FlowId == flowId &&\n        //                            s.ContactPhone == fromDigits);\n\n        //                    if (state == null)\n        //                    {\n        //                        // first click -> start with this button text (original casing)\n        //                        state = new ContactJourneyState\n        //                        {\n        //                            Id = Guid.NewGuid(),\n        //                            BusinessId = businessId,\n        //                            FlowId = flowId,\n        //                            ContactPhone = fromDigits,\n        //                            JourneyText = buttonText ?? string.Empty,\n        //                            ClickCount = 1,\n        //                            LastButtonText = buttonText,\n        //                            CreatedAt = DateTime.UtcNow,\n        //                            UpdatedAt = DateTime.UtcNow\n        //                        };\n        //                        _context.ContactJourneyStates.Add(state);\n        //                        await _context.SaveChangesAsync();\n        //                        runningJourney = state.JourneyText;\n        //                        _logger.LogInformation(\"üßµ Journey init: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n        //                            runningJourney, businessId, flowId, fromDigits);\n        //                    }\n        //                    else\n        //                    {\n        //                        // append EVERY press (duplicates allowed), keep original casing\n        //                        var parts = (state.JourneyText ?? string.Empty)\n        //                            .Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)\n        //                            .ToList();\n\n        //                        if (!string.IsNullOrWhiteSpace(buttonText))\n        //                            parts.Add(buttonText!);\n\n        //                        // optional safety: cap growth\n        //                        const int cap = 15;\n        //                        if (parts.Count > cap) parts = parts.Skip(parts.Count - cap).ToList();\n\n        //                        state.JourneyText = string.Join('/', parts);\n        //                        state.ClickCount += 1;\n        //                        state.LastButtonText = buttonText;\n        //                        state.UpdatedAt = DateTime.UtcNow;\n\n        //                        await _context.SaveChangesAsync();\n        //                        runningJourney = state.JourneyText ?? string.Empty;\n\n        //                        _logger.LogInformation(\"üßµ Journey update: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n        //                            runningJourney, businessId, flowId, fromDigits);\n        //                    }\n        //                }\n        //                catch (Exception exState)\n        //                {\n        //                    _logger.LogWarning(exState, \"‚ö†Ô∏è Failed to upsert ContactJourneyState.\");\n        //                    // fall back to this click only\n        //                    runningJourney = buttonText ?? string.Empty;\n        //                }\n        //            }\n        //            else\n        //            {\n        //                // Business not configured ‚Üí do NOT save any state. Just use the current button for emit.\n        //                runningJourney = buttonText ?? string.Empty;\n        //            }\n        //            // ===== END RUNNING CTA JOURNEY STATE UPSERT =====\n\n\n        //            // ===== CTAJourney EMIT (running journey) =====\n        //            try\n        //            {\n        //                // contact (for userName / userPhone)\n        //                var contact = await _context.Contacts\n        //                    .AsNoTracking()\n        //                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n        //                // prefer PhoneNumberId (botId) from the originating send; otherwise pick any active one\n        //                string? phoneNumberId = null;\n        //                if (campaignSendLogId.HasValue)\n        //                {\n        //                    phoneNumberId = await _context.CampaignSendLogs\n        //                        .AsNoTracking()\n        //                        .Where(s => s.Id == campaignSendLogId.Value)\n        //                        .Select(s => s.Campaign.PhoneNumberId)\n        //                        .FirstOrDefaultAsync();\n        //                }\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)\n        //                {\n        //                    phoneNumberId = await _context.Campaigns\n        //                        .AsNoTracking()\n        //                        .Where(c => c.Id == origin.CampaignId.Value)\n        //                        .Select(c => c.PhoneNumberId)\n        //                        .FirstOrDefaultAsync();\n        //                }\n\n        //                //if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                //{\n        //                //    phoneNumberId = await _context.WhatsAppSettings\n        //                //        .AsNoTracking()\n        //                //        .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)\n        //                //        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //                //        .Select(s => s.PhoneNumberId)\n        //                //        .FirstOrDefaultAsync();\n        //                //}\n        //                // 2) Map PhoneNumberId -> WhatsAppBusinessNumber\n        //                string? botWaNumber = null;\n        //                if (!string.IsNullOrWhiteSpace(phoneNumberId))\n        //                {\n        //                    botWaNumber = await _context.WhatsAppPhoneNumbers\n        //                        .AsNoTracking()\n        //                        .Where(n => n.BusinessId == businessId && n.PhoneNumberId == phoneNumberId)\n        //                        .Select(n => n.WhatsAppBusinessNumber)\n        //                        .FirstOrDefaultAsync();\n        //                }\n        //                // business WA display number (fallback botId if no PhoneNumberId)\n        //                var displayProfilename = await _context.WhatsAppSettings\n        //                    .AsNoTracking()\n        //                    .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)\n        //                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //                    .Select(s => s.WhatsAppBusinessNumber)\n        //                    .FirstOrDefaultAsync();\n\n        //                // Build DTO and POST (CTAJourney = the running slash-joined string with original casing)\n        //                var dto = CtaJourneyMapper.Build(\n        //                    journeyKey: runningJourney,                    // <<‚Äî‚Äî use the running state\n        //                    contact: contact,\n        //                    profileName: contact?.ProfileName ?? contact?.Name,\n        //                    userId: null,\n        //                    phoneNumberId: botWaNumber,                  // preferred botId\n        //                    businessDisplayPhone: displayProfilename,               // fallback botId if above missing\n        //                    categoryBrowsed: null,\n        //                    productBrowsed: null\n        //                );\n\n        //                await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n        //                _logger.LogInformation(\"üì§ CTAJourney posted (running): {Journey} (biz={Biz}, phone={Phone})\",\n        //                    dto.CTAJourney, businessId, dto.userPhone);\n        //            }\n        //            catch (Exception ex)\n        //            {\n        //                _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶\");\n        //            }\n\n        //            // ===== end CTAJourney EMIT =====\n\n\n        //            // ===== CTAJourney EMIT (button name) =====\n        //            //try\n        //            //{\n        //            //    CTAJourney must be the button name now\n        //            //   var journeyKey = ToKey(buttonText);\n        //            //    var journeyKey = buttonText?.Trim();\n        //            //    contact(for userName / userPhone)\n        //            //        var contact = await _context.Contacts\n        //            //            .AsNoTracking()\n        //            //            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n        //            //    prefer PhoneNumberId(botId) from the originating send; otherwise pick any active one\n        //            //    string? phoneNumberId = null;\n        //            //    if (campaignSendLogId.HasValue)\n        //            //    {\n        //            //        phoneNumberId = await _context.CampaignSendLogs\n        //            //            .AsNoTracking()\n        //            //            .Where(s => s.Id == campaignSendLogId.Value)\n        //            //            .Select(s => s.Campaign.PhoneNumberId)\n        //            //            .FirstOrDefaultAsync();\n        //            //    }\n        //            //    if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)\n        //            //    {\n        //            //        phoneNumberId = await _context.Campaigns\n        //            //            .AsNoTracking()\n        //            //            .Where(c => c.Id == origin.CampaignId.Value)\n        //            //            .Select(c => c.PhoneNumberId)\n        //            //            .FirstOrDefaultAsync();\n        //            //    }\n        //            //    if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //            //    {\n        //            //        phoneNumberId = await _context.WhatsAppSettings\n        //            //            .AsNoTracking()\n        //            //            .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)\n        //            //            .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //            //            .Select(s => s.PhoneNumberId)\n        //            //            .FirstOrDefaultAsync();\n        //            //    }\n\n        //            //    business WA display number(fallback botId if no PhoneNumberId)\n        //            //    var displayWa = await _context.WhatsAppSettings\n        //            //        .AsNoTracking()\n        //            //        .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)\n        //            //        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //            //        .Select(s => s.WhatsAppBusinessNumber)\n        //            //        .FirstOrDefaultAsync();\n\n        //            //    build DTO and POST(maps to: userName / profileName, userPhone, botId, CTAJourney)\n        //            //    var dto = CtaJourneyMapper.Build(\n        //            //        journeyKey: journeyKey,                         // <<‚Äî‚Äî button name\n        //            //        contact: contact,\n        //            //        profileName: contact?.ProfileName ?? contact?.Name,\n        //            //        userId: null,                                   // we don't have external user id\n        //            //        phoneNumberId: phoneNumberId,                   // preferred botId\n        //            //        businessDisplayPhone: displayWa,                // fallback botId if above missing\n        //            //        categoryBrowsed: null,\n        //            //        productBrowsed: null\n        //            //    );\n\n        //            //    await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n        //            //    _logger.LogInformation(\"üì§ CTAJourney posted (button): {Journey} (biz={Biz}, phone={Phone})\",\n        //            //        dto.CTAJourney, businessId, dto.userPhone);\n        //            //}\n        //            //catch (Exception ex)\n        //            //{\n        //            //    _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶\");\n        //            //}\n\n\n\n\n\n        //            // ‚Äî‚Äî If terminal/URL button: already logged the click\n        //            if (link.NextStepId == null)\n        //            {\n        //                _logger.LogInformation(\"üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'\",\n        //                    flowId, stepId, resolvedIndex, link.ButtonText);\n        //                continue;\n        //            }\n\n        //            if (_flowRuntime == null)\n        //            {\n        //                _logger.LogError(\"‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}\", flowId, stepId, resolvedIndex);\n        //                continue;\n        //            }\n\n        //            // ‚Äî‚Äî üîé Resolve sender from the originating campaign/send (use SAME WABA)\n        //            string? providerFromCampaign = null;\n        //            string? phoneNumberIdFromCampaign = null;\n\n        //            if (campaignSendLogId.HasValue)\n        //            {\n        //                var originSend = await _context.CampaignSendLogs\n        //                    .AsNoTracking()\n        //                    .Include(s => s.Campaign)\n        //                    .Where(s => s.Id == campaignSendLogId.Value)\n        //                    .Select(s => new\n        //                    {\n        //                        s.Campaign.Provider,\n        //                        s.Campaign.PhoneNumberId\n        //                    })\n        //                    .FirstOrDefaultAsync();\n\n        //                providerFromCampaign = originSend?.Provider;\n        //                phoneNumberIdFromCampaign = originSend?.PhoneNumberId;\n        //            }\n        //            else if (origin != null && origin.CampaignId.HasValue)\n        //            {\n        //                var originCamp = await _context.Campaigns\n        //                    .AsNoTracking()\n        //                    .Where(c => c.Id == origin.CampaignId.Value)\n        //                    .Select(c => new { c.Provider, c.PhoneNumberId })\n        //                    .FirstOrDefaultAsync();\n\n        //                providerFromCampaign = originCamp?.Provider;\n        //                phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;\n        //            }\n\n        //            // ‚Äî‚Äî Execute next (carry sender forward)\n        //            var ctxObj = new NextStepContext\n        //            {\n        //                BusinessId = businessId,\n        //                FlowId = flowId,\n        //                Version = flowVersion ?? 1,\n        //                SourceStepId = stepId,\n        //                TargetStepId = link.NextStepId!.Value,\n        //                ButtonIndex = resolvedIndex,\n        //                MessageLogId = origin?.Id ?? Guid.Empty,\n        //                ContactPhone = fromDigits,     // ‚úÖ digits-only, so runtime finds the Contact\n        //                RequestId = Guid.NewGuid(),\n        //                ClickedButton = link,\n\n        //                // üß∑ Sender from campaign so runtime won‚Äôt guess or fail with ‚ÄúMissing PhoneNumberId‚Äù\n        //                Provider = providerFromCampaign,\n        //                PhoneNumberId = phoneNumberIdFromCampaign,\n        //                AlwaysSend = true // üî• force runtime to send even if it‚Äôs a loopback/same step\n        //            };\n\n        //            try\n        //            {\n        //                var result = await _flowRuntime.ExecuteNextAsync(ctxObj);\n\n        //                if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))\n        //                {\n        //                    _logger.LogInformation(\"üîó URL button redirect (logical): {Url}\", result.RedirectUrl);\n        //                }\n        //            }\n        //            catch (Exception exRun)\n        //            {\n        //                _logger.LogError(exRun,\n        //                    \"‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'\",\n        //                    ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);\n        //            }\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"‚ùå Failed to process CTA button click.\");\n        //    }\n        //}\n\n        public async Task ProcessClickAsync(JsonElement value)\n        {\n            _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n            try\n            {\n                if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n                    return;\n\n                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                static string Norm(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n                    return string.Join(' ', s.Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries))\n                                 .Trim()\n                                 .ToLowerInvariant();\n                }\n\n                // canonical phone: keep only digits (matches how we store & search contacts)\n                static string NormalizePhone(string? raw)\n                    => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());\n\n                // contacts[0].profile.name (Meta shape)\n                static string? TryGetProfileName(JsonElement root)\n                {\n                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                        contactsEl.ValueKind == JsonValueKind.Array &&\n                        contactsEl.GetArrayLength() > 0)\n                    {\n                        var c0 = contactsEl[0];\n                        if (c0.TryGetProperty(\"profile\", out var profEl) &&\n                            profEl.ValueKind == JsonValueKind.Object &&\n                            profEl.TryGetProperty(\"name\", out var nameEl) &&\n                            nameEl.ValueKind == JsonValueKind.String)\n                        {\n                            var n = nameEl.GetString();\n                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                        }\n                    }\n                    return null;\n                }\n\n                // optional helper (kept for future use)\n                static string ToKey(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n                    var t = s.Trim().ToLowerInvariant();\n                    var sb = new System.Text.StringBuilder(t.Length);\n                    foreach (var ch in t)\n                    {\n                        if (char.IsLetterOrDigit(ch)) sb.Append(ch);\n                        else if (char.IsWhiteSpace(ch) || ch == '-' || ch == '_' || ch == '.') sb.Append('_');\n                    }\n                    var k = sb.ToString().Trim('_');\n                    return string.IsNullOrEmpty(k) ? \"unknown\" : k;\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // read WA display number once (used as botId) ‚Äì optional, not strictly required\n                string botIdFromWebhook = \"\";\n                if (value.TryGetProperty(\"metadata\", out var md) &&\n                    md.TryGetProperty(\"display_phone_number\", out var dpnEl) &&\n                    dpnEl.ValueKind == JsonValueKind.String)\n                {\n                    botIdFromWebhook = NormalizePhone(dpnEl.GetString());\n                }\n\n                foreach (var msg in messages.EnumerateArray())\n                {\n                    if (!msg.TryGetProperty(\"type\", out var typeProp))\n                        continue;\n\n                    var type = typeProp.GetString();\n\n                    string? clickMessageId = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                    string? originalMessageId = msg.TryGetProperty(\"context\", out var ctx) && ctx.TryGetProperty(\"id\", out var ctxId)\n                        ? ctxId.GetString()\n                        : null;\n\n                    var fromRaw = msg.TryGetProperty(\"from\", out var fromProp) ? (fromProp.GetString() ?? \"\") : \"\";\n                    var fromDigits = NormalizePhone(fromRaw);\n\n                    // ‚Äî‚Äî‚Äî button label extraction\n                    string? buttonText = null;\n                    if (string.Equals(type, \"button\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        buttonText = msg.TryGetProperty(\"button\", out var btn) &&\n                                     btn.TryGetProperty(\"text\", out var textProp)\n                                       ? textProp.GetString()?.Trim()\n                                       : null;\n                    }\n                    else if (string.Equals(type, \"interactive\", StringComparison.OrdinalIgnoreCase) &&\n                             msg.TryGetProperty(\"interactive\", out var interactive))\n                    {\n                        if (interactive.TryGetProperty(\"type\", out var intrType) &&\n                            string.Equals(intrType.GetString(), \"button_reply\", StringComparison.OrdinalIgnoreCase) &&\n                            interactive.TryGetProperty(\"button_reply\", out var br) &&\n                            br.TryGetProperty(\"title\", out var titleProp))\n                        {\n                            buttonText = titleProp.GetString()?.Trim();\n                        }\n                        else if (interactive.TryGetProperty(\"list_reply\", out var lr) &&\n                                 lr.TryGetProperty(\"title\", out var listTitleProp))\n                        {\n                            buttonText = listTitleProp.GetString()?.Trim();\n                        }\n                    }\n\n                    if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))\n                    {\n                        _logger.LogDebug(\"‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}\", type);\n                        continue;\n                    }\n\n                    _logger.LogInformation(\"üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n                        fromDigits, clickMessageId, originalMessageId, buttonText);\n\n                    // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)\n                    var origin = await _context.MessageLogs\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(m =>\n                            m.MessageId == originalMessageId &&\n                            m.CTAFlowConfigId != null &&\n                            m.CTAFlowStepId != null);\n\n                    Guid businessId;\n                    Guid flowId;\n                    Guid stepId;\n                    string? bundleJson = null;\n                    int? flowVersion = null;\n\n                    Guid? campaignSendLogId = null; // link the click to the shown message\n                    Guid? runId = null;             // copy from parent CSL when available\n\n                    if (origin != null)\n                    {\n                        businessId = origin.BusinessId;\n                        flowId = origin.CTAFlowConfigId!.Value;\n                        stepId = origin.CTAFlowStepId!.Value;\n                        bundleJson = origin.ButtonBundleJson;\n                        flowVersion = origin.FlowVersion;\n\n                        // Map back to CSL via MessageLogId or WAMID and fetch RunId\n                        var cslInfo = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))\n                            .OrderByDescending(csl => csl.CreatedAt)\n                            .Select(csl => new { csl.Id, csl.RunId })\n                            .FirstOrDefaultAsync();\n\n                        campaignSendLogId = cslInfo?.Id;\n                        runId = cslInfo?.RunId;\n                    }\n                    else\n                    {\n                        // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)\n                        var sendLog = await _context.CampaignSendLogs\n                            .Include(sl => sl.Campaign)\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);\n\n                        if (sendLog == null)\n                        {\n                            _logger.LogWarning(\"‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        businessId = sendLog.BusinessId != Guid.Empty\n                            ? sendLog.BusinessId\n                            : (sendLog.Campaign?.BusinessId ?? Guid.Empty);\n\n                        if (businessId == Guid.Empty)\n                        {\n                            _logger.LogWarning(\"‚ùå Could not resolve BusinessId for WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        campaignSendLogId = sendLog.Id;\n                        runId = sendLog.RunId;\n\n                        if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)\n                        {\n                            flowId = sendLog.CTAFlowConfigId.Value;\n                            stepId = sendLog.CTAFlowStepId.Value;\n                        }\n                        else if (sendLog.Campaign?.CTAFlowConfigId != null)\n                        {\n                            flowId = sendLog.Campaign.CTAFlowConfigId.Value;\n\n                            var entry = await _context.CTAFlowSteps\n                                .Where(s => s.CTAFlowConfigId == flowId)\n                                .OrderBy(s => s.StepOrder)\n                                .Select(s => s.Id)\n                                .FirstOrDefaultAsync();\n\n                            if (entry == Guid.Empty)\n                            {\n                                _logger.LogWarning(\"‚ùå No entry step found for flow {Flow}\", flowId);\n                                continue;\n                            }\n\n                            stepId = entry;\n                        }\n                        else\n                        {\n                            _logger.LogWarning(\"‚ùå No flow context on CampaignSendLog for WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        bundleJson = sendLog.ButtonBundleJson;\n                    }\n\n                    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                    // ‚úÖ UPSERT PROFILE NAME (create-or-update) *before* next step\n                    //    ensure we look up by digits-only phone.\n                    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                    try\n                    {\n                        var profileName = TryGetProfileName(value);\n                        if (!string.IsNullOrWhiteSpace(profileName))\n                        {\n                            var now = DateTime.UtcNow;\n                            var contact = await _context.Contacts\n                                .FirstOrDefaultAsync(c => c.BusinessId == businessId &&\n                                                          (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));\n\n                            if (contact == null)\n                            {\n                                profileName = profileName ?? \"User\";\n                                contact = new Contact\n                                {\n                                    Id = Guid.NewGuid(),\n                                    BusinessId = businessId,\n                                    PhoneNumber = fromDigits, // store canonical\n                                    Name = profileName,\n                                    ProfileName = profileName,\n                                    ProfileNameUpdatedAt = now,\n                                    CreatedAt = now,\n                                };\n                                _context.Contacts.Add(contact);\n                                await _context.SaveChangesAsync();\n                                _logger.LogInformation(\"üë§ Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})\",\n                                    profileName, fromDigits, businessId);\n                            }\n                            else\n                            {\n                                var changed = false;\n\n                                if (!string.Equals(contact.ProfileName, profileName, StringComparison.Ordinal))\n                                {\n                                    contact.ProfileName = profileName;\n                                    contact.ProfileNameUpdatedAt = now;\n                                    changed = true;\n                                }\n\n                                if (string.IsNullOrWhiteSpace(contact.Name) ||\n                                    contact.Name == \"WhatsApp User\" ||\n                                    contact.Name == contact.PhoneNumber)\n                                {\n                                    if (!string.Equals(contact.Name, profileName, StringComparison.Ordinal))\n                                    {\n                                        contact.Name = profileName;\n                                        changed = true;\n                                    }\n                                }\n\n                                if (changed)\n                                {\n                                    contact.ProfileNameUpdatedAt = now;\n                                    await _context.SaveChangesAsync();\n                                    _logger.LogInformation(\"üë§ Updated WA profile name to '{Name}' for {Phone} (biz {Biz})\",\n                                        profileName, fromDigits, businessId);\n                                }\n                            }\n                        }\n                    }\n                    catch (Exception exProf)\n                    {\n                        _logger.LogWarning(exProf, \"‚ö†Ô∏è Failed to upsert WA profile name on click webhook.\");\n                    }\n\n                    // ‚Äî‚Äî Map clicked text -> button index via the shown bundle\n                    short? buttonIndex = null;\n                    FlowBtnBundleNode? hit = null;\n\n                    if (!string.IsNullOrWhiteSpace(bundleJson))\n                    {\n                        try\n                        {\n                            var nodes = System.Text.Json.JsonSerializer\n                                .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();\n\n                            hit = nodes.FirstOrDefault(n =>\n                                      string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                  ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));\n\n                            if (hit != null)\n                                buttonIndex = (short)hit.i;\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to parse ButtonBundleJson\");\n                        }\n                    }\n\n                    // ‚Äî‚Äî Fallback: find link by TEXT for this step\n                    FlowButtonLink? linkMatchedByText = null;\n                    if (buttonIndex == null)\n                    {\n                        var stepLinks = await _context.FlowButtonLinks\n                            .Where(l => l.CTAFlowStepId == stepId)\n                            .OrderBy(l => l.ButtonIndex)\n                            .ToListAsync();\n\n                        if (stepLinks.Count > 0)\n                        {\n                            linkMatchedByText = stepLinks.FirstOrDefault(l =>\n                                string.Equals(l.ButtonText ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));\n\n                            if (linkMatchedByText == null && stepLinks.Count == 1)\n                            {\n                                linkMatchedByText = stepLinks[0];\n                                _logger.LogInformation(\"üü® Falling back to single available link for step {Step}\", stepId);\n                            }\n\n                            if (linkMatchedByText != null)\n                            {\n                                buttonIndex = (short?)linkMatchedByText.ButtonIndex;\n                                _logger.LogInformation(\"‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})\",\n                                    buttonIndex, flowId, stepId);\n                            }\n                        }\n                    }\n\n                    if (buttonIndex == null)\n                    {\n                        _logger.LogInformation(\"üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'\",\n                            originalMessageId, buttonText);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link\n                    var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)\n                               ?? linkMatchedByText;\n\n                    if (link == null)\n                    {\n                        _logger.LogInformation(\"üü° No button link for (flow={Flow}, step={Step}, idx={Idx})\",\n                            flowId, stepId, buttonIndex);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Resolve index + step name (for logging)\n                    short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);\n                    var stepName = await _context.CTAFlowSteps\n                        .Where(s => s.Id == stepId)\n                        .Select(s => s.TemplateToSend)\n                        .FirstOrDefaultAsync() ?? string.Empty;\n\n                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n                    // üìù WRITE CLICK LOG (always, even if terminal)\n                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n                    try\n                    {\n                        var clickExec = new FlowExecutionLog\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            FlowId = flowId,\n                            StepId = stepId,\n                            StepName = stepName,\n                            CampaignSendLogId = campaignSendLogId,\n                            MessageLogId = origin?.Id,\n                            ContactPhone = fromDigits,      // digits-only\n                            ButtonIndex = resolvedIndex,\n                            TriggeredByButton = buttonText,\n                            TemplateName = null,\n                            TemplateType = \"quick_reply\",\n                            Success = true,\n                            ExecutedAt = DateTime.UtcNow,\n                            RequestId = Guid.NewGuid(),\n                            RunId = runId\n                        };\n\n                        _context.FlowExecutionLogs.Add(clickExec);\n                        await _context.SaveChangesAsync();\n                    }\n                    catch (Exception exSave)\n                    {\n                        _logger.LogWarning(exSave, \"‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶\");\n                    }\n\n                    // ===== RUNNING CTA JOURNEY STATE UPSERT (ONLY IF THIS BIZ IS CONFIGURED) =====\n                    string runningJourney;\n\n                    // Check once if this business is configured to receive CTAJourney.\n                    bool shouldTrackState = await _context.CustomerWebhookConfigs\n                        .AsNoTracking()\n                        .AnyAsync(x => x.BusinessId == businessId && x.IsActive);\n\n                    if (shouldTrackState)\n                    {\n                        try\n                        {\n                            // load current state for (business, flow, phone)\n                            var state = await _context.ContactJourneyStates\n                                .SingleOrDefaultAsync(s =>\n                                    s.BusinessId == businessId &&\n                                    s.FlowId == flowId &&\n                                    s.ContactPhone == fromDigits);\n\n                            if (state == null)\n                            {\n                                // first click -> start with this button text (original casing)\n                                state = new ContactJourneyState\n                                {\n                                    Id = Guid.NewGuid(),\n                                    BusinessId = businessId,\n                                    FlowId = flowId,\n                                    ContactPhone = fromDigits,\n                                    JourneyText = buttonText ?? string.Empty,\n                                    ClickCount = 1,\n                                    LastButtonText = buttonText,\n                                    CreatedAt = DateTime.UtcNow,\n                                    UpdatedAt = DateTime.UtcNow\n                                };\n                                _context.ContactJourneyStates.Add(state);\n                                await _context.SaveChangesAsync();\n                                runningJourney = state.JourneyText;\n                                _logger.LogInformation(\"üßµ Journey init: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n                                    runningJourney, businessId, flowId, fromDigits);\n                            }\n                            else\n                            {\n                                // append EVERY press (duplicates allowed), keep original casing\n                                var parts = (state.JourneyText ?? string.Empty)\n                                    .Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)\n                                    .ToList();\n\n                                if (!string.IsNullOrWhiteSpace(buttonText))\n                                    parts.Add(buttonText!);\n\n                                // cap growth\n                                const int cap = 15;\n                                if (parts.Count > cap) parts = parts.Skip(parts.Count - cap).ToList();\n\n                                state.JourneyText = string.Join('/', parts);\n                                state.ClickCount += 1;\n                                state.LastButtonText = buttonText;\n                                state.UpdatedAt = DateTime.UtcNow;\n\n                                await _context.SaveChangesAsync();\n                                runningJourney = state.JourneyText ?? string.Empty;\n\n                                _logger.LogInformation(\"üßµ Journey update: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n                                    runningJourney, businessId, flowId, fromDigits);\n                            }\n                        }\n                        catch (Exception exState)\n                        {\n                            _logger.LogWarning(exState, \"‚ö†Ô∏è Failed to upsert ContactJourneyState.\");\n                            // fall back to this click only\n                            runningJourney = buttonText ?? string.Empty;\n                        }\n                    }\n                    else\n                    {\n                        // Business not configured ‚Üí do NOT save any state. Just use the current button for emit.\n                        runningJourney = buttonText ?? string.Empty;\n                    }\n                    // ===== END RUNNING CTA JOURNEY STATE UPSERT =====\n\n                    // ===== CTAJourney EMIT (running journey) =====\n                    try\n                    {\n                        // contact (for userName / userPhone)\n                        var contact = await _context.Contacts\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n                        // Prefer sender from the originating send (keeps the same WABA)\n                        string? senderProvider = null;\n                        string? senderPhoneNumberId = null;\n\n                        if (campaignSendLogId.HasValue)\n                        {\n                            var originSend = await _context.CampaignSendLogs\n                                .AsNoTracking()\n                                .Include(s => s.Campaign)\n                                .Where(s => s.Id == campaignSendLogId.Value)\n                                .Select(s => new { s.Campaign.Provider, s.Campaign.PhoneNumberId })\n                                .FirstOrDefaultAsync();\n\n                            senderProvider = originSend?.Provider;\n                            senderPhoneNumberId = originSend?.PhoneNumberId;\n                        }\n                        if (string.IsNullOrWhiteSpace(senderPhoneNumberId) && origin?.CampaignId != null)\n                        {\n                            var originCamp = await _context.Campaigns\n                                .AsNoTracking()\n                                .Where(c => c.Id == origin.CampaignId.Value)\n                                .Select(c => new { c.Provider, c.PhoneNumberId })\n                                .FirstOrDefaultAsync();\n\n                            senderProvider ??= originCamp?.Provider;\n                            senderPhoneNumberId = originCamp?.PhoneNumberId;\n                        }\n\n                        // Map PhoneNumberId -> WhatsAppBusinessNumber, or choose a default for the same provider\n                        string? waBusinessNumber = null;\n\n                        if (!string.IsNullOrWhiteSpace(senderPhoneNumberId))\n                        {\n                            waBusinessNumber = await _context.WhatsAppPhoneNumbers\n                                .AsNoTracking()\n                                .Where(n => n.BusinessId == businessId && n.PhoneNumberId == senderPhoneNumberId)\n                                .Select(n => n.WhatsAppBusinessNumber)\n                                .FirstOrDefaultAsync();\n                        }\n\n                        if (string.IsNullOrWhiteSpace(waBusinessNumber))\n                        {\n                            var row = await _context.WhatsAppPhoneNumbers\n                                .AsNoTracking()\n                                .Where(n => n.BusinessId == businessId &&\n                                            n.IsActive &&\n                                            (string.IsNullOrEmpty(senderProvider) || n.Provider == senderProvider))\n                                .OrderByDescending(n => n.IsDefault)\n                                .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                                .Select(n => new { n.PhoneNumberId, n.WhatsAppBusinessNumber })\n                                .FirstOrDefaultAsync();\n\n                            senderPhoneNumberId ??= row?.PhoneNumberId;\n                            waBusinessNumber = row?.WhatsAppBusinessNumber;\n                        }\n\n                        var dto = CtaJourneyMapper.Build(\n                            journeyKey: runningJourney,                      // running state with original casing\n                            contact: contact,\n                            profileName: contact?.ProfileName ?? contact?.Name,\n                            userId: null,\n                            phoneNumberId: waBusinessNumber,                 // publish WA display number as bot id\n                            businessDisplayPhone: waBusinessNumber,          // same as above\n                            categoryBrowsed: null,\n                            productBrowsed: null\n                        );\n\n                        await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n                        _logger.LogInformation(\"üì§ CTAJourney posted (running): {Journey} (biz={Biz}, phone={Phone})\",\n                            dto.CTAJourney, businessId, dto.userPhone);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶\");\n                    }\n                    // ===== end CTAJourney EMIT =====\n\n                    // ‚Äî‚Äî If terminal/URL button: already logged the click\n                    if (link.NextStepId == null)\n                    {\n                        _logger.LogInformation(\"üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'\",\n                            flowId, stepId, resolvedIndex, link.ButtonText);\n                        continue;\n                    }\n\n                    if (_flowRuntime == null)\n                    {\n                        _logger.LogError(\"‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}\", flowId, stepId, resolvedIndex);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî üîé Resolve sender from the originating campaign/send (use SAME WABA) for next step\n                    string? providerFromCampaign = null;\n                    string? phoneNumberIdFromCampaign = null;\n\n                    if (campaignSendLogId.HasValue)\n                    {\n                        var originSend = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Include(s => s.Campaign)\n                            .Where(s => s.Id == campaignSendLogId.Value)\n                            .Select(s => new\n                            {\n                                s.Campaign.Provider,\n                                s.Campaign.PhoneNumberId\n                            })\n                            .FirstOrDefaultAsync();\n\n                        providerFromCampaign = originSend?.Provider;\n                        phoneNumberIdFromCampaign = originSend?.PhoneNumberId;\n                    }\n                    else if (origin != null && origin.CampaignId.HasValue)\n                    {\n                        var originCamp = await _context.Campaigns\n                            .AsNoTracking()\n                            .Where(c => c.Id == origin.CampaignId.Value)\n                            .Select(c => new { c.Provider, c.PhoneNumberId })\n                            .FirstOrDefaultAsync();\n\n                        providerFromCampaign = originCamp?.Provider;\n                        phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;\n                    }\n\n                    // ‚Äî‚Äî Execute next (carry sender forward)\n                    var ctxObj = new NextStepContext\n                    {\n                        BusinessId = businessId,\n                        FlowId = flowId,\n                        Version = flowVersion ?? 1,\n                        SourceStepId = stepId,\n                        TargetStepId = link.NextStepId!.Value,\n                        ButtonIndex = resolvedIndex,\n                        MessageLogId = origin?.Id ?? Guid.Empty,\n                        ContactPhone = fromDigits,     // digits-only\n                        RequestId = Guid.NewGuid(),\n                        ClickedButton = link,\n\n                        // carry same sender into the next step\n                        Provider = providerFromCampaign,\n                        PhoneNumberId = phoneNumberIdFromCampaign,\n                        AlwaysSend = true // force runtime to send even if it‚Äôs a loopback/same step\n                    };\n\n                    try\n                    {\n                        var result = await _flowRuntime.ExecuteNextAsync(ctxObj);\n\n                        if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))\n                        {\n                            _logger.LogInformation(\"üîó URL button redirect (logical): {Url}\", result.RedirectUrl);\n                        }\n                    }\n                    catch (Exception exRun)\n                    {\n                        _logger.LogError(exRun,\n                            \"‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'\",\n                            ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process CTA button click.\");\n            }\n        }\n\n        private sealed class FlowBtnBundleNode\n        {\n            public int i { get; init; }\n            public string? t { get; init; }   // button text/title\n            public string? ty { get; init; }  // button type (URL/QUICK_REPLY/FLOW)\n            public string? v { get; init; }   // value/payload (e.g., URL)\n            public Guid? ns { get; init; }    // next step id\n        }\n        private static string ToKey(string? s)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n            // letters/digits ‚Üí lower, spaces/._- ‚Üí underscore, strip the rest\n            var chars = s.Trim().ToLowerInvariant()\n                .Select(ch => char.IsLetterOrDigit(ch) ? ch : '_')\n                .ToArray();\n            var key = new string(chars);\n            // squeeze duplicate underscores\n            while (key.Contains(\"__\")) key = key.Replace(\"__\", \"_\");\n            return key.Trim('_');\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IClickWebhookProcessor.cs",
      "sha256": "5c42427d1e6c36dd122b3a10412eb70d7c412baf00ce54a614491a5b1590afeb",
      "language": "csharp",
      "size": 228,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IClickWebhookProcessor\n    {\n        Task ProcessClickAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IInboundMessageProcessor.cs",
      "sha256": "ec5496c7810122c99affe09fa17861d6d0c371457d9284e0ba58be6a93ea60f2",
      "language": "csharp",
      "size": 229,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IInboundMessageProcessor\n    {\n        Task ProcessChatAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/InboundMessageProcessor.cs",
      "sha256": "f3ffce0f6dbaf9f28400e14be41bb0622e4450b64a4c6eefddcb3bb0a2608310",
      "language": "csharp",
      "size": 54270,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing Microsoft.Extensions.DependencyInjection;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.CRM.Services;\nusing xbytechat.api.Features.Automation.Services;\nusing xbytechat.api.Features.Webhooks.Directory;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Services; // üîπ NEW: provider directory\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class InboundMessageProcessor : IInboundMessageProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly ILogger<InboundMessageProcessor> _logger;\n        private readonly IInboxService _inboxService;\n        private readonly IServiceScopeFactory _serviceScopeFactory;\n        private readonly IHubContext<InboxHub> _hub;\n        private readonly IContactProfileService _contactProfile;\n        private readonly IProviderDirectory _providerDirectory; // üîπ NEW\n\n        public InboundMessageProcessor(\n            AppDbContext context,\n            IHubContext<InboxHub> hubContext,\n            ILogger<InboundMessageProcessor> logger,\n            IInboxService inboxService,\n            IServiceScopeFactory serviceScopeFactory,\n            IHubContext<InboxHub> hub,\n            IContactProfileService contactProfile,\n            IProviderDirectory providerDirectory // üîπ NEW\n        )\n        {\n            _context = context;\n            _hubContext = hubContext;\n            _logger = logger;\n            _inboxService = inboxService;\n            _serviceScopeFactory = serviceScopeFactory;\n            _hub = hub;\n            _contactProfile = contactProfile;\n            _providerDirectory = providerDirectory; // üîπ NEW\n        }\n\n        public async Task ProcessChatAsync(JsonElement value)\n        {\n            try\n            {\n                using var scope = _serviceScopeFactory.CreateScope();\n                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n                var autoReplyRuntime = scope.ServiceProvider.GetRequiredService<IAutoReplyRuntimeService>();\n                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n                var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n\n                // digits-only normalizer (matches how we store/search phones)\n                static string Normalize(string? s) =>\n                    string.IsNullOrWhiteSpace(s) ? \"\" : new string(s.Where(char.IsDigit).ToArray());\n\n                // 1) Extract WA metadata + message (Meta Cloud shape)\n                if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n                {\n                    logger.LogWarning(\"Inbound WA payload has no messages array.\");\n                    return;\n                }\n\n                var msg = messages[0];\n\n                var msgType = msg.TryGetProperty(\"type\", out var typeProp)\n                    ? typeProp.GetString()\n                    : \"unknown\";\n\n                var rawContactPhone = msg.GetProperty(\"from\").GetString() ?? \"\";\n                var contactPhone = Normalize(rawContactPhone);\n\n                string? content = msgType switch\n                {\n                    \"text\" when msg.TryGetProperty(\"text\", out var t) &&\n                                t.TryGetProperty(\"body\", out var b)\n                                => b.GetString(),\n\n                    \"image\" when msg.TryGetProperty(\"image\", out var img) &&\n                                 img.TryGetProperty(\"caption\", out var cap)\n                                 => cap.GetString(),\n\n                    _ => null\n                };\n\n                logger.LogInformation(\n                    \"üì• Inbound WA message: type={MsgType}, from={From}, preview={Preview}\",\n                    msgType,\n                    rawContactPhone,\n                    content?.Length > 50 ? content[..50] : content\n                );\n\n                // 2) Resolve business via ProviderDirectory first, then fallback to WhatsAppPhoneNumbers\n                if (!value.TryGetProperty(\"metadata\", out var metadata))\n                {\n                    logger.LogWarning(\"Inbound: metadata missing on webhook payload.\");\n                    return;\n                }\n\n                string? displayNumber = metadata.TryGetProperty(\"display_phone_number\", out var dn)\n                    ? dn.GetString()\n                    : null;\n\n                string? phoneNumberId = metadata.TryGetProperty(\"phone_number_id\", out var pn)\n                    ? pn.GetString()\n                    : null;\n\n                string? wabaId = metadata.TryGetProperty(\"waba_id\", out var we)\n                    ? we.GetString()\n                    : null;\n\n                // 2.1 Prefer provider directory (uses provider + phone_number_id + waba_id)\n                Guid? businessId = await _providerDirectory.ResolveBusinessIdAsync(\n                    provider: \"meta_cloud\",          // canonical provider key for Meta Cloud\n                    phoneNumberId: phoneNumberId,\n                    displayPhoneNumber: displayNumber,\n                    wabaId: wabaId,\n                    waId: rawContactPhone           // the WA user id (\"from\")\n                );\n\n                // 2.2 Fallback to legacy WhatsAppPhoneNumbers by display number if needed\n                if (businessId == null && !string.IsNullOrWhiteSpace(displayNumber))\n                {\n                    var cleanIncomingBiz = Normalize(displayNumber);\n\n                    var candidates = await db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.IsActive)\n                        .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n                        .ToListAsync();\n\n                    var numHit = candidates.FirstOrDefault(n =>\n                        Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);\n\n                    if (numHit != null)\n                        businessId = numHit.BusinessId;\n                }\n\n                // 2.3 Still nothing ‚Üí log and bail\n                if (businessId == null || businessId == Guid.Empty)\n                {\n                    logger.LogWarning(\n                        \"‚ùå Inbound: business not resolved. phone_number_id={PhoneId}, display={Display}, waba={Waba}, from={From}\",\n                        phoneNumberId,\n                        displayNumber,\n                        wabaId,\n                        rawContactPhone\n                    );\n                    return;\n                }\n\n                var resolvedBusinessId = businessId.Value;\n\n                // 3) Find or create contact\n                var contact = await contactService.FindOrCreateAsync(resolvedBusinessId, contactPhone);\n                if (contact == null)\n                {\n                    logger.LogWarning(\"‚ùå Could not resolve contact for phone: {Phone}\", contactPhone);\n                    return;\n                }\n\n                // Extract profile name (contacts[0].profile.name) and upsert into Contacts\n                static string? TryGetProfileName(JsonElement root)\n                {\n                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                        contactsEl.ValueKind == JsonValueKind.Array &&\n                        contactsEl.GetArrayLength() > 0)\n                    {\n                        var c0 = contactsEl[0];\n                        if (c0.TryGetProperty(\"profile\", out var prof) &&\n                            prof.ValueKind == JsonValueKind.Object &&\n                            prof.TryGetProperty(\"name\", out var nm) &&\n                            nm.ValueKind == JsonValueKind.String)\n                        {\n                            var n = nm.GetString();\n                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                        }\n                    }\n                    return null;\n                }\n\n                var profileName = TryGetProfileName(value);\n                if (!string.IsNullOrWhiteSpace(profileName))\n                {\n                    try\n                    {\n                        await contactProfileService.UpsertProfileNameAsync(\n                            resolvedBusinessId,\n                            contactPhone,\n                            profileName!,\n                            CancellationToken.None);\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName for {Phone}\", contactPhone);\n                    }\n                }\n\n                // 4) Check chat mode‚Ä¶\n                var mode = await chatSessionStateService.GetChatModeAsync(resolvedBusinessId, contact.Id);\n                var isAgentMode = mode == \"agent\";\n\n                // 5) Log incoming message\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = resolvedBusinessId,\n                    ContactId = contact.Id,\n                    RecipientNumber = contactPhone,\n                    MessageContent = content,\n                    Status = \"received\",\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    IsIncoming = true\n                };\n\n                db.MessageLogs.Add(messageLog);\n                await db.SaveChangesAsync();\n\n                await _hub.Clients\n                    .Group($\"business_{resolvedBusinessId}\")\n                    .SendAsync(\"ReceiveInboxMessage\", new\n                    {\n                        contactId = contact.Id,\n                        message = messageLog.MessageContent,\n                        isIncoming = true,\n                        senderId = (Guid?)null,\n                        sentAt = messageLog.CreatedAt\n                    });\n\n                // 6) Try AutoReply runtime first, then fall back to legacy automation\n                try\n                {\n                    var triggerRaw = (content ?? string.Empty).Trim();\n                    var triggerKeyword = triggerRaw.ToLowerInvariant();\n\n                    var autoHandled = false;\n\n                    // 6.1 ‚Äì New AutoReply runtime (keyword ‚Üí simple reply or CTA flow)\n                    if (!string.IsNullOrWhiteSpace(triggerRaw))\n                    {\n                        var autoResult = await autoReplyRuntime.TryHandleAsync(\n                            resolvedBusinessId,\n                            contact.Id,\n                            contact.PhoneNumber,\n                            triggerRaw,                // pass original text (not forced lowercase)\n                            CancellationToken.None     // you can thread a real ct later if you extend the method\n                        );\n\n                        autoHandled = autoResult.Handled;\n\n                        if (autoResult.Handled)\n                        {\n                            logger.LogInformation(\n                                \"ü§ñ AutoReply runtime handled inbound message. BusinessId={BusinessId}, ContactId={ContactId}, Keyword={Keyword}, SentSimpleReply={SentSimpleReply}, StartedCtaFlow={StartedCtaFlow}, AutoReplyFlowId={FlowId}, CtaFlowConfigId={CtaId}\",\n                                resolvedBusinessId,\n                                contact.Id,\n                                triggerKeyword,\n                                autoResult.SentSimpleReply,\n                                autoResult.StartedCtaFlow,\n                                autoResult.AutoReplyFlowId,\n                                autoResult.CtaFlowConfigId\n                            );\n                        }\n                        else\n                        {\n                            logger.LogInformation(\n                                \"ü§ñ AutoReply runtime did not handle message. Falling back to legacy automation. Keyword={Keyword}\",\n                                triggerKeyword\n                            );\n                        }\n                    }\n\n                    // 6.2 ‚Äì Legacy AutomationService fallback (only if AutoReply did NOT handle)\n                    if (!autoHandled)\n                    {\n                        var handledByLegacy = await automationService.TryRunFlowByKeywordAsync(\n                            resolvedBusinessId,\n                            triggerKeyword,\n                            contact.PhoneNumber,\n                            sourceChannel: \"whatsapp\",\n                            industryTag: \"default\");\n\n                        if (!handledByLegacy)\n                        {\n                            logger.LogInformation(\"üïµÔ∏è No automation flow matched keyword (legacy): {Keyword}\", triggerKeyword);\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"‚ùå AutoReply / Automation flow execution failed.\");\n                }\n\n\n                // 7) Sync to inbox only if agent mode\n                if (isAgentMode)\n                {\n                    try\n                    {\n                        var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n\n                        logger.LogInformation(\n                            \"üì• Inbound: syncing message to inbox for BusinessId={BusinessId}, ContactId={ContactId}\",\n                            resolvedBusinessId,\n                            contact.Id);\n\n                        await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n                        {\n                            BusinessId = resolvedBusinessId,\n                            ContactId = contact.Id,\n                            RecipientPhone = contact.PhoneNumber,\n                            MessageBody = messageLog.MessageContent,\n                            IsIncoming = true,\n                            Status = messageLog.Status,\n                            SentAt = messageLog.CreatedAt\n                        });\n\n                        logger.LogInformation(\"‚úÖ Message synced to inbox for contact {Phone}\", contactPhone);\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.LogError(ex, \"‚ùå Failed to sync inbound message to inbox.\");\n                    }\n                }\n                else\n                {\n                    logger.LogInformation(\"üö´ Skipping inbox sync: chat mode is not 'agent'\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process inbound WhatsApp chat.\");\n            }\n        }\n\n        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)\n        {\n            using var scope = _serviceScopeFactory.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n            static string Normalize(string? number) =>\n                string.IsNullOrWhiteSpace(number) ? \"\" : new string(number.Where(char.IsDigit).ToArray());\n\n            // Safe extract of profile name (Meta Cloud shape)\n            static string? TryGetProfileName(JsonElement root)\n            {\n                if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                    contactsEl.ValueKind == JsonValueKind.Array &&\n                    contactsEl.GetArrayLength() > 0)\n                {\n                    var c0 = contactsEl[0];\n                    if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n                        profileEl.ValueKind == JsonValueKind.Object &&\n                        profileEl.TryGetProperty(\"name\", out var nameEl) &&\n                        nameEl.ValueKind == JsonValueKind.String)\n                    {\n                        var n = nameEl.GetString();\n                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                    }\n                }\n                return null;\n            }\n\n            // messages[0].from is always present for interactive/button\n            if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n                return;\n\n            var msg0 = msgs[0];\n            var fromRaw = msg0.GetProperty(\"from\").GetString() ?? \"\";\n            var fromE164 = Normalize(fromRaw);\n\n            // Resolve Business via metadata.display_phone_number ‚Üí WhatsAppPhoneNumbers\n            var displayNumberRaw = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString() ?? \"\";\n            var displayNumber = Normalize(displayNumberRaw);\n\n            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers\n            var candidates = await db.WhatsAppPhoneNumbers\n                .AsNoTracking()\n                .Where(n => n.IsActive)\n                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n                .ToListAsync(ct);\n\n            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);\n            if (numHit == null)\n            {\n                logger.LogWarning(\"‚ùå Business not found for interactive webhook number: {Num}\", displayNumberRaw);\n                return;\n            }\n\n            var businessId = numHit.BusinessId;\n\n            // Upsert profile name if present\n            var profileName = TryGetProfileName(value);\n            if (!string.IsNullOrWhiteSpace(profileName))\n            {\n                try\n                {\n                    await contactProfileService.UpsertProfileNameAsync(businessId, fromE164, profileName!, ct);\n                }\n                catch (Exception ex)\n                {\n                    logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName on interactive webhook for {Phone}\", fromE164);\n                }\n            }\n\n            // ‚Ä¶ continue your existing interactive handling (routing to next step, etc.)\n        }\n    }\n}\n\n\n//using System;\n//using System.Text.Json;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.SignalR;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.CRM.Models;\n//using xbytechat.api.Features.Inbox.Hubs;\n//using Microsoft.Extensions.DependencyInjection;\n//using xbytechat.api.CRM.Interfaces;\n//using xbytechat.api.Features.AutoReplyBuilder.Services;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.CRM.Services;\n//using xbytechat.api.Features.Automation.Services;\n//using xbytechat.api.Features.Contacts.Services;\n\n//namespace xbytechat.api.Features.Webhooks.Services.Processors\n//{\n//    public class InboundMessageProcessor : IInboundMessageProcessor\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IHubContext<InboxHub> _hubContext;\n//        private readonly ILogger<InboundMessageProcessor> _logger;\n//        private readonly IInboxService _inboxService;\n//        private readonly IServiceScopeFactory _serviceScopeFactory;\n//        private readonly IHubContext<InboxHub> _hub;\n//        private readonly IContactProfileService _contactProfile;\n\n//        public InboundMessageProcessor(\n//            AppDbContext context,\n//            IHubContext<InboxHub> hubContext,\n//            ILogger<InboundMessageProcessor> logger,\n//            IInboxService inboxService,\n//            IServiceScopeFactory serviceScopeFactory,\n//            IHubContext<InboxHub> hub,\n//            IContactProfileService contactProfile)\n//        {\n//            _context = context;\n//            _hubContext = hubContext;\n//            _logger = logger;\n//            _inboxService = inboxService;\n//            _serviceScopeFactory = serviceScopeFactory;\n//            _hub = hub;\n//            _contactProfile = contactProfile;\n//        }\n\n//        //public async Task ProcessChatAsync(JsonElement value)\n//        //{\n//        //    // High-level trace for every inbound chat\n//        //    try\n//        //    {\n//        //        var rawText = value.GetRawText();\n//        //        _logger.LogInformation(\n//        //            \"üí¨ InboundMessageProcessor.ProcessChatAsync started. PayloadLength={Length}\",\n//        //            rawText?.Length ?? 0);\n//        //    }\n//        //    catch\n//        //    {\n//        //        // ignore any GetRawText failures ‚Äì not critical\n//        //    }\n\n//        //    try\n//        //    {\n//        //        using var scope = _serviceScopeFactory.CreateScope();\n//        //        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//        //        var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n//        //        var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n//        //        var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n//        //        var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n//        //        var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n\n//        //        // digits-only normalizer (matches how we store/search phones)\n//        //        static string Normalize(string? s) =>\n//        //            string.IsNullOrWhiteSpace(s) ? \"\" : new string(s.Where(char.IsDigit).ToArray());\n\n//        //        // 1) Extract WA metadata + message (Meta Cloud shape)\n//        //        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n//        //        {\n//        //            logger.LogWarning(\"‚ùå Inbound payload has no 'messages' array or it is empty.\");\n//        //            return;\n//        //        }\n\n//        //        var msg = msgs[0];\n\n//        //        var rawContactPhone = msg.GetProperty(\"from\").GetString() ?? \"\";\n//        //        var contactPhone = Normalize(rawContactPhone);\n//        //        var content = msg.TryGetProperty(\"text\", out var t) && t.TryGetProperty(\"body\", out var b)\n//        //            ? b.GetString()\n//        //            : null;\n\n//        //        if (!value.TryGetProperty(\"metadata\", out var metadata))\n//        //        {\n//        //            logger.LogWarning(\"‚ùå Inbound payload missing 'metadata' field.\");\n//        //            return;\n//        //        }\n\n//        //        var rawBusinessNumber = metadata.GetProperty(\"display_phone_number\").GetString() ?? \"\";\n//        //        var cleanIncomingBiz = Normalize(rawBusinessNumber);\n\n//        //        logger.LogInformation(\n//        //            \"üîé Inbound extract: rawContactPhone={RawContact}, normalizedContact={Contact}, rawBusinessNumber={RawBiz}, normalizedBiz={Biz}\",\n//        //            rawContactPhone,\n//        //            contactPhone,\n//        //            rawBusinessNumber,\n//        //            cleanIncomingBiz);\n\n//        //        // 2) Resolve business  ‚úÖ now via WhatsAppPhoneNumbers (NOT WhatsAppSettings)\n//        //        Guid? businessIdHit = null;\n\n//        //        // Pull active numbers (small table; client-side normalization for reliability)\n//        //        var candidates = await db.WhatsAppPhoneNumbers\n//        //            .AsNoTracking()\n//        //            .Where(n => n.IsActive)\n//        //            .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n//        //            .ToListAsync();\n\n//        //        logger.LogDebug(\"üìä Inbound: Loaded {Count} active WhatsAppPhoneNumbers candidates.\", candidates.Count);\n\n//        //        var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);\n//        //        if (numHit != null)\n//        //        {\n//        //            businessIdHit = numHit.BusinessId;\n//        //            logger.LogInformation(\n//        //                \"‚úÖ Inbound: resolved BusinessId={BusinessId} for display_phone_number={RawBiz}\",\n//        //                businessIdHit,\n//        //                rawBusinessNumber);\n//        //        }\n\n//        //        if (businessIdHit == null || businessIdHit == Guid.Empty)\n//        //        {\n//        //            logger.LogWarning(\n//        //                \"‚ùå Business not found for WhatsApp number: {Number} (normalized={Norm})\",\n//        //                rawBusinessNumber,\n//        //                cleanIncomingBiz);\n//        //            return;\n//        //        }\n\n//        //        var businessId = businessIdHit.Value;\n\n//        //        // 3) Find or create contact\n//        //        logger.LogInformation(\n//        //            \"üë§ Inbound: resolving contact for BusinessId={BusinessId}, Phone={Phone}\",\n//        //            businessId,\n//        //            contactPhone);\n\n//        //        var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);\n//        //        if (contact == null)\n//        //        {\n//        //            logger.LogWarning(\"‚ùå Could not resolve contact for phone: {Phone}\", contactPhone);\n//        //            return;\n//        //        }\n\n//        //        logger.LogInformation(\"‚úÖ Inbound: contact resolved. ContactId={ContactId}\", contact.Id);\n\n//        //        // Extract profile name (contacts[0].profile.name) and upsert into Contacts\n//        //        static string? TryGetProfileName(JsonElement root)\n//        //        {\n//        //            if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n//        //                contactsEl.ValueKind == JsonValueKind.Array &&\n//        //                contactsEl.GetArrayLength() > 0)\n//        //            {\n//        //                var c0 = contactsEl[0];\n//        //                if (c0.TryGetProperty(\"profile\", out var prof) &&\n//        //                    prof.ValueKind == JsonValueKind.Object &&\n//        //                    prof.TryGetProperty(\"name\", out var nm) &&\n//        //                    nm.ValueKind == JsonValueKind.String)\n//        //                {\n//        //                    var n = nm.GetString();\n//        //                    return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n//        //                }\n//        //            }\n//        //            return null;\n//        //        }\n\n//        //        var profileName = TryGetProfileName(value);\n//        //        if (!string.IsNullOrWhiteSpace(profileName))\n//        //        {\n//        //            try\n//        //            {\n//        //                logger.LogInformation(\n//        //                    \"üßæ Inbound: upserting profile name for BusinessId={BusinessId}, Phone={Phone}, Name={Name}\",\n//        //                    businessId,\n//        //                    contactPhone,\n//        //                    profileName);\n\n//        //                await contactProfileService.UpsertProfileNameAsync(\n//        //                    businessId,\n//        //                    contactPhone,\n//        //                    profileName!,\n//        //                    CancellationToken.None);\n//        //            }\n//        //            catch (Exception ex)\n//        //            {\n//        //                logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName for {Phone}\", contactPhone);\n//        //            }\n//        //        }\n\n//        //        // 4) Check chat mode‚Ä¶\n//        //        var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);\n//        //        var isAgentMode = mode == \"agent\";\n\n//        //        logger.LogInformation(\n//        //            \"üí¨ Inbound: chat mode for contact {ContactId} is '{Mode}' (isAgentMode={IsAgentMode})\",\n//        //            contact.Id,\n//        //            mode,\n//        //            isAgentMode);\n\n//        //        // 5) Log incoming message\n//        //        var messageLog = new MessageLog\n//        //        {\n//        //            Id = Guid.NewGuid(),\n//        //            BusinessId = businessId,\n//        //            ContactId = contact.Id,\n//        //            RecipientNumber = contactPhone,\n//        //            MessageContent = content,\n//        //            Status = \"received\",\n//        //            CreatedAt = DateTime.UtcNow,\n//        //            SentAt = DateTime.UtcNow,\n//        //            IsIncoming = true\n//        //        };\n\n//        //        db.MessageLogs.Add(messageLog);\n//        //        await db.SaveChangesAsync();\n\n//        //        logger.LogInformation(\n//        //            \"üìù Inbound: MessageLog saved. MessageLogId={MessageLogId}, BusinessId={BusinessId}, ContactId={ContactId}\",\n//        //            messageLog.Id,\n//        //            businessId,\n//        //            contact.Id);\n\n//        //        // 6) Notify Inbox clients via SignalR\n//        //        try\n//        //        {\n//        //            var groupName = $\"business_{businessId}\";\n//        //            logger.LogInformation(\n//        //                \"üì° Inbound: broadcasting ReceiveInboxMessage to SignalR group {GroupName} for ContactId={ContactId}\",\n//        //                groupName,\n//        //                contact.Id);\n\n//        //            await _hub.Clients\n//        //                .Group(groupName)\n//        //                .SendAsync(\"ReceiveInboxMessage\", new\n//        //                {\n//        //                    contactId = contact.Id,\n//        //                    message = messageLog.MessageContent,\n//        //                    isIncoming = true,\n//        //                    senderId = (Guid?)null,\n//        //                    sentAt = messageLog.CreatedAt\n//        //                });\n//        //        }\n//        //        catch (Exception ex)\n//        //        {\n//        //            logger.LogWarning(ex, \"‚ö†Ô∏è Inbound: failed to broadcast ReceiveInboxMessage to SignalR.\");\n//        //        }\n\n//        //        // 7) Try to trigger automation by keyword\n//        //        try\n//        //        {\n//        //            var triggerKeyword = (content ?? string.Empty).Trim().ToLowerInvariant();\n//        //            logger.LogInformation(\n//        //                \"‚öôÔ∏è Inbound: attempting automation flow match for keyword='{Keyword}'\",\n//        //                triggerKeyword);\n\n//        //            var handled = await automationService.TryRunFlowByKeywordAsync(\n//        //                businessId,\n//        //                triggerKeyword,\n//        //                contact.PhoneNumber,\n//        //                sourceChannel: \"whatsapp\",\n//        //                industryTag: \"default\");\n\n//        //            if (!handled)\n//        //                logger.LogInformation(\"üïµÔ∏è No automation flow matched keyword: {Keyword}\", triggerKeyword);\n//        //            else\n//        //                logger.LogInformation(\"‚úÖ Automation flow handled inbound keyword: {Keyword}\", triggerKeyword);\n//        //        }\n//        //        catch (Exception ex)\n//        //        {\n//        //            logger.LogError(ex, \"‚ùå Automation flow execution failed.\");\n//        //        }\n\n//        //        // 8) Sync to inbox only if agent mode\n//        //        if (isAgentMode)\n//        //        {\n//        //            try\n//        //            {\n//        //                var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n\n//        //                logger.LogInformation(\n//        //                    \"üì• Inbound: syncing message to inbox for BusinessId={BusinessId}, ContactId={ContactId}\",\n//        //                    businessId,\n//        //                    contact.Id);\n\n//        //                await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n//        //                {\n//        //                    BusinessId = businessId,\n//        //                    ContactId = contact.Id,\n//        //                    RecipientPhone = contact.PhoneNumber,\n//        //                    MessageBody = messageLog.MessageContent,\n//        //                    IsIncoming = true,\n//        //                    Status = messageLog.Status,\n//        //                    SentAt = messageLog.CreatedAt\n//        //                });\n\n//        //                logger.LogInformation(\"‚úÖ Message synced to inbox for contact {Phone}\", contactPhone);\n//        //            }\n//        //            catch (Exception ex)\n//        //            {\n//        //                logger.LogError(ex, \"‚ùå Failed to sync inbound message to inbox.\");\n//        //            }\n//        //        }\n//        //        else\n//        //        {\n//        //            logger.LogInformation(\"üö´ Skipping inbox sync: chat mode is not 'agent'\");\n//        //        }\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        _logger.LogError(ex, \"‚ùå Failed to process inbound WhatsApp chat.\");\n//        //    }\n//        //}\n\n//        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)\n//        {\n//            _logger.LogInformation(\"üí¨ InboundMessageProcessor.ProcessInteractiveAsync started.\");\n\n//            using var scope = _serviceScopeFactory.CreateScope();\n//            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n//            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n//            static string Normalize(string? number) =>\n//                string.IsNullOrWhiteSpace(number) ? \"\" : new string(number.Where(char.IsDigit).ToArray());\n\n//            // Safe extract of profile name (Meta Cloud shape)\n//            static string? TryGetProfileName(JsonElement root)\n//            {\n//                if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n//                    contactsEl.ValueKind == JsonValueKind.Array &&\n//                    contactsEl.GetArrayLength() > 0)\n//                {\n//                    var c0 = contactsEl[0];\n//                    if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n//                        profileEl.ValueKind == JsonValueKind.Object &&\n//                        profileEl.TryGetProperty(\"name\", out var nameEl) &&\n//                        nameEl.ValueKind == JsonValueKind.String)\n//                    {\n//                        var n = nameEl.GetString();\n//                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n//                    }\n//                }\n//                return null;\n//            }\n\n//            // messages[0].from is always present for interactive/button\n//            if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n//            {\n//                logger.LogWarning(\"‚ùå Interactive payload has no 'messages' array or it is empty.\");\n//                return;\n//            }\n\n//            var msg0 = msgs[0];\n//            var fromRaw = msg0.GetProperty(\"from\").GetString() ?? \"\";\n//            var fromE164 = Normalize(fromRaw);\n\n//            logger.LogInformation(\n//                \"üîé Interactive: fromRaw={FromRaw}, normalized={FromNorm}\",\n//                fromRaw,\n//                fromE164);\n\n//            // Resolve Business via metadata.display_phone_number ‚Üí WhatsAppPhoneNumbers\n//            if (!value.TryGetProperty(\"metadata\", out var metadata))\n//            {\n//                logger.LogWarning(\"‚ùå Interactive payload missing 'metadata' field.\");\n//                return;\n//            }\n\n//            var displayNumberRaw = metadata.GetProperty(\"display_phone_number\").GetString() ?? \"\";\n//            var displayNumber = Normalize(displayNumberRaw);\n\n//            logger.LogInformation(\n//                \"üîé Interactive: display_phone_number raw={Raw}, normalized={Norm}\",\n//                displayNumberRaw,\n//                displayNumber);\n\n//            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers\n//            var candidates = await db.WhatsAppPhoneNumbers\n//                .AsNoTracking()\n//                .Where(n => n.IsActive)\n//                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n//                .ToListAsync(ct);\n\n//            logger.LogDebug(\"üìä Interactive: Loaded {Count} active WhatsAppPhoneNumbers candidates.\", candidates.Count);\n\n//            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);\n//            if (numHit == null)\n//            {\n//                logger.LogWarning(\n//                    \"‚ùå Business not found for interactive webhook number: {NumRaw} (normalized={Norm})\",\n//                    displayNumberRaw,\n//                    displayNumber);\n//                return;\n//            }\n\n//            var businessId = numHit.BusinessId;\n//            logger.LogInformation(\n//                \"‚úÖ Interactive: resolved BusinessId={BusinessId} for number={NumRaw}\",\n//                businessId,\n//                displayNumberRaw);\n\n//            // Upsert profile name if present\n//            var profileName = TryGetProfileName(value);\n//            if (!string.IsNullOrWhiteSpace(profileName))\n//            {\n//                try\n//                {\n//                    logger.LogInformation(\n//                        \"üßæ Interactive: upserting profile name for BusinessId={BusinessId}, Phone={Phone}, Name={Name}\",\n//                        businessId,\n//                        fromE164,\n//                        profileName);\n\n//                    await contactProfileService.UpsertProfileNameAsync(\n//                        businessId,\n//                        fromE164,\n//                        profileName!,\n//                        ct);\n//                }\n//                catch (Exception ex)\n//                {\n//                    logger.LogWarning(\n//                        ex,\n//                        \"‚ö†Ô∏è Failed to upsert ProfileName on interactive webhook for {Phone}\",\n//                        fromE164);\n//                }\n//            }\n\n//            // ‚Ä¶ your existing interactive handling continues (routing to next step, etc.)\n//        }\n//    }\n//}\n\n\n////using System;\n////using System.Text.Json;\n////using System.Threading.Tasks;\n////using Microsoft.AspNetCore.SignalR;\n////using Microsoft.EntityFrameworkCore;\n////using Microsoft.Extensions.Logging;\n////using xbytechat.api;\n////using xbytechat.api.Features.Inbox.DTOs;\n////using xbytechat.api.CRM.Models;\n////using xbytechat.api.Features.Inbox.Hubs;\n////using Microsoft.Extensions.DependencyInjection;\n////using xbytechat.api.CRM.Interfaces;\n////using xbytechat.api.Features.AutoReplyBuilder.Services;\n////using xbytechat.api.Features.Inbox.Services;\n////using xbytechat.api.Features.MessagesEngine.DTOs;\n////using xbytechat.api.Features.MessagesEngine.Services;\n////using xbytechat.api.CRM.Services;\n////using xbytechat.api.Features.Automation.Services;\n////using xbytechat.api.Features.Contacts.Services;\n\n\n////namespace xbytechat.api.Features.Webhooks.Services.Processors\n////{\n////    public class InboundMessageProcessor : IInboundMessageProcessor\n////    {\n////        private readonly AppDbContext _context;\n////        private readonly IHubContext<InboxHub> _hubContext;\n////        private readonly ILogger<InboundMessageProcessor> _logger;\n////        private readonly IInboxService _inboxService;\n////        private readonly IServiceScopeFactory _serviceScopeFactory;\n////        private readonly IHubContext<InboxHub> _hub;\n////        private readonly IContactProfileService _contactProfile;\n////        public InboundMessageProcessor(\n////            AppDbContext context,\n////            IHubContext<InboxHub> hubContext,\n////            ILogger<InboundMessageProcessor> logger,\n////            IInboxService inboxService,\n////            IServiceScopeFactory serviceScopeFactory,\n////            IHubContext<InboxHub> hub, IContactProfileService contactProfile)\n////        {\n////            _context = context;\n////            _hubContext = hubContext;\n////            _logger = logger;\n////            _inboxService = inboxService;\n////            _serviceScopeFactory = serviceScopeFactory;\n////            _hub = hub;\n////            _contactProfile = contactProfile;\n////        }\n\n////        public async Task ProcessChatAsync(JsonElement value)\n////        {\n////            try\n////            {\n////                using var scope = _serviceScopeFactory.CreateScope();\n////                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n////                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n////                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n////                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n////                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n////                var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n\n////                // digits-only normalizer (matches how we store/search phones)\n////                static string Normalize(string? s) =>\n////                    string.IsNullOrWhiteSpace(s) ? \"\" : new string(s.Where(char.IsDigit).ToArray());\n\n////                // 1) Extract WA metadata + message (Meta Cloud shape)\n////                var msg = value.GetProperty(\"messages\")[0];\n////                var rawContactPhone = msg.GetProperty(\"from\").GetString() ?? \"\";\n////                var contactPhone = Normalize(rawContactPhone);\n////                var content = msg.TryGetProperty(\"text\", out var t) && t.TryGetProperty(\"body\", out var b) ? b.GetString() : null;\n\n////                var rawBusinessNumber = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString() ?? \"\";\n////                var cleanIncomingBiz = Normalize(rawBusinessNumber);\n\n////                // 2) Resolve business  ‚úÖ now via WhatsAppPhoneNumbers (NOT WhatsAppSettings)\n////                Guid? businessIdHit = null;\n\n////                // Pull active numbers (small table; client-side normalization for reliability)\n////                var candidates = await db.WhatsAppPhoneNumbers\n////                    .AsNoTracking()\n////                    .Where(n => n.IsActive)\n////                    .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n////                    .ToListAsync();\n\n////                var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);\n////                if (numHit != null) businessIdHit = numHit.BusinessId;\n\n////                if (businessIdHit == null || businessIdHit == Guid.Empty)\n////                {\n////                    logger.LogWarning(\"‚ùå Business not found for WhatsApp number: {Number}\", rawBusinessNumber);\n////                    return;\n////                }\n\n////                var businessId = businessIdHit.Value;\n\n////                // 3) Find or create contact\n////                var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);\n////                if (contact == null)\n////                {\n////                    logger.LogWarning(\"‚ùå Could not resolve contact for phone: {Phone}\", contactPhone);\n////                    return;\n////                }\n\n////                // Extract profile name (contacts[0].profile.name) and upsert into Contacts\n////                static string? TryGetProfileName(JsonElement root)\n////                {\n////                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n////                        contactsEl.ValueKind == JsonValueKind.Array &&\n////                        contactsEl.GetArrayLength() > 0)\n////                    {\n////                        var c0 = contactsEl[0];\n////                        if (c0.TryGetProperty(\"profile\", out var prof) &&\n////                            prof.ValueKind == JsonValueKind.Object &&\n////                            prof.TryGetProperty(\"name\", out var nm) &&\n////                            nm.ValueKind == JsonValueKind.String)\n////                        {\n////                            var n = nm.GetString();\n////                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n////                        }\n////                    }\n////                    return null;\n////                }\n\n////                var profileName = TryGetProfileName(value);\n////                if (!string.IsNullOrWhiteSpace(profileName))\n////                {\n////                    try\n////                    {\n////                        await contactProfileService.UpsertProfileNameAsync(businessId, contactPhone, profileName!, CancellationToken.None);\n////                    }\n////                    catch (Exception ex)\n////                    {\n////                        logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName for {Phone}\", contactPhone);\n////                    }\n////                }\n\n////                // 4) Check chat mode‚Ä¶\n////                var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);\n////                var isAgentMode = mode == \"agent\";\n\n////                // 5) Log incoming message\n////                var messageLog = new MessageLog\n////                {\n////                    Id = Guid.NewGuid(),\n////                    BusinessId = businessId,\n////                    ContactId = contact.Id,\n////                    RecipientNumber = contactPhone,\n////                    MessageContent = content,\n////                    Status = \"received\",\n////                    CreatedAt = DateTime.UtcNow,\n////                    SentAt = DateTime.UtcNow,\n////                    IsIncoming = true\n////                };\n\n////                db.MessageLogs.Add(messageLog);\n////                await db.SaveChangesAsync();\n\n////                await _hub.Clients\n////                    .Group($\"business_{businessId}\")\n////                    .SendAsync(\"ReceiveInboxMessage\", new\n////                    {\n////                        contactId = contact.Id,\n////                        message = messageLog.MessageContent,\n////                        isIncoming = true,\n////                        senderId = (Guid?)null,\n////                        sentAt = messageLog.CreatedAt\n////                    });\n\n////                // 6) Try to trigger automation by keyword\n////                try\n////                {\n////                    var triggerKeyword = (content ?? string.Empty).Trim().ToLowerInvariant();\n////                    var handled = await automationService.TryRunFlowByKeywordAsync(\n////                        businessId,\n////                        triggerKeyword,\n////                        contact.PhoneNumber,\n////                        sourceChannel: \"whatsapp\",\n////                        industryTag: \"default\");\n\n////                    if (!handled)\n////                        logger.LogInformation(\"üïµÔ∏è No automation flow matched keyword: {Keyword}\", triggerKeyword);\n////                }\n////                catch (Exception ex)\n////                {\n////                    logger.LogError(ex, \"‚ùå Automation flow execution failed.\");\n////                }\n\n////                // 7) Sync to inbox only if agent mode\n////                if (isAgentMode)\n////                {\n////                    var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n////                    await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n////                    {\n////                        BusinessId = businessId,\n////                        ContactId = contact.Id,\n////                        RecipientPhone = contact.PhoneNumber,\n////                        MessageBody = messageLog.MessageContent,\n////                        IsIncoming = true,\n////                        Status = messageLog.Status,\n////                        SentAt = messageLog.CreatedAt\n////                    });\n\n////                    logger.LogInformation(\"üì• Message synced to inbox for contact {Phone}\", contactPhone);\n////                }\n////                else\n////                {\n////                    logger.LogInformation(\"üö´ Skipping inbox sync: chat mode is not 'agent'\");\n////                }\n////            }\n////            catch (Exception ex)\n////            {\n////                _logger.LogError(ex, \"‚ùå Failed to process inbound WhatsApp chat.\");\n////            }\n////        }\n\n////        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)\n////        {\n////            using var scope = _serviceScopeFactory.CreateScope();\n////            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n////            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n////            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n////            static string Normalize(string? number) =>\n////                string.IsNullOrWhiteSpace(number) ? \"\" : new string(number.Where(char.IsDigit).ToArray());\n\n////            // Safe extract of profile name (Meta Cloud shape)\n////            static string? TryGetProfileName(JsonElement root)\n////            {\n////                if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n////                    contactsEl.ValueKind == JsonValueKind.Array &&\n////                    contactsEl.GetArrayLength() > 0)\n////                {\n////                    var c0 = contactsEl[0];\n////                    if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n////                        profileEl.ValueKind == JsonValueKind.Object &&\n////                        profileEl.TryGetProperty(\"name\", out var nameEl) &&\n////                        nameEl.ValueKind == JsonValueKind.String)\n////                    {\n////                        var n = nameEl.GetString();\n////                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n////                    }\n////                }\n////                return null;\n////            }\n\n////            // messages[0].from is always present for interactive/button\n////            if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n////                return;\n\n////            var msg0 = msgs[0];\n////            var fromRaw = msg0.GetProperty(\"from\").GetString() ?? \"\";\n////            var fromE164 = Normalize(fromRaw);\n\n////            // Resolve Business via metadata.display_phone_number ‚Üí WhatsAppPhoneNumbers\n////            var displayNumberRaw = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString() ?? \"\";\n////            var displayNumber = Normalize(displayNumberRaw);\n\n////            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers\n////            var candidates = await db.WhatsAppPhoneNumbers\n////                .AsNoTracking()\n////                .Where(n => n.IsActive)\n////                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n////                .ToListAsync(ct);\n\n////            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);\n////            if (numHit == null)\n////            {\n////                logger.LogWarning(\"‚ùå Business not found for interactive webhook number: {Num}\", displayNumberRaw);\n////                return;\n////            }\n\n////            var businessId = numHit.BusinessId;\n\n////            // Upsert profile name if present\n////            var profileName = TryGetProfileName(value);\n////            if (!string.IsNullOrWhiteSpace(profileName))\n////            {\n////                try\n////                {\n////                    await contactProfileService.UpsertProfileNameAsync(businessId, fromE164, profileName!, ct);\n////                }\n////                catch (Exception ex)\n////                {\n////                    logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName on interactive webhook for {Phone}\", fromE164);\n////                }\n////            }\n\n////            // ‚Ä¶ continue your existing interactive handling (routing to next step, etc.)\n////        }\n\n////    }\n////}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IStatusWebhookProcessor.cs",
      "sha256": "4a20eff4b49cd6b4a448445b156c4cab5024becc931566b1cba6d9c5c4e4d89f",
      "language": "csharp",
      "size": 275,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IStatusWebhookProcessor\n    {\n        Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default);\n    }\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ITemplateWebhookProcessor.cs",
      "sha256": "6f04b24d675a88073c59204ed241e4744205e80e8d488dd464550a6105c45b7a",
      "language": "csharp",
      "size": 242,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface ITemplateWebhookProcessor\n    {\n        Task ProcessTemplateUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/StatusWebhookProcessor.cs",
      "sha256": "8dbca3bd505a7a12bd18166688de1e4762c7c6ad5afdc5aa37cfb6789c8018f5",
      "language": "csharp",
      "size": 17950,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\n// üëá where your AppDbContext lives\nusing xbytechat.api;\n\nusing xbytechat.api.Features.CampaignTracking.Models;   // CampaignSendLog\nusing xbytechat.api.Features.MessageManagement.DTOs;    // MessageLog\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Features.Webhooks.Status;\nusing xbytechat.api.Infrastructure.Observability;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    /// <summary>\n    /// Legacy status processor (back-compat).\n    /// - Extracts statuses from the payload\n    /// - Resolves CampaignSendLog via IMessageIdResolver when possible\n    /// - Updates CampaignSendLog / MessageLog idempotently\n    /// New provider-aware flow should go through the dispatcher -> WhatsAppWebhookService.\n    /// </summary>\n    public class StatusWebhookProcessor : IStatusWebhookProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<StatusWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly IMessageStatusUpdater _updater;\n        public StatusWebhookProcessor(\n            AppDbContext context,\n            ILogger<StatusWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            IMessageStatusUpdater updater)\n        {\n            _context = context;\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _updater = updater;\n        }\n\n        /// <summary>\n        /// Entry point from dispatcher (legacy path).\n        /// Normalizes Meta envelope to a \"value\" object, then processes.\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default)\n        {\n            _logger.LogDebug(\"status_webhook_in (legacy)\\n{Payload}\", payload.ToString());\n\n            // 0) Batch payloads: recurse per item\n            if (payload.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var item in payload.EnumerateArray())\n                    await ProcessStatusUpdateAsync(item, ct);\n                return;\n            }\n\n            // 1) Canonical Meta envelope: { entry:[{ changes:[{ value:{...} }]}] }\n            if (payload.ValueKind == JsonValueKind.Object &&\n                payload.TryGetProperty(\"entry\", out var entry) &&\n                entry.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var e in entry.EnumerateArray())\n                {\n                    if (e.TryGetProperty(\"changes\", out var changes) && changes.ValueKind == JsonValueKind.Array)\n                    {\n                        foreach (var ch in changes.EnumerateArray())\n                        {\n                            if (ch.TryGetProperty(\"value\", out var v))\n                                await ProcessAsync(v.GetRawText(), ct); // <- pass string + ct\n                        }\n                    }\n                }\n                return;\n            }\n\n            // 2) Envelope ‚Üí value via helper (back-compat)\n            if (TryExtractValue(payload, out var value))\n            {\n                await ProcessAsync(value.GetRawText(), ct);            // <- pass string + ct\n                return;\n            }\n\n            // 3) Already value-like (adapter flattened)\n            if (payload.ValueKind == JsonValueKind.Object &&\n                (payload.TryGetProperty(\"statuses\", out _) || payload.TryGetProperty(\"messages\", out _)))\n            {\n                await ProcessAsync(payload.GetRawText(), ct);          // <- pass string + ct\n                return;\n            }\n\n            // 4) Minimal single-status object (id/status)\n            if (payload.ValueKind == JsonValueKind.Object &&\n                payload.TryGetProperty(\"id\", out _) &&\n                payload.TryGetProperty(\"status\", out _))\n            {\n                await ProcessAsync(payload.GetRawText(), ct);          // <- pass string + ct\n                return;\n            }\n\n            _logger.LogWarning(\"Unrecognized status payload shape (legacy path).\");\n            MetricsRegistry.MessagesFailed.Add(1);\n        }\n\n        /// <summary>\n        /// Extract statuses from a Meta-like \"value\" object and update DB.\n        /// </summary>\n        //public async Task ProcessAsync(JsonElement value)\n        //{\n        //    if (!value.TryGetProperty(\"statuses\", out var statuses) || statuses.ValueKind != JsonValueKind.Array)\n        //    {\n        //        _logger.LogWarning(\"‚ö†Ô∏è 'statuses' array missing in webhook payload (legacy path).\");\n        //        return;\n        //    }\n\n        //    foreach (var status in statuses.EnumerateArray())\n        //    {\n        //        if (status.ValueKind != JsonValueKind.Object) continue;\n\n        //        // message id (WAMID)\n        //        var messageId = status.TryGetProperty(\"id\", out var idEl) && idEl.ValueKind == JsonValueKind.String\n        //            ? idEl.GetString()\n        //            : null;\n\n        //        // status text\n        //        var statusText = status.TryGetProperty(\"status\", out var stEl) && stEl.ValueKind == JsonValueKind.String\n        //            ? stEl.GetString()\n        //            : null;\n\n        //        if (string.IsNullOrWhiteSpace(messageId) || string.IsNullOrWhiteSpace(statusText))\n        //        {\n        //            _logger.LogWarning(\"‚ö†Ô∏è Missing messageId or status in webhook payload (legacy path).\");\n        //            continue;\n        //        }\n\n        //        // timestamp (string or number)\n        //        DateTime? eventTime = null;\n        //        if (status.TryGetProperty(\"timestamp\", out var tsEl))\n        //        {\n        //            if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var epochS))\n        //                eventTime = DateTimeOffset.FromUnixTimeSeconds(epochS).UtcDateTime;\n        //            else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var epochN))\n        //                eventTime = DateTimeOffset.FromUnixTimeSeconds(epochN).UtcDateTime;\n        //        }\n\n        //        _logger.LogDebug(\"üïì Parsed timestamp: {Time} (raw kind={Kind})\",\n        //            eventTime?.ToString(\"o\") ?? \"n/a\", status.TryGetProperty(\"timestamp\", out var tsDbg) ? tsDbg.ValueKind.ToString() : \"n/a\");\n\n        //        // ‚úÖ First try resolving a CampaignSendLog row via resolver\n        //        Guid? sendLogId = null;\n        //        try\n        //        {\n        //            sendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n        //        }\n        //        catch (Exception ex)\n        //        {\n        //            _logger.LogWarning(ex, \"MessageId resolver failed for {MessageId}\", messageId);\n        //        }\n\n        //        if (sendLogId is Guid sid)\n        //        {\n        //            var log = await _context.Set<CampaignSendLog>()\n        //                                    .FirstOrDefaultAsync(l => l.Id == sid);\n\n        //            if (log != null)\n        //            {\n        //                bool changed = false;\n\n        //                var newStatus = MapMetaStatus(statusText);\n        //                if (!string.IsNullOrEmpty(newStatus) &&\n        //                    !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))\n        //                {\n        //                    log.SendStatus = newStatus;\n        //                    changed = true;\n        //                }\n\n        //                if (statusText == \"sent\" && (log.SentAt == null || log.SentAt == default) && eventTime.HasValue)\n        //                {\n        //                    log.SentAt = eventTime.Value;\n        //                    changed = true;\n        //                }\n        //                if (statusText == \"delivered\" && (log.DeliveredAt == null || log.DeliveredAt == default) && eventTime.HasValue)\n        //                {\n        //                    log.DeliveredAt = eventTime.Value;\n        //                    changed = true;\n        //                }\n        //                if (statusText == \"read\" && (log.ReadAt == null || log.ReadAt == default) && eventTime.HasValue)\n        //                {\n        //                    log.ReadAt = eventTime.Value;\n        //                    changed = true;\n        //                }\n\n        //                if (changed)\n        //                {\n        //                    await _context.SaveChangesAsync();\n        //                    _logger.LogInformation(\"‚úÖ CampaignSendLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}\", messageId, newStatus ?? statusText);\n        //                }\n        //                else\n        //                {\n        //                    _logger.LogInformation(\"üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)\", statusText, messageId);\n        //                }\n\n        //                continue; // done with this status item\n        //            }\n        //        }\n\n        //        // üîÅ Fallback: update MessageLog when there‚Äôs no CampaignSendLog\n        //        var msg = await _context.Set<MessageLog>()\n        //                                .FirstOrDefaultAsync(m => m.MessageId == messageId);\n\n        //        if (msg != null)\n        //        {\n        //            bool changed = false;\n\n        //            switch (statusText)\n        //            {\n        //                case \"sent\":\n        //                    if (!EqualsIgnoreCase(msg.Status, \"Sent\"))\n        //                    {\n        //                        msg.Status = \"Sent\";\n        //                        changed = true;\n        //                    }\n        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n        //                    {\n        //                        msg.SentAt = eventTime.Value;\n        //                        changed = true;\n        //                    }\n        //                    break;\n\n        //                case \"delivered\":\n        //                    // no DeliveredAt column on MessageLog; just progression\n        //                    if (!EqualsIgnoreCase(msg.Status, \"Read\") &&\n        //                        !EqualsIgnoreCase(msg.Status, \"Delivered\"))\n        //                    {\n        //                        msg.Status = \"Delivered\";\n        //                        changed = true;\n        //                    }\n        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n        //                    {\n        //                        msg.SentAt = eventTime.Value; // ensure SentAt eventually set\n        //                        changed = true;\n        //                    }\n        //                    break;\n\n        //                case \"read\":\n        //                    if (!EqualsIgnoreCase(msg.Status, \"Read\"))\n        //                    {\n        //                        msg.Status = \"Read\";\n        //                        changed = true;\n        //                    }\n        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n        //                    {\n        //                        msg.SentAt = eventTime.Value;\n        //                        changed = true;\n        //                    }\n        //                    break;\n\n        //                default:\n        //                    // leave as-is for unknown statuses\n        //                    break;\n        //            }\n\n        //            if (changed)\n        //            {\n        //                await _context.SaveChangesAsync();\n        //                _logger.LogInformation(\"‚ÑπÔ∏è MessageLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}\", messageId, msg.Status);\n        //            }\n        //            else\n        //            {\n        //                _logger.LogInformation(\"üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)\", statusText, messageId);\n        //            }\n        //        }\n        //        else\n        //        {\n        //            // lower severity; common when a send failed before obtaining a message id\n        //            _logger.LogInformation(\"‚ìò No matching CampaignSendLog/MessageLog for MessageId: {MessageId} (legacy)\", messageId);\n        //        }\n        //    }\n        //}\n        public sealed class MetaStatusEnvelope\n        {\n            public Entry[]? entry { get; set; }\n            public sealed class Entry { public Change[]? changes { get; set; } }\n            public sealed class Change { public Value? value { get; set; } }\n            public sealed class Value { public Status[]? statuses { get; set; } }\n            public sealed class Status\n            {\n                public string? id { get; set; }          // WAMID\n                public string? status { get; set; }      // sent|delivered|read|failed\n                public long? timestamp { get; set; }     // epoch seconds\n                public StatusError[]? errors { get; set; }\n            }\n            public sealed class StatusError { public string? message { get; set; } public string? code { get; set; } }\n        }\n\n        // Fallback \"simple\" event for manual tests/tools\n        public sealed class SimpleStatusEvent\n        {\n            public string? MessageId { get; set; }\n            public string? Status { get; set; }\n            public long? Timestamp { get; set; }\n            public string? ErrorMessage { get; set; }\n        }\n\n      \n                // make sure this is injected too\n\n        public async Task<int> ProcessAsync(string rawJson, CancellationToken ct)\n        {\n            // Try Meta-like envelope first\n            try\n            {\n                var env = System.Text.Json.JsonSerializer.Deserialize<MetaStatusEnvelope>(rawJson);\n                if (env?.entry is { Length: > 0 })\n                {\n                    var total = 0;\n                    foreach (var e in env.entry)\n                        foreach (var ch in e.changes ?? Array.Empty<MetaStatusEnvelope.Change>())\n                            foreach (var st in ch.value?.statuses ?? Array.Empty<MetaStatusEnvelope.Status>())\n                            {\n                                var providerMsgId = st.id ?? string.Empty;\n                                var wamid = await _messageIdResolver.ResolveAsync(providerMsgId, ct) ?? providerMsgId; // no-op if already WAMID\n                                var status = (st.status ?? \"\").Trim().ToLowerInvariant();\n                                var ts = st.timestamp.HasValue\n                                    ? DateTimeOffset.FromUnixTimeSeconds(st.timestamp.Value).UtcDateTime\n                                    : DateTime.UtcNow;\n                                var err = st.errors?.FirstOrDefault()?.message;\n\n                                if (!string.IsNullOrWhiteSpace(wamid) && !string.IsNullOrWhiteSpace(status))\n                                {\n                                    total += await _updater.UpdateAsync(wamid, status, ts, err, ct);\n                                }\n                            }\n                    return total;\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"[StatusWebhookProcessor] Meta envelope parse failed; trying simple shape.\");\n            }\n\n            // Fallback: simple shape (handy for cURL testing)\n            try\n            {\n                var ev = System.Text.Json.JsonSerializer.Deserialize<SimpleStatusEvent>(rawJson);\n                if (ev?.MessageId is not null && ev.Status is not null)\n                {\n                    var ts = ev.Timestamp.HasValue\n                        ? DateTimeOffset.FromUnixTimeSeconds(ev.Timestamp.Value).UtcDateTime\n                        : DateTime.UtcNow;\n                    return await _updater.UpdateAsync(ev.MessageId, ev.Status, ts, ev.ErrorMessage, ct);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"[StatusWebhookProcessor] Simple shape parse failed\");\n            }\n\n            _logger.LogWarning(\"[StatusWebhookProcessor] Unsupported payload\");\n            return 0;\n        }\n\n        // ----------------- helpers -----------------\n\n        private static bool TryExtractValue(JsonElement payload, out JsonElement value)\n        {\n            value = default;\n            if (payload.ValueKind != JsonValueKind.Object) return false;\n            if (!payload.TryGetProperty(\"entry\", out var entry) || entry.ValueKind != JsonValueKind.Array || entry.GetArrayLength() == 0) return false;\n\n            var e0 = entry[0];\n            if (!e0.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0) return false;\n\n            var c0 = changes[0];\n            if (!c0.TryGetProperty(\"value\", out var v) || v.ValueKind != JsonValueKind.Object) return false;\n\n            value = v;\n            return true;\n        }\n\n        private static string? MapMetaStatus(string? s) =>\n            (s ?? \"\").ToLowerInvariant() switch\n            {\n                \"sent\" => \"Sent\",\n                \"delivered\" => \"Delivered\",\n                \"read\" => \"Read\",\n                \"failed\" => \"Failed\",\n                \"deleted\" => \"Deleted\",\n                _ => null\n            };\n\n        private static bool EqualsIgnoreCase(string? a, string? b) =>\n            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/TemplateWebhookProcessor.cs",
      "sha256": "0dbe7873fcf7b84d3a4fb9d78bda6689d86cbfd4d9fd50ce1d98029aaaef0558",
      "language": "csharp",
      "size": 1391,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class TemplateWebhookProcessor : ITemplateWebhookProcessor\n    {\n        private readonly ILogger<TemplateWebhookProcessor> _logger;\n\n        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task ProcessTemplateUpdateAsync(JsonElement payload)\n        {\n            try\n            {\n                var entry = payload.GetProperty(\"entry\")[0];\n                var changes = entry.GetProperty(\"changes\")[0];\n                var value = changes.GetProperty(\"value\");\n\n                var eventType = value.GetProperty(\"event\").GetString();\n                var templateId = value.TryGetProperty(\"message_template_id\", out var idProp)\n                                 ? idProp.GetString() : \"(unknown)\";\n\n                _logger.LogInformation($\"üßæ Template Event Received: {eventType} for ID: {templateId}\");\n\n                // üß† You can store in DB or show in admin logs in the future\n\n                await Task.CompletedTask;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process template webhook update.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/IMessageIdResolver.cs",
      "sha256": "b7b826aacb41d60aaa63c0a5c7350a4384eeb07af18d899fb8199afe7e9ef3d9",
      "language": "csharp",
      "size": 463,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public interface IMessageIdResolver\n    {\n        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);\n        Task<Guid?> ResolveMessageLogIdAsync(string messageId);\n        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);\n        Task<string?> ResolveAsync(string providerMessageId, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/MessageIdResolver.cs",
      "sha256": "631816c0acf1e2bbc9d610ef2145f4ee80c89efd95d2abf8728ff32be09142e8",
      "language": "csharp",
      "size": 3838,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Serilog;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public class MessageIdResolver : IMessageIdResolver\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageIdResolver> _logger;\n\n        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        public async Task<string?> ResolveAsync(string providerMessageId, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(providerMessageId))\n                return null;\n\n            // 1) Already a WAMID? Return as-is.\n            if (providerMessageId.StartsWith(\"wamid.\", StringComparison.OrdinalIgnoreCase))\n                return providerMessageId;\n\n            // 2) Try MessageLogs mapping (most reliable)\n            //    We pick any field that looks like a WAMID if present; otherwise fall back to MessageId.\n            var mlHit = await _context.MessageLogs.AsNoTracking()\n                .Where(m => m.ProviderMessageId == providerMessageId || m.MessageId == providerMessageId)\n                .OrderByDescending(m => m.CreatedAt)\n                .Select(m =>\n                    m.ProviderMessageId.StartsWith(\"wamid.\", StringComparison.OrdinalIgnoreCase)\n                        ? m.ProviderMessageId\n                        : (m.MessageId ?? m.ProviderMessageId))\n                .FirstOrDefaultAsync(ct);\n\n            if (!string.IsNullOrEmpty(mlHit))\n                return mlHit;\n\n            // 3) Some paths write WAMID straight into CampaignSendLogs.MessageId (no mapping required)\n            var cslHit = await _context.CampaignSendLogs.AsNoTracking()\n                .Where(c => c.MessageId == providerMessageId)\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => c.MessageId)\n                .FirstOrDefaultAsync(ct);\n\n            if (!string.IsNullOrEmpty(cslHit))\n                return cslHit;\n\n            // 4) Fallback: return original (keeps pipeline flowing even if we can‚Äôt map)\n            _logger.LogDebug(\"MessageIdResolver: passthrough for provider id {ProviderMessageId}\", providerMessageId);\n            return providerMessageId;\n        }\n\n        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)\n        {\n            var log = await _context.CampaignSendLogs\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è CampaignSendLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.BusinessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WebhookQueueService.cs",
      "sha256": "2d311701b4dcbde69080bf38449fde5e42e9f1aeb9138ba1735af41c8971caee",
      "language": "csharp",
      "size": 3691,
      "content": "using System.Text.Json;\nusing System.Threading.Channels;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WebhookQueueService : IWebhookQueueService\n    {\n        private readonly Channel<JsonElement> _queue;\n        private readonly ILogger<WebhookQueueService> _logger;\n\n        public WebhookQueueService(ILogger<WebhookQueueService> logger)\n        {\n            _logger = logger;\n\n            var options = new BoundedChannelOptions(5000)\n            {\n                FullMode = BoundedChannelFullMode.Wait,\n                SingleReader = true,\n                SingleWriter = false\n            };\n\n            _queue = Channel.CreateBounded<JsonElement>(options);\n\n            _logger.LogInformation(\n                \"‚úÖ WebhookQueueService initialized with capacity {Capacity}, FullMode={FullMode}, SingleReader={SingleReader}, SingleWriter={SingleWriter}.\",\n                5000,\n                options.FullMode,\n                options.SingleReader,\n                options.SingleWriter\n            );\n        }\n\n        public void Enqueue(JsonElement item)\n        {\n            // Optional: log size instead of full content to avoid noisy logs\n            var length = item.ToString()?.Length ?? 0;\n\n            if (!_queue.Writer.TryWrite(item))\n            {\n                _logger.LogError(\n                    \"‚ùå Failed to enqueue webhook payload: queue is full. CurrentCount={Count}, PayloadLength={PayloadLength}.\",\n                    _queue.Reader.Count,\n                    length\n                );\n                throw new InvalidOperationException(\"‚ö†Ô∏è Webhook queue is full.\");\n            }\n\n            _logger.LogInformation(\n                \"üì• Enqueued webhook payload successfully. CurrentCount={Count}, PayloadLength={PayloadLength}.\",\n                _queue.Reader.Count,\n                length\n            );\n        }\n\n        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n        {\n            var item = await _queue.Reader.ReadAsync(cancellationToken);\n\n            // Again, just log length, not the full JSON, to keep logs readable\n            var length = item.ToString()?.Length ?? 0;\n\n            _logger.LogInformation(\n                \"üì§ Dequeued webhook payload for processing. RemainingCount={Count}, PayloadLength={PayloadLength}.\",\n                _queue.Reader.Count,\n                length\n            );\n\n            return item;\n        }\n\n        public int GetQueueLength() => _queue.Reader.Count;\n    }\n}\n\n\n//using System.Text.Json;\n//using System.Threading.Channels;\n\n//namespace xbytechat.api.Features.Webhooks.Services\n//{\n//    public class WebhookQueueService : IWebhookQueueService\n//    {\n//        private readonly Channel<JsonElement> _queue;\n\n//        public WebhookQueueService()\n//        {\n//            var options = new BoundedChannelOptions(5000)\n//            {\n//                FullMode = BoundedChannelFullMode.Wait,\n//                SingleReader = true,\n//                SingleWriter = false\n//            };\n\n//            _queue = Channel.CreateBounded<JsonElement>(options);\n//        }\n\n//        public void Enqueue(JsonElement item)\n//        {\n//            if (!_queue.Writer.TryWrite(item))\n//            {\n//                throw new InvalidOperationException(\"‚ö†Ô∏è Webhook queue is full.\");\n//            }\n//        }\n\n//        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n//        {\n//            return await _queue.Reader.ReadAsync(cancellationToken);\n//        }\n\n//        public int GetQueueLength() => _queue.Reader.Count;\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookDispatcher.cs",
      "sha256": "e6fada25e39b363b0b7136d0997fba40cc2d1fd8347f8fb7a16f779172e7822b",
      "language": "csharp",
      "size": 34800,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Directory;\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n    {\n        // Removed legacy _statusProcessor on purpose\n        private readonly ITemplateWebhookProcessor _templateProcessor;\n        private readonly IClickWebhookProcessor _clickProcessor;\n        private readonly IInboundMessageProcessor _inboundMessageProcessor;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IProviderDirectory _directory;\n        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;\n        private readonly IBillingIngestService _billingIngest;\n\n        public WhatsAppWebhookDispatcher(\n            ITemplateWebhookProcessor templateProcessor,\n            ILogger<WhatsAppWebhookDispatcher> logger,\n            IClickWebhookProcessor clickProcessor,\n            IInboundMessageProcessor inboundMessageProcessor,\n            IWhatsAppWebhookService webhookService,\n            IProviderDirectory directory,\n            IPinnacleToMetaAdapter pinnacleToMetaAdapter,\n            IBillingIngestService billingIngest)\n        {\n            _templateProcessor = templateProcessor;\n            _logger = logger;\n            _clickProcessor = clickProcessor;\n            _inboundMessageProcessor = inboundMessageProcessor;\n            _webhookService = webhookService;\n            _directory = directory;\n            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;\n            _billingIngest = billingIngest;\n        }\n\n        public async Task DispatchAsync(JsonElement payload)\n        {\n            // Keep raw payload at Debug to avoid log spam in prod\n            _logger.LogDebug(\"üì¶ Dispatcher raw payload:\\n{Payload}\", payload.GetRawText());\n\n            try\n            {\n                // 0) Detect provider & normalize into a Meta-like \"entry[].changes[].value\" envelope\n                var provider = DetectProvider(payload); // \"meta\" | \"pinnacle\" | null\n                _logger.LogInformation(\"üåê Dispatcher: detected provider={Provider}\", provider ?? \"(auto/meta)\");\n\n                var envelope = provider == \"pinnacle\"\n                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)\n                    : payload;\n\n                if (!envelope.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array)\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è Dispatcher: No 'entry' array found on envelope; skipping payload.\");\n                    return;\n                }\n\n                // Compute once per envelope (micro-optimization)\n                var isStatus = IsStatusPayload(envelope);\n                _logger.LogInformation(\"üîé Dispatcher: isStatusPayload={IsStatus}\", isStatus);\n\n                foreach (var entry in entries.EnumerateArray())\n                {\n                    if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array)\n                    {\n                        _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: 'entry' without 'changes' array; skipping entry.\");\n                        continue;\n                    }\n\n                    foreach (var change in changes.EnumerateArray())\n                    {\n                        if (!change.TryGetProperty(\"value\", out var value) || value.ValueKind != JsonValueKind.Object)\n                        {\n                            _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: 'change' without object 'value'; skipping change.\");\n                            continue;\n                        }\n\n                        // 1) STATUS UPDATES\n                        if (isStatus)\n                        {\n                            _logger.LogInformation(\"üì¶ Dispatcher: treating envelope as STATUS payload (provider={Provider}).\", provider ?? \"meta\");\n\n                            // Resolve BusinessId using *envelope* metadata (works for Meta and adapted Pinnacle)\n                            Guid resolvedBiz = Guid.Empty;\n                            try\n                            {\n                                var hints = ExtractNumberHints(envelope, provider);\n                                _logger.LogDebug(\n                                    \"üî¢ Dispatcher: Number hints extracted. PhoneNumberId={PhoneNumberId}, DisplayPhone={DisplayPhone}, WabaId={WabaId}, WaId={WaId}\",\n                                    hints.PhoneNumberId,\n                                    hints.DisplayPhoneNumber,\n                                    hints.WabaId,\n                                    hints.WaId);\n\n                                var bid = await _directory.ResolveBusinessIdAsync(\n                                    provider: provider,\n                                    phoneNumberId: hints.PhoneNumberId,\n                                    displayPhoneNumber: hints.DisplayPhoneNumber,\n                                    wabaId: hints.WabaId,\n                                    waId: hints.WaId\n                                );\n                                if (bid.HasValue) resolvedBiz = bid.Value;\n                            }\n                            catch (Exception ex)\n                            {\n                                _logger.LogWarning(ex, \"ProviderDirectory lookup failed; proceeding without BusinessId.\");\n                            }\n\n                            // Canonical provider label for billing\n                            var providerCanonical = string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase)\n                                ? \"PINNACLE\"\n                                : \"META_CLOUD\";\n\n                            // Only call billing ingest when BusinessId was resolved\n                            if (resolvedBiz != Guid.Empty)\n                            {\n                                try\n                                {\n                                    _logger.LogInformation(\n                                        \"üí∞ Dispatcher: routing status payload to BillingIngest for BusinessId={BusinessId}, Provider={ProviderCanonical}\",\n                                        resolvedBiz,\n                                        providerCanonical);\n\n                                    await _billingIngest.IngestFromWebhookAsync(\n                                        resolvedBiz,\n                                        providerCanonical,\n                                        envelope.GetRawText());\n                                }\n                                catch (Exception ex)\n                                {\n                                    _logger.LogWarning(ex, \"Billing ingest from webhook failed (non-fatal).\");\n                                }\n                            }\n                            else\n                            {\n                                _logger.LogWarning(\n                                    \"‚ö†Ô∏è Dispatcher: status payload had no resolved BusinessId; billing ingest will be skipped.\");\n                            }\n\n                            // Unified status updater (no legacy fallback)\n                            _logger.LogInformation(\n                                \"üì¶ Dispatcher: routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})\",\n                                provider,\n                                resolvedBiz == Guid.Empty ? \"(unknown)\" : resolvedBiz.ToString());\n\n                            await _webhookService.ProcessStatusUpdateAsync(\n                                resolvedBiz,\n                                provider ?? \"meta\",\n                                envelope);\n\n                            // Note: continue to next change ‚Äî even if envelope is status-oriented,\n                            // other changes in the same webhook could be non-status in some providers.\n                            continue;\n                        }\n\n                        // 2) TEMPLATE EVENTS\n                        if (value.TryGetProperty(\"event\", out var eventType) &&\n                            eventType.GetString()?.StartsWith(\"template_\", StringComparison.Ordinal) == true)\n                        {\n                            _logger.LogInformation(\"üì¶ Dispatcher: routing to Template Processor (event={Event})\", eventType.GetString());\n                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope);\n                            continue;\n                        }\n\n                        // 3) MESSAGES (clicks + inbound)\n                        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n                        {\n                            _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: 'value' has no 'messages' array or it is empty; skipping.\");\n                            continue;\n                        }\n\n                        foreach (var m in msgs.EnumerateArray())\n                        {\n                            if (!m.TryGetProperty(\"type\", out var typeProp))\n                            {\n                                _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: message without 'type' field; skipping message.\");\n                                continue;\n                            }\n\n                            var type = typeProp.GetString();\n                            _logger.LogDebug(\"üîç Dispatcher: inspecting message of type '{Type}'.\", type);\n\n                            // (A) Legacy quick-reply button ‚Üí CLICK\n                            if (type == \"button\")\n                            {\n                                _logger.LogInformation(\"üëâ Dispatcher: routing to Click Processor (legacy 'button').\");\n                                await _clickProcessor.ProcessClickAsync(value);\n                                continue;\n                            }\n\n                            // (B) Interactive (button_reply / list_reply) ‚Üí CLICK\n                            if (type == \"interactive\" && m.TryGetProperty(\"interactive\", out var interactive))\n                            {\n                                if (interactive.TryGetProperty(\"type\", out var interactiveType) &&\n                                    interactiveType.GetString() == \"button_reply\")\n                                {\n                                    _logger.LogInformation(\"üëâ Dispatcher: routing to Click Processor (interactive/button_reply).\");\n                                    await _clickProcessor.ProcessClickAsync(value);\n                                    continue;\n                                }\n\n                                if (interactive.TryGetProperty(\"list_reply\", out _))\n                                {\n                                    _logger.LogInformation(\"üëâ Dispatcher: routing to Click Processor (interactive/list_reply).\");\n                                    await _clickProcessor.ProcessClickAsync(value);\n                                    continue;\n                                }\n                            }\n\n                            // (C) Inbound plain message types ‚Üí INBOUND\n                            if (type is \"text\" or \"image\" or \"audio\")\n                            {\n                                _logger.LogInformation(\n                                    \"üí¨ Dispatcher: routing to InboundMessageProcessor (message type: {Type}, provider={Provider}).\",\n                                    type,\n                                    provider ?? \"meta\");\n\n                                await _inboundMessageProcessor.ProcessChatAsync(value);\n                                continue;\n                            }\n\n                            _logger.LogDebug(\"‚ÑπÔ∏è Dispatcher: message type '{Type}' not handled by dispatcher.\", type);\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n            }\n        }\n\n        private static bool IsStatusPayload(JsonElement root)\n        {\n            // Meta-like: entry[].changes[].value.statuses\n            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty(\"statuses\", out _))\n                return true;\n\n            // Some providers mark with \"status\" or event containing \"status\"\n            if (root.TryGetProperty(\"status\", out _)) return true;\n            if (root.TryGetProperty(\"event\", out var ev) &&\n                (ev.GetString()?.Contains(\"status\", StringComparison.OrdinalIgnoreCase) ?? false))\n                return true;\n\n            return false;\n        }\n\n        private static string? DetectProvider(JsonElement root)\n        {\n            // Heuristics by envelope\n            if (root.TryGetProperty(\"object\", out var obj) && obj.GetString() == \"whatsapp_business_account\")\n                return \"meta\";\n            if (root.TryGetProperty(\"entry\", out _))\n                return \"meta\";\n            if (root.TryGetProperty(\"event\", out _))\n                return \"pinnacle\";\n            return null;\n        }\n\n        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n        {\n            res = default;\n            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n                return false;\n\n            var entry = entries[0];\n            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n                return false;\n\n            var change = changes[0];\n            if (!change.TryGetProperty(\"value\", out var value))\n                return false;\n\n            res = (value, change, entry);\n            return true;\n        }\n\n        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)\n        {\n            var hints = new NumberHints();\n\n            // Meta (or unknown ‚Üí treat as Meta envelope)\n            if (string.Equals(provider, \"meta\", StringComparison.OrdinalIgnoreCase) || provider is null)\n            {\n                if (TryGetMetaValue(root, out var v))\n                {\n                    if (v.Value.TryGetProperty(\"metadata\", out var md))\n                    {\n                        if (md.TryGetProperty(\"phone_number_id\", out var pnid))\n                            hints.PhoneNumberId = pnid.GetString();\n\n                        if (md.TryGetProperty(\"display_phone_number\", out var disp))\n                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());\n\n                        if (md.TryGetProperty(\"waba_id\", out var wabaFromMeta))\n                            hints.WabaId = wabaFromMeta.GetString();\n                    }\n\n                    // Some adapters put waba_id at value-level\n                    if (string.IsNullOrWhiteSpace(hints.WabaId) &&\n                        v.Value.TryGetProperty(\"waba_id\", out var wabaTop))\n                    {\n                        hints.WabaId = wabaTop.GetString();\n                    }\n\n                    // First status often carries recipient_id (WA ID)\n                    if (v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)\n                    {\n                        var s0 = statuses[0];\n                        if (s0.TryGetProperty(\"recipient_id\", out var rid))\n                            hints.WaId = rid.GetString();\n                    }\n                }\n            }\n            // Pinnacle (raw or adapted)\n            else if (string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase))\n            {\n                // If your adapter produced a Meta-like envelope, this will work too:\n                if (TryGetMetaValue(root, out var v2) && v2.Value.TryGetProperty(\"metadata\", out var md2))\n                {\n                    if (md2.TryGetProperty(\"phone_number_id\", out var pnid2))\n                        hints.PhoneNumberId = pnid2.GetString();\n\n                    if (md2.TryGetProperty(\"display_phone_number\", out var disp2))\n                        hints.DisplayPhoneNumber = NormalizePhone(disp2.GetString());\n                }\n\n                // Raw Pinnacle-style fields on the envelope\n                if (string.IsNullOrWhiteSpace(hints.PhoneNumberId) &&\n                    root.TryGetProperty(\"phone_number_id\", out var pn))\n                    hints.PhoneNumberId = pn.GetString();\n\n                if (string.IsNullOrWhiteSpace(hints.DisplayPhoneNumber))\n                {\n                    if (root.TryGetProperty(\"from\", out var from))\n                        hints.DisplayPhoneNumber = NormalizePhone(from.GetString());\n                    else if (root.TryGetProperty(\"msisdn\", out var msisdn))\n                        hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());\n                }\n\n                if (root.TryGetProperty(\"wabaId\", out var waba))\n                    hints.WabaId = waba.GetString();\n            }\n\n            return hints;\n        }\n\n        private static string? NormalizePhone(string? v)\n        {\n            if (string.IsNullOrWhiteSpace(v)) return null;\n            var t = v.Trim();\n            var keepPlus = t.StartsWith(\"+\");\n            var digits = new string(t.Where(char.IsDigit).ToArray());\n            return keepPlus ? \"+\" + digits : digits;\n        }\n\n        private struct NumberHints\n        {\n            public string? PhoneNumberId { get; set; }\n            public string? DisplayPhoneNumber { get; set; }\n            public string? WabaId { get; set; }\n            public string? WaId { get; set; }\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Text.Json;\n//using System.Threading.Tasks;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api.Features.Webhooks.Directory;\n//using xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\n//using xbytechat.api.Features.Webhooks.Services.Processors;\n//using xbytechat_api.Features.Billing.Services;\n\n//namespace xbytechat.api.Features.Webhooks.Services\n//{\n//    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n//    {\n//        // Removed legacy _statusProcessor on purpose\n//        private readonly ITemplateWebhookProcessor _templateProcessor;\n//        private readonly IClickWebhookProcessor _clickProcessor;\n//        private readonly IInboundMessageProcessor _inboundMessageProcessor;\n//        private readonly IWhatsAppWebhookService _webhookService;\n//        private readonly IProviderDirectory _directory;\n//        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n//        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;\n//        private readonly IBillingIngestService _billingIngest;\n\n//        public WhatsAppWebhookDispatcher(\n//            ITemplateWebhookProcessor templateProcessor,\n//            ILogger<WhatsAppWebhookDispatcher> logger,\n//            IClickWebhookProcessor clickProcessor,\n//            IInboundMessageProcessor inboundMessageProcessor,\n//            IWhatsAppWebhookService webhookService,\n//            IProviderDirectory directory,\n//            IPinnacleToMetaAdapter pinnacleToMetaAdapter,\n//            IBillingIngestService billingIngest)\n//        {\n//            _templateProcessor = templateProcessor;\n//            _logger = logger;\n//            _clickProcessor = clickProcessor;\n//            _inboundMessageProcessor = inboundMessageProcessor;\n//            _webhookService = webhookService;\n//            _directory = directory;\n//            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;\n//            _billingIngest = billingIngest;\n//        }\n\n//        public async Task DispatchAsync(JsonElement payload)\n//        {\n//            // Keep raw payload at Debug to avoid log spam in prod\n//            _logger.LogDebug(\"üì¶ Dispatcher raw payload:\\n{Payload}\", payload.GetRawText());\n\n//            try\n//            {\n//                // 0) Detect provider & normalize into a Meta-like \"entry[].changes[].value\" envelope\n//                var provider = DetectProvider(payload); // \"meta\" | \"pinnacle\" | null\n\n//                var envelope = provider == \"pinnacle\"\n//                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)\n//                    : payload;\n\n//                if (!envelope.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array)\n//                    return;\n\n//                // Compute once per envelope (micro-optimization)\n//                var isStatus = IsStatusPayload(envelope);\n\n//                foreach (var entry in entries.EnumerateArray())\n//                {\n//                    if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array)\n//                        continue;\n\n//                    foreach (var change in changes.EnumerateArray())\n//                    {\n//                        if (!change.TryGetProperty(\"value\", out var value) || value.ValueKind != JsonValueKind.Object)\n//                            continue;\n\n//                        // 1) STATUS UPDATES\n//                        if (isStatus)\n//                        {\n//                            // Resolve BusinessId using *envelope* metadata (works for Meta and adapted Pinnacle)\n//                            Guid resolvedBiz = Guid.Empty;\n//                            try\n//                            {\n//                                var hints = ExtractNumberHints(envelope, provider);\n//                                var bid = await _directory.ResolveBusinessIdAsync(\n//                                    provider: provider,\n//                                    phoneNumberId: hints.PhoneNumberId,\n//                                    displayPhoneNumber: hints.DisplayPhoneNumber,\n//                                    wabaId: hints.WabaId,\n//                                    waId: hints.WaId\n//                                );\n//                                if (bid.HasValue) resolvedBiz = bid.Value;\n//                            }\n//                            catch (Exception ex)\n//                            {\n//                                _logger.LogWarning(ex, \"ProviderDirectory lookup failed; proceeding without BusinessId.\");\n//                            }\n\n//                            // Canonical provider label for billing\n//                            var providerCanonical = string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase)\n//                                ? \"PINNACLE\"\n//                                : \"META_CLOUD\";\n\n//                            // Only call billing ingest when BusinessId was resolved\n//                            if (resolvedBiz != Guid.Empty)\n//                            {\n//                                try\n//                                {\n//                                    await _billingIngest.IngestFromWebhookAsync(\n//                                        resolvedBiz,\n//                                        providerCanonical,\n//                                        envelope.GetRawText());\n//                                }\n//                                catch (Exception ex)\n//                                {\n//                                    _logger.LogWarning(ex, \"Billing ingest from webhook failed (non-fatal).\");\n//                                }\n//                            }\n\n//                            // Unified status updater (no legacy fallback)\n//                            _logger.LogInformation(\n//                                \"üì¶ Routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})\",\n//                                provider, resolvedBiz == Guid.Empty ? \"(unknown)\" : resolvedBiz.ToString());\n\n//                            await _webhookService.ProcessStatusUpdateAsync(\n//                                resolvedBiz,\n//                                provider ?? \"meta\",\n//                                envelope);\n\n//                            // Note: continue to next change ‚Äî even if envelope is status-oriented,\n//                            // other changes in the same webhook could be non-status in some providers.\n//                            continue;\n//                        }\n\n//                        // 2) TEMPLATE EVENTS\n//                        if (value.TryGetProperty(\"event\", out var eventType) &&\n//                            eventType.GetString()?.StartsWith(\"template_\", StringComparison.Ordinal) == true)\n//                        {\n//                            _logger.LogInformation(\"üì¶ Routing to Template Processor\");\n//                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope);\n//                            continue;\n//                        }\n\n//                        // 3) MESSAGES (clicks + inbound)\n//                        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n//                        {\n//                            _logger.LogDebug(\"‚ÑπÔ∏è No 'messages' array present.\");\n//                            continue;\n//                        }\n\n//                        foreach (var m in msgs.EnumerateArray())\n//                        {\n//                            if (!m.TryGetProperty(\"type\", out var typeProp))\n//                            {\n//                                _logger.LogDebug(\"‚ÑπÔ∏è Message without 'type' field.\");\n//                                continue;\n//                            }\n\n//                            var type = typeProp.GetString();\n\n//                            // (A) Legacy quick-reply button ‚Üí CLICK\n//                            if (type == \"button\")\n//                            {\n//                                _logger.LogInformation(\"üëâ Routing to Click Processor (legacy 'button')\");\n//                                await _clickProcessor.ProcessClickAsync(value);\n//                                continue;\n//                            }\n\n//                            // (B) Interactive (button_reply / list_reply) ‚Üí CLICK\n//                            if (type == \"interactive\" && m.TryGetProperty(\"interactive\", out var interactive))\n//                            {\n//                                if (interactive.TryGetProperty(\"type\", out var interactiveType) &&\n//                                    interactiveType.GetString() == \"button_reply\")\n//                                {\n//                                    _logger.LogInformation(\"üëâ Routing to Click Processor (interactive/button_reply)\");\n//                                    await _clickProcessor.ProcessClickAsync(value);\n//                                    continue;\n//                                }\n\n//                                if (interactive.TryGetProperty(\"list_reply\", out _))\n//                                {\n//                                    _logger.LogInformation(\"üëâ Routing to Click Processor (interactive/list_reply)\");\n//                                    await _clickProcessor.ProcessClickAsync(value);\n//                                    continue;\n//                                }\n//                            }\n\n//                            // (C) Inbound plain message types ‚Üí INBOUND\n//                            if (type is \"text\" or \"image\" or \"audio\")\n//                            {\n//                                _logger.LogInformation(\"üí¨ Routing to InboundMessageProcessor (type: {Type})\", type);\n//                                await _inboundMessageProcessor.ProcessChatAsync(value);\n//                                continue;\n//                            }\n\n//                            _logger.LogDebug(\"‚ÑπÔ∏è Message type '{Type}' not handled by dispatcher.\", type);\n//                        }\n//                    }\n//                }\n//            }\n//            catch (Exception ex)\n//            {\n//                _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n//            }\n//        }\n\n//        private static bool IsStatusPayload(JsonElement root)\n//        {\n//            // Meta-like: entry[].changes[].value.statuses\n//            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty(\"statuses\", out _))\n//                return true;\n\n//            // Some providers mark with \"status\" or event containing \"status\"\n//            if (root.TryGetProperty(\"status\", out _)) return true;\n//            if (root.TryGetProperty(\"event\", out var ev) &&\n//                (ev.GetString()?.Contains(\"status\", StringComparison.OrdinalIgnoreCase) ?? false))\n//                return true;\n\n//            return false;\n//        }\n\n//        private static string? DetectProvider(JsonElement root)\n//        {\n//            // Heuristics by envelope\n//            if (root.TryGetProperty(\"object\", out var obj) && obj.GetString() == \"whatsapp_business_account\")\n//                return \"meta\";\n//            if (root.TryGetProperty(\"entry\", out _))\n//                return \"meta\";\n//            if (root.TryGetProperty(\"event\", out _))\n//                return \"pinnacle\";\n//            return null;\n//        }\n\n//        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n//        {\n//            res = default;\n//            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n//                return false;\n\n//            var entry = entries[0];\n//            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n//                return false;\n\n//            var change = changes[0];\n//            if (!change.TryGetProperty(\"value\", out var value))\n//                return false;\n\n//            res = (value, change, entry);\n//            return true;\n//        }\n\n//        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)\n//        {\n//            var hints = new NumberHints();\n\n//            // Meta (or unknown ‚Üí treat as Meta envelope)\n//            if (string.Equals(provider, \"meta\", StringComparison.OrdinalIgnoreCase) || provider is null)\n//            {\n//                if (TryGetMetaValue(root, out var v))\n//                {\n//                    if (v.Value.TryGetProperty(\"metadata\", out var md))\n//                    {\n//                        if (md.TryGetProperty(\"phone_number_id\", out var pnid))\n//                            hints.PhoneNumberId = pnid.GetString();\n\n//                        if (md.TryGetProperty(\"display_phone_number\", out var disp))\n//                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());\n\n//                        if (md.TryGetProperty(\"waba_id\", out var wabaFromMeta))\n//                            hints.WabaId = wabaFromMeta.GetString();\n//                    }\n\n//                    // Some adapters put waba_id at value-level\n//                    if (string.IsNullOrWhiteSpace(hints.WabaId) &&\n//                        v.Value.TryGetProperty(\"waba_id\", out var wabaTop))\n//                    {\n//                        hints.WabaId = wabaTop.GetString();\n//                    }\n\n//                    // First status often carries recipient_id (WA ID)\n//                    if (v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n//                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)\n//                    {\n//                        var s0 = statuses[0];\n//                        if (s0.TryGetProperty(\"recipient_id\", out var rid))\n//                            hints.WaId = rid.GetString();\n//                    }\n//                }\n//            }\n//            // Pinnacle (raw or adapted)\n//            else if (string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase))\n//            {\n//                // If your adapter produced a Meta-like envelope, this will work too:\n//                if (TryGetMetaValue(root, out var v2) && v2.Value.TryGetProperty(\"metadata\", out var md2))\n//                {\n//                    if (md2.TryGetProperty(\"phone_number_id\", out var pnid2))\n//                        hints.PhoneNumberId = pnid2.GetString();\n\n//                    if (md2.TryGetProperty(\"display_phone_number\", out var disp2))\n//                        hints.DisplayPhoneNumber = NormalizePhone(disp2.GetString());\n//                }\n\n//                // Raw Pinnacle-style fields on the envelope\n//                if (string.IsNullOrWhiteSpace(hints.PhoneNumberId) &&\n//                    root.TryGetProperty(\"phone_number_id\", out var pn))\n//                    hints.PhoneNumberId = pn.GetString();\n\n//                if (string.IsNullOrWhiteSpace(hints.DisplayPhoneNumber))\n//                {\n//                    if (root.TryGetProperty(\"from\", out var from))\n//                        hints.DisplayPhoneNumber = NormalizePhone(from.GetString());\n//                    else if (root.TryGetProperty(\"msisdn\", out var msisdn))\n//                        hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());\n//                }\n\n//                if (root.TryGetProperty(\"wabaId\", out var waba))\n//                    hints.WabaId = waba.GetString();\n//            }\n\n//            return hints;\n//        }\n\n//        private static string? NormalizePhone(string? v)\n//        {\n//            if (string.IsNullOrWhiteSpace(v)) return null;\n//            var t = v.Trim();\n//            var keepPlus = t.StartsWith(\"+\");\n//            var digits = new string(t.Where(char.IsDigit).ToArray());\n//            return keepPlus ? \"+\" + digits : digits;\n//        }\n\n//        private struct NumberHints\n//        {\n//            public string? PhoneNumberId { get; set; }\n//            public string? DisplayPhoneNumber { get; set; }\n//            public string? WabaId { get; set; }\n//            public string? WaId { get; set; }\n//        }\n//    }\n//}\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookService.cs",
      "sha256": "28a7cd652990f6303b6c0d8b76fb79b17aa8df36d79774e23c593d21a44df972",
      "language": "csharp",
      "size": 5929,
      "content": "using System.Text.Json;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog (optional if you keep only MessageLogs lookup)\nusing xbytechat.api.Features.MessageManagement.Services; // IMessageStatusUpdater\nusing xbytechat.api.Features.Webhooks.Status;\nusing xbytechat.api.Infrastructure; // your AppDbContext namespace (adjust if different)\nusing xbytechat.api.Infrastructure.Observability; // MetricsRegistry\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    \n\n    public sealed class WhatsAppWebhookService : IWhatsAppWebhookService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<WhatsAppWebhookService> _logger;\n        private readonly IMessageStatusUpdater _updater;\n\n        public WhatsAppWebhookService(\n            AppDbContext context,\n            ILogger<WhatsAppWebhookService> logger,\n            IMessageStatusUpdater updater)\n        {\n            _context = context;\n            _logger = logger;\n            _updater = updater;\n        }\n\n        /// <summary>\n        /// Single modern entrypoint. Assumes payload is Meta-shaped (entry[].changes[].value.statuses[]).\n        /// If you ingest other providers, adapt them to this shape before calling here.\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default)\n        {\n            provider = (provider ?? \"\").Trim().ToLowerInvariant();\n\n            // Normalize status text to what the updater expects\n            static string NormalizeStatus(string? s)\n            {\n                s = (s ?? \"\").Trim().ToLowerInvariant();\n                return s switch\n                {\n                    \"sent\" => \"sent\",\n                    \"delivered\" => \"delivered\",\n                    \"read\" => \"read\",\n                    \"failed\" => \"failed\",\n                    _ => s\n                };\n            }\n\n            // Parse Meta-like envelope: entry[].changes[].value.statuses[]\n            if (!payload.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array)\n            {\n                _logger.LogWarning(\"Status payload missing 'entry' array.\");\n                return;\n            }\n\n            foreach (var entry in entries.EnumerateArray())\n            {\n                if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array)\n                    continue;\n\n                foreach (var change in changes.EnumerateArray())\n                {\n                    if (!change.TryGetProperty(\"value\", out var value) || value.ValueKind != JsonValueKind.Object)\n                        continue;\n\n                    if (!value.TryGetProperty(\"statuses\", out var statuses) || statuses.ValueKind != JsonValueKind.Array)\n                        continue;\n\n                    foreach (var st in statuses.EnumerateArray())\n                    {\n                        // Fields: id (WAMID or provider id), status, timestamp\n                        string? providerOrWaId = st.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                        string? statusText = st.TryGetProperty(\"status\", out var statusProp) ? statusProp.GetString() : null;\n\n                        long unixTs = 0;\n                        if (st.TryGetProperty(\"timestamp\", out var tsProp))\n                        {\n                            if (tsProp.ValueKind == JsonValueKind.String && long.TryParse(tsProp.GetString(), out var parsed))\n                                unixTs = parsed;\n                            else if (tsProp.ValueKind == JsonValueKind.Number)\n                                unixTs = tsProp.GetInt64();\n                        }\n\n                        if (string.IsNullOrWhiteSpace(providerOrWaId) || string.IsNullOrWhiteSpace(statusText))\n                        {\n                            _logger.LogWarning(\"Status item missing id or status: {Item}\", st.GetRawText());\n                            continue;\n                        }\n\n                        // Resolve canonical MessageId (WAMID) from DB; fallback to provider id if not found.\n                        // 1) Try MessageLogs\n                        string? messageId = await _context.MessageLogs.AsNoTracking()\n                            .Where(m => m.ProviderMessageId == providerOrWaId || m.MessageId == providerOrWaId)\n                            .OrderByDescending(m => m.CreatedAt)\n                            .Select(m => m.MessageId ?? m.ProviderMessageId)\n                            .FirstOrDefaultAsync(ct);\n\n                        // 2) Optional: also look in CampaignSendLogs if desired\n                        if (string.IsNullOrWhiteSpace(messageId))\n                        {\n                            messageId = await _context.CampaignSendLogs.AsNoTracking()\n                                .Where(c => c.MessageId == providerOrWaId)\n                                .OrderByDescending(c => c.CreatedAt)\n                                .Select(c => c.MessageId)\n                                .FirstOrDefaultAsync(ct);\n                        }\n\n                        messageId ??= providerOrWaId;\n\n                        var tsUtc = unixTs > 0\n                            ? DateTimeOffset.FromUnixTimeSeconds(unixTs).UtcDateTime\n                            : DateTime.UtcNow;\n\n                        var norm = NormalizeStatus(statusText);\n\n                        // Updater signature: (messageId, status, tsUtc, error, ct)\n                        await _updater.UpdateAsync(messageId, norm, tsUtc, null, ct);\n\n                        _logger.LogInformation(\"Status updated: msg={MessageId} status={Status} ts={Ts}\", messageId, norm, tsUtc);\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/IMessageStatusUpdater.cs",
      "sha256": "38df9b6edc3c2706c404a79c6b9fa66e5065c9a4481e798e7f497e9e56c9c358",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    public interface IMessageStatusUpdater\n    {\n       // Task UpdateAsync(StatusEvent ev, CancellationToken ct = default);\n        Task<int> UpdateAsync(string messageId, string status, DateTime tsUtc, string? error, CancellationToken ct);\n    }\n\n    public sealed class StatusEvent\n    {\n        public Guid BusinessId { get; init; }\n        public string Provider { get; init; } = \"\";          // \"meta\" | \"pinnacle\"\n\n        // Provider message id (Meta \"id\", Pinnacle equivalent) ‚Üí maps to MessageId in your DB\n        public string ProviderMessageId { get; init; } = \"\";\n\n        // Optional hints (not required in your current lookups)\n        public Guid? CampaignSendLogId { get; init; }\n        public string? RecipientWaId { get; init; }\n\n        public MessageDeliveryState State { get; init; }     // Sent/Delivered/Read/Failed/Deleted\n        public DateTimeOffset OccurredAt { get; init; }      // from provider timestamp when available\n\n        public string? ErrorCode { get; init; }\n        public string? ErrorMessage { get; init; }\n        public string? ConversationId { get; init; }\n    }\n\n    public enum MessageDeliveryState\n    {\n        Sent,\n        Delivered,\n        Read,\n        Failed,\n        Deleted\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusContracts.cs",
      "sha256": "37627bd0faaa1e9e438a5d7379dc5f5773a8f7553fe9e1b476e74ee20a66ce30",
      "language": "csharp",
      "size": 1443,
      "content": "namespace xbytechat.api.Features.Webhooks.Status\n{\n    public class MessageStatusContracts\n    {\n        public enum CanonicalMessageStatus\n        {\n            Unknown = 0,\n            Submitted,   // API accepted (optional)\n            Sent,        // provider accepted / sent\n            Delivered,\n            Read,\n            Failed\n        }\n        public sealed class UpdateMessageStatusRequest\n        {\n            public Guid BusinessId { get; set; }\n            public string Provider { get; set; } = \"\";              // \"meta_cloud\" | \"pinnacle\" | etc.\n            public string MessageId { get; set; } = \"\";             // provider message id (WAMID / id)\n            public string RawStatus { get; set; } = \"\";             // provider-specific (e.g., \"sent\", \"delivered\")\n            public DateTimeOffset? EventTime { get; set; }          // provider timestamp, if any\n\n            public string? RecipientNumber { get; set; }            // optional sanity context\n            public string? ErrorCode { get; set; }                  // optional error info\n            public string? ErrorMessage { get; set; }               // optional error info\n            public string? RawPayloadJson { get; set; }             // optional audit/debug\n        }\n\n        public interface IMessageStatusUpdater\n        {\n            Task<bool> UpdateAsync(UpdateMessageStatusRequest req, CancellationToken ct = default);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusUpdater.cs",
      "sha256": "9bbb3fb92f5443fc392f4ef65a69eef507c7139272044426334fc9d111e6a62c",
      "language": "csharp",
      "size": 25566,
      "content": "using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\n// üëá make sure this is where your AppDbContext lives\nusing xbytechat.api;\n\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\nusing xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)\nusing xbytechat.api.Features.CRM.Models;                      // Contact (nav)\nusing xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog\n\n// üëá Billing ingest\nusing xbytechat_api.Features.Billing.Services;        // IBillingIngestService\nusing xbytechat.api.Infrastructure.Observability;\nusing Channel = System.Threading.Channels.Channel;\nusing System.Threading.RateLimiting;\nusing Serilog;\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    /// <summary>\n    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.\n    /// Also forwards raw Meta webhook payloads to Billing ingest for pricing/billing capture.\n    /// </summary>\n    public class MessageStatusUpdater : IMessageStatusUpdater\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<MessageStatusUpdater> _log;\n        private readonly IBillingIngestService _billing;\n\n        public MessageStatusUpdater(AppDbContext db,\n                                    ILogger<MessageStatusUpdater> log,\n                                    IBillingIngestService billing)\n        {\n            _db = db;\n            _log = log;\n            _billing = billing;\n        }\n\n        //public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)\n        //{\n        //    // üîé Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably\n        //    if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n        //    {\n        //        _log.LogWarning(\"Status update missing key fields (BusinessId or ProviderMessageId). Skip.\");\n        //        return;\n        //    }\n\n        //    // 1) Pull candidates (scoped to business + WAMID)\n        //    var sendLogQ = _db.Set<CampaignSendLog>()\n        //                      .AsTracking()\n        //                      .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);\n\n        //    // NOTE: some rows set both MessageId and ProviderMessageId to the wamid; be flexible.\n        //    var msgLogQ = _db.Set<MessageLog>()\n        //                     .AsTracking()\n        //                     .Where(m => m.BusinessId == ev.BusinessId &&\n        //                                (m.ProviderMessageId == ev.ProviderMessageId ||\n        //                                 m.MessageId == ev.ProviderMessageId));\n\n        //    // If caller passed a specific CampaignSendLogId, narrow further\n        //    if (ev.CampaignSendLogId is Guid sid)\n        //        sendLogQ = sendLogQ.Where(s => s.Id == sid);\n\n        //    var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);\n        //    var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);\n\n        //    // 2) Apply transition (idempotent)\n        //    var changed = ApplyTransition(sendLog, msgLog, ev);\n\n        //    // 3) Persist only if something actually changed\n        //    if (changed > 0)\n        //        await _db.SaveChangesAsync(ct);\n\n        //    // 4) Always forward Meta status webhook payloads to Billing ingest (for pricing events).\n        //    await TryForwardToBillingAsync(ev, ct);\n        //}\n\n\n        public async Task<int> UpdateAsync(string messageId, string status, DateTime tsUtc, string? error, CancellationToken ct)\n        {\n            if (string.IsNullOrWhiteSpace(messageId)) return 0;\n\n            status = status.Trim().ToLowerInvariant();\n\n            // 1) Update CampaignSendLogs by MessageId (idempotent)\n            var cslQuery = _db.CampaignSendLogs.Where(x => x.MessageId == messageId);\n\n            int affected;\n            if (status == \"delivered\")\n            {\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error)\n                    .SetProperty(x => x.DeliveredAt, tsUtc)\n                    .SetProperty(x => x.SendStatus, \"Delivered\")\n                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"read\")\n            {\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error)\n                    .SetProperty(x => x.ReadAt, tsUtc)\n                    .SetProperty(x => x.SendStatus, \"Read\")\n                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc)\n                    .SetProperty(x => x.DeliveredAt, x => x.DeliveredAt ?? tsUtc), ct);\n            }\n            else if (status == \"failed\")\n            {\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error)\n                    .SetProperty(x => x.SendStatus, \"Failed\")\n                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"sent\")\n            {\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error)\n                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc)\n                    .SetProperty(x => x.SendStatus, \"Sent\"), ct);\n            }\n            else\n            {\n                // Unknown status: only persist the error text (harmless)\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error), ct);\n            }\n\n            // 2) Mirror onto MessageLogs (optional but useful for parity)\n            var mlQuery = _db.MessageLogs.Where(m => m.ProviderMessageId == messageId);\n\n            if (status == \"delivered\")\n            {\n                await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Delivered\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"read\")\n            {\n                await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Read\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"failed\")\n            {\n                await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Failed\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"sent\")\n            {\n                await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Sent\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n            // else: ignore unknown statuses for MessageLogs\n\n            // 3) Side-effects & metrics\n            if (affected == 0)\n            {\n                _log.LogWarning(\"[StatusUpdater] No CampaignSendLog row for messageId={MessageId}\", messageId);\n            }\n            else\n            {\n                if (status == \"failed\") MetricsRegistry.MessagesFailed.Add(1);\n                else if (status == \"sent\") MetricsRegistry.MessagesSent.Add(1);\n                // delivered/read are visible in analytics; counters optional\n            }\n\n            // Optional: billing for delivered/read goes here if required\n\n            return affected;\n        }\n\n        /// <summary>Returns number of entities modified.</summary>\n        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)\n        {\n            int modified = 0;\n\n            // --- CampaignSendLog updates ---\n            if (sendLog != null)\n            {\n                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n                {\n                    sendLog.MessageId = ev.ProviderMessageId;\n                    modified++;\n                }\n\n                switch (ev.State)\n                {\n                    case MessageDeliveryState.Sent:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Sent\"))\n                        {\n                            sendLog.SendStatus = \"Sent\";\n                            modified++;\n                        }\n                        if (sendLog.SentAt == null || sendLog.SentAt == default)\n                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Delivered:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\") &&\n                            !EqualsIgnoreCase(sendLog.SendStatus, \"Delivered\"))\n                        {\n                            sendLog.SendStatus = \"Delivered\";\n                            modified++;\n                        }\n                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)\n                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Read:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\"))\n                        {\n                            sendLog.SendStatus = \"Read\";\n                            modified++;\n                        }\n                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)\n                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Failed:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Failed\"))\n                        {\n                            sendLog.SendStatus = \"Failed\";\n                            modified++;\n                        }\n                        if (sendLog.ErrorMessage != ev.ErrorMessage)\n                        {\n                            sendLog.ErrorMessage = ev.ErrorMessage;\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Deleted:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Deleted\"))\n                        {\n                            sendLog.SendStatus = \"Deleted\";\n                            modified++;\n                        }\n                        break;\n                }\n            }\n\n            // --- MessageLog updates ---\n            if (msgLog != null)\n            {\n                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n                {\n                    msgLog.MessageId = ev.ProviderMessageId;\n                    modified++;\n                }\n\n                switch (ev.State)\n                {\n                    case MessageDeliveryState.Sent:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Sent\"))\n                        {\n                            msgLog.Status = \"Sent\";\n                            modified++;\n                        }\n                        if (msgLog.SentAt == null || msgLog.SentAt == default)\n                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Delivered:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\") &&\n                            !EqualsIgnoreCase(msgLog.Status, \"Delivered\"))\n                        {\n                            msgLog.Status = \"Delivered\";\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Read:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\"))\n                        {\n                            msgLog.Status = \"Read\";\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Failed:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Failed\"))\n                        {\n                            msgLog.Status = \"Failed\";\n                            modified++;\n                        }\n                        if (msgLog.ErrorMessage != ev.ErrorMessage)\n                        {\n                            msgLog.ErrorMessage = ev.ErrorMessage;\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Deleted:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Deleted\"))\n                        {\n                            msgLog.Status = \"Deleted\";\n                            modified++;\n                        }\n                        break;\n                }\n            }\n\n            if (sendLog == null && msgLog == null)\n            {\n                _log.LogWarning(\"No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}\",\n                    ev.BusinessId, ev.ProviderMessageId, ev.State);\n            }\n\n            return modified;\n        }\n\n        private static bool EqualsIgnoreCase(string? a, string? b) =>\n            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n\n        // ---------------- Billing forwarder ----------------\n\n        private async Task TryForwardToBillingAsync(StatusEvent ev, CancellationToken ct)\n        {\n            try\n            {\n                if (ev.BusinessId == Guid.Empty) return;\n\n                // Pull Provider (via reflection to avoid changing your StatusEvent contract)\n                var provider = GetStringProp(ev, \"Provider\")\n                               ?? GetStringProp(ev, \"ChannelProvider\")\n                               ?? GetStringProp(ev, \"SourceProvider\")\n                               ?? GetStringProp(ev, \"ProviderNormalized\");\n\n                // Try to get raw JSON payload from common property names\n                string? rawJson =\n                    GetStringProp(ev, \"RawPayloadJson\") ??\n                    GetStringProp(ev, \"PayloadJson\") ??\n                    TryGetJsonElementText(ev, \"Body\") ??\n                    TryGetJsonElementText(ev, \"RawBody\");\n\n                // If provider missing, use a lightweight sniff (Meta sends \"whatsapp_business_account\")\n                if (string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(rawJson) &&\n                    rawJson.IndexOf(\"\\\"whatsapp_business_account\\\"\", StringComparison.OrdinalIgnoreCase) >= 0)\n                {\n                    provider = \"META_CLOUD\";\n                }\n\n                // Normalize provider for billing\n                var normalized = NormalizeProvider(provider);\n                if (normalized != \"META_CLOUD\") return; // only forward Meta to billing ingest for now\n\n                if (string.IsNullOrWhiteSpace(rawJson))\n                {\n                    _log.LogDebug(\"Billing forward skipped: no raw payload JSON available on StatusEvent.\");\n                    return;\n                }\n\n                await _billing.IngestFromWebhookAsync(ev.BusinessId, normalized, rawJson);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"Billing ingest (status webhook) failed. businessId={BusinessId}\", ev.BusinessId);\n            }\n        }\n\n        private static string NormalizeProvider(string? provider)\n        {\n            if (string.IsNullOrWhiteSpace(provider)) return \"\";\n            var p = provider.Trim();\n            if (p.Equals(\"META_CLOUD\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            if (p.Equals(\"meta\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            if (p.Equals(\"meta_cloud\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            return p; // other providers unchanged\n        }\n\n        private static string? GetStringProp(object obj, string propName)\n        {\n            var pi = obj.GetType().GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            if (pi == null) return null;\n            var val = pi.GetValue(obj);\n            return val as string;\n        }\n\n        private static string? TryGetJsonElementText(object obj, string propName)\n        {\n            var pi = obj.GetType().GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            if (pi == null) return null;\n            var val = pi.GetValue(obj);\n            if (val is JsonElement je) return je.GetRawText();\n            return null;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n\n//// üëá make sure this is where your AppDbContext lives\n//using xbytechat.api;\n\n//using xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\n//using xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)\n//using xbytechat.api.CRM.Models;                       // Contact (nav)\n//using xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog\n\n//namespace xbytechat.api.Features.Webhooks.Status\n//{\n//    /// <summary>\n//    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.\n//    /// </summary>\n//    public class MessageStatusUpdater : IMessageStatusUpdater\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly ILogger<MessageStatusUpdater> _log;\n\n//        public MessageStatusUpdater(AppDbContext db, ILogger<MessageStatusUpdater> log)\n//        {\n//            _db = db;\n//            _log = log;\n//        }\n\n//        public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)\n//        {\n//            // üîé Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably\n//            if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n//            {\n//                _log.LogWarning(\"Status update missing key fields (BusinessId or ProviderMessageId). Skip.\");\n//                return;\n//            }\n\n//            // 1) Pull candidates (scoped to business + WAMID)\n//            var sendLogQ = _db.Set<CampaignSendLog>()\n//                              .AsTracking()\n//                              .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);\n\n//            var msgLogQ = _db.Set<MessageLog>()\n//                             .AsTracking()\n//                             .Where(m => m.BusinessId == ev.BusinessId && m.MessageId == ev.ProviderMessageId);\n\n//            // If caller passed a specific CampaignSendLogId, narrow further\n//            if (ev.CampaignSendLogId is Guid sid)\n//                sendLogQ = sendLogQ.Where(s => s.Id == sid);\n\n//            var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);\n//            var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);\n\n//            // 2) Apply transition (idempotent)\n//            var changed = ApplyTransition(sendLog, msgLog, ev);\n\n//            // 3) Persist only if something actually changed\n//            if (changed > 0)\n//                await _db.SaveChangesAsync(ct);\n//        }\n\n//        /// <summary>Returns number of entities modified.</summary>\n//        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)\n//        {\n//            int modified = 0;\n\n//            // --- CampaignSendLog updates ---\n//            if (sendLog != null)\n//            {\n//                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n//                {\n//                    sendLog.MessageId = ev.ProviderMessageId;\n//                    modified++;\n//                }\n\n//                switch (ev.State)\n//                {\n//                    case MessageDeliveryState.Sent:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Sent\"))\n//                        {\n//                            sendLog.SendStatus = \"Sent\";\n//                            modified++;\n//                        }\n//                        if (sendLog.SentAt == null || sendLog.SentAt == default)\n//                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Delivered:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\") &&\n//                            !EqualsIgnoreCase(sendLog.SendStatus, \"Delivered\"))\n//                        {\n//                            sendLog.SendStatus = \"Delivered\";\n//                            modified++;\n//                        }\n//                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)\n//                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Read:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\"))\n//                        {\n//                            sendLog.SendStatus = \"Read\";\n//                            modified++;\n//                        }\n//                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)\n//                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Failed:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Failed\"))\n//                        {\n//                            sendLog.SendStatus = \"Failed\";\n//                            modified++;\n//                        }\n//                        if (sendLog.ErrorMessage != ev.ErrorMessage)\n//                        {\n//                            sendLog.ErrorMessage = ev.ErrorMessage;\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Deleted:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Deleted\"))\n//                        {\n//                            sendLog.SendStatus = \"Deleted\";\n//                            modified++;\n//                        }\n//                        break;\n//                }\n//            }\n\n//            // --- MessageLog updates ---\n//            if (msgLog != null)\n//            {\n//                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n//                {\n//                    msgLog.MessageId = ev.ProviderMessageId;\n//                    modified++;\n//                }\n\n//                switch (ev.State)\n//                {\n//                    case MessageDeliveryState.Sent:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Sent\"))\n//                        {\n//                            msgLog.Status = \"Sent\";\n//                            modified++;\n//                        }\n//                        if (msgLog.SentAt == null || msgLog.SentAt == default)\n//                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Delivered:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\") &&\n//                            !EqualsIgnoreCase(msgLog.Status, \"Delivered\"))\n//                        {\n//                            msgLog.Status = \"Delivered\";\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Read:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\"))\n//                        {\n//                            msgLog.Status = \"Read\";\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Failed:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Failed\"))\n//                        {\n//                            msgLog.Status = \"Failed\";\n//                            modified++;\n//                        }\n//                        if (msgLog.ErrorMessage != ev.ErrorMessage)\n//                        {\n//                            msgLog.ErrorMessage = ev.ErrorMessage;\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Deleted:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Deleted\"))\n//                        {\n//                            msgLog.Status = \"Deleted\";\n//                            modified++;\n//                        }\n//                        break;\n//                }\n//            }\n\n//            if (sendLog == null && msgLog == null)\n//            {\n//                _log.LogWarning(\"No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}\",\n//                    ev.BusinessId, ev.ProviderMessageId, ev.State);\n//            }\n\n//            return modified;\n//        }\n\n//        private static bool EqualsIgnoreCase(string? a, string? b) =>\n//            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n//    }\n//}\n"
    }
  ]
}
