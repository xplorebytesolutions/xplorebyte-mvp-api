{
  "name": "xbytechat-api/Features",
  "part": 3,
  "of": 5,
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ClickTokenService.cs",
      "sha256": "b80c48d547509139d45775d1f8447eceeec7d399e27cd9a55c20dc1aecb854fb",
      "language": "csharp",
      "size": 3152,
      "content": "// üìÑ Features/CampaignTracking/Services/ClickTokenService.cs\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public record ClickTokenPayload(\n        Guid cid,            // CampaignSendLogId\n        int bi,              // button index\n        string bt,           // button title (optional)\n        string to,           // destination absolute URL\n        long iat,            // issued at (unix seconds)\n        long exp             // expiry (unix seconds)\n    );\n\n    public interface IClickTokenService\n    {\n        string Create(ClickTokenPayload payload);\n        bool TryValidate(string token, out ClickTokenPayload? payload, out string? error);\n    }\n\n    public class ClickTokenService : IClickTokenService\n    {\n        private readonly byte[] _key;\n\n        public ClickTokenService(IOptions<TrackingOptions> opt)\n        {\n            _key = Encoding.UTF8.GetBytes(opt.Value.Secret ?? throw new ArgumentNullException(nameof(opt.Value.Secret)));\n        }\n\n        public string Create(ClickTokenPayload payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var data = Encoding.UTF8.GetBytes(json);\n            var body = WebEncoders.Base64UrlEncode(data);\n\n            var sig = ComputeHmac(body);\n            return $\"{body}.{sig}\";\n        }\n\n        public bool TryValidate(string token, out ClickTokenPayload? payload, out string? error)\n        {\n            payload = null;\n            error = null;\n\n            var parts = token.Split('.');\n            if (parts.Length != 2) { error = \"format\"; return false; }\n\n            var body = parts[0];\n            var sig = parts[1];\n\n            var expected = ComputeHmac(body);\n            // timing-safe compare\n            if (!CryptographicOperations.FixedTimeEquals(Encoding.UTF8.GetBytes(sig), Encoding.UTF8.GetBytes(expected)))\n            { error = \"bad-signature\"; return false; }\n\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(body);\n                var obj = JsonSerializer.Deserialize<ClickTokenPayload>(bytes);\n                if (obj is null) { error = \"decode\"; return false; }\n\n                var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n                if (now > obj.exp) { error = \"expired\"; return false; }\n\n                // minimal URL sanity check\n                if (!Uri.TryCreate(obj.to, UriKind.Absolute, out var _)) { error = \"bad-destination\"; return false; }\n\n                payload = obj;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                error = \"exception:\" + ex.GetType().Name;\n                return false;\n            }\n        }\n\n        private string ComputeHmac(string body)\n        {\n            using var h = new HMACSHA256(_key);\n            var sig = h.ComputeHash(Encoding.UTF8.GetBytes(body));\n            return WebEncoders.Base64UrlEncode(sig);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignAnalyticsService.cs",
      "sha256": "c4c188f0eba3b537c076a7fc42ef62094de1ced491abcaecb619097e40debb8b",
      "language": "csharp",
      "size": 437,
      "content": "using xbytechat.api.Features.CampaignTracking.DTOs;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignAnalyticsService\n    {\n       // Task<CampaignStatusDashboardDto> GetStatusDashboardAsync(Guid businessId);\n        Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5);\n        Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId);\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogEnricher.cs",
      "sha256": "9204a2182522e06e53fe6beb21100820231943995d044f01feb200bdcaa521de",
      "language": "csharp",
      "size": 290,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogEnricher\n    {\n        Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogService.cs",
      "sha256": "2be8275d1874b38f88f5395552b8a10412b7949d360e6abb4f12f10fdfa504f9",
      "language": "csharp",
      "size": 1276,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogService\n    {\n        // This is the NEW signature that matches your updated service and controller\n        Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n            Guid campaignId, string? status, string? search, int page, int pageSize);\n        // üìç Get logs for a specific contact in a campaign\n        Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId);\n\n        // üÜï Add a new send log entry with enrichment (IP, User-Agent)\n        Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent);\n\n        // üì® Update delivery or read status\n        Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt);\n\n        // üìà Track CTA click (e.g., BuyNow, ViewDetails)\n        Task<bool> TrackClickAsync(Guid logId, string clickType);\n        // üìä Get summary of campaign logs\n        Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(Guid campaignId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignTrackingRetryService.cs",
      "sha256": "0ea3dd070b8b87ab800873972e6200421e942c4e4536a316a8623bd7108e72ec",
      "language": "csharp",
      "size": 554,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignTrackingRetryService\n    {\n\n        // Retry a single failed message log by its ID.\n        // will be used when user clicks \"Retry Now\" on a log row.\n        Task<bool> RetrySingleAsync(Guid logId);\n\n\n        // Retry all failed messages in a campaign where retry is allowed.\n        // will support \"Retry All Failed\" button from Campaign logs.\n        Task<int> RetryFailedInCampaignAsync(Guid campaignId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickEvent.cs",
      "sha256": "feba0a8efef3e111690aeca876198178018024d5c39d3415d1cb3db163a8e52e",
      "language": "csharp",
      "size": 380,
      "content": "// Features/CampaignTracking/Worker/ClickEvent.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed record ClickEvent(\n        Guid CampaignSendLogId,\n        int ButtonIndex,\n        string ButtonTitle,\n        string Destination,\n        DateTime ClickedAtUtc,\n        string Ip,\n        string UserAgent,\n         string ClickType\n         \n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickLogWorker.cs",
      "sha256": "6c5f66aa812a1532420b44d66e9a0d9b72234af71077dbb32151c78d78d30a97",
      "language": "csharp",
      "size": 8009,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class ClickLogWorker : BackgroundService\n    {\n        private readonly ILogger<ClickLogWorker> _log;\n        private readonly IClickEventQueue _queue;\n        private readonly IServiceScopeFactory _scopeFactory;\n\n        public ClickLogWorker(\n            ILogger<ClickLogWorker> log,\n            IClickEventQueue queue,\n            IServiceScopeFactory scopeFactory)\n        {\n            _log = log;\n            _queue = queue;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _log.LogInformation(\"ClickLogWorker started\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                List<ClickEvent> batch;\n                try\n                {\n                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n                    if (batch.Count == 0) continue;\n\n                    // quick visibility: confirm we are ingesting call/whatsapp/web events\n                    var byType = batch.GroupBy(e => e.ClickType ?? \"web\")\n                                      .Select(g => $\"{g.Key}:{g.Count()}\")\n                                      .ToArray();\n                    _log.LogInformation(\"WORKER processing {Count} events [{Kinds}]\",\n                        batch.Count, string.Join(\", \", byType));\n                }\n                catch (OperationCanceledException)\n                {\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Queue read failed; retrying\");\n                    try { await Task.Delay(500, stoppingToken); } catch { /* ignore */ }\n                    continue;\n                }\n\n                // nothing to do\n                if (batch.Count == 0) continue;\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    // Prefetch CampaignId for this batch (we only need CampaignId for the aggregates)\n                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n                    if (sendIds.Count == 0) continue;\n\n                    var sendMap = await db.CampaignSendLogs\n                        .Where(s => sendIds.Contains(s.Id))\n                        .Select(s => new { s.Id, s.CampaignId })\n                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n                    // Prepare aggregate groups: (CampaignId, Day, ButtonIndex) -> count\n                    var groups = batch\n                        .Select(e =>\n                        {\n                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n                        })\n                        .Where(x => x.CampaignId != Guid.Empty)\n                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n                        .ToList();\n\n                    if (groups.Count == 0) continue;\n\n                    foreach (var g in groups)\n                    {\n                        await db.Database.ExecuteSqlRawAsync(@\"\n                    insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n                    values ({0}, {1}, {2}, {3})\n                    on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n                    do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Aggregate update failed; skipped this batch.\");\n                }\n            }\n\n            _log.LogInformation(\"ClickLogWorker stopped\");\n        }\n    }\n}\n\n\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n\n//namespace xbytechat.api.Features.CampaignTracking.Worker\n//{\n//    public sealed class ClickLogWorker : BackgroundService\n//    {\n//        private readonly ILogger<ClickLogWorker> _log;\n//        private readonly IClickEventQueue _queue;\n//        private readonly IServiceScopeFactory _scopeFactory;\n\n//        public ClickLogWorker(\n//            ILogger<ClickLogWorker> log,\n//            IClickEventQueue queue,\n//            IServiceScopeFactory scopeFactory)\n//        {\n//            _log = log;\n//            _queue = queue;\n//            _scopeFactory = scopeFactory;\n//        }\n\n//        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//        {\n//            _log.LogInformation(\"ClickLogWorker started\");\n\n//            while (!stoppingToken.IsCancellationRequested)\n//            {\n//                List<ClickEvent> batch;\n//                try\n//                {\n//                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n//                    if (batch.Count == 0) continue;\n//                    _log.LogInformation(\"WORKER processing {Count} events (aggregates only)\", batch.Count);\n//                }\n//                catch (OperationCanceledException) { break; }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Queue read failed; retrying\");\n//                    try { await Task.Delay(500, stoppingToken); } catch { }\n//                    continue;\n//                }\n\n//                try\n//                {\n//                    using var scope = _scopeFactory.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//                    // Prefetch CampaignId for this batch\n//                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n//                    var sendMap = await db.CampaignSendLogs\n//                        .Where(s => sendIds.Contains(s.Id))\n//                        .Select(s => new { s.Id, s.CampaignId })\n//                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n//                    // Build aggregate groups\n//                    var groups = batch\n//                        .Select(e =>\n//                        {\n//                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n//                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n//                        })\n//                        .Where(x => x.CampaignId != Guid.Empty)\n//                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n//                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n//                        .ToList();\n\n//                    foreach (var g in groups)\n//                    {\n//                        await db.Database.ExecuteSqlRawAsync(@\"\n//insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n//values ({0}, {1}, {2}, {3})\n//on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n//do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n//                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n//                    }\n//                }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Aggregate update failed; skipped.\");\n//                }\n//            }\n\n//            _log.LogInformation(\"ClickLogWorker stopped\");\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/IClickEventQueue.cs",
      "sha256": "a0e8a3bbb51c949024de93f0d4794c3ed494cc047e0b7dafdabe4cf696dad89c",
      "language": "csharp",
      "size": 304,
      "content": "// Features/CampaignTracking/Worker/IClickEventQueue.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public interface IClickEventQueue\n    {\n        bool TryWrite(ClickEvent evt);\n        Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/InProcessClickEventQueue.cs",
      "sha256": "8344c869f22df147598c7b1db117ba72d4c518901138838f7fed724201392009",
      "language": "csharp",
      "size": 1254,
      "content": "using System.Threading.Channels;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class InProcessClickEventQueue : IClickEventQueue\n    {\n        private readonly Channel<ClickEvent> _ch;\n\n        public InProcessClickEventQueue(int capacity = 20_000)\n        {\n            _ch = Channel.CreateBounded<ClickEvent>(new BoundedChannelOptions(capacity)\n            {\n                // keep newest; never block redirect\n                FullMode = BoundedChannelFullMode.DropOldest,\n                SingleReader = true,\n                SingleWriter = false\n            });\n        }\n\n        public bool TryWrite(ClickEvent evt) => _ch.Writer.TryWrite(evt);\n\n        public async Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct)\n        {\n            var list = new List<ClickEvent>(maxItems);\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            cts.CancelAfter(wait);\n\n            while (list.Count < maxItems && await _ch.Reader.WaitToReadAsync(cts.Token))\n            {\n                while (list.Count < maxItems && _ch.Reader.TryRead(out var item))\n                    list.Add(item);\n            }\n            return list;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogDashboardController.cs",
      "sha256": "f9186d5de3a12145a3d7a2411736c6510ca02a7b70409ebdcaaa0de5172c0370",
      "language": "csharp",
      "size": 1708,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-dashboard\")]\n    public class CatalogDashboardController : ControllerBase\n    {\n        private readonly ICatalogDashboardService _dashboardService;\n\n        public CatalogDashboardController(ICatalogDashboardService dashboardService)\n        {\n            _dashboardService = dashboardService;\n        }\n\n        [HttpGet(\"summary\")]\n        public async Task<ActionResult<CatalogDashboardSummaryDto>> GetSummary([FromQuery] Guid businessId)\n        {\n            var summary = await _dashboardService.GetDashboardSummaryAsync(businessId);\n            return Ok(summary);\n        }\n\n        [HttpGet(\"top-products\")]\n        public async Task<IActionResult> GetTopClickedProducts([FromQuery] Guid businessId, [FromQuery] int topN = 5)\n        {\n            var topProducts = await _dashboardService.GetTopClickedProductsAsync(businessId, topN);\n            return Ok(topProducts);\n        }\n        [HttpGet(\"cta-summary\")]\n        public async Task<IActionResult> GetCtaJourneySummary([FromQuery] Guid businessId)\n        {\n            var stats = await _dashboardService.GetCtaJourneyStatsAsync(businessId);\n            return Ok(stats);\n        }\n        [HttpGet(\"product-cta-breakdown\")]\n        public async Task<IActionResult> GetProductCtaBreakdown([FromQuery] Guid businessId)\n        {\n            var breakdown = await _dashboardService.GetProductCtaBreakdownAsync(businessId);\n            return Ok(breakdown);\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogTrackingController.cs",
      "sha256": "85581ce69ed9dbbad069ca060c3e8a2c356ec348d74d860ed2ed1905c46f9514",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-tracking\")]\n    public class CatalogTrackingController : ControllerBase\n    {\n        private readonly ICatalogTrackingService _trackingService;\n        private readonly ILogger<CatalogTrackingController> _logger;\n\n        public CatalogTrackingController(\n            ICatalogTrackingService trackingService,\n            ILogger<CatalogTrackingController> logger)\n        {\n            _trackingService = trackingService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"log-click\")]\n        public async Task<IActionResult> LogClick([FromBody] CatalogClickLogDto dto)\n        {\n            var result = await _trackingService.LogClickAsync(dto);\n\n            if (!result.Success)\n            {\n                _logger.LogWarning(\"‚ùå Catalog click log failed: {Msg}\", result.Message);\n                return BadRequest(result);\n            }\n\n            return StatusCode(201, result);\n        }\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 5)\n        {\n            var result = await _trackingService.GetRecentLogsAsync(limit);\n\n            if (!result.Success)\n            {\n                _logger.LogError(\"‚ùå Failed to fetch recent logs: {Error}\", result.ErrorMessage);\n                return StatusCode(500, result);\n            }\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/ProductController.cs",
      "sha256": "96a44de270bbb3d5a3b88cc161908c14045b78ca5adab88fb776640f55de1a1b",
      "language": "csharp",
      "size": 3021,
      "content": "// üìÑ File: Features/Catalog/Controllers/ProductController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Middleware.Attributes;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductService _productService;\n\n        public ProductController(IProductService productService)\n        {\n            _productService = productService;\n        }\n\n        // ‚úÖ GET /api/product?businessId=...\n        [HttpGet]\n        [RequirePermission(\"ViewCatalog\")]\n        public async Task<IActionResult> GetAll([FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.GetProductsByBusinessIdAsync(businessId);\n            return Ok(result);\n        }\n\n        // ‚úÖ POST /api/product\n        [HttpPost]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Create([FromBody] CreateProductDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                var errors = ModelState.Values\n                    .SelectMany(v => v.Errors)\n                    .Select(e => e.ErrorMessage)\n                    .ToList();\n\n                var errorString = string.Join(\"; \", errors);\n                return BadRequest(ResponseResult.ErrorInfo(\"Invalid product data.\", errorString));\n            }\n\n            var result = await _productService.AddProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return StatusCode(201, result);\n        }\n\n        // ‚úÖ DELETE /api/product/{id}?businessId=...\n        [HttpDelete(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Delete(Guid id, [FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.RemoveProductAsync(id, businessId);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n\n        // ‚úÖ PUT /api/product/{id}\n        [HttpPut(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] UpdateProductDto dto)\n        {\n            if (id != dto.Id)\n                return BadRequest(ResponseResult.ErrorInfo(\"ID mismatch between route and body.\"));\n\n            var result = await _productService.UpdateProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogClickLogDto.cs",
      "sha256": "901cea612e459695f97b806841df45393d04066624affedbfd85cc9d7d3899ce",
      "language": "csharp",
      "size": 979,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogClickLogDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid? ContactId { get; set; }  // ‚úÖ Add this\n        public Guid? ProductId { get; set; }\n\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        public string? BotId { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public string? CTAJourney { get; set; }\n        public Guid? MessageLogId { get; set; }      // ‚úÖ ADD THIS FIELD\n        public string? RefMessageId { get; set; }\n\n        public string TemplateId { get; set; }\n        public string ButtonText { get; set; }\n\n        // üß† Optional: Used for A/B tracking and analytics\n        public string? PlanSnapshot { get; set; }\n\n        public string? Source { get; set; } // ‚úÖ Add this\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogDashboardSummaryDto.cs",
      "sha256": "31e171cf2d8c5bc006b770f4be2a968db3300aaad51072555faecd119e0e0e07",
      "language": "csharp",
      "size": 698,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogDashboardSummaryDto\n    {\n        // Engagement Metrics\n        public int TotalMessagesSent { get; set; }\n        public int? UniqueCustomersMessaged { get; set; }\n        public int? ProductClicks { get; set; }\n\n        // Catalog Overview\n        public int? ActiveProducts { get; set; }\n        public int? ProductsSharedViaWhatsApp { get; set; }\n\n        // Lead Intelligence\n        public int? RepeatClickers { get; set; }\n        public int? NewClickersToday { get; set; }\n\n        // Timestamps\n        public DateTime? LastCatalogClickAt { get; set; }\n        public DateTime? LastMessageSentAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CreateProductDto.cs",
      "sha256": "8605a9900a0537d7cec14264a91a4a4432debcdaafb06cff99b177460bd47233",
      "language": "csharp",
      "size": 472,
      "content": "// File: Features/Catalog/DTOs/CreateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CreateProductDto\n    {\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CtaJourneyStatsDto.cs",
      "sha256": "ca4efb6e222da04add4d8f9892be95a16ae180b34e53eec32d300c471ea503bd",
      "language": "csharp",
      "size": 188,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CtaJourneyStatsDto\n    {\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductCtaBreakdownDto.cs",
      "sha256": "a94adfe171430503ede80ebb733fc9983f3fe1eae04b4a5a4ed6eb14d354bc10",
      "language": "csharp",
      "size": 284,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductCtaBreakdownDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductDto.cs",
      "sha256": "9351e6b36ce1f707bd46bb92652331f1751b150a9d062ecfd31572a0998d59b7",
      "language": "csharp",
      "size": 549,
      "content": "// File: Features/Catalog/DTOs/ProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/TopProductDto.cs",
      "sha256": "464918c2b2d66c5710042f7d26d7b64fc8f4fb0380f12e7c756a0d248e613684",
      "language": "csharp",
      "size": 228,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class TopProductDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/UpdateProductDto.cs",
      "sha256": "3d2fa63b4ce50da54504b1efa60375305ee53bd12498eb5c359bec2f13aeb11c",
      "language": "csharp",
      "size": 511,
      "content": "// File: Features/Catalog/DTOs/UpdateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class UpdateProductDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/CatalogClickLog.cs",
      "sha256": "04b5faf86ec274241aa075f5ba6309899ae07f9c0074d1a34285b4f7c96b437d",
      "language": "csharp",
      "size": 1636,
      "content": "namespace xbytechat.api.Features.Catalog.Models\n{\n    public class CatalogClickLog\n    {\n        public Guid Id { get; set; }\n\n        // üîó Business & Product Info\n        public Guid BusinessId { get; set; }\n        public Guid? ProductId { get; set; }\n\n        // üë§ Customer Info\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        // ü§ñ Bot / Messaging Context\n        public string? BotId { get; set; }\n\n        // üõçÔ∏è Browsing Context\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n\n        // üîò CTA Clicked\n        public string? CTAJourney { get; set; }\n        public string TemplateId { get; set; }\n        public string RefMessageId { get; set; }\n        public string ButtonText { get; set; }\n\n        // üïí Meta\n        public DateTime? ClickedAt { get; set; } = DateTime.UtcNow;\n\n        // ‚úÖ CRM / Campaign / Analytics\n        public Guid? CampaignSendLogId { get; set; }\n        public Guid? ContactId { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n        public string? LastInteractionType { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public string? PlanSnapshot { get; set; }\n\n        // üÜï [New Additions for CTA Campaign Tracking]\n        public Guid? CtaId { get; set; }             // Link to CTA definition\n        public Guid? CampaignId { get; set; }        // Link to campaign (if any)\n        public string Source { get; set; } = \"catalog\"; // \"catalog\", \"campaign\", \"auto-reply\"\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/Product.cs",
      "sha256": "428554206c02d4602a873704a1e49c995a274f4633e0f32d8c0991c4eea72a31",
      "language": "csharp",
      "size": 1062,
      "content": "// File: Features/Catalog/Models/Product.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.Catalog.Models\n{\n    public class Product\n    {\n        public Guid Id { get; set; }\n\n        // üîó Foreign Key - Business/Owner\n        public Guid BusinessId { get; set; }\n\n        // üì¶ Core Product Info\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n\n        // ‚úÖ Visibility & State\n        public bool IsActive { get; set; } = true;\n\n        // üìÖ Metadata\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public int TotalClicks { get; set; } = 0; // Total CTA clicks tracked\n        public DateTime? LastClickedAt { get; set; } // Last time a user clicked CTA for this product\n        public string? MostClickedCTA { get; set; } // Button text with highest click count (e.g., \"Buy Now\")\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogDashboardService.cs",
      "sha256": "3303616ebf70e99e2e646759834c707405060cc1b22ceb5f743dfa1d8af50198",
      "language": "csharp",
      "size": 6538,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting.Server;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogDashboardService : ICatalogDashboardService\n    {\n        private readonly AppDbContext _context;\n\n        public CatalogDashboardService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n       \n        public async Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalMessagesSent = await _context.MessageLogs\n                .CountAsync(m => m.BusinessId == businessId);\n\n            var uniqueCustomersMessaged = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .Select(m => m.RecipientNumber)\n                .Distinct()\n                .CountAsync();\n\n            var productClicks = await _context.CatalogClickLogs\n                .CountAsync(c => c.BusinessId == businessId && c.ProductId != null);\n\n            var activeProducts = await _context.Products\n                .CountAsync(p => p.BusinessId == businessId);\n\n            var productsSharedViaWhatsapp = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .Select(c => c.ProductId)\n                .Distinct()\n                .CountAsync();\n\n            var repeatClickers = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.UserPhone)\n                .CountAsync(g => g.Count() > 1);\n\n            var newClickersToday = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ClickedAt.Value.Date == today)\n                .Select(c => c.UserPhone)\n                .Distinct()\n                .CountAsync();\n            //        var newClickersToday = _context.CatalogClickLogs\n            //.Where(c => c.BusinessId == businessId)\n            //.ToList() // now it's LINQ to Objects\n            //        .Where(c => c.ClickedAt?.Date == today)\n            //        .Select(c => c.UserPhone)\n            //        .Distinct()\n            //.Count();\n            //        But if your data is large, the first(server-side filtering) is the better choice.\n\n            var lastCatalogClickAt = await _context.CatalogClickLogs\n    .Where(c => c.BusinessId == businessId)\n    .MaxAsync(c => (DateTime?)c.ClickedAt);\n\n            var lastMessageSentAt = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .MaxAsync(m => (DateTime?)m.SentAt);\n\n            return new CatalogDashboardSummaryDto\n            {\n                TotalMessagesSent = totalMessagesSent,\n                UniqueCustomersMessaged = uniqueCustomersMessaged,\n                ProductClicks = productClicks,\n                ActiveProducts = activeProducts,\n                ProductsSharedViaWhatsApp = productsSharedViaWhatsapp,\n                RepeatClickers = repeatClickers,\n                NewClickersToday = newClickersToday,\n                LastCatalogClickAt = lastCatalogClickAt,\n                LastMessageSentAt = lastMessageSentAt\n            };\n        }\n\n        public async Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5)\n        {\n            var topProducts = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .GroupBy(c => c.ProductId)\n                .Select(g => new\n                {\n                    ProductId = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .Take(topN)\n                .ToListAsync();\n\n            // Now fetch product names to join with clicks\n            var productIds = topProducts.Select(x => x.ProductId).ToList();\n\n            var products = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            return topProducts.Select(x => new TopProductDto\n            {\n                ProductId = x.ProductId.Value,\n                ProductName = products.ContainsKey(x.ProductId.Value) ? products[x.ProductId.Value] : \"Unknown\",\n                ClickCount = x.ClickCount\n            }).ToList();\n        }\n        public async Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId)\n        {\n            var stats = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => c.CTAJourney)\n                .Select(g => new CtaJourneyStatsDto\n                {\n                    CTAJourney = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .ToListAsync();\n\n            return stats;\n        }\n        public async Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId)\n        {\n            var groupedClicks = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => new { c.ProductId, c.CTAJourney })\n                .Select(g => new\n                {\n                    ProductId = g.Key.ProductId.Value,\n                    CTAJourney = g.Key.CTAJourney,\n                    ClickCount = g.Count()\n                })\n                .ToListAsync();\n\n            // Fetch product names for all involved productIds\n            var productIds = groupedClicks.Select(g => g.ProductId).Distinct().ToList();\n\n            var productNames = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            var result = groupedClicks.Select(g => new ProductCtaBreakdownDto\n            {\n                ProductId = g.ProductId,\n                ProductName = productNames.ContainsKey(g.ProductId) ? productNames[g.ProductId] : \"Unknown\",\n                CTAJourney = g.CTAJourney,\n                ClickCount = g.ClickCount\n            }).ToList();\n\n            return result;\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogTrackingService.cs",
      "sha256": "466e53210d232226ec62ffaed236063b75a748eff0f420e423d8f482ff3a4fdf",
      "language": "csharp",
      "size": 6371,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;\nusing xbytechat.api.Services.Messages.Interfaces;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogTrackingService : ICatalogTrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageService _messageService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public CatalogTrackingService(\n            AppDbContext context,\n            IMessageService messageService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _context = context;\n            _messageService = messageService;\n            _leadTimelineService = leadTimelineService;\n        }\n\n        public async Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto)\n        {\n            if (dto == null || dto.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(dto.UserPhone))\n            {\n                Log.Warning(\"‚ùå Invalid catalog click log attempt: missing businessId or userPhone.\");\n                return ResponseResult.ErrorInfo(\"Required fields are missing (businessId, userPhone).\");\n            }\n\n            try\n            {\n                Guid? campaignSendLogId = null;\n                Guid? contactId = null;\n                bool followUpSent = false;\n\n                // STEP 1: Link campaign log via RefMessageId if available\n                if (!string.IsNullOrWhiteSpace(dto.RefMessageId))\n                {\n                    var sendLog = await _context.CampaignSendLogs\n                        .FirstOrDefaultAsync(x => x.MessageId == dto.RefMessageId);\n\n                    if (sendLog != null)\n                    {\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = DateTime.UtcNow;\n                        sendLog.ClickType = dto.CTAJourney ?? dto.ButtonText;\n                        campaignSendLogId = sendLog.Id;\n                    }\n                }\n\n                // STEP 2: Link or Create CRM Contact\n                if (!string.IsNullOrWhiteSpace(dto.UserPhone))\n                {\n                    var contact = await _context.Contacts\n                        .FirstOrDefaultAsync(c => c.PhoneNumber == dto.UserPhone && c.BusinessId == dto.BusinessId);\n\n                    if (contact == null)\n                    {\n                        contact = new Contact\n                        {\n                            Id = Guid.NewGuid(),\n                            Name = dto.UserName ?? \"Lead\",\n                            PhoneNumber = dto.UserPhone,\n                            BusinessId = dto.BusinessId,\n                            CreatedAt = DateTime.UtcNow\n                        };\n                        _context.Contacts.Add(contact);\n                        await _context.SaveChangesAsync();\n                    }\n\n                    contactId = contact.Id;\n\n                    // STEP 3: Auto follow-up if plan allows\n                    var business = await _context.Businesses\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(b => b.Id == dto.BusinessId);\n\n                    if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                    {\n                        var message = $\"Hi {contact.Name ?? \"there\"}, how can I help you?\";\n                        await _messageService.SendFollowUpAsync(contact.PhoneNumber, message);\n                        followUpSent = true;\n                    }\n                }\n\n                // STEP 4: Save the click with all linked data\n                var log = new CatalogClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ProductId = dto.ProductId,\n                    UserId = dto.UserId,\n                    UserName = dto.UserName,\n                    UserPhone = dto.UserPhone,\n                    BotId = dto.BotId,\n                    CategoryBrowsed = dto.CategoryBrowsed,\n                    ProductBrowsed = dto.ProductBrowsed,\n                    CTAJourney = dto.CTAJourney,\n                    TemplateId = dto.TemplateId,\n                    ButtonText = dto.ButtonText,\n                    RefMessageId = dto.RefMessageId,\n                    ClickedAt = DateTime.UtcNow,\n                    CampaignSendLogId = campaignSendLogId,\n                    ContactId = contactId,\n                    FollowUpSent = followUpSent,\n                    LastInteractionType = \"Clicked\",\n                    PlanSnapshot = dto.PlanSnapshot\n                };\n\n                _context.CatalogClickLogs.Add(log);\n                await _context.SaveChangesAsync();\n\n                // STEP 5: Save into LeadTimeline (no await error)\n                await _leadTimelineService.AddFromCatalogClickAsync(log);\n\n                Log.Information(\"üìä Catalog click tracked: {BusinessId}, {UserPhone}, {CTA}\", dto.BusinessId, dto.UserPhone, dto.CTAJourney);\n                return ResponseResult.SuccessInfo(\"‚úÖ Click tracked successfully.\", log.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to log catalog click\");\n                return ResponseResult.ErrorInfo(\"‚ùå Error while tracking catalog click.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetRecentLogsAsync(int limit)\n        {\n            try\n            {\n                var logs = await _context.CatalogClickLogs\n                    .OrderByDescending(x => x.ClickedAt)\n                    .Take(limit)\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Recent logs fetched.\", logs);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch recent catalog click logs\");\n                return ResponseResult.ErrorInfo(\"Failed to fetch logs.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogDashboardService.cs",
      "sha256": "9cac16574ec18c7343c13d49a28395b9ab04bf296e8d7b910b05d1cc88378a7d",
      "language": "csharp",
      "size": 546,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogDashboardService\n    {\n        Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId);\n        Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5);\n        Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId);\n        Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId);\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogTrackingService.cs",
      "sha256": "b9ea119f807697f7e52cbea8b7c3aa4320c2ffe23326d076d1d1f0f9a2f12310",
      "language": "csharp",
      "size": 342,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogTrackingService\n    {\n        Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto);\n        Task<ResponseResult> GetRecentLogsAsync(int limit);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/IProductService.cs",
      "sha256": "23245f8c5da029c4146e515732f03b3e815636c1fddfec0f38a3a26355bdc1b1",
      "language": "csharp",
      "size": 510,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface IProductService\n    {\n        Task<ResponseResult> AddProductAsync(CreateProductDto dto);\n        Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId);\n        Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto);\n        Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ProductService.cs",
      "sha256": "b42253a9398257b4f84555e31c4423127d843bd60b73560f7730b71433d17fd0",
      "language": "csharp",
      "size": 5527,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class ProductService : IProductService\n    {\n        private readonly AppDbContext _context;\n\n        public ProductService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<ResponseResult> AddProductAsync(CreateProductDto dto)\n        {\n            try\n            {\n                var exists = await _context.Products\n                    .AnyAsync(p => p.BusinessId == dto.BusinessId && p.Name == dto.Name);\n\n                if (exists)\n                {\n                    Log.Warning(\"‚ùå Duplicate product add attempt: {ProductName} for BusinessId: {BusinessId}\", dto.Name, dto.BusinessId);\n                    return ResponseResult.ErrorInfo(\"Product with this name already exists.\");\n                }\n\n                var newProduct = new Product\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    Price = dto.Price,\n                    Currency = dto.Currency,\n                    ImageUrl = dto.ImageUrl,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                await _context.Products.AddAsync(newProduct);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Product created: {ProductName} ({ProductId})\", dto.Name, newProduct.Id);\n                return ResponseResult.SuccessInfo(\"‚úÖ Product added successfully.\", newProduct.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add product: {ProductName}\", dto.Name);\n                return ResponseResult.ErrorInfo(\"Failed to add product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == id && p.BusinessId == businessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"‚ùå Attempted to delete non-existent product: {ProductId}\", id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                _context.Products.Remove(product);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üóëÔ∏è Product deleted: {ProductId}\", id);\n                return ResponseResult.SuccessInfo(\"üóëÔ∏è Product deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to delete product: {ProductId}\", id);\n                return ResponseResult.ErrorInfo(\"Failed to delete product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == dto.Id && p.BusinessId == dto.BusinessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"‚ùå Attempted to update non-existent product: {ProductId}\", dto.Id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                product.Name = dto.Name;\n                product.Description = dto.Description;\n                product.Price = dto.Price;\n                product.Currency = dto.Currency;\n                product.ImageUrl = dto.ImageUrl;\n\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Product updated: {ProductId}\", dto.Id);\n                return ResponseResult.SuccessInfo(\"‚úÖ Product updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to update product: {ProductId}\", dto.Id);\n                return ResponseResult.ErrorInfo(\"Failed to update product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId)\n        {\n            try\n            {\n                var products = await _context.Products\n                    .Where(p => p.BusinessId == businessId && p.IsActive)\n                    .Select(p => new ProductDto\n                    {\n                        Id = p.Id,\n                        BusinessId = p.BusinessId,\n                        Name = p.Name,\n                        Description = p.Description,\n                        Price = p.Price,\n                        Currency = p.Currency,\n                        ImageUrl = p.ImageUrl,\n                        IsActive = p.IsActive\n                    })\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Products fetched.\", products);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch products for BusinessId: {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"Failed to fetch products.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs",
      "sha256": "a4d7703060f27a3527a15f3159f436e52c46728ed6d1fa07570a4e002bcc0e0f",
      "language": "csharp",
      "size": 7002,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Services;\n\nnamespace xbytechat.api.Features.ChatInbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/chat-inbox\")]\n    public sealed class ChatInboxController : ControllerBase\n    {\n        private readonly IChatInboxQueryService _queryService;\n        private readonly IChatInboxCommandService _commandService;\n\n        public ChatInboxController(\n            IChatInboxQueryService queryService,\n            IChatInboxCommandService commandService)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _commandService = commandService ?? throw new ArgumentNullException(nameof(commandService));\n        }\n\n        // üö© Conversations list\n        [HttpGet(\"conversations\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxConversationDto>), 200)]\n        public async Task<IActionResult> GetConversations(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? currentUserId,\n            [FromQuery] string? tab,\n            [FromQuery] string? numberId,\n            [FromQuery] string? search,\n            [FromQuery] int? limit,\n            CancellationToken cancellationToken)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            var filter = new ChatInboxFilterDto\n            {\n                BusinessId = businessId,\n                CurrentUserId = currentUserId,\n                Tab = tab,\n                NumberId = string.IsNullOrWhiteSpace(numberId) ? null : numberId,\n                SearchTerm = string.IsNullOrWhiteSpace(search) ? null : search,\n                Limit = limit.GetValueOrDefault(50),\n            };\n\n            switch (tab?.ToLowerInvariant())\n            {\n                case \"unassigned\":\n                    filter.OnlyUnassigned = true;\n                    break;\n                case \"my\":\n                    filter.OnlyAssignedToMe = true;\n                    break;\n            }\n\n            var result = await _queryService.GetConversationsAsync(filter, cancellationToken);\n            return Ok(result);\n        }\n\n        // üí¨ Messages for a conversation\n        [HttpGet(\"messages\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxMessageDto>), 200)]\n        public async Task<ActionResult<IReadOnlyList<ChatInboxMessageDto>>> GetMessages(\n            [FromQuery] Guid businessId,\n            [FromQuery] string contactPhone,\n            [FromQuery] int limit = 50,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n            {\n                return BadRequest(\"contactPhone is required.\");\n            }\n\n            var messages = await _queryService.GetMessagesForConversationAsync(\n                businessId,\n                contactPhone,\n                limit,\n                ct);\n\n            return Ok(messages);\n        }\n\n        // üì§ Send a message from agent ‚Üí customer (used by Chat Inbox middle panel)\n        [HttpPost(\"send-message\")]\n        [ProducesResponseType(typeof(ChatInboxMessageDto), 200)]\n        public async Task<ActionResult<ChatInboxMessageDto>> SendMessage(\n            [FromBody] ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            var result = await _commandService.SendAgentMessageAsync(request, ct);\n            return Ok(result);\n        }\n\n        // ‚úÖ Mark conversation as read for current user\n        [HttpPost(\"mark-read\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> MarkRead(\n            [FromBody] ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            await _commandService.MarkConversationAsReadAsync(request, ct);\n            return NoContent();\n        }\n\n        // üë§ Assign conversation to an agent\n        [HttpPost(\"assign\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> Assign(\n            [FromBody] ChatInboxAssignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            await _commandService.AssignConversationAsync(request, ct);\n            return NoContent();\n        }\n\n        // üö´ Unassign conversation\n        [HttpPost(\"unassign\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> Unassign(\n            [FromBody] ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId and ContactId are required.\");\n            }\n\n            await _commandService.UnassignConversationAsync(request, ct);\n            return NoContent();\n        }\n\n        [HttpPost(\"status\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> ChangeStatus(\n            [FromBody] ChatInboxChangeStatusRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId and ContactId are required.\");\n            }\n\n            await _commandService.ChangeConversationStatusAsync(request, ct);\n            return NoContent();\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs",
      "sha256": "1070b71e595443da5bb86c5ae223123d517333fd06193925c55359d7d2e869ae",
      "language": "csharp",
      "size": 1156,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for assigning a conversation (contact) to a specific user.\n    /// </summary>\n    public sealed class ChatInboxAssignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Agent/user who will own this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n    }\n\n    /// <summary>\n    /// Request payload for unassigning a conversation.\n    /// </summary>\n    public sealed class ChatInboxUnassignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs",
      "sha256": "272eac87602469cf471a8599cfe4fecc87e11b2cb22b59c430a28de6e1296a39",
      "language": "csharp",
      "size": 923,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Command payload for changing the status of an Inbox conversation.\n    /// Internally this maps to Contact.IsArchived / IsActive.\n    /// </summary>\n    public sealed class ChatInboxChangeStatusRequestDto\n    {\n        /// <summary>\n        /// Tenant / business id (required).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact whose conversation we want to change (required).\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Target status: \"Open\" | \"Closed\" (case-insensitive).\n        /// We also accept \"New\"/\"Pending\" but treat them as Open internally.\n        /// </summary>\n        public string? TargetStatus { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs",
      "sha256": "76991e3473373fb2fb8f90fbb2191461275be41a786a6b5e04dbf02ac32b3668",
      "language": "csharp",
      "size": 2451,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Lightweight conversation summary for the Chat Inbox UI.\n    /// Mirrors the front-end ConversationSummary model.\n    /// </summary>\n    public sealed class ChatInboxConversationDto\n    {\n        /// <summary>\n        /// Conversation identifier for the UI.\n        /// For v1 this can be derived from (ContactId + NumberId).\n        /// In the future, if you create an InboxConversation table,\n        /// use its primary key here.\n        /// </summary>\n        public string Id { get; set; } = default!;\n\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } = string.Empty;\n        public string ContactPhone { get; set; } = string.Empty;\n\n        public string LastMessagePreview { get; set; } = string.Empty;\n        public DateTime LastMessageAt { get; set; }\n\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// \"New\" | \"Open\" | \"Pending\" | \"Closed\"\n        /// </summary>\n        public string Status { get; set; } = \"New\";\n\n        /// <summary>\n        /// WhatsApp number id (e.g. wa-num-1).\n        /// Later you may map this to WhatsAppPhoneNumber.Id.\n        /// </summary>\n        public string NumberId { get; set; } = string.Empty;\n\n        public string NumberLabel { get; set; } = string.Empty;\n\n        /// <summary>\n        /// True if within 24h messaging window (WhatsApp session).\n        /// </summary>\n        public bool Within24h { get; set; }\n\n        public string? AssignedToUserId { get; set; }\n        public string? AssignedToUserName { get; set; }\n        public bool IsAssignedToMe { get; set; }\n\n        /// <summary>\n        /// \"automation\" | \"agent\"\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// \"AutoReply\" | \"Campaign\" | \"Manual\" | \"Unknown\"\n        /// </summary>\n        public string SourceType { get; set; } = \"Unknown\";\n\n        /// <summary>\n        /// Campaign name / AutoReply flow name / other source label.\n        /// </summary>\n        public string? SourceName { get; set; }\n\n        public DateTime? FirstSeenAt { get; set; }\n        public int TotalMessages { get; set; }\n\n        public DateTime? LastAgentReplyAt { get; set; }\n        public DateTime? LastAutomationAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs",
      "sha256": "edeb9ca6d210c4107c4f2982f08c387f6350b04fd2bf31bfbe643f36b2b97729",
      "language": "csharp",
      "size": 1707,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Filters used by the Chat Inbox conversation list endpoint.\n    /// This matches the UI needs: tab, number, search, \"my\" vs \"unassigned\".\n    /// </summary>\n    public sealed class ChatInboxFilterDto\n    {\n        /// <summary>\n        /// Business Id (tenant). Mandatory for multi-tenant isolation.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Currently logged-in user id (for \"my\" filter).\n        /// Optional: if null, \"my\" filter is ignored.\n        /// </summary>\n        public Guid? CurrentUserId { get; set; }\n\n        /// <summary>\n        /// \"live\" | \"history\" | \"unassigned\" | \"my\"\n        /// </summary>\n        public string? Tab { get; set; }\n\n        /// <summary>\n        /// WhatsApp number id, e.g. \"wa-num-1\". If null or \"all\", no filter.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Free text search over name, phone, and last message preview.\n        /// </summary>\n        public string? SearchTerm { get; set; }\n\n        /// <summary>\n        /// Max number of conversations to return. Hard-capped to 200.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n\n        /// <summary>\n        /// If true: only conversations without AssignedToUserId.\n        /// </summary>\n        public bool OnlyUnassigned { get; set; }\n\n        /// <summary>\n        /// If true: only conversations assigned to CurrentUserId.\n        /// </summary>\n        public bool OnlyAssignedToMe { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs",
      "sha256": "9375b5c5b9178604658d3f966c53db98de8d656c7eef85e219477f817cd16df8",
      "language": "csharp",
      "size": 1031,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for marking a conversation as \"read\"\n    /// for a given user in the Chat Inbox.\n    /// </summary>\n    public sealed class ChatInboxMarkReadRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id whose messages are being marked as read.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// The user (agent) that just read this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n\n        /// <summary>\n        /// Optional timestamp for \"last read\". If not supplied,\n        /// the server will use DateTime.UtcNow.\n        /// </summary>\n        public DateTime? LastReadAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs",
      "sha256": "c75975d0670537a2936e7dd5a8e79c9bd7bdbed9de88fc166b02e78200c61c45",
      "language": "csharp",
      "size": 1804,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Single message in a Chat Inbox conversation.\n    /// Kept intentionally simple and stable so the React UI\n    /// can bind to it without worrying about provider details.\n    /// </summary>\n    public sealed class ChatInboxMessageDto\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// \"in\"  = message came from customer to us.\n        /// \"out\" = message we sent to customer.\n        /// For now we only have reliable data for \"out\"; we keep\n        /// the string type so we can extend it later without schema changes.\n        /// </summary>\n        public string Direction { get; set; } = \"out\";\n\n        /// <summary>\n        /// Channel identifier (e.g. \"whatsapp\") ‚Äì future-proofing.\n        /// </summary>\n        public string Channel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Rendered text content for the bubble.\n        /// For templates we‚Äôll store the final rendered body.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n\n        /// <summary>\n        /// When we created/sent the message (UTC).\n        /// If SentAt is missing, falls back to CreatedAt.\n        /// </summary>\n        public DateTime SentAtUtc { get; set; }\n\n        /// <summary>\n        /// Provider / delivery status (‚ÄúSent‚Äù, ‚ÄúDelivered‚Äù, ‚ÄúRead‚Äù, ‚ÄúFailed‚Äù, etc.),\n        /// mapped from MessageLog.Status.\n        /// </summary>\n        public string? Status { get; set; }\n\n        /// <summary>\n        /// For failed messages, a short error string from MessageLog.ErrorMessage.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs",
      "sha256": "2b73973de1d335932a58540ba4a31877247732c77d7ddc345d910b40883913af",
      "language": "csharp",
      "size": 1554,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for sending an agent reply from the Chat Inbox.\n    /// This is what the React ChatInbox.jsx will POST.\n    /// </summary>\n    public sealed class ChatInboxSendMessageRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Conversation id from the UI. For v1 this is typically ContactId.ToString().\n        /// Mainly for tracing; not mandatory for the send logic.\n        /// </summary>\n        public string? ConversationId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id for this chat (preferred for lookups).\n        /// </summary>\n        public Guid? ContactId { get; set; }\n\n        /// <summary>\n        /// Target phone number (normalized WhatsApp number).\n        /// Same as selectedConversation.contactPhone in the UI.\n        /// </summary>\n        public string To { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optional: which WhatsApp number we are sending from\n        /// (e.g. \"wa-1\"). Useful when you support multiple WABA numbers.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Message body typed by the agent.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ConversationSummaryDto.cs",
      "sha256": "8d4800233670cbca833d145eba5da1a64e0b2a520e5f5bfc65ea5a36c2c9ce86",
      "language": "csharp",
      "size": 2421,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Read model used by the Chat Inbox to show the left-hand conversation list.\n    /// Mirrors the shape used in ChatInbox.jsx (INITIAL_CONVERSATIONS).\n    /// </summary>\n    public class ConversationSummaryDto\n    {\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Primary display name (CRM contact name).\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (normalized).\n        /// </summary>\n        public string PhoneNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Latest WhatsApp profile.name we saw.\n        /// </summary>\n        public string? ProfileName { get; set; }\n\n        /// <summary>\n        /// Short preview of the last message in this conversation.\n        /// </summary>\n        public string? LastMessagePreview { get; set; }\n\n        /// <summary>\n        /// When the last message was seen/sent.\n        /// </summary>\n        public DateTime? LastMessageAt { get; set; }\n\n        /// <summary>\n        /// Count of unread inbound messages for this contact.\n        /// </summary>\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// Priority like \"Hot\", \"Warm\", \"Cold\" (CRM-driven, optional).\n        /// </summary>\n        public string? Priority { get; set; }\n\n        /// <summary>\n        /// True if this contact is treated as VIP or important.\n        /// </summary>\n        public bool IsVip { get; set; }\n\n        /// <summary>\n        /// Conversation mode: \"automation\" or \"agent\".\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// Name of the assigned agent (if any).\n        /// </summary>\n        public string? AssignedAgentName { get; set; }\n\n        /// <summary>\n        /// CRM tags as chips for quick context (e.g. VIP, Lead, Follow-up).\n        /// </summary>\n        public List<string> Tags { get; set; } = new();\n\n        /// <summary>\n        /// Text like \"3 notes ‚Ä¢ 1 reminder today\".\n        /// </summary>\n        public string? LastActivitySummary { get; set; }\n\n        /// <summary>\n        /// Text like \"Next follow-up tomorrow at 11:30 AM\".\n        /// </summary>\n        public string? TaskSummary { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs",
      "sha256": "7dc0c8eb585a5b0432d326d952073ca870913b850b774b051dedc0d077c3e409",
      "language": "csharp",
      "size": 11813,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Default write-side handler for Chat Inbox actions.\n    /// Delegates the actual send to the central MessagesEngine so that\n    /// MessageLogs / provider calls stay consistent across the app.\n    /// Also manages per-user read state (ContactReads) and assignment.\n    /// </summary>\n    public sealed class ChatInboxCommandService : IChatInboxCommandService\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n\n        public ChatInboxCommandService(\n            AppDbContext db,\n            IMessageEngineService messageEngine)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n        }\n\n        public async Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.To))\n                throw new ArgumentException(\"Target phone (To) is required.\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.Text))\n                throw new ArgumentException(\"Text is required.\", nameof(request));\n\n            var businessId = request.BusinessId;\n            var phone = request.To.Trim();\n\n            // üîé Resolve contact:\n            Guid? contactId = request.ContactId;\n\n            if (!contactId.HasValue)\n            {\n                var contact = await _db.Contacts\n                    .AsNoTracking()\n                    .Where(c => c.BusinessId == businessId && c.PhoneNumber == phone)\n                    .FirstOrDefaultAsync(ct)\n                    .ConfigureAwait(false);\n\n                contactId = contact?.Id;\n            }\n\n            var effectiveContactId = contactId ?? Guid.Empty;\n\n            // üì® Build the DTO expected by MessagesEngine text pipeline.\n            var textDto = new TextMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = phone,\n                TextContent = request.Text,\n                ContactId = effectiveContactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId)\n                    ? null\n                    : request.NumberId.Trim(),\n                Provider = null,         // let engine resolve default provider/number\n                Source = \"agent\"         // so analytics can separate human replies\n            };\n\n            // üß† Delegate to the central MessagesEngine.\n            var result = await _messageEngine\n                .SendTextDirectAsync(textDto)\n                .ConfigureAwait(false);\n\n            // Try to load the MessageLog row so we can return a rich bubble DTO.\n            MessageLog? log = null;\n            if (result.LogId.HasValue)\n            {\n                log = await _db.MessageLogs\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(m => m.Id == result.LogId.Value, ct)\n                    .ConfigureAwait(false);\n            }\n\n            var nowUtc = DateTime.UtcNow;\n            var sentAt = nowUtc;\n            var bubbleText = request.Text;\n            string? status = null;\n            string? errorMessage = null;\n            Guid bubbleId;\n\n            if (log != null)\n            {\n                bubbleId = log.Id;\n                bubbleText = log.MessageContent ?? request.Text;\n\n                var ts = log.SentAt ?? log.CreatedAt;\n                sentAt = ts.Kind == DateTimeKind.Utc ? ts : ts.ToUniversalTime();\n\n                status = log.Status;\n                errorMessage = log.ErrorMessage;\n            }\n            else\n            {\n                bubbleId = Guid.NewGuid();\n                sentAt = nowUtc;\n                status = result.Success ? \"Sent\" : \"Failed\";\n                errorMessage = result.Success ? null : result.Message;\n            }\n\n            // üß± Map to ChatInboxMessageDto so the UI can render the bubble immediately.\n            var dto = new ChatInboxMessageDto\n            {\n                Id = bubbleId,\n                Direction = \"out\",           // agent ‚Üí customer\n                Channel = \"whatsapp\",\n                Text = bubbleText,\n                SentAtUtc = sentAt,\n                Status = status,\n                ErrorMessage = errorMessage\n            };\n\n            return dto;\n        }\n\n        public async Task MarkConversationAsReadAsync(\n            ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            if (request.UserId == Guid.Empty)\n                throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n            var businessId = request.BusinessId;\n            var contactId = request.ContactId;\n            var userId = request.UserId;\n            var nowUtc = DateTime.UtcNow;\n\n            var lastReadAt = request.LastReadAtUtc.HasValue\n                ? (request.LastReadAtUtc.Value.Kind == DateTimeKind.Utc\n                    ? request.LastReadAtUtc.Value\n                    : request.LastReadAtUtc.Value.ToUniversalTime())\n                : nowUtc;\n\n            // Either insert or update ContactReads row.\n            var existing = await _db.ContactReads\n                .FirstOrDefaultAsync(\n                    r => r.BusinessId == businessId\n                         && r.ContactId == contactId\n                         && r.UserId == userId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (existing == null)\n            {\n                var entity = new ContactRead\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    UserId = userId,\n                    LastReadAt = lastReadAt\n                };\n\n                await _db.ContactReads.AddAsync(entity, ct).ConfigureAwait(false);\n            }\n            else\n            {\n                // Only move forward in time; never move LastReadAt backwards.\n                if (existing.LastReadAt < lastReadAt)\n                {\n                    existing.LastReadAt = lastReadAt;\n                    _db.ContactReads.Update(existing);\n                }\n            }\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task AssignConversationAsync(\n            ChatInboxAssignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            if (request.UserId == Guid.Empty)\n                throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for assignment.\");\n            }\n\n            contact.AssignedAgentId = request.UserId;\n            _db.Contacts.Update(contact);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task UnassignConversationAsync(\n            ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for unassign.\");\n            }\n\n            contact.AssignedAgentId = null;\n            _db.Contacts.Update(contact);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task ChangeConversationStatusAsync(\n           ChatInboxChangeStatusRequestDto request,\n           CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            var rawStatus = request.TargetStatus ?? string.Empty;\n            var normalized = rawStatus.Trim();\n\n            if (string.IsNullOrEmpty(normalized))\n                throw new ArgumentException(\"TargetStatus is required.\", nameof(request));\n\n            normalized = normalized.ToLowerInvariant();\n\n            // We accept: \"open\", \"closed\", \"new\", \"pending\"\n            var close = normalized switch\n            {\n                \"closed\" => true,\n                \"open\" => false,\n                \"new\" => false,\n                \"pending\" => false,\n                _ => throw new ArgumentException(\n                    \"TargetStatus must be one of: Open, Closed, New, Pending.\",\n                    nameof(request))\n            };\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for status change.\");\n            }\n\n            if (close)\n            {\n                contact.IsArchived = true;\n                contact.IsActive = false;\n            }\n            else\n            {\n                contact.IsArchived = false;\n                contact.IsActive = true;\n            }\n\n            _db.Contacts.Update(contact);\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs",
      "sha256": "d5a3d95f42b211f1232fd16ff6d0868ae3ec2d9f8ecf9751c385d08bbdd828dc",
      "language": "csharp",
      "size": 17553,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Models; // AppDbContext\n// We avoid referencing MessageLog / Contact types by name so we don't fight namespaces.\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Default implementation of IChatInboxQueryService.\n    /// \n    /// v1 implementation:\n    ///  - Groups MessageLogs by ContactId for a Business.\n    ///  - Joins Contacts for display name / phone.\n    ///  - Computes last message, unread count (per user), 24h window, assignment flags.\n    ///  - Applies tab filters (\"live\", \"history\", \"unassigned\", \"my\") and search.\n    /// \n    /// This is intentionally conservative and can be optimized later\n    /// (server-side aggregates, better indexes, source-type mapping, etc.).\n    /// </summary>\n    public sealed class ChatInboxQueryService : IChatInboxQueryService\n    {\n        private readonly AppDbContext _db;\n\n        public ChatInboxQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            if (filter == null) throw new ArgumentNullException(nameof(filter));\n            if (filter.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(filter));\n\n            // Hard cap to avoid insane result sets\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 200) limit = 200;\n\n            var businessId = filter.BusinessId;\n            var currentUserId = filter.CurrentUserId;\n\n            // Base query: all message logs for this business that are linked to a contact.\n            // NOTE: we rely on AppDbContext.MessageLogs and ContactId being non-null for chat contacts.\n            var baseMessagesQuery = _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.ContactId != null);\n\n            // --- 1) Aggregate per contact: last message, first seen, total count ---\n            // This is done server-side; we only bring down a small projection.\n            var convoAggregates = await baseMessagesQuery\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => new\n                {\n                    ContactId = g.Key,\n                    LastMessageAt = g.Max(m => m.CreatedAt),\n                    FirstSeenAt = g.Min(m => m.CreatedAt),\n                    TotalMessages = g.Count()\n                })\n                .OrderByDescending(x => x.LastMessageAt)\n                .Take(limit)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            if (convoAggregates.Count == 0)\n            {\n                return Array.Empty<ChatInboxConversationDto>();\n            }\n\n            var contactIds = convoAggregates.Select(x => x.ContactId).ToList();\n\n            // --- 2) Load contacts for those ids (CRM) ---\n            // We assume AppDbContext.Contacts exists and has basic fields we need.\n            var contacts = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && contactIds.Contains(c.Id))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var contactsById = contacts.ToDictionary(c => c.Id, c => c);\n\n            // --- 3) Load last messages for preview (one per contact) ---\n            // We re-query MessageLogs but only for the selected contactIds.\n            var lastMessages = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId\n                            && m.ContactId != null\n                            && contactIds.Contains(m.ContactId.Value))\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => g\n                    .OrderByDescending(m => m.CreatedAt)\n                    .FirstOrDefault())\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var lastMessageByContactId = lastMessages\n                .Where(m => m != null && m.ContactId != null)\n                .ToDictionary(m => m!.ContactId!.Value, m => m!);\n\n            // --- 4) Compute unread counts for the current user (if any) ---\n            var unreadCounts = new Dictionary<Guid, int>();\n\n            if (currentUserId.HasValue)\n            {\n                // ContactReads for this user + business\n                var reads = await _db.ContactReads\n                    .AsNoTracking()\n                    .Where(r => r.BusinessId == businessId\n                                && r.UserId == currentUserId.Value\n                                && contactIds.Contains(r.ContactId))\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                var lastReadByContact = reads.ToDictionary(r => r.ContactId, r => r.LastReadAt);\n\n                // Inbound messages for those contacts\n                var inboundMessages = await _db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => m.BusinessId == businessId\n                                && m.ContactId != null\n                                && contactIds.Contains(m.ContactId.Value)\n                                && m.IsIncoming)\n                    .Select(m => new { m.ContactId, m.CreatedAt })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                foreach (var group in inboundMessages.GroupBy(x => x.ContactId!.Value))\n                {\n                    var cid = group.Key;\n                    DateTime? lastRead = null;\n                    if (lastReadByContact.TryGetValue(cid, out var value))\n                    {\n                        lastRead = value;\n                    }\n\n                    var count = lastRead.HasValue\n                        ? group.Count(x => x.CreatedAt > lastRead.Value)\n                        : group.Count();\n\n                    unreadCounts[cid] = count;\n                }\n            }\n\n            // --- 5) Load session state for \"mode\" (automation vs agent), if available ---\n            // We assume ChatSessionStates table exists and tracks Mode + last touch.\n            var sessionStates = await _db.ChatSessionStates\n                .AsNoTracking()\n                .Where(s => s.BusinessId == businessId && contactIds.Contains(s.ContactId))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var sessionByContactId = sessionStates.ToDictionary(s => s.ContactId, s => s);\n\n            // --- 6) Build DTOs in memory ---\n            var nowUtc = DateTime.UtcNow;\n            var results = new List<ChatInboxConversationDto>(convoAggregates.Count);\n\n            foreach (var agg in convoAggregates)\n            {\n                if (!contactsById.TryGetValue(agg.ContactId, out var contact))\n                {\n                    // Contact might have been hard-deleted. Skip for now.\n                    continue;\n                }\n\n                lastMessageByContactId.TryGetValue(agg.ContactId, out var lastMsg);\n\n                var preview = lastMsg?.RenderedBody ?? lastMsg?.MessageContent ?? string.Empty;\n                if (preview.Length > 140)\n                {\n                    preview = preview.Substring(0, 140) + \"‚Ä¶\";\n                }\n\n                var unread = unreadCounts.TryGetValue(agg.ContactId, out var count) ? count : 0;\n\n                var within24h = (nowUtc - agg.LastMessageAt).TotalHours <= 24;\n\n                // Conversation status heuristic:\n                // - Archived / inactive contact => Closed\n                // - Else if unread > 0 => Open\n                // - Else => Pending\n                var status =\n                    (contact.IsArchived || !contact.IsActive) ? \"Closed\"\n                    : unread > 0 ? \"Open\"\n                    : \"Pending\";\n\n                // Assignment\n                var assignedUserId = contact.AssignedAgentId;\n                var assignedUserIdString = assignedUserId?.ToString();\n                var isAssignedToMe =\n                    currentUserId.HasValue &&\n                    assignedUserId.HasValue &&\n                    assignedUserId.Value == currentUserId.Value;\n\n                // Mode: if we have ChatSessionState, use that; else infer from last message.\n                string mode = \"automation\";\n                if (sessionByContactId.TryGetValue(agg.ContactId, out var session))\n                {\n                    // Assuming session.Mode is an enum or string; normalize to lower-case string.\n                    mode = session.Mode?.ToString().ToLowerInvariant() ?? \"automation\";\n                }\n                else if (lastMsg != null)\n                {\n                    // Fallback: if last message is an outgoing \"agent\" message\n                    // we treat it as agent mode; otherwise automation.\n                    // (This depends on how you store Source; adjust later.)\n                    if (!lastMsg.IsIncoming && string.Equals(lastMsg.Source, \"agent\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        mode = \"agent\";\n                    }\n                }\n\n                // For v1 we don't yet decode exact SourceType / SourceName from Campaign / AutoReply / CTAFlow.\n                // We'll set \"Unknown\" and fill this later when we wire analytics.\n                var dto = new ChatInboxConversationDto\n                {\n                    // For v1 we use the ContactId as conversation id.\n                    Id = agg.ContactId.ToString(),\n\n                    ContactId = agg.ContactId,\n                    ContactName = string.IsNullOrWhiteSpace(contact.Name)\n                        ? (contact.ProfileName ?? contact.PhoneNumber)\n                        : contact.Name,\n                    ContactPhone = contact.PhoneNumber,\n\n                    LastMessagePreview = preview,\n                    LastMessageAt = agg.LastMessageAt,\n\n                    UnreadCount = unread,\n                    Status = status,\n\n                    // NumberId/NumberLabel: for now we leave empty.\n                    // Once WhatsApp phone mapping is wired, we can fill these.\n                    NumberId = string.Empty,\n                    NumberLabel = string.Empty,\n\n                    Within24h = within24h,\n\n                    AssignedToUserId = assignedUserIdString,\n                    AssignedToUserName = null,  // will be filled in v2 by joining Users table\n                    IsAssignedToMe = isAssignedToMe,\n\n                    Mode = mode,\n                    SourceType = \"Unknown\",\n                    SourceName = null,\n\n                    FirstSeenAt = agg.FirstSeenAt,\n                    TotalMessages = agg.TotalMessages,\n\n                    LastAgentReplyAt = null,     // can be filled later via MessageLogs aggregate\n                    LastAutomationAt = null      // same as above\n                };\n\n                results.Add(dto);\n            }\n\n            // --- 7) Apply tab filters (\"live\", \"history\", \"unassigned\", \"my\") + number + search ---\n\n            IEnumerable<ChatInboxConversationDto> filtered = results;\n\n            if (!string.IsNullOrWhiteSpace(filter.Tab))\n            {\n                var tab = filter.Tab.ToLowerInvariant();\n                switch (tab)\n                {\n                    case \"live\":\n                        filtered = filtered.Where(c => c.Within24h);\n                        break;\n                    case \"history\":\n                        filtered = filtered.Where(c => !c.Within24h);\n                        break;\n                    // \"unassigned\" and \"my\" were already mapped to flags in the controller,\n                    // but we double-check here too (harmless).\n                    case \"unassigned\":\n                        filtered = filtered.Where(c => string.IsNullOrEmpty(c.AssignedToUserId));\n                        break;\n                    case \"my\":\n                        if (currentUserId.HasValue)\n                        {\n                            filtered = filtered.Where(c => c.IsAssignedToMe);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            if (filter.OnlyUnassigned)\n            {\n                filtered = filtered.Where(c => string.IsNullOrEmpty(c.AssignedToUserId));\n            }\n\n            if (filter.OnlyAssignedToMe && currentUserId.HasValue)\n            {\n                filtered = filtered.Where(c => c.IsAssignedToMe);\n            }\n\n            // NumberId filter: for now we don't yet know which number a conversation belongs to.\n            // Once MessageLogs have NumberId / PhoneNumberId we can populate dto.NumberId and filter here.\n            if (!string.IsNullOrWhiteSpace(filter.NumberId)\n                && !string.Equals(filter.NumberId, \"all\", StringComparison.OrdinalIgnoreCase))\n            {\n                filtered = filtered.Where(c => string.Equals(c.NumberId, filter.NumberId, StringComparison.OrdinalIgnoreCase));\n            }\n\n            // Search: name, phone, last message preview (case-insensitive)\n            if (!string.IsNullOrWhiteSpace(filter.SearchTerm))\n            {\n                var term = filter.SearchTerm.Trim();\n                var termLower = term.ToLowerInvariant();\n\n                filtered = filtered.Where(c =>\n                    (!string.IsNullOrEmpty(c.ContactName) && c.ContactName.ToLowerInvariant().Contains(termLower)) ||\n                    (!string.IsNullOrEmpty(c.ContactPhone) && c.ContactPhone.Contains(term)) ||\n                    (!string.IsNullOrEmpty(c.LastMessagePreview) && c.LastMessagePreview.ToLowerInvariant().Contains(termLower)));\n            }\n\n            // Final cap (defensive)\n            var finalList = filtered\n                .OrderByDescending(c => c.LastMessageAt)\n                .Take(limit)\n                .ToList();\n\n            return finalList;\n        }\n\n        // üí¨ Messages for a single conversation (center pane)\n        // inside ChatInboxQueryService\n\n        // üí¨ Messages for a single conversation (center pane)\n        // inside ChatInboxQueryService\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"Contact phone is required.\", nameof(contactPhone));\n\n            if (limit <= 0)\n                limit = 50;\n            if (limit > 500)\n                limit = 500;\n\n            var trimmedPhone = contactPhone.Trim();\n\n            // üü¢ Step 1: resolve ContactId from phone number for this business\n            var contactId = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && c.PhoneNumber == trimmedPhone)\n                .Select(c => (Guid?)c.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (contactId == null)\n            {\n                // No such contact ‚Üí no messages\n                return Array.Empty<ChatInboxMessageDto>();\n            }\n\n            // üü¢ Step 2: fetch all messages for this contact (both directions)\n            var query = _db.MessageLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId &&\n                            x.ContactId == contactId.Value);\n\n            // Newest first\n            query = query\n                .OrderByDescending(x => x.SentAt ?? x.CreatedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit);\n\n            var rows = await query\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            // Map to DTOs (newest ‚Üí oldest; UI can reverse if needed).\n            var list = rows\n                .Select(x =>\n                {\n                    var instant = x.SentAt ?? x.CreatedAt;\n                    var utcInstant = instant.Kind == DateTimeKind.Utc\n                        ? instant\n                        : instant.ToUniversalTime();\n\n                    return new ChatInboxMessageDto\n                    {\n                        Id = x.Id,\n\n                        // ‚úÖ Use MessageLog.IsIncoming to decide bubble side\n                        Direction = x.IsIncoming ? \"in\" : \"out\",\n\n                        Channel = \"whatsapp\",\n\n                        // Prefer rendered template body when available\n                        Text = x.RenderedBody ?? x.MessageContent ?? string.Empty,\n\n                        SentAtUtc = utcInstant,\n                        Status = x.Status,\n                        ErrorMessage = x.ErrorMessage\n                    };\n                })\n                .ToList();\n\n            return list;\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs",
      "sha256": "4741408b7d2642c02f2c810518a363a0a18086afbf5fe1dbd5a30b8c66936951",
      "language": "csharp",
      "size": 1165,
      "content": "using xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxCommandService\n    {\n        /// <summary>\n        /// Sends an agent-authored text message to a contact from the Chat Inbox\n        /// and returns the resulting message DTO for the UI bubble.\n        /// </summary>\n        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default);\n        Task MarkConversationAsReadAsync(\n            ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default);\n\n        Task AssignConversationAsync(\n           ChatInboxAssignRequestDto request,\n           CancellationToken ct = default);\n\n        /// <summary>\n        /// Unassigns a conversation (sets AssignedAgentId to null).\n        /// </summary>\n        Task UnassignConversationAsync(\n            ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default);\n\n        Task ChangeConversationStatusAsync(\n           ChatInboxChangeStatusRequestDto request,\n           CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs",
      "sha256": "12fea9a47aa0deb5812b81de304846b9de47b8d4ed1cda7b11eb159a7353ac13",
      "language": "csharp",
      "size": 870,
      "content": "// üìÑ xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Read-only query service for Chat Inbox conversations.\n    /// This is a pure \"read model\" projection over MessageLogs + CRM.\n    /// </summary>\n    public interface IChatInboxQueryService\n    {\n        Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default);\n    }\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/ContactsController.cs",
      "sha256": "91d4a67e40e7f64a2681fc17937e9d420cacf129993c12967cb41f3a03968377",
      "language": "csharp",
      "size": 8378,
      "content": "using CsvHelper.Configuration;\nusing CsvHelper;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Globalization;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ContactsController : ControllerBase\n    {\n        private readonly IContactService _contactService;\n        private readonly ILogger<ContactsController> _logger;\n        public ContactsController(IContactService contactService, ILogger<ContactsController> logger)\n        {\n            _contactService = contactService;\n            _logger = logger;\n        }\n\n        // POST: api/contacts\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> AddContact([FromBody] ContactDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid contact payload.\"));\n\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _contactService.AddContactAsync(businessId, dto);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(result); // Already ResponseResult.ErrorInfo\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"üö® Unexpected error in AddContact\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Server error while creating contact.\", ex.ToString()));\n            }\n        }\n\n\n\n\n        // GET: api/contacts/{id}\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetContactById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var contact = await _contactService.GetContactByIdAsync(businessId, id);\n            if (contact == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Contact loaded.\", contact));\n        }\n\n        // PUT: api/contacts/{id}\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateContact(Guid id, [FromBody] ContactDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            dto.Id = id;\n            var success = await _contactService.UpdateContactAsync(businessId, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Contact updated.\"));\n        }\n\n        // DELETE: api/contacts/{id}\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteContact(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _contactService.DeleteContactAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Contact deleted.\"));\n        }\n\n        // POST: api/contacts/parse-csv\n        [ApiExplorerSettings(IgnoreApi = true)]\n        [HttpPost(\"parse-csv\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> ParseCsvToContactsAsync([FromForm] IFormFile file)\n        {\n            if (file == null || file.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n            using var stream = file.OpenReadStream();\n\n            try\n            {\n                var parseResult = await _contactService.ParseCsvToContactsAsync(businessId, stream);\n                return Ok(ResponseResult.SuccessInfo(\"CSV parsed with detailed results.\", parseResult));\n            }\n            catch (Exception ex)\n            {\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV parsing failed: \" + ex.Message));\n            }\n        }\n\n        // PATCH: /api/contacts/{id}/favorite\n        [HttpPatch(\"{id}/favorite\")]\n        public async Task<IActionResult> ToggleFavorite(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _contactService.ToggleFavoriteAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Favorite toggled.\"));\n        }\n\n        // PATCH: /api/contacts/{id}/archive\n        [HttpPatch(\"{id}/archive\")]\n        public async Task<IActionResult> ToggleArchive(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _contactService.ToggleArchiveAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Archive toggled.\"));\n        }\n\n        // POST: api/contacts/bulk-assign-tag\n        [HttpPost(\"bulk-assign-tag\")]\n        public async Task<IActionResult> AssignTagToContacts([FromBody] AssignTagToContactsDto dto)\n        {\n            if (dto.ContactIds == null || !dto.ContactIds.Any())\n                return BadRequest(ResponseResult.ErrorInfo(\"No contact IDs provided.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n            await _contactService.AssignTagToContactsAsync(businessId, dto.ContactIds, dto.TagId);\n\n            return Ok(ResponseResult.SuccessInfo(\"Tag assigned to selected contacts.\"));\n        }\n\n        //[HttpGet(\"contacts\")]\n        [HttpGet]\n        public async Task<IActionResult> GetAllContacts(\n        [FromQuery] string? tab = \"all\",\n        [FromQuery] int page = 1,\n        [FromQuery] int pageSize = 25)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var pagedResult = await _contactService.GetPagedContactsAsync(businessId, tab, page, pageSize);\n            return Ok(ResponseResult.SuccessInfo(\"Contacts loaded.\", pagedResult));\n        }\n        // GET: api/contacts/all\n        [HttpGet(\"all\")]\n        public async Task<IActionResult> GetAllContactsFlat()\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var allContacts = await _contactService.GetAllContactsAsync(businessId); // This returns IEnumerable<ContactDto>\n            return Ok(allContacts); // Returns plain array!\n        }\n\n        [HttpPost(\"filter-by-tags\")]\n        public async Task<IActionResult> GetContactsByTags([FromBody] List<string> tags)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            // ‚úÖ Convert to Guid list safely\n            var tagGuids = tags\n                .Where(x => Guid.TryParse(x, out _))\n                .Select(Guid.Parse)\n                .ToList();\n\n            var contacts = await _contactService.GetContactsByTagsAsync(businessId, tagGuids);\n\n            return Ok(ResponseResult.SuccessInfo(\"Contacts filtered successfully\", contacts));\n        }\n\n        [HttpPost(\"bulk-import\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> BulkImportContactsAsync(IFormFile file)\n        {\n            if (file == null || file.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            try\n            {\n                var result = await _contactService.BulkImportAsync(businessId, file.OpenReadStream());\n                return Ok(ResponseResult.SuccessInfo(\"Contacts imported successfully.\", result));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Bulk import failed.\");\n                return BadRequest(ResponseResult.ErrorInfo(\"Import failed: \" + ex.Message));\n            }\n        }\n\n        [HttpGet(\"by-tags\")]\n        public async Task<IActionResult> GetContactsByTags([FromQuery] List<Guid> tagIds)\n        {\n            var businessId = User.GetBusinessId();  // Your tenant logic\n            var contacts = await _contactService.GetContactsByTagsAsync(businessId, tagIds);\n            return Ok(contacts);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/CrmContactSummaryController.cs",
      "sha256": "804c510c09cab8b7fd6a474121078cb64210d3660e08bcd90b1bea1dbd167883",
      "language": "csharp",
      "size": 5514,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    /// <summary>\n    /// Read-only CRM aggregation endpoint used by Chat Inbox right panel.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm\")]\n    public sealed class CrmContactSummaryController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<CrmContactSummaryController> _log;\n\n        public CrmContactSummaryController(\n            AppDbContext db,\n            ILogger<CrmContactSummaryController> log)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _log = log ?? throw new ArgumentNullException(nameof(log));\n        }\n\n        /// <summary>\n        /// Returns a compact \"Contact 360\" summary for Inbox.\n        /// </summary>\n        [HttpGet(\"contact-summary/{contactId:guid}\")]\n        public async Task<ActionResult<CrmContactSummaryDto>> GetContactSummary(\n            Guid contactId,\n            CancellationToken cancellationToken)\n        {\n            // 1Ô∏è‚É£ Load the contact (also gives us BusinessId for scoping)\n            var contact = await _db.Contacts\n                .AsNoTracking()\n                .FirstOrDefaultAsync(c => c.Id == contactId, cancellationToken);\n\n            if (contact == null)\n            {\n                return NotFound(new { message = \"Contact not found.\" });\n            }\n\n            var businessId = contact.BusinessId;\n\n            var dto = new CrmContactSummaryDto\n            {\n                ContactId = contact.Id,\n                BusinessId = businessId,\n                // Map with typical Contact fields (adjust if your entity differs)\n                Name = contact.Name,\n                PhoneNumber = contact.PhoneNumber,\n                Email = contact.Email,\n                LeadSource = contact.LeadSource,\n                CreatedAt = contact.CreatedAt\n            };\n\n            // 2Ô∏è‚É£ Tags ‚Äì simple many-to-many via ContactTags\n            var tagQuery =\n                from ct in _db.ContactTags.AsNoTracking()\n                join t in _db.Tags.AsNoTracking()\n                    on ct.TagId equals t.Id\n                where ct.ContactId == contactId\n                      && ct.BusinessId == businessId\n                select new CrmTagChipDto\n                {\n                    Id = t.Id,\n                    TagName = t.Name,\n                    ColorHex = t.ColorHex\n                };\n\n            dto.Tags = await tagQuery\n                .OrderBy(t => t.TagName)\n                .ToListAsync(cancellationToken);\n\n            // 3Ô∏è‚É£ Recent notes ‚Äì last 3\n            var noteQuery = _db.Notes\n                .AsNoTracking()\n                .Where(n => n.ContactId == contactId && n.BusinessId == businessId)\n                .OrderByDescending(n => n.CreatedAt)\n                .Take(3)\n                .Select(n => new CrmNoteSnippetDto\n                {\n                    Id = n.Id,\n                    Title = n.Title,\n                    Content = n.Content,\n                    CreatedByName = n.CreatedBy,\n                    CreatedAt = n.CreatedAt\n                });\n\n            dto.RecentNotes = await noteQuery.ToListAsync(cancellationToken);\n\n            // 4Ô∏è‚É£ Next reminder ‚Äì nearest future reminder (not completed)\n            var nowUtc = DateTime.UtcNow;\n\n            var nextReminderEntity = await _db.Reminders\n                .AsNoTracking()\n                .Where(r =>\n                    r.ContactId == contactId &&\n                    r.BusinessId == businessId &&\n                    r.DueAt >= nowUtc &&\n                    r.Status != \"Completed\") // using Status instead of IsCompleted\n                .OrderBy(r => r.DueAt)\n                .FirstOrDefaultAsync(cancellationToken);\n\n            if (nextReminderEntity != null)\n            {\n                dto.NextReminder = new CrmReminderSnippetDto\n                {\n                    Id = nextReminderEntity.Id,\n                    Title = nextReminderEntity.Title,\n                    Description = nextReminderEntity.Description,\n                    Status = nextReminderEntity.Status,\n                    DueAt = nextReminderEntity.DueAt,\n                    Priority = nextReminderEntity.Priority\n                };\n            }\n\n            // 5Ô∏è‚É£ Recent timeline ‚Äì last 5 timeline events\n            var timelineQuery = _db.LeadTimelines\n                .AsNoTracking()\n                .Where(e => e.ContactId == contactId && e.BusinessId == businessId)\n                .OrderByDescending(e => e.CreatedAt)\n                .Take(5)\n                .Select(e => new CrmTimelineEventDto\n                {\n                    Id = e.Id,\n                    Title = e.Description, // no Title/ShortDescription on model\n                    Source = e.Source,\n                    Category = e.Category,\n                    EventType = e.EventType,\n                    CreatedAt = e.CreatedAt\n                });\n\n            dto.RecentTimeline = await timelineQuery.ToListAsync(cancellationToken);\n\n            _log.LogInformation(\n                \"[CRM] Contact summary loaded: Business={BusinessId} Contact={ContactId}\",\n                businessId,\n                contactId);\n\n            return Ok(dto);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/NotesController.cs",
      "sha256": "ebce43df28dd9a59eb8a21a1b39592edf5a00e1527501b27fff1f47b9536631b",
      "language": "csharp",
      "size": 2959,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class NotesController : ControllerBase\n    {\n        private readonly INoteService _noteService;\n\n        public NotesController(INoteService noteService)\n        {\n            _noteService = noteService;\n        }\n\n        [HttpPost(\"notes\")]\n        public async Task<IActionResult> AddNote([FromBody] NoteDto dto)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _noteService.AddNoteAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"Note created.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"Error creating note\", ex.Message));\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetNotesByContact(Guid contactId)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _noteService.GetNotesByContactAsync(businessId, contactId);\n                return Ok(ResponseResult.SuccessInfo(\"Notes loaded.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"Error fetching notes\", ex.Message));\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetNoteById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var result = await _noteService.GetNoteByIdAsync(businessId, id);\n            if (result == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Note loaded.\", result));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateNote(Guid id, [FromBody] NoteDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _noteService.UpdateNoteAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Note updated.\"));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteNote(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _noteService.DeleteNoteAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Note deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/RemindersController.cs",
      "sha256": "94768043e5877270f9ca797c084d60b10d081df7b7973bed29466c4b07018405",
      "language": "csharp",
      "size": 3241,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class RemindersController : ControllerBase\n    {\n        private readonly IReminderService _reminderService;\n\n        public RemindersController(IReminderService reminderService)\n        {\n            _reminderService = reminderService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddReminder(ReminderDto dto)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                if (dto == null)\n                    return BadRequest(ResponseResult.ErrorInfo(\"Reminder data is missing.\"));\n\n                var result = await _reminderService.AddReminderAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"Reminder created.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"An error occurred while adding the reminder.\", ex.Message));\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllReminders()\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var reminders = await _reminderService.GetAllRemindersAsync(businessId);\n                return Ok(ResponseResult.SuccessInfo(\"Reminders loaded.\", reminders));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"An error occurred while fetching reminders.\", ex.Message));\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetReminderById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var reminder = await _reminderService.GetReminderByIdAsync(businessId, id);\n            if (reminder == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder loaded.\", reminder));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateReminder(Guid id, [FromBody] ReminderDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _reminderService.UpdateReminderAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder updated.\"));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteReminder(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _reminderService.DeleteReminderAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/TagsController.cs",
      "sha256": "aaa8771539b4136dcbfb5a98734d5e4ae2e6b14ad2179be7822746ac6fa3d93b",
      "language": "csharp",
      "size": 1999,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TagsController : ControllerBase\n    {\n        private readonly ITagService _tagService;\n\n        public TagsController(ITagService tagService)\n        {\n            _tagService = tagService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTag([FromBody] TagDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var result = await _tagService.AddTagAsync(businessId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"Tag created.\", result));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateTag(Guid id, [FromBody] TagDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _tagService.UpdateTagAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Tag updated.\"));\n        }\n\n        [HttpGet(\"get-tags\")]\n        public async Task<IActionResult> GetAllTags()\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var tags = await _tagService.GetAllTagsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"Tags loaded.\", tags));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteTag(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _tagService.DeleteTagAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Tag deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/AssignTagToContactsDto.cs",
      "sha256": "905dc04f16dd3b6ee269a89e0ea202a6af3dea76b223c9013713e74bb418bb24",
      "language": "csharp",
      "size": 198,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class AssignTagToContactsDto\n    {\n        public List<Guid> ContactIds { get; set; } = new();\n        public Guid TagId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/BulkImportResultDto.cs",
      "sha256": "fe6c5584078fe7488e519566ddc228be57d05be0a7a67f1427ceb0b3e90949fd",
      "language": "csharp",
      "size": 342,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class BulkImportResultDto\n    {\n        public int Imported { get; set; }\n        public List<CsvImportError> Errors { get; set; } = new();\n    }\n\n    public class CsvImportErrorMsg\n    {\n        public int RowNumber { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactDto.cs",
      "sha256": "83bef17a1c7bc4901f020261fb9a4d30c7bab7acab03e82fe3182e4eb4a24de3",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactDto\n    {\n        public Guid? Id { get; set; } // Nullable for Create (used in PUT)\n\n        public string Name { get; set; } // Contact full name\n\n        public string PhoneNumber { get; set; } // WhatsApp-compatible number\n\n        public string? Email { get; set; } // Optional email address\n\n        public string? LeadSource { get; set; } // e.g., \"WhatsApp\", \"Facebook\", \"Landing Page\"\n\n        public DateTime? LastContactedAt { get; set; } // Last WhatsApp or CRM interaction\n\n        public DateTime? NextFollowUpAt { get; set; } // For scheduling reminders\n\n        public string? Notes { get; set; } // Internal notes for the contact\n\n        public DateTime? CreatedAt { get; set; } // Read-only timestamp\n\n        // ‚úÖ NEW: Structured Tags (replaces comma-separated strings)\n        // Example: [{ id: 1, name: \"VIP\" }, { id: 2, name: \"Follow-up\" }]\n        public List<ContactTagDto> Tags { get; set; } = new();\n\n        public bool IsFavorite { get; set; } = false;\n        public bool IsArchived { get; set; } = false;\n        public string? Group { get; set; }\n\n        public bool IsTemporary { get; set; } = false;\n        public Guid? SourceCampaignId { get; set; }\n        public DateTime? ExpiresAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactDtoCsvMap.cs",
      "sha256": "dde35933fff5c8c84bc55769637d7467f36135c71549b547b60773aa4cf8da62",
      "language": "csharp",
      "size": 482,
      "content": "using CsvHelper.Configuration;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactDtoCsvMap : ClassMap<ContactDto>\n    {\n        public ContactDtoCsvMap()\n        {\n            Map(m => m.Name).Name(\"name\", \"Name\", \"full name\");\n            Map(m => m.PhoneNumber).Name(\"phone\", \"Phone\", \"mobile\", \"mobile number\");\n            Map(m => m.Email).Name(\"email\", \"Email\").Optional();\n            Map(m => m.Notes).Name(\"notes\", \"Notes\").Optional();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactTagDto.cs",
      "sha256": "69e97156f1e9453485bbaa39803b7c132d5a991e27091eb6cb648b42a148fc7a",
      "language": "csharp",
      "size": 281,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactTagDto\n    {\n        public Guid TagId { get; set; }\n        public string TagName { get; set; } = string.Empty;\n        public string? ColorHex { get; set; }\n        public string? Category { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/CrmContactSummaryDto.cs",
      "sha256": "320c7a1b0dd1223ea9e8a517b258e7235d2c12f71a798317c71483d95d2b0d26",
      "language": "csharp",
      "size": 2012,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.DTOs\n{\n    public sealed class CrmContactSummaryDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string PhoneNumber { get; set; } = string.Empty;\n        public string? Email { get; set; }\n        public string? LeadSource { get; set; }\n        public DateTime? CreatedAt { get; set; }\n\n        // üëá These names match ChatInbox.jsx usage\n        public List<CrmTagChipDto> Tags { get; set; } = new();\n        public List<CrmNoteSnippetDto> RecentNotes { get; set; } = new();\n        public CrmReminderSnippetDto? NextReminder { get; set; }\n        public List<CrmTimelineEventDto> RecentTimeline { get; set; } = new();\n    }\n\n    public sealed class CrmTagChipDto\n    {\n        public Guid Id { get; set; }\n        public string TagName { get; set; } = string.Empty;\n        public string? ColorHex { get; set; }\n    }\n\n    public sealed class CrmNoteSnippetDto\n    {\n        public Guid Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string Content { get; set; } = string.Empty;\n        public string? CreatedByName { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public sealed class CrmReminderSnippetDto\n    {\n        public Guid Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string? Description { get; set; }\n        public string? Status { get; set; }\n        public DateTime DueAt { get; set; }\n        public int? Priority { get; set; }\n    }\n\n    public sealed class CrmTimelineEventDto\n    {\n        public int Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public string? EventType { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/CsvImportResult.cs",
      "sha256": "b960c95f03cdabf593c9264c4a26457bc30278af2e88d77efe9a54ae066dd3c7",
      "language": "csharp",
      "size": 373,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class CsvImportResult<T>\n    {\n        public List<T> SuccessRecords { get; set; } = new();\n        public List<CsvImportError> Errors { get; set; } = new();\n    }\n\n    public class CsvImportError\n    {\n        public int RowNumber { get; set; }\n        public string ErrorMessage { get; set; } = string.Empty;\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/NoteDto.cs",
      "sha256": "2cf81a6442725d71886e1a87250278823b8c5d4d653ff38ab6d8f7b83e5a0586",
      "language": "csharp",
      "size": 524,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class NoteDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }\n        public string Title { get; set; }\n        public string Content { get; set; }\n        public string Source { get; set; }\n        public string CreatedBy { get; set; }\n        public bool IsPinned { get; set; }\n        public bool IsInternal { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? EditedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/PagedResult.cs",
      "sha256": "fecb6fb29ec3bedc245dacd6fb2198d2f2c98335be5a5d93cd5a787d9248faa3",
      "language": "csharp",
      "size": 351,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class PagedResult<T>\n    {\n        public List<T> Items { get; set; } = new();\n        public int TotalCount { get; set; }\n\n        public int Page { get; set; }\n        public int PageSize { get; set; }\n        public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ReminderDto.cs",
      "sha256": "50148cbe3ff493fa413666d9cd8590f078edc71c0a9127144a5b7c6116020f92",
      "language": "csharp",
      "size": 955,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ReminderDto\n    {\n        public Guid? Id { get; set; }  // Null when creating, present when updating\n\n        public Guid? ContactId { get; set; }\n\n        public string Title { get; set; } = default!;\n\n        public string? Description { get; set; }\n\n        public DateTime DueAt { get; set; }\n\n        public string? Status { get; set; } = \"Pending\";\n\n        public string? ReminderType { get; set; }\n\n        public int? Priority { get; set; }\n\n        public bool IsRecurring { get; set; }\n\n        public string? RecurrencePattern { get; set; }\n\n        public bool SendWhatsappNotification { get; set; }\n\n        public string? LinkedCampaign { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime? CreatedAt { get; set; }\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public DateTime? CompletedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/TagDto.cs",
      "sha256": "cd0010264a2cc4567c59311afd6d637f23f2e070be2d4da68f6be0ab97e46ff4",
      "language": "csharp",
      "size": 521,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class TagDto\n    {\n        public Guid? Id { get; set; }\n\n        public string Name { get; set; } = default!;\n\n        public string? ColorHex { get; set; }\n\n        public string? Category { get; set; }\n\n        public string? Notes { get; set; }\n\n        public bool IsSystemTag { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime? CreatedAt { get; set; }\n\n        public DateTime? LastUsedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IContactService.cs",
      "sha256": "b7ca4f37c5420dd9e44b8fd2d03c1c0fff462256304cae410fbd5a135aa261b9",
      "language": "csharp",
      "size": 1862,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    /// <summary>\n    /// Defines the contract for all operations related to managing contacts.\n    /// </summary>\n    public interface IContactService\n    {\n\n        Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto);\n        Task<ContactDto> GetContactByIdAsync(Guid businessId, Guid contactId);\n        Task<bool> UpdateContactAsync(Guid businessId, ContactDto dto);\n        Task<bool> DeleteContactAsync(Guid businessId, Guid contactId);\n        Task<CsvImportResult<ContactDto>> ParseCsvToContactsAsync(Guid businessId, Stream csvStream);\n        Task<Contact> FindOrCreateAsync(Guid businessId, string phoneNumber);\n        Task<bool> ToggleFavoriteAsync(Guid businessId, Guid contactId);\n        Task<bool> ToggleArchiveAsync(Guid businessId, Guid contactId);\n        Task<IEnumerable<ContactDto>> GetAllContactsAsync(Guid businessId, string? tab = \"all\");\n        Task AssignTagToContactsAsync(Guid businessId, List<Guid> contactIds, Guid tagId);\n        Task<PagedResult<ContactDto>> GetPagedContactsAsync(\n             Guid businessId,\n             string? tab = \"all\",\n             int page = 1,\n             int pageSize = 25,\n             string? searchTerm = null\n            );\n        // ‚úÖ Tag-based filtering support\n        Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<Guid> tags);\n\n        Task<BulkImportResultDto> BulkImportAsync(Guid businessId, Stream csvStream);\n        // üìå New method to support flow node ‚Üí tag assignment\n        Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tags);\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/INoteService.cs",
      "sha256": "3a55224ed1bd77632f1df5c60e2b9e83f76c595578c5cb47c07bd3965bda4360",
      "language": "csharp",
      "size": 705,
      "content": "using xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface INoteService\n    {\n        // For creating new note\n        Task<NoteDto> AddNoteAsync(Guid businessId, NoteDto dto);\n\n        // List all notes for dashboard view\n        Task<IEnumerable<NoteDto>> GetNotesByContactAsync(Guid businessId, Guid contactId);\n\n        // For loading note in edit mode\n        Task<NoteDto?> GetNoteByIdAsync(Guid businessId, Guid noteId);\n        // Handles editing\n        Task<bool> UpdateNoteAsync(Guid businessId, Guid noteId, NoteDto dto);\n        // Soft delete ‚Üí IsActive = false\n        Task<bool> DeleteNoteAsync(Guid businessId, Guid noteId);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IReminderService.cs",
      "sha256": "ee0bb73d2c3d212a59012abdf1d71ab3ef240b6f785d25dde255e5c7d30f3e16",
      "language": "csharp",
      "size": 824,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface IReminderService\n    {\n        //For creating new reminder\n        Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto);\n\n        //List all reminders for dashboard view\n        Task<IEnumerable<ReminderDto>> GetAllRemindersAsync(Guid businessId);\n\n        //For loading reminder in edit mode\n        Task<ReminderDto?> GetReminderByIdAsync(Guid businessId, Guid reminderId);\n\n        //Handles editing\n        Task<bool> UpdateReminderAsync(Guid businessId, Guid reminderId, ReminderDto dto);\n        //Soft delete ‚Üí IsActive = false\n        Task<bool> DeleteReminderAsync(Guid businessId, Guid reminderId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/ITagService.cs",
      "sha256": "736259ffc3b829a1b584543e52713f6207c977647abd89389fb465385b7aaaaa",
      "language": "csharp",
      "size": 652,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface ITagService\n    {\n        Task<TagDto> AddTagAsync(Guid businessId, TagDto dto);\n\n        Task<IEnumerable<TagDto>> GetAllTagsAsync(Guid businessId);\n        Task<bool> UpdateTagAsync(Guid businessId, Guid tagId, TagDto dto);\n        Task<bool> DeleteTagAsync(Guid businessId, Guid tagId);\n        // Task AssignTagAsync(Guid businessId, string phone, string tag);\n        Task AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tagNames);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/ContactDtoCsvMap.cs",
      "sha256": "5cd5f3e2a53b4eabb3f3dd20e5afcc50f2c101f9f2a4225fa9aae68e11507167",
      "language": "csharp",
      "size": 396,
      "content": "using CsvHelper.Configuration;\nusing xbytechat.api.Features.CRM.Dtos;\n\npublic sealed class ContactDtoCsvMap : ClassMap<ContactDto>\n{\n    public ContactDtoCsvMap()\n    {\n        Map(m => m.Name).Name(\"Name\");\n        Map(m => m.PhoneNumber).Name(\"Phone\");\n        Map(m => m.Email).Name(\"Email\");\n        Map(m => m.LeadSource).Name(\"LeadSource\");\n        Map(m => m.Notes).Name(\"Notes\");\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/NoteMapper.cs",
      "sha256": "c1a7011bee26e547e4064999d2b18acaa207560f62b38ce965cbe2d2c6c93ee1",
      "language": "csharp",
      "size": 1265,
      "content": "using xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Mappers\n{\n    public static class NoteMapper\n    {\n        public static NoteDto MapToDto(Note note)\n        {\n            return new NoteDto\n            {\n                Id = note.Id,\n                ContactId = note.ContactId,\n                Title = note.Title,\n                Content = note.Content,\n                Source = note.Source,\n                CreatedBy = note.CreatedBy,\n                IsPinned = note.IsPinned,\n                IsInternal = note.IsInternal,\n                CreatedAt = note.CreatedAt,\n                EditedAt = note.EditedAt\n            };\n        }\n\n        public static Note MapToEntity(NoteDto dto, Guid businessId)\n        {\n            return new Note\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = dto.ContactId,\n                Title = dto.Title,\n                Content = dto.Content,\n                Source = dto.Source,\n                CreatedBy = dto.CreatedBy,\n                IsPinned = dto.IsPinned,\n                IsInternal = dto.IsInternal,\n                CreatedAt = DateTime.UtcNow\n            };\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/ReminderMapper.cs",
      "sha256": "950330c648a97a44de32a21621ac0b162359f35f1354664a00a509cab43a0dba",
      "language": "csharp",
      "size": 892,
      "content": "namespace xbytechat.api.Features.CRM.Mappers\n{\n    using xbytechat.api.Features.CRM.Dtos;\n    using xbytechat.api.Features.CRM.Models;\n\n    public static class ReminderMapper\n    {\n        public static ReminderDto MapToDto(Reminder r)\n        {\n            return new ReminderDto\n            {\n                Id = r.Id,\n                Title = r.Title,\n                Description = r.Description,\n                DueAt = r.DueAt,\n                ReminderType = r.ReminderType,\n                Priority = r.Priority,\n                IsRecurring = r.IsRecurring,\n                RecurrencePattern = r.RecurrencePattern,\n                SendWhatsappNotification = r.SendWhatsappNotification,\n                LinkedCampaign = r.LinkedCampaign,\n                Status = r.Status,\n                CreatedAt = r.CreatedAt,\n                ContactId = r.ContactId\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Contact.cs",
      "sha256": "b1e174cb56e84029fb8007267b479da61257b0097a0b522c5b6eab5a4f7b2280",
      "language": "csharp",
      "size": 2370,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Contact\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; } = null!;\n        // üîó FK to Business\n        [Required]\n        [MaxLength(100)]\n        public string Name { get; set; }\n\n        [Required]\n        [MaxLength(20)]\n        public string PhoneNumber { get; set; }\n\n        [MaxLength(100)]\n        public string? Email { get; set; }\n\n        [MaxLength(50)]\n        public string? LeadSource { get; set; }\n\n        [MaxLength(200)]\n        public string? Tags { get; set; } // Legacy, will be deprecated after ContactTag rollout\n\n        public DateTime? LastContactedAt { get; set; }\n        public DateTime? NextFollowUpAt { get; set; }\n\n        [MaxLength(500)]\n        public string? Notes { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // üß© NEW: Link to Tags\n        public ICollection<ContactTag> ContactTags { get; set; } = new List<ContactTag>();\n        // ‚úÖ New: Navigation property for many-to-many tags\n        //public ICollection<ContactTag> TagsLink { get; set; } = new List<ContactTag>();\n\n        public DateTime? LastCTAInteraction { get; set; }\n        public string? LastCTAType { get; set; }\n        public Guid? LastClickedProductId { get; set; }\n\n        // üö¶ If true, skip automation flows (manually or programmatically paused)\n        public bool IsAutomationPaused { get; set; } = false;\n\n        // üë§ If agent assigned, automation should pause (runtime check)\n        public Guid? AssignedAgentId { get; set; }\n\n        public bool IsFavorite { get; set; } = false;\n        public bool IsArchived { get; set; } = false;\n        public string? Group { get; set; }\n        public bool IsActive { get; set; } = true;\n\n\n        //public bool IsTemporary { get; set; } = false;\n        //public Guid? SourceCampaignId { get; set; }\n        //public DateTime? ExpiresAt { get; set; }\n\n        public string? ProfileName { get; set; }            // latest WA profile.name we saw inbound\n        public DateTime? ProfileNameUpdatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/ContactTag.cs",
      "sha256": "de88c1bdb0a34e2703e0bb2d9c83c80f2d4af9f2c008e11782fa4949ae0dc782",
      "language": "csharp",
      "size": 510,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.CRM.Models;\n\npublic class ContactTag\n{\n    [Key]\n    public Guid Id { get; set; }\n\n    [Required]\n    public Guid ContactId { get; set; }\n\n    public Contact Contact { get; set; }\n\n    [Required]\n    public Guid TagId { get; set; }\n\n    public Tag Tag { get; set; }\n\n    [Required]\n    public Guid BusinessId { get; set; }\n\n    public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n\n    public string? AssignedBy { get; set; }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Note.cs",
      "sha256": "00b6b2dacb3efff3e8043beb4d763a5e8196378a60d699f59f0253b718c6d65d",
      "language": "csharp",
      "size": 923,
      "content": "namespace xbytechat.api.Features.CRM.Models\n{\n    public class Note\n    {\n        public Guid Id { get; set; }\n\n        // üîó Ownership & Association\n        public Guid? BusinessId { get; set; }\n        public Guid? ContactId { get; set; }\n\n        // üìù Core Content\n        public string Title { get; set; } // Optional short title (for pinning or preview)\n        public string Content { get; set; }\n\n        // üîñ Contextual Intelligence\n        public string Source { get; set; } // e.g., \"Manual\", \"Call Log\", \"WhatsApp\", \"LeadForm\"\n        public string CreatedBy { get; set; } // Store agent/user name or userId\n\n        // üìå UX Flags\n        public bool IsPinned { get; set; } = false;\n        public bool IsInternal { get; set; } = false; // if true, only visible to team\n\n        // üïì Timestamps\n        public DateTime CreatedAt { get; set; }\n        public DateTime? EditedAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Reminder.cs",
      "sha256": "fc98f9aad251b376a21b81c2984660a17369d962f22e44a6fdc4b404508542c1",
      "language": "csharp",
      "size": 1728,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Reminder\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }   // For multi-tenant isolation\n\n        public Guid ContactId { get; set; }    // Which contact this reminder is for\n\n        public string Title { get; set; } = default!; // Main reminder title (e.g., \"Call back about invoice\")\n\n        public string? Description { get; set; } // Longer notes, optional (for internal detail)\n\n        public DateTime DueAt { get; set; }    // When reminder should notify\n\n        public string Status { get; set; } = \"Pending\"; // \"Pending\", \"Done\", \"Overdue\"\n\n        public string? ReminderType { get; set; } // e.g., \"Call\", \"Email\", \"Follow-up\", \"Meeting\"\n\n        public int? Priority { get; set; } // e.g., 1 (High), 2 (Medium), 3 (Low)\n\n        public bool IsRecurring { get; set; } = false; // For future ‚Üí repeat reminder\n\n        public string? RecurrencePattern { get; set; } // e.g., \"Weekly\", \"Monthly\" (optional)\n\n        public bool SendWhatsappNotification { get; set; } = false; // Future: auto-WA message trigger\n\n        public string? LinkedCampaign { get; set; } // Optional: which campaign this reminder relates to\n\n        public bool IsActive { get; set; } = true;  // Soft delete support\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public DateTime? CompletedAt { get; set; } // Track when it was marked Done\n\n        public string? LastCTAType { get; set; } // e.g., Confirm, Reschedule\n        public DateTime? LastClickedAt { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Tag.cs",
      "sha256": "387b3c7cd221661c2ced818b097b3a5cc250067db94531b997e4ed61f1e43e35",
      "language": "csharp",
      "size": 1117,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Tag\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }             // Multi-tenant isolation\n\n        public string Name { get; set; } = default!;     // e.g., \"VIP\", \"Follow-up\"\n\n        public string? ColorHex { get; set; }            // For UI tag styling (e.g., #FF5733)\n\n        public string? Category { get; set; }            // e.g., \"Priority\", \"Campaign\", \"Stage\"\n\n        public string? Notes { get; set; }               // Admin/internal notes about this tag\n\n        public bool IsSystemTag { get; set; } = false;   // Reserved tags like \"New\", \"Subscribed\"\n\n        public bool IsActive { get; set; } = true;       // For soft-deactivation (future bulk ops)\n\n        public DateTime CreatedAt { get; set; }          // For analytics / sorting\n\n        public DateTime? LastUsedAt { get; set; }        // Useful for CRM insights later\n\n        public ICollection<ContactTag> ContactTags { get; set; } = new List<ContactTag>(); // Linked contacts\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactProfileService.cs",
      "sha256": "080cb0423a22385c8529565389af54c7ef55d8ba2e5b4ffb05fe5345afc3e644",
      "language": "csharp",
      "size": 3349,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public sealed class ContactProfileService : IContactProfileService\n    {\n        private readonly AppDbContext _db;\n\n        public ContactProfileService(AppDbContext db) => _db = db;\n\n        public async Task UpsertProfileNameAsync(\n            Guid businessId,\n            string phoneE164,\n            string? profileName,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(phoneE164) || string.IsNullOrWhiteSpace(profileName))\n                return;\n\n            static string Digits(string s) => new string(s.Where(char.IsDigit).ToArray());\n            var phoneDigits = Digits(phoneE164);\n            var newName = profileName.Trim();\n            var now = DateTime.UtcNow;\n\n            // Try digits first; fall back to raw (handles legacy rows)\n            var contact = await _db.Contacts.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId &&\n                     (c.PhoneNumber == phoneDigits || c.PhoneNumber == phoneE164),\n                ct);\n\n            if (contact == null)\n            {\n                // Concurrency-safe create\n                try\n                {\n                    _db.Contacts.Add(new Contact\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        PhoneNumber = phoneDigits,          // canonical = digits-only\n                        Name = newName,                     // display fallback\n                        ProfileName = newName,              // WA profile name\n                        ProfileNameUpdatedAt = now,\n                        CreatedAt = now,\n                        LastContactedAt = now\n                    });\n                    await _db.SaveChangesAsync(ct);\n                    return;\n                }\n                catch (DbUpdateException)\n                {\n                    // Someone else created it ‚Äî refetch and continue as update\n                    contact = await _db.Contacts.FirstOrDefaultAsync(\n                        c => c.BusinessId == businessId && c.PhoneNumber == phoneDigits, ct);\n                    if (contact == null) return;\n                }\n            }\n\n            var anyChange = false;\n\n            if (!string.Equals(contact.ProfileName, newName, StringComparison.Ordinal))\n            {\n                contact.ProfileName = newName;\n                contact.ProfileNameUpdatedAt = now;\n                anyChange = true;\n            }\n\n            // Backfill Name if empty/placeholder/phone\n            if (string.IsNullOrWhiteSpace(contact.Name) ||\n                contact.Name == \"WhatsApp User\" ||\n                contact.Name == contact.PhoneNumber)\n            {\n                if (!string.Equals(contact.Name, newName, StringComparison.Ordinal))\n                {\n                    contact.Name = newName;\n                    anyChange = true;\n                }\n            }\n\n            if (anyChange)\n            {\n                contact.ProfileNameUpdatedAt = now;\n                await _db.SaveChangesAsync(ct);\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactService.cs",
      "sha256": "2c3488314b614bd3c4500ad7ffdb8a64eec31c213e87616fafe5f86f51e7acfd",
      "language": "csharp",
      "size": 36981,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing CsvHelper;\nusing CsvHelper.Configuration;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ContactService : IContactService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ContactService> _logger;\n\n        public ContactService(AppDbContext db, ILogger<ContactService> logger)\n        {\n            _db = db;\n            _logger = logger;\n        }\n\n        //public async Task<ContactDto> AddContactAsync(Guid businessId, ContactDto dto)\n        //{\n        //    _logger.LogInformation(\"AddContactAsync called for businessId={BusinessId}, Name={Name}\", businessId, dto.Name);\n\n        //    var contact = new Contact\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        BusinessId = businessId,\n        //        Name = dto.Name,\n        //        PhoneNumber = dto.PhoneNumber,\n        //        Email = dto.Email,\n        //        LeadSource = dto.LeadSource,\n        //        LastContactedAt = dto.LastContactedAt?.ToUniversalTime(),\n        //        NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime(),\n        //        Notes = dto.Notes,\n        //        CreatedAt = DateTime.UtcNow,\n        //        IsFavorite = dto.IsFavorite,\n        //        IsArchived = dto.IsArchived,\n        //        Group = dto.Group\n        //    };\n\n        //    if (dto.Tags != null && dto.Tags.Any())\n        //    {\n        //        contact.ContactTags = dto.Tags.Select(t => new ContactTag\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            ContactId = contact.Id,\n        //            TagId = t.TagId,\n        //            BusinessId = businessId,\n        //            AssignedAt = DateTime.UtcNow,\n        //            AssignedBy = \"system\"\n        //        }).ToList();\n        //    }\n\n        //    _db.Contacts.Add(contact);\n\n        //    try\n        //    {\n        //        await _db.SaveChangesAsync();\n        //        _logger.LogInformation(\"Contact added: {ContactId} for businessId={BusinessId}\", contact.Id, businessId);\n        //    }\n        //    catch (DbUpdateException ex)\n        //    {\n        //        _logger.LogError(ex, \"DB error in AddContactAsync (Contact: {Contact}, BusinessId={BusinessId})\", contact, businessId);\n        //        var innerMessage = ex.InnerException?.Message ?? ex.Message;\n        //        throw new Exception(\"‚ùå DB save error (Contact): \" + innerMessage, ex);\n        //    }\n\n        //    return new ContactDto\n        //    {\n        //        Id = contact.Id,\n        //        Name = contact.Name,\n        //        PhoneNumber = contact.PhoneNumber,\n        //        Email = contact.Email,\n        //        LeadSource = contact.LeadSource,\n        //        LastContactedAt = contact.LastContactedAt,\n        //        NextFollowUpAt = contact.NextFollowUpAt,\n        //        Notes = contact.Notes,\n        //        CreatedAt = contact.CreatedAt,\n        //        Tags = dto.Tags ?? new List<ContactTagDto>()\n        //    };\n        //}\n\n        //public async Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto)\n        //{\n        //    _logger.LogInformation(\"üì© AddContactAsync called for businessId={BusinessId}, Name={Name}\", businessId, dto.Name);\n\n        //    try\n        //    {\n        //        // 1. Duplicate check\n        //        if (!string.IsNullOrWhiteSpace(dto.PhoneNumber))\n        //        {\n        //            var existingContact = await _db.Contacts.FirstOrDefaultAsync(c =>\n        //                c.BusinessId == businessId && c.PhoneNumber == dto.PhoneNumber);\n\n        //            if (existingContact != null)\n        //            {\n        //                _logger.LogWarning(\"‚ö†Ô∏è Duplicate contact attempt for phone {Phone}\", dto.PhoneNumber);\n        //                return ResponseResult.ErrorInfo(\n        //                    $\"‚ùå A contact with the phone number '{dto.PhoneNumber}' already exists.\"\n        //                );\n        //            }\n        //        }\n\n        //        // 2. Build entity\n        //        var contact = new Contact\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = businessId,\n        //            Name = dto.Name,\n        //            PhoneNumber = dto.PhoneNumber,\n        //            Email = dto.Email,\n        //            LeadSource = dto.LeadSource,\n        //            LastContactedAt = dto.LastContactedAt?.ToUniversalTime(),\n        //            NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime(),\n        //            Notes = dto.Notes,\n        //            CreatedAt = DateTime.UtcNow,\n        //            IsFavorite = dto.IsFavorite,\n        //            IsArchived = dto.IsArchived,\n        //            Group = dto.Group\n        //        };\n\n        //        // 3. Tags mapping\n        //        if (dto.Tags != null && dto.Tags.Any())\n        //        {\n        //            contact.ContactTags = dto.Tags.Select(t => new ContactTag\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                ContactId = contact.Id,\n        //                TagId = t.TagId,\n        //                BusinessId = businessId,\n        //                AssignedAt = DateTime.UtcNow,\n        //                AssignedBy = \"system\"\n        //            }).ToList();\n        //        }\n\n        //        _db.Contacts.Add(contact);\n\n        //        // 4. Save\n        //        try\n        //        {\n        //            await _db.SaveChangesAsync();\n        //            _logger.LogInformation(\"‚úÖ Contact added successfully: {ContactId} (BusinessId={BusinessId})\", contact.Id, businessId);\n        //        }\n        //        catch (DbUpdateException ex)\n        //        {\n        //            _logger.LogError(ex, \"‚ùå DB error in AddContactAsync (BusinessId={BusinessId})\", businessId);\n        //            var innerMessage = ex.InnerException?.Message ?? ex.Message;\n        //            return ResponseResult.ErrorInfo(\"‚ùå Database save error (Contact): \" + innerMessage);\n        //        }\n\n        //        // 5. Map back to DTO\n        //        var resultDto = new ContactDto\n        //        {\n        //            Id = contact.Id,\n        //            Name = contact.Name,\n        //            PhoneNumber = contact.PhoneNumber,\n        //            Email = contact.Email,\n        //            LeadSource = contact.LeadSource,\n        //            LastContactedAt = contact.LastContactedAt,\n        //            NextFollowUpAt = contact.NextFollowUpAt,\n        //            Notes = contact.Notes,\n        //            CreatedAt = contact.CreatedAt,\n        //            IsFavorite = contact.IsFavorite,\n        //            IsArchived = contact.IsArchived,\n        //            Group = contact.Group,\n        //            Tags = dto.Tags ?? new List<ContactTagDto>()\n        //        };\n\n        //        return ResponseResult.SuccessInfo(\"‚úÖ Contact created successfully.\", resultDto);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"üö® Unexpected error in AddContactAsync (BusinessId={BusinessId})\", businessId);\n        //        return ResponseResult.ErrorInfo(\"üö® A server error occurred while creating the contact.\", ex.Message);\n        //    }\n        //}\n\n        public async Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto)\n        {\n            _logger.LogInformation(\"üì© AddContactAsync called for businessId={BusinessId}, Name={Name}\", businessId, dto.Name);\n\n            try\n            {\n                // 1. Normalize the phone number using your private method first.\n                var normalizedPhone = NormalizePhone(dto.PhoneNumber);\n\n                // 2. Validate the normalized number.\n                // Your NormalizePhone method returns an empty string for invalid numbers.\n                if (string.IsNullOrWhiteSpace(normalizedPhone))\n                {\n                    return ResponseResult.ErrorInfo(\"‚ùå Phone number is invalid. It must contain exactly 10 digits.\");\n                }\n\n                // 3. Use the clean, normalized number for the duplicate check.\n                var existingContact = await _db.Contacts.FirstOrDefaultAsync(c =>\n                    c.BusinessId == businessId && c.PhoneNumber == normalizedPhone);\n\n                if (existingContact != null)\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è Duplicate contact attempt for phone {Phone}\", dto.PhoneNumber);\n                    return ResponseResult.ErrorInfo(\n                        $\"‚ùå A contact with the phone number '{dto.PhoneNumber}' already exists.\"\n                    );\n                }\n\n                // 4. Build the new contact entity, SAVING the normalized number.\n                var contact = new Contact\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = dto.Name,\n                    PhoneNumber = normalizedPhone, // Save the standardized number\n                    Email = dto.Email,\n                    LeadSource = dto.LeadSource,\n                    LastContactedAt = dto.LastContactedAt?.ToUniversalTime(),\n                    NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime(),\n                    Notes = dto.Notes,\n                    CreatedAt = DateTime.UtcNow,\n                    IsFavorite = dto.IsFavorite,\n                    IsArchived = dto.IsArchived,\n                    Group = dto.Group\n                };\n\n                // Map tags if they are provided\n                if (dto.Tags != null && dto.Tags.Any())\n                {\n                    contact.ContactTags = dto.Tags.Select(t => new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        ContactId = contact.Id,\n                        TagId = t.TagId,\n                        BusinessId = businessId,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = \"system\"\n                    }).ToList();\n                }\n\n                _db.Contacts.Add(contact);\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"‚úÖ Contact added successfully: {ContactId}\", contact.Id);\n\n                // Map the created entity back to a DTO for the response\n                var resultDto = new ContactDto\n                {\n                    Id = contact.Id,\n                    Name = contact.Name,\n                    PhoneNumber = contact.PhoneNumber,\n                    Email = contact.Email,\n                    LeadSource = contact.LeadSource,\n                    CreatedAt = contact.CreatedAt,\n                    Tags = contact.ContactTags?.Select(ct => new ContactTagDto { TagId = ct.TagId }).ToList() ?? new List<ContactTagDto>()\n                };\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Contact created successfully.\", resultDto);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"üö® Unexpected error in AddContactAsync for business {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"üö® A server error occurred while creating the contact.\", ex.Message);\n            }\n        }\n        public async Task<ContactDto> GetContactByIdAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"GetContactByIdAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n            try\n            {\n                var contact = await _db.Contacts\n                     .Where(c => c.BusinessId == businessId && c.Id == contactId && c.IsActive)\n                    .Include(c => c.ContactTags)\n                        .ThenInclude(ct => ct.Tag)\n                    .FirstOrDefaultAsync();\n\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                    return null;\n                }\n\n                return new ContactDto\n                {\n                    Id = contact.Id,\n                    Name = contact.Name,\n                    PhoneNumber = contact.PhoneNumber,\n                    Email = contact.Email,\n                    LeadSource = contact.LeadSource,\n                    LastContactedAt = contact.LastContactedAt,\n                    NextFollowUpAt = contact.NextFollowUpAt,\n                    Notes = contact.Notes,\n                    CreatedAt = contact.CreatedAt,\n                    Tags = contact.ContactTags?\n                        .Where(ct => ct.Tag != null)\n                        .Select(ct => new ContactTagDto\n                        {\n                            TagId = ct.TagId,\n                            TagName = ct.Tag.Name\n                        })\n                        .ToList() ?? new List<ContactTagDto>()\n                };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching contact by id: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                throw;\n            }\n        }\n\n        public async Task<bool> UpdateContactAsync(Guid businessId, ContactDto dto)\n        {\n            _logger.LogInformation(\"UpdateContactAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, dto.Id);\n            try\n            {\n                var contact = await _db.Contacts\n                    .Include(c => c.ContactTags)\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == dto.Id);\n\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found for update: businessId={BusinessId}, contactId={ContactId}\", businessId, dto.Id);\n                    return false;\n                }\n\n                contact.Name = dto.Name;\n                contact.PhoneNumber = dto.PhoneNumber;\n                contact.Email = dto.Email;\n                contact.LeadSource = dto.LeadSource;\n                contact.LastContactedAt = dto.LastContactedAt?.ToUniversalTime();\n                contact.NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime();\n                contact.Notes = dto.Notes;\n\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact updated: {ContactId}\", contact.Id);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating contact: businessId={BusinessId}, contactId={ContactId}\", businessId, dto.Id);\n                throw;\n            }\n        }\n\n        public async Task<bool> DeleteContactAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"DeleteContactAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n            try\n            {\n                var contact = await _db.Contacts\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId && c.IsActive);\n\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found for delete: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                    return false;\n                }\n\n                contact.IsActive = false; // üëà Soft delete\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact soft-deleted: {ContactId}\", contactId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting contact: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                throw;\n            }\n        }\n\n\n        public async Task<CsvImportResult<ContactDto>> ParseCsvToContactsAsync(Guid businessId, Stream csvStream)\n        {\n            _logger.LogInformation(\"ParseCsvToContactsAsync: businessId={BusinessId}\", businessId);\n\n            var result = new CsvImportResult<ContactDto>();\n\n            var config = new CsvConfiguration(CultureInfo.InvariantCulture)\n            {\n                HeaderValidated = null,\n                MissingFieldFound = null\n            };\n\n            using var reader = new StreamReader(csvStream);\n            using var csv = new CsvReader(reader, config);\n\n            // Register custom column mapping for ContactDto\n            csv.Context.RegisterClassMap<ContactDtoCsvMap>();\n\n            int rowNumber = 1;\n\n            await csv.ReadAsync();     // Move to first row\n            csv.ReadHeader();          // Read header row\n\n            while (await csv.ReadAsync())\n            {\n                rowNumber++;\n                try\n                {\n                    var record = csv.GetRecord<ContactDto>();\n                    record.CreatedAt = DateTime.UtcNow;\n\n                    result.SuccessRecords.Add(record);\n                }\n                catch (Exception ex)\n                {\n                    // Avoid ambiguity by using explicit object instantiation\n                    var error = new CsvImportError\n                    {\n                        RowNumber = rowNumber,\n                        ErrorMessage = ex.Message\n                    };\n                    result.Errors.Add(error);\n                }\n            }\n\n            _logger.LogInformation(\"CSV parsed with {SuccessCount} successes and {ErrorCount} errors.\",\n                result.SuccessRecords.Count, result.Errors.Count);\n\n            return result;\n        }\n\n        //private string NormalizePhone(string phoneNumber)\n        //{\n        //    if (string.IsNullOrWhiteSpace(phoneNumber))\n        //        return phoneNumber;\n\n        //    var digits = new string(phoneNumber.Where(char.IsDigit).ToArray());\n\n        //    // If it starts with \"91\" and length = 12 ‚Üí add +\n        //    if (digits.StartsWith(\"91\") && digits.Length == 12)\n        //        return \"+\" + digits;\n\n        //    // If it starts with \"91\" and length = 10 (missing country code) ‚Üí add +91\n        //    if (digits.Length == 10)\n        //        return \"+91\" + digits;\n\n        //    // If it already includes country code with + (13 digits for India)\n        //    if (digits.StartsWith(\"91\") && digits.Length == 12)\n        //        return \"+\" + digits;\n\n        //    // Fallback ‚Üí return with +\n        //    if (!digits.StartsWith(\"+\"))\n        //        return \"+\" + digits;\n\n        //    return digits;\n        //}\n\n        private string NormalizePhone(string phoneNumber)\n        {\n            // 1. Handle empty or null input\n            if (string.IsNullOrWhiteSpace(phoneNumber))\n            {\n                return string.Empty;\n            }\n\n            // 2. Extract only the numeric digits from the string\n            var digits = new string(phoneNumber.Where(char.IsDigit).ToArray());\n\n            // 3. If the number starts with India's country code (91) and is 12 digits long,\n            //    strip the country code to get the core 10-digit number.\n            if (digits.StartsWith(\"91\") && digits.Length == 12)\n            {\n                digits = digits.Substring(2);\n            }\n\n            // 4. NEW: Strictly validate that the result is 10 digits long.\n            if (digits.Length != 10)\n            {\n                // If the number of digits is not exactly 10, it's invalid.\n                // Return an empty string to signal that it could not be normalized.\n                return string.Empty;\n            }\n\n            // 5. If the number is a valid 10 digits, return it in the standard +91 format.\n            return \"+91\" + digits;\n        }\n        public async Task<Contact> FindOrCreateAsync(Guid businessId, string phoneNumber)\n        {\n            var normalized = NormalizePhone(phoneNumber);\n            _logger.LogInformation(\"FindOrCreateAsync: businessId={BusinessId}, rawPhone={PhoneNumber}, normalized={Normalized}\",\n                businessId, phoneNumber, normalized);\n\n            try\n            {\n                var contact = await _db.Contacts\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == normalized);\n\n                if (contact != null)\n                {\n                    _logger.LogInformation(\"Contact already exists: contactId={ContactId}\", contact.Id);\n                    return contact;\n                }\n\n                var newContact = new Contact\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = \"WhatsApp User\",\n                    PhoneNumber = normalized,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _db.Contacts.Add(newContact);\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact created: {ContactId}\", newContact.Id);\n\n                return newContact;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error in FindOrCreateAsync: businessId={BusinessId}, phoneNumber={PhoneNumber}\", businessId, phoneNumber);\n                throw;\n            }\n        }\n\n        public async Task<bool> ToggleFavoriteAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"ToggleFavoriteAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n            try\n            {\n                var contact = await _db.Contacts.FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId);\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found for favorite toggle: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                    return false;\n                }\n\n                contact.IsFavorite = !contact.IsFavorite;\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact favorite toggled: {ContactId} -> {IsFavorite}\", contactId, contact.IsFavorite);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error toggling favorite: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                throw;\n            }\n        }\n\n        public async Task AssignTagToContactsAsync(Guid businessId, List<Guid> contactIds, Guid tagId)\n        {\n            _logger.LogInformation(\"AssignTagToContactsAsync: businessId={BusinessId}, tagId={TagId}, contactIds={ContactIds}\", businessId, tagId, contactIds);\n            try\n            {\n                var contacts = await _db.Contacts\n                    .Where(c => c.BusinessId == businessId && contactIds.Contains(c.Id))\n                    .Include(c => c.ContactTags)\n                    .ToListAsync();\n\n                foreach (var contact in contacts)\n                {\n                    bool alreadyAssigned = contact.ContactTags.Any(link => link.TagId == tagId);\n                    if (!alreadyAssigned)\n                    {\n                        contact.ContactTags.Add(new ContactTag\n                        {\n                            ContactId = contact.Id,\n                            TagId = tagId\n                        });\n                    }\n                }\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Tags assigned to contacts\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error assigning tag: businessId={BusinessId}, tagId={TagId}\", businessId, tagId);\n                throw;\n            }\n        }\n\n        public async Task<bool> ToggleArchiveAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"ToggleArchiveAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n            try\n            {\n                var contact = await _db.Contacts.FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId);\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found for archive toggle: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                    return false;\n                }\n\n                contact.IsArchived = !contact.IsArchived;\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact archive toggled: {ContactId} -> {IsArchived}\", contactId, contact.IsArchived);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error toggling archive: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                throw;\n            }\n        }\n\n        public async Task<IEnumerable<ContactDto>> GetAllContactsAsync(Guid businessId, string? tab = \"all\")\n        {\n            _logger.LogInformation(\"GetAllContactsAsync: businessId={BusinessId}, tab={Tab}\", businessId, tab);\n            try\n            {\n                var baseQuery = _db.Contacts\n                    .Where(c => c.BusinessId == businessId && c.IsActive);\n\n                if (tab == \"favourites\")\n                    baseQuery = baseQuery.Where(c => c.IsFavorite);\n                else if (tab == \"archived\")\n                    baseQuery = baseQuery.Where(c => c.IsArchived);\n                else if (tab == \"groups\")\n                    baseQuery = baseQuery.Where(c => !string.IsNullOrEmpty(c.Group));\n\n                var query = baseQuery\n                    .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag);\n\n                var contacts = await query.ToListAsync();\n\n                var result = contacts.Select(c => new ContactDto\n                {\n                    Id = c.Id,\n                    Name = c.Name,\n                    PhoneNumber = c.PhoneNumber,\n                    Email = c.Email,\n                    LeadSource = c.LeadSource,\n                    LastContactedAt = c.LastContactedAt,\n                    NextFollowUpAt = c.NextFollowUpAt,\n                    Notes = c.Notes,\n                    CreatedAt = c.CreatedAt,\n                    IsFavorite = c.IsFavorite,\n                    IsArchived = c.IsArchived,\n                    Group = c.Group,\n                    Tags = c.ContactTags?\n                        .Where(ct => ct.Tag != null)\n                        .Select(ct => new ContactTagDto\n                        {\n                            TagId = ct.TagId,\n                            TagName = ct.Tag.Name,\n                            ColorHex = ct.Tag.ColorHex,\n                            Category = ct.Tag.Category\n                        })\n                        .ToList() ?? new List<ContactTagDto>()\n                });\n\n                _logger.LogInformation(\"GetAllContactsAsync returned {Count} contacts\", contacts.Count);\n                return result;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error in GetAllContactsAsync: businessId={BusinessId}\", businessId);\n                throw;\n            }\n        }\n        public async Task<PagedResult<ContactDto>> GetPagedContactsAsync(Guid businessId, string? tab, int page, int pageSize, string? searchTerm)\n        {\n            _logger.LogInformation(\"GetPagedContactsAsync: businessId={BusinessId}, tab={Tab}, page={Page}, pageSize={PageSize}\",\n                businessId, tab, page, pageSize);\n\n            if (page < 1) page = 1;\n            if (pageSize < 1) pageSize = 25;\n            if (pageSize > 100) pageSize = 100; // max limit\n\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.IsActive);\n\n            if (tab == \"favourites\")\n                baseQuery = baseQuery.Where(c => c.IsFavorite);\n            else if (tab == \"archived\")\n                baseQuery = baseQuery.Where(c => c.IsArchived);\n            else if (tab == \"groups\")\n                baseQuery = baseQuery.Where(c => !string.IsNullOrEmpty(c.Group));\n\n            var totalCount = await baseQuery.CountAsync();\n\n            var contacts = await baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .OrderBy(c => c.Name) // or any order preferred\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .ToListAsync();\n\n            var items = contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Email = c.Email,\n                LeadSource = c.LeadSource,\n                LastContactedAt = c.LastContactedAt,\n                NextFollowUpAt = c.NextFollowUpAt,\n                Notes = c.Notes,\n                CreatedAt = c.CreatedAt,\n                IsFavorite = c.IsFavorite,\n                IsArchived = c.IsArchived,\n                Group = c.Group,\n                Tags = c.ContactTags?\n                    .Where(ct => ct.Tag != null)\n                    .Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.TagId,\n                        TagName = ct.Tag.Name,\n                        ColorHex = ct.Tag.ColorHex,\n                        Category = ct.Tag.Category\n                    })\n                    .ToList() ?? new List<ContactTagDto>()\n            }).ToList();\n\n            return new PagedResult<ContactDto>\n            {\n                Items = items,\n                TotalCount = totalCount\n            };\n        }\n\n        public async Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<string> tags)\n        {\n            var contacts = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && !c.IsArchived)\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .Where(c => c.ContactTags.Any(ct => tags.Contains(ct.Tag.Name))) // üîç Filter by tag names\n                .OrderBy(c => c.Name)\n                .Select(c => new ContactDto\n                {\n                    Id = c.Id,\n                    Name = c.Name,\n                    PhoneNumber = c.PhoneNumber,\n                    Email = c.Email,\n                    Notes = c.Notes,\n                    Tags = c.ContactTags.Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.Tag.Id,\n                        TagName = ct.Tag.Name,\n                        ColorHex = ct.Tag.ColorHex,\n                        Category = ct.Tag.Category\n                    }).ToList()\n                })\n                .ToListAsync();\n\n            return contacts;\n        }\n        public async Task<BulkImportResultDto> BulkImportAsync(Guid businessId, Stream csvStream)\n        {\n            _logger.LogInformation(\"Bulk import started for businessId={BusinessId}\", businessId);\n\n            var result = new BulkImportResultDto();\n            var config = new CsvConfiguration(CultureInfo.InvariantCulture)\n            {\n                HeaderValidated = null,\n                MissingFieldFound = null\n            };\n\n            using var reader = new StreamReader(csvStream);\n            using var csv = new CsvReader(reader, config);\n            csv.Context.RegisterClassMap<ContactDtoCsvMap>();\n\n            await csv.ReadAsync();\n            csv.ReadHeader();\n\n            var contactsToAdd = new List<Contact>();\n            int row = 1;\n\n            while (await csv.ReadAsync())\n            {\n                row++;\n                try\n                {\n                    var dto = csv.GetRecord<ContactDto>();\n                    if (string.IsNullOrWhiteSpace(dto.PhoneNumber)) continue;\n\n                    var contact = new Contact\n                    {\n                        Id = Guid.NewGuid(),\n                        Name = dto.Name?.Trim() ?? \"Unnamed\",\n                        PhoneNumber = dto.PhoneNumber.Trim(),\n                        Email = dto.Email?.Trim(),\n                        Notes = dto.Notes,\n                        BusinessId = businessId,\n                        CreatedAt = DateTime.UtcNow\n                    };\n\n                    contactsToAdd.Add(contact);\n                    result.Imported++;\n                }\n                catch (Exception ex)\n                {\n                    result.Errors.Add(new CsvImportError\n                    {\n                        RowNumber = row,\n                        ErrorMessage = ex.Message\n                    });\n                }\n            }\n\n            await _db.Contacts.AddRangeAsync(contactsToAdd);\n            await _db.SaveChangesAsync();\n\n            _logger.LogInformation(\"Bulk import completed: {Imported} contacts, {Errors} errors\",\n                result.Imported, result.Errors.Count);\n\n            return result;\n        }\n        public async Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<Guid> tagIds)\n        {\n            // Step 1: Prepare base query (without Include yet)\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && !c.IsArchived);\n\n            // Step 2: Apply tag filter only if tagIds are provided\n            if (tagIds?.Any() == true)\n            {\n                baseQuery = baseQuery.Where(c =>\n                    c.ContactTags.Any(ct =>\n                        tagIds.Contains(ct.TagId)\n                    )\n                );\n            }\n\n            // Step 3: Add Includes after filtering to avoid cast issue\n            var queryWithIncludes = baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag);\n\n            // Step 4: Fetch data\n            var contacts = await queryWithIncludes.ToListAsync();\n\n            // Step 5: Project to DTO\n            return contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Tags = c.ContactTags.Select(ct => new ContactTagDto\n                {\n                    TagId = ct.Tag.Id,\n                    TagName = ct.Tag.Name,\n                    ColorHex = ct.Tag.ColorHex,\n                    Category = ct.Tag.Category\n                }).ToList()\n            });\n        }\n        public async Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tags)\n        {\n            if (tags == null || tags.Count == 0)\n                return false;\n\n            // üß† Step 1: Find the contact by phone\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phoneNumber && !c.IsArchived);\n\n            if (contact == null)\n                return false;\n\n            foreach (var tagName in tags)\n            {\n                if (string.IsNullOrWhiteSpace(tagName))\n                    continue;\n\n                // ‚úÖ Step 2: Find or create the tag (by name)\n                var tag = await _db.Tags\n                    .FirstOrDefaultAsync(t => t.BusinessId == businessId && t.Name == tagName && t.IsActive);\n\n                if (tag == null)\n                {\n                    tag = new Tag\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        Name = tagName,\n                        ColorHex = \"#8c8c8c\", // default gray if not assigned\n                        IsActive = true,\n                        CreatedAt = DateTime.UtcNow\n                    };\n                    _db.Tags.Add(tag);\n                }\n\n                // üß™ Step 3: Check if contact already has this tag\n                var alreadyTagged = await _db.ContactTags.AnyAsync(ct =>\n                    ct.ContactId == contact.Id && ct.TagId == tag.Id);\n\n                if (!alreadyTagged)\n                {\n                    _db.ContactTags.Add(new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        ContactId = contact.Id,\n                        TagId = tag.Id\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/IContactProfileService.cs",
      "sha256": "2238c717846876f685aeb1424a5812b4673fd589105f31cdfbe116672d1cfd61",
      "language": "csharp",
      "size": 492,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public interface IContactProfileService\n    {\n        /// <summary>\n        /// Update contact's ProfileName if changed. Lookup by (BusinessId, E.164 phone).\n        /// No-op if contact not found or name is empty.\n        /// </summary>\n        Task UpsertProfileNameAsync(Guid businessId, string phoneE164, string? profileName, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/NoteService.cs",
      "sha256": "1a01e1930780a7e13d5e36302be3472e247d730a0224537fc195291d0de6f3ed",
      "language": "csharp",
      "size": 4460,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Mappers;\nusing xbytechat.api.Features.CRM.Timelines.Services;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class NoteService : INoteService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService; // ‚úÖ Injected Timeline Service\n\n        // ‚úÖ Constructor: Inject AppDbContext + TimelineService\n        public NoteService(AppDbContext db, ITimelineService timelineService)\n        {\n            _db = db;\n            _timelineService = timelineService;\n        }\n\n        // üìù Add a new Note + Log into LeadTimeline\n        public async Task<NoteDto> AddNoteAsync(Guid businessId, NoteDto dto)\n        {\n            // 1Ô∏è‚É£ Map incoming DTO to Note entity\n            var note = NoteMapper.MapToEntity(dto, businessId);\n\n            // 2Ô∏è‚É£ Save the Note into database\n            _db.Notes.Add(note);\n            await _db.SaveChangesAsync();\n\n            // 3Ô∏è‚É£ Log this Note creation into LeadTimeline (only if ContactId is present)\n            if (dto.ContactId.HasValue)\n            {\n                try\n                {\n                    await _timelineService.LogNoteAddedAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = dto.ContactId.Value,       // ‚ûî Which contact the note is related to\n                        BusinessId = businessId,               // ‚ûî Which business created this\n                        EventType = \"NoteAdded\",                // ‚ûî Timeline event type\n                        Description = $\"üìù Note added: {dto.Title ?? \"(Untitled)\"}\", // ‚ûî Friendly description\n                        ReferenceId = note.Id,                  // ‚ûî Link back to Note Id\n                        CreatedBy = dto.CreatedBy,              // ‚ûî Who created it\n                        Timestamp = DateTime.UtcNow             // ‚ûî When created\n                    });\n                }\n                catch (Exception ex)\n                {\n                    // üõ° Timeline saving failure should not break note creation\n                    Console.WriteLine($\"‚ö†Ô∏è Timeline log failed for NoteId {note.Id}: {ex.Message}\");\n                }\n            }\n\n            // 4Ô∏è‚É£ Return the saved note as DTO\n            return NoteMapper.MapToDto(note);\n        }\n\n        // üìã List all Notes by Contact\n        public async Task<IEnumerable<NoteDto>> GetNotesByContactAsync(Guid businessId, Guid contactId)\n        {\n            return await _db.Notes\n                .AsNoTracking()\n                .Where(n => n.BusinessId == businessId && n.ContactId == contactId)\n                .OrderByDescending(n => n.CreatedAt)\n                .Select(n => NoteMapper.MapToDto(n))\n                .ToListAsync();\n        }\n\n        // üìã Get a single Note by Id\n        public async Task<NoteDto?> GetNoteByIdAsync(Guid businessId, Guid noteId)\n        {\n            var note = await _db.Notes\n                .AsNoTracking()\n                .FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n\n            return note == null ? null : NoteMapper.MapToDto(note);\n        }\n\n        // ‚úèÔ∏è Update an existing Note\n        public async Task<bool> UpdateNoteAsync(Guid businessId, Guid noteId, NoteDto dto)\n        {\n            var note = await _db.Notes.FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n            if (note == null) return false;\n\n            note.Title = dto.Title;\n            note.Content = dto.Content;\n            note.IsPinned = dto.IsPinned;\n            note.IsInternal = dto.IsInternal;\n            note.EditedAt = DateTime.SpecifyKind(DateTime.UtcNow, DateTimeKind.Utc); // Always UTC timestamp\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // üóëÔ∏è Soft delete (actually remove) a Note\n        public async Task<bool> DeleteNoteAsync(Guid businessId, Guid noteId)\n        {\n            var note = await _db.Notes.FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n            if (note == null) return false;\n\n            _db.Notes.Remove(note);\n            await _db.SaveChangesAsync();\n            return true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ReminderService.cs",
      "sha256": "a5618517be86901337fa64637ecc7f8e0fc365fa99a2d58e8304c544f0e72451",
      "language": "csharp",
      "size": 5949,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Mappers;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ReminderService : IReminderService\n    {\n        private readonly AppDbContext _db;\n\n        public ReminderService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        //public async Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto)\n        //{\n        //    var reminder = new Reminder\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        BusinessId = businessId,\n        //        //ContactId = dto.ContactId,\n        //        Title = dto.Title,\n        //        Description = dto.Description,\n        //        DueAt = dto.DueAt,\n        //        Status = dto.Status ?? \"Pending\",\n        //        ReminderType = dto.ReminderType,\n        //        Priority = dto.Priority,\n        //        IsRecurring = dto.IsRecurring,\n        //        RecurrencePattern = dto.RecurrencePattern,\n        //        SendWhatsappNotification = dto.SendWhatsappNotification,\n        //        LinkedCampaign = dto.LinkedCampaign,\n        //        CreatedAt = DateTime.UtcNow,\n        //        IsActive = true\n        //    };\n\n        //    _db.Reminders.Add(reminder);\n        //    await _db.SaveChangesAsync();\n\n        //    return MapToDto(reminder);\n        //}\n        public async Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto)\n        {\n            try\n            {\n                var reminder = new Reminder\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = dto.ContactId ?? Guid.Empty, // add default fallback\n                    Title = dto.Title,\n                    Description = dto.Description,\n                    DueAt = DateTime.SpecifyKind(dto.DueAt, DateTimeKind.Utc),\n                    Status = dto.Status ?? \"Pending\",\n                    ReminderType = dto.ReminderType,\n                    Priority = dto.Priority,\n                    IsRecurring = dto.IsRecurring,\n                    RecurrencePattern = dto.RecurrencePattern,\n                    SendWhatsappNotification = dto.SendWhatsappNotification,\n                    LinkedCampaign = dto.LinkedCampaign,\n                    CreatedAt = DateTime.SpecifyKind(dto.DueAt, DateTimeKind.Utc),\n                    IsActive = true\n                };\n\n                _db.Reminders.Add(reminder);\n                await _db.SaveChangesAsync();\n\n                return MapToDto(reminder);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Error in AddReminderAsync: \" + ex.Message);\n                throw;\n            }\n        }\n\n        public async Task<IEnumerable<ReminderDto>> GetAllRemindersAsync(Guid businessId)\n        {\n            return await _db.Reminders\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.IsActive)\n                .OrderBy(r => r.DueAt)\n                .Select(r => ReminderMapper.MapToDto(r))\n                .ToListAsync();\n        }\n\n\n        public async Task<ReminderDto?> GetReminderByIdAsync(Guid businessId, Guid reminderId)\n        {\n            var reminder = await _db.Reminders\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n\n            return reminder == null ? null : MapToDto(reminder);\n        }\n\n        public async Task<bool> UpdateReminderAsync(Guid businessId, Guid reminderId, ReminderDto dto)\n        {\n            var reminder = await _db.Reminders.FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n            if (reminder == null) return false;\n\n            reminder.Title = dto.Title;\n            reminder.Description = dto.Description;\n            reminder.DueAt = DateTime.SpecifyKind(dto.DueAt, DateTimeKind.Utc);\n            reminder.Status = dto.Status ?? reminder.Status;\n            reminder.ReminderType = dto.ReminderType;\n            reminder.Priority = dto.Priority;\n            reminder.IsRecurring = dto.IsRecurring;\n            reminder.RecurrencePattern = dto.RecurrencePattern;\n            reminder.SendWhatsappNotification = dto.SendWhatsappNotification;\n            reminder.LinkedCampaign = dto.LinkedCampaign;\n            reminder.UpdatedAt = DateTime.UtcNow;\n\n            if (dto.Status?.ToLower() == \"done\")\n                reminder.CompletedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> DeleteReminderAsync(Guid businessId, Guid reminderId)\n        {\n            var reminder = await _db.Reminders.FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n            if (reminder == null) return false;\n\n            reminder.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        private ReminderDto MapToDto(Reminder r)\n        {\n            return new ReminderDto\n            {\n                Id = r.Id,\n                ContactId = r.ContactId,\n                Title = r.Title,\n                Description = r.Description,\n                DueAt = r.DueAt,\n                Status = r.Status,\n                ReminderType = r.ReminderType,\n                Priority = r.Priority,\n                IsRecurring = r.IsRecurring,\n                RecurrencePattern = r.RecurrencePattern,\n                SendWhatsappNotification = r.SendWhatsappNotification,\n                LinkedCampaign = r.LinkedCampaign,\n                CreatedAt = r.CreatedAt,\n                UpdatedAt = r.UpdatedAt,\n                CompletedAt = r.CompletedAt,\n                IsActive = r.IsActive\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/TagService.cs",
      "sha256": "e5d685392f0ff2c71b90f89621b099c06623f9f07a79907ee7c67fdb58b967d6",
      "language": "csharp",
      "size": 8716,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Timelines.Services;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class TagService : ITagService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService; // ‚úÖ Injected TimelineService\n        private readonly ILogger<TagService> _logger;\n        public TagService(AppDbContext db, ITimelineService timelineService, ILogger<TagService> logger)\n        {\n            _db = db;\n            _timelineService = timelineService;\n            _logger = logger;\n        }\n\n        public async Task<TagDto> AddTagAsync(Guid businessId, TagDto dto)\n        {\n            var tag = new Tag\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Name = dto.Name,\n                ColorHex = dto.ColorHex,\n                Category = dto.Category,\n                Notes = dto.Notes,\n                IsSystemTag = dto.IsSystemTag,\n                IsActive = dto.IsActive,\n                CreatedAt = DateTime.UtcNow,\n                LastUsedAt = null\n            };\n\n            _db.Tags.Add(tag);\n            await _db.SaveChangesAsync();\n\n            // ‚úÖ After saving tag ‚Üí try logging into Timeline (non-blocking)\n            try\n            {\n                await _timelineService.LogTagAppliedAsync(new CRMTimelineLogDto\n                {\n                    ContactId = Guid.Empty,    // ‚û°Ô∏è No specific contact, general event\n                    BusinessId = businessId,\n                    EventType = \"TagCreated\",\n                    Description = $\"üè∑Ô∏è New tag created: {dto.Name}\",\n                    ReferenceId = tag.Id,\n                    CreatedBy = \"System\",\n                    Timestamp = DateTime.UtcNow,\n                    Category = \"CRM\"\n                });\n            }\n            catch (Exception ex)\n            {\n                // üõ° Fail-safe: Do not block tag creation if timeline fails\n                Console.WriteLine($\"‚ö†Ô∏è Timeline log failed for TagId {tag.Id}: {ex.Message}\");\n            }\n\n            return new TagDto\n            {\n                Id = tag.Id,\n                Name = tag.Name,\n                ColorHex = tag.ColorHex,\n                Category = tag.Category,\n                Notes = tag.Notes,\n                IsSystemTag = tag.IsSystemTag,\n                IsActive = tag.IsActive,\n                CreatedAt = tag.CreatedAt,\n                LastUsedAt = tag.LastUsedAt\n            };\n        }\n\n        public async Task<IEnumerable<TagDto>> GetAllTagsAsync(Guid businessId)\n        {\n            return await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive)\n                .OrderByDescending(t => t.CreatedAt)\n                .Select(t => new TagDto\n                {\n                    Id = t.Id,\n                    Name = t.Name,\n                    ColorHex = t.ColorHex,\n                    Category = t.Category,\n                    Notes = t.Notes,\n                    IsSystemTag = t.IsSystemTag,\n                    IsActive = t.IsActive,\n                    CreatedAt = t.CreatedAt,\n                    LastUsedAt = t.LastUsedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<bool> UpdateTagAsync(Guid businessId, Guid tagId, TagDto dto)\n        {\n            var tag = await _db.Tags.FirstOrDefaultAsync(t => t.Id == tagId && t.BusinessId == businessId);\n            if (tag == null) return false;\n\n            tag.Name = dto.Name;\n            tag.ColorHex = dto.ColorHex;\n            tag.Category = dto.Category;\n            tag.Notes = dto.Notes;\n            tag.IsSystemTag = dto.IsSystemTag;\n            tag.IsActive = dto.IsActive;\n            tag.LastUsedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> DeleteTagAsync(Guid businessId, Guid tagId)\n        {\n            var tag = await _db.Tags.FirstOrDefaultAsync(t => t.Id == tagId && t.BusinessId == businessId);\n            if (tag == null) return false;\n\n            tag.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n        //public async Task AssignTagAsync(Guid businessId, string phone, string tag)\n        //{\n        //    try\n        //    {\n        //        // ‚úÖ Step 1: Lookup contact\n        //        var contact = await _db.Contacts\n        //            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phone);\n\n        //        if (contact == null)\n        //        {\n        //            _logger.LogWarning(\"‚ö†Ô∏è Contact not found for phone: {Phone}\", phone);\n        //            return;\n        //        }\n\n        //        // ‚úÖ Step 2: Check if tag exists\n        //        var existingTag = await _db.Tags\n        //            .FirstOrDefaultAsync(t => t.BusinessId == businessId && t.Name == tag);\n\n        //        if (existingTag == null)\n        //        {\n        //            existingTag = new Tag\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = businessId,\n        //                Name = tag,\n        //                CreatedAt = DateTime.UtcNow\n        //            };\n\n        //            await _db.Tags.AddAsync(existingTag);\n        //        }\n\n        //        // ‚úÖ Step 3: Associate tag with contact if not already\n        //        var alreadyTagged = await _db.ContactTags\n        //            .AnyAsync(ct => ct.ContactId == contact.Id && ct.TagId == existingTag.Id);\n\n        //        if (!alreadyTagged)\n        //        {\n        //            await _db.ContactTags.AddAsync(new ContactTag\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                ContactId = contact.Id,\n        //                TagId = existingTag.Id,\n        //                AssignedAt = DateTime.UtcNow\n        //            });\n\n        //            _logger.LogInformation(\"üè∑ Tag '{Tag}' assigned to contact {ContactId}\", tag, contact.Id);\n        //        }\n\n        //        await _db.SaveChangesAsync();\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"‚ùå Error assigning tag to contact.\");\n        //        throw;\n        //    }\n        //}\n        public async Task AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tagNames)\n        {\n            if (tagNames == null || !tagNames.Any())\n                return;\n\n            // üîç Fetch the contact and existing tag links\n            var contact = await _db.Contacts\n             .Include(c => c.ContactTags)\n             .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phoneNumber);\n\n\n            if (contact == null) return;\n\n            var existingTagIds = contact.ContactTags.Select(t => t.TagId).ToHashSet();\n\n            // üîç Ensure tags exist or create them\n            var tags = await _db.Tags\n                .Where(t => t.BusinessId == businessId && tagNames.Contains(t.Name))\n                .ToListAsync();\n\n            var existingNames = tags.Select(t => t.Name).ToHashSet(StringComparer.OrdinalIgnoreCase);\n            var missingNames = tagNames.Where(t => !existingNames.Contains(t)).Distinct().ToList();\n\n            foreach (var name in missingNames)\n            {\n                var newTag = new Tag\n                {\n                    Id = Guid.NewGuid(),\n                    Name = name,\n                    BusinessId = businessId,\n                    CreatedAt = DateTime.UtcNow\n                };\n                _db.Tags.Add(newTag);\n                tags.Add(newTag);\n            }\n\n            await _db.SaveChangesAsync(); // Save new tags before linking\n\n            // ‚úÖ Link new tags to contact\n            foreach (var tag in tags)\n            {\n                if (!existingTagIds.Contains(tag.Id))\n                {\n                    contact.ContactTags.Add(new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        TagId = tag.Id,\n                        ContactId = contact.Id,\n                        BusinessId = businessId,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = \"automation\" // optional: set to flow name\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Summary/Controllers/CrmSummaryController.cs",
      "sha256": "d45879a7c0b131ba0bc44d157fee084c9cd8f431793fd32fe5a957582d8e1e43",
      "language": "csharp",
      "size": 2810,
      "content": "// üìÑ xbytechat-api/Features/CRM/Summary/Controllers/CrmSummaryController.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Summary.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Summary.Controllers\n{\n    /// <summary>\n    /// Thin API surface for CRM summary endpoints used by Chat Inbox\n    /// and future dashboards.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm-summary\")]\n    public sealed class CrmSummaryController : ControllerBase\n    {\n        private readonly IContactSummaryService _contactSummaryService;\n        private readonly ILogger<CrmSummaryController> _logger;\n\n        public CrmSummaryController(\n            IContactSummaryService contactSummaryService,\n            ILogger<CrmSummaryController> logger)\n        {\n            _contactSummaryService = contactSummaryService ?? throw new ArgumentNullException(nameof(contactSummaryService));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        /// <summary>\n        /// Returns a compact CRM snapshot for a given contact:\n        /// Contact core fields, tags, recent notes, next reminder, recent timeline entries.\n        /// </summary>\n        [HttpGet(\"contact-summary/{contactId:guid}\")]\n        public async Task<IActionResult> GetContactSummary(Guid contactId, CancellationToken ct)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            if (businessId == Guid.Empty)\n            {\n                return Unauthorized(ResponseResult.ErrorInfo(\"Missing BusinessId in user claims.\"));\n            }\n\n            try\n            {\n                var summary = await _contactSummaryService.GetContactSummaryAsync(businessId, contactId, ct);\n                if (summary == null)\n                {\n                    return NotFound(ResponseResult.ErrorInfo(\"Contact not found for this business.\"));\n                }\n\n                return Ok(ResponseResult.SuccessInfo(\"Contact summary loaded.\", summary));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"‚ùå Failed to load contact summary. Business={BusinessId}, Contact={ContactId}\",\n                    businessId,\n                    contactId);\n\n                // You already have global error handling, but we still wrap with ResponseResult for consistency.\n                return StatusCode(\n                    500,\n                    ResponseResult.ErrorInfo(\n                        \"An error occurred while loading contact summary.\",\n                        ex.Message));\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Summary/Dtos/ContactSummaryResponseDto.cs",
      "sha256": "c001cccb870161328a9e37057c268eb9c5304d4be4b557a60e9ed297a89ba236",
      "language": "csharp",
      "size": 1483,
      "content": "// üìÑ xbytechat-api/Features/CRM/Summary/Dtos/ContactSummaryResponseDto.cs\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Summary.Dtos\n{\n    /// <summary>\n    /// Compact CRM snapshot for a contact:\n    /// - Core contact fields\n    /// - Tags\n    /// - Recent notes\n    /// - Next reminder\n    /// - Recent timeline events\n    /// </summary>\n    public sealed class ContactSummaryResponseDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        // Core contact profile\n        public string Name { get; set; } = string.Empty;\n        public string PhoneNumber { get; set; } = string.Empty;\n        public string? Email { get; set; }\n        public string? LeadSource { get; set; }\n\n        public bool IsFavorite { get; set; }\n        public bool IsArchived { get; set; }\n        public string? Group { get; set; }\n\n        public DateTime? LastContactedAt { get; set; }\n        public DateTime? NextFollowUpAt { get; set; }\n\n        // Structured tags (from ContactDto.ContactTags ‚Üí ContactTagDto)\n        public List<ContactTagDto> Tags { get; set; } = new();\n\n        // Mini timeline section\n        public List<NoteDto> RecentNotes { get; set; } = new();\n\n        public ReminderDto? NextReminder { get; set; }\n\n        public List<LeadTimelineDto> RecentTimeline { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Summary/Interfaces/IContactSummaryService.cs",
      "sha256": "2adcd4704ac049cb3e7ee5b2652d8b389427a1bfeb1acf6a8fa6c1aee0a1c6eb",
      "language": "csharp",
      "size": 791,
      "content": "// üìÑ xbytechat-api/Features/CRM/Summary/Interfaces/IContactSummaryService.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Summary.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Summary.Interfaces\n{\n    /// <summary>\n    /// Aggregates data from CRM modules (Contacts, Notes, Reminders, Timeline)\n    /// into a single contact summary for the Chat Inbox / dashboards.\n    /// </summary>\n    public interface IContactSummaryService\n    {\n        /// <summary>\n        /// Returns a compact CRM snapshot for the given contact and business.\n        /// </summary>\n        Task<ContactSummaryResponseDto?> GetContactSummaryAsync(\n            Guid businessId,\n            Guid contactId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Summary/Services/ContactSummaryService.cs",
      "sha256": "c9f37c47799808a8aac1a5bf84b09b88dcc7b0649a86892a49ecead6ad52fe5b",
      "language": "csharp",
      "size": 4428,
      "content": "// üìÑ xbytechat-api/Features/CRM/Summary/Services/ContactSummaryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Summary.Dtos;\nusing xbytechat.api.Features.CRM.Summary.Interfaces;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Mappers;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Summary.Services\n{\n    /// <summary>\n    /// Default implementation of IContactSummaryService.\n    /// Orchestrates calls into existing CRM services and returns\n    /// a single response model tailored for UI consumption.\n    /// </summary>\n    public sealed class ContactSummaryService : IContactSummaryService\n    {\n        private readonly IContactService _contactService;\n        private readonly INoteService _noteService;\n        private readonly IReminderService _reminderService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public ContactSummaryService(\n            IContactService contactService,\n            INoteService noteService,\n            IReminderService reminderService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _contactService = contactService ?? throw new ArgumentNullException(nameof(contactService));\n            _noteService = noteService ?? throw new ArgumentNullException(nameof(noteService));\n            _reminderService = reminderService ?? throw new ArgumentNullException(nameof(reminderService));\n            _leadTimelineService = leadTimelineService ?? throw new ArgumentNullException(nameof(leadTimelineService));\n        }\n\n        public async Task<ContactSummaryResponseDto?> GetContactSummaryAsync(\n            Guid businessId,\n            Guid contactId,\n            CancellationToken ct = default)\n        {\n            // 1) Core contact (this already returns ContactDto with tags)\n            var contact = await _contactService.GetContactByIdAsync(businessId, contactId);\n            if (contact == null)\n            {\n                return null;\n            }\n\n            // 2) Notes ‚Äì latest 3 by CreatedAt\n            var notes = await _noteService.GetNotesByContactAsync(businessId, contactId);\n            var recentNotes = notes\n                .OrderByDescending(n => n.CreatedAt)\n                .Take(3)\n                .ToList();\n\n            // 3) Next upcoming reminder for this contact (in-memory filter from service)\n            var allReminders = await _reminderService.GetAllRemindersAsync(businessId);\n            var nowUtc = DateTime.UtcNow;\n\n            var nextReminder = allReminders\n                .Where(r =>\n                    r.ContactId == contactId &&\n                    r.IsActive &&\n                    string.Equals(r.Status, \"Pending\", StringComparison.OrdinalIgnoreCase) &&\n                    r.DueAt >= nowUtc)\n                .OrderBy(r => r.DueAt)\n                .FirstOrDefault();\n\n            // 4) Recent timeline entries (latest 5 by CreatedAt)\n            var timelineEntities = await _leadTimelineService.GetTimelineByContactIdAsync(contactId);\n\n            var recentTimeline = timelineEntities\n                .OrderByDescending(e => e.CreatedAt)\n                .Take(5)\n                .Select(LeadTimelineMapper.ToDto)\n                .Where(dto => dto != null)\n                .ToList()!; // mapper may return null, we filter just in case\n\n            // 5) Assemble response\n            return new ContactSummaryResponseDto\n            {\n                BusinessId = businessId,\n                ContactId = contactId,\n\n                Name = contact.Name,\n                PhoneNumber = contact.PhoneNumber,\n                Email = contact.Email,\n                LeadSource = contact.LeadSource,\n                LastContactedAt = contact.LastContactedAt,\n                NextFollowUpAt = contact.NextFollowUpAt,\n                IsFavorite = contact.IsFavorite,\n                IsArchived = contact.IsArchived,\n                Group = contact.Group,\n\n                Tags = contact.Tags ?? new List<ContactTagDto>(),\n\n                RecentNotes = recentNotes,\n                NextReminder = nextReminder,\n                RecentTimeline = recentTimeline\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Controllers/LeadTimelineController.cs",
      "sha256": "acbf1f3b85665c403e9ba8358653b9dbf039c8881b112af442083b59f7c6d1ee",
      "language": "csharp",
      "size": 2035,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class LeadTimelineController : ControllerBase\n    {\n        private readonly ILeadTimelineService _timelineService;\n\n        public LeadTimelineController(ILeadTimelineService timelineService)\n        {\n            _timelineService = timelineService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTimelineEntry([FromBody] LeadTimelineDto dto)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                    return BadRequest(ModelState);\n\n                var result = await _timelineService.AddTimelineEntryAsync(dto);\n\n                Log.Information(\"‚úÖ Timeline entry created for ContactId: {ContactId}\", dto.ContactId);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw;\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetTimeline(Guid contactId)\n        {\n            try\n            {\n                var timeline = await _timelineService.GetTimelineByContactIdAsync(contactId);\n\n                Log.Information(\"üìÑ Retrieved {Count} entries for ContactId: {ContactId}\", timeline.Count, contactId);\n\n                return Ok(timeline);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to get timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll()\n        {\n            var timelines = await _timelineService.GetAllTimelinesAsync();\n            return Ok(timelines);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/CampaignTimelineLogDto.cs",
      "sha256": "b279e39522b2d36effd77fe29c36653ca83b93c6cc9a1281d1ed6b3e596b96e3",
      "language": "csharp",
      "size": 361,
      "content": "public class CampaignTimelineLogDto\n{\n    public Guid ContactId { get; set; }\n    public Guid BusinessId { get; set; }   // ‚úÖ Needed for timeline insertion\n    public Guid CampaignId { get; set; }\n    public string CampaignName { get; set; } = string.Empty; // ‚úÖ Safe default to avoid null issues\n    public DateTime? Timestamp { get; set; } // optional\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/CRMTimelineLogDto.cs",
      "sha256": "523614f609f53bf0e19c490cf47a69ceb3ccc7df61bba97b431fcbcf6c739bdf",
      "language": "csharp",
      "size": 695,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Timelines.DTOs\n{\n    public class CRMTimelineLogDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public string EventType { get; set; }  // üß© Example: \"NoteAdded\", \"ReminderSet\", \"TagApplied\"\n        public string Description { get; set; }\n        public Guid? ReferenceId { get; set; }  // üÜî Related NoteId, ReminderId, TagId (optional)\n        public string CreatedBy { get; set; }\n        public string? Category { get; set; } = \"CRM\";  // üìÇ Default category: CRM\n        public DateTime? Timestamp { get; set; }  // ‚è∞ Custom time if needed (else CreatedAt = now)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/LeadTimelineDto.cs",
      "sha256": "3b83f102ec5c0ddae6f265b6d33ddbd741f854e83baa0f696a1a05a7d9639104",
      "language": "csharp",
      "size": 687,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Timelines.DTOs\n{\n    public class LeadTimelineDto\n    {\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactNumber { get; set; }\n        public string EventType { get; set; }\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }\n        public bool IsSystemGenerated { get; set; } = false;\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Mappers/LeadTimelineMapper.cs",
      "sha256": "d3a2ed675f44c84af1ce0317d44c4407bf3fc23bf4bfdd91ebf0c52bf63a9296",
      "language": "csharp",
      "size": 1843,
      "content": "using xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Mappers\n{\n    public static class LeadTimelineMapper\n    {\n        public static LeadTimelineDto ToDto(Models.LeadTimeline entry)\n        {\n            if (entry == null) return null;\n\n            return new LeadTimelineDto\n            {\n                ContactId = entry.ContactId,\n                ContactName = entry.Contact?.Name,                // ‚úÖ Enriched from navigation\n                ContactNumber = entry.Contact?.PhoneNumber,       // ‚úÖ Enriched from navigation\n                EventType = entry.EventType,\n                Description = entry.Description,\n                Data = entry.Data,\n                ReferenceId = entry.ReferenceId,\n                IsSystemGenerated = entry.IsSystemGenerated,\n                CreatedBy = entry.CreatedBy,\n                Source = entry.Source,\n                Category = entry.Category,\n                // ‚úÖ CreatedAt is intentionally excluded from DTO\n            };\n        }\n\n        // Optional for create/update, include only necessary fields\n        public static Models.LeadTimeline ToModel(LeadTimelineDto dto)\n        {\n            if (dto == null) return null;\n\n            return new Models.LeadTimeline\n            {\n                ContactId = dto.ContactId,\n                EventType = dto.EventType,\n                Description = dto.Description,\n                Data = dto.Data,\n                ReferenceId = dto.ReferenceId,\n                IsSystemGenerated = dto.IsSystemGenerated,\n                CreatedBy = dto.CreatedBy,\n                Source = dto.Source,\n                Category = dto.Category,\n                CreatedAt = DateTime.UtcNow // ‚úÖ Always use UTC when creating\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Models/LeadTimeline.cs",
      "sha256": "3f31e8a170176d76713be299c4d314a5d1aaf17514d4903adb3685d41ca42572",
      "language": "csharp",
      "size": 1206,
      "content": "using xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Models\n{\n    public class LeadTimeline\n    {\n        public int Id { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }  // optional\n\n        public Contact Contact { get; set; } // üÜï Navigation property\n\n        public string EventType { get; set; }\n\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }           // ‚úÖ New\n        public bool IsSystemGenerated { get; set; } = false;  // ‚úÖ New\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n        public string? CTAType { get; set; } // e.g., \"BuyNow\", \"PriceCheck\", \"ConfirmReminder\"\n        public string? CTASourceType { get; set; } // e.g., \"catalog\", \"campaign\", \"reminder\"\n        public Guid? CTASourceId { get; set; } // ID of the source object (productId, reminderId)\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/ILeadTimelineService.cs",
      "sha256": "50629497a65281bae0ab515aa0b85e6a12eba14d8da57398c82e68cff749f58e",
      "language": "csharp",
      "size": 717,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public interface ILeadTimelineService\n    {\n        Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto);\n        Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId);\n        Task<List<LeadTimelineDto>> GetAllTimelinesAsync();\n        Task AddFromCatalogClickAsync(CatalogClickLog log);\n        Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto);\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/ITimelineService.cs",
      "sha256": "66f4590edcc54a2259174e6cb8efd54989b43d5250c46de459fd7d3b0907086f",
      "language": "csharp",
      "size": 452,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public interface ITimelineService\n    {\n        // Already existing methods...\n\n        // üÜï CRM related methods\n        Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto);\n        Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/LeadTimelineService.cs",
      "sha256": "509c3bc3cf8d36b9acac08b54bf211a5992bb367934df75327f233af36eb9333",
      "language": "csharp",
      "size": 7570,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.Catalog.Models;\nusing static xbytechat.api.Features.BusinessModule.Models.Business;\nusing System.Text.Json;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public class LeadTimelineService : ILeadTimelineService\n    {\n        private readonly AppDbContext _context;\n\n\n        public LeadTimelineService(AppDbContext context)\n        {\n            _context = context;\n\n        }\n\n        public async Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto)\n        {\n            try\n            {\n                var entry = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    EventType = dto.EventType,\n                    Description = dto.Description,\n                    Data = dto.Data,\n                    ReferenceId = dto.ReferenceId,\n                    IsSystemGenerated = dto.IsSystemGenerated,\n                    CreatedBy = dto.CreatedBy,\n                    Source = dto.Source,\n                    Category = dto.Category,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(entry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Timeline entry added for ContactId: {ContactId}\", dto.ContactId);\n\n                return entry;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error adding timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw; // Let global middleware handle this\n            }\n        }\n\n        public async Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId)\n        {\n            try\n            {\n                var results = await _context.LeadTimelines\n                    .Where(x => x.ContactId == contactId)\n                    .OrderByDescending(x => x.CreatedAt)\n                    .ToListAsync();\n\n                Log.Information(\"üìÑ Fetched {Count} timeline entries for ContactId: {ContactId}\", results.Count, contactId);\n\n                return results;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        public async Task<List<LeadTimelineDto>> GetAllTimelinesAsync()\n        {\n            try\n            {\n                var entries = await _context.LeadTimelines\n                    .Include(t => t.Contact) // for Contact Name/Phone\n                    .OrderByDescending(e => e.CreatedAt)\n                    .ToListAsync();\n\n                var dtoList = entries.Select(entry => new LeadTimelineDto\n                {\n                    ContactId = entry.ContactId,\n                    EventType = entry.EventType,\n                    Description = entry.Description,\n                    Data = entry.Data,\n                    ReferenceId = entry.ReferenceId,\n                    CreatedAt = entry.CreatedAt,\n                    CreatedBy = entry.CreatedBy,\n                    Source = entry.Source,\n                    Category = entry.Category,\n                    IsSystemGenerated = entry.IsSystemGenerated,\n                    ContactName = entry.Contact?.Name,\n                    ContactNumber = entry.Contact?.PhoneNumber\n                }).ToList();\n\n                Log.Information(\"üìÑ Loaded {Count} total timeline entries\", dtoList.Count);\n                return dtoList;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch all timeline entries\");\n                throw;\n            }\n        }\n        public async Task AddFromCatalogClickAsync(CatalogClickLog log)\n        {\n            if (log == null)\n            {\n                Log.Warning(\"CatalogClickLog is null. Skipping timeline creation.\");\n                return;\n            }\n\n            try\n            {\n                var business = await _context.Businesses\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(b => b.Id == log.BusinessId);\n\n                if (business == null)\n                {\n                    Log.Warning(\"Business not found for ID: {BusinessId}. Skipping timeline creation.\", log.BusinessId);\n                    return;\n                }\n\n                // if (business.Plan == PlanType.Advanced)\n                if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                {\n                    Log.Information(\"Timeline skipped for Basic Plan - BusinessId: {BusinessId}\", business.Id);\n                    return;\n                }\n\n\n                var description = $\"{log.ProductBrowsed} | {log.CTAJourney}\";\n\n                var timelineEntry = new LeadTimeline\n                {\n                    BusinessId = log.BusinessId,\n                    ContactId = log.ContactId ?? Guid.Empty,\n                    EventType = \"CatalogCTA\",\n                    Description = description,\n                    Data = JsonSerializer.Serialize(log),\n                    ReferenceId = null,\n                    CreatedBy = \"system\",\n                    IsSystemGenerated = true,\n                    Source = \"Catalog\",\n                    Category = log.CategoryBrowsed,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(timelineEntry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üìà Timeline entry created from CatalogClick for UserId: {UserId}\", log.UserId);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error creating timeline entry from CatalogClick for UserId: {UserId}\", log.UserId);\n                // Safe swallow\n            }\n        }\n\n        public async Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"CampaignSend\",\n                    Description = $\"Campaign '{dto.CampaignName}' was sent.\", // ‚úÖ Timeline me readable text\n                    ReferenceId = dto.CampaignId, // ‚úÖ Linking to campaign record\n                    IsSystemGenerated = false,    // ‚úÖ Default (campaign sending is manual action)\n                    CreatedBy = \"system\",         // ‚úÖ Or actual user email if needed later\n                    Source = \"CampaignModule\",    // ‚úÖ Source field for clarity\n                    Category = \"Messaging\",       // ‚úÖ Logical grouping\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow // ‚úÖ Use given Timestamp or fallback to now\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Campaign send event logged into timeline.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to log campaign send event: \" + ex.Message);\n            }\n        }\n\n\n    }\n\n\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/TimelineService.cs",
      "sha256": "15812c9261e54e2de1c7290ff48319573169fbc694ea5c6adf072f40d9bbfbff",
      "language": "csharp",
      "size": 3347,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public class TimelineService : ITimelineService\n    {\n        private readonly AppDbContext _context;\n\n        public TimelineService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // üß© Log Note Added into Timeline\n        public async Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"NoteAdded\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // ‚è∞ Log Reminder Set into Timeline\n        public async Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"ReminderSet\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // üè∑Ô∏è Log Tag Applied into Timeline\n        public async Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"TagApplied\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Controllers/CrmAnalyticsController.cs",
      "sha256": "9148ea0201bfa24665b2fc92339cec7f58019baa66443aba80189bc1a4c9c833",
      "language": "csharp",
      "size": 1948,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.Services;\nusing xbytechat.api.Shared;\nusing System.Security.Claims;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Controllers\n{\n    /// <summary>\n    /// Handles CRM analytics summary and trends.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm\")]\n    public class CrmAnalyticsController : ControllerBase\n    {\n        private readonly ICrmAnalyticsService _crmAnalyticsService;\n\n        public CrmAnalyticsController(ICrmAnalyticsService crmAnalyticsService)\n        {\n            _crmAnalyticsService = crmAnalyticsService;\n        }\n\n        /// <summary>\n        /// Returns dashboard summary stats for the CRM.\n        /// </summary>\n        [HttpGet(\"summary\")]\n        public async Task<IActionResult> GetSummary()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetSummaryAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"üìä CRM analytics loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Returns contacts-added-over-time trend for graph.\n        /// </summary>\n        [HttpGet(\"trends/contacts\")]\n        public async Task<IActionResult> GetContactTrends()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetContactTrendsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"üìà Contact trends loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Extracts the businessId (Guid) from current user claims.\n        /// </summary>\n        private Guid GetBusinessIdFromContext()\n        {\n            return Guid.TryParse(HttpContext.User.FindFirst(\"BusinessId\")?.Value, out var id)\n                ? id\n                : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/ContactTrendsDto.cs",
      "sha256": "132d9271e14f9c3f2a65c9241917f67bc8129c91c7050c86a67df545c68419bc",
      "language": "csharp",
      "size": 362,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    /// <summary>\n    /// Represents the number of contacts added on a specific date.\n    /// Used for trend charting on the CRM dashboard.\n    /// </summary>\n    public class ContactTrendsDto\n    {\n        public string Date { get; set; } // Format: yyyy-MM-dd\n        public int Count { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/CrmAnalyticsSummaryDto.cs",
      "sha256": "73027ff6ddc0b680b03714267bbf642053cdc28f2d97c16b593a3321186ab9d9",
      "language": "csharp",
      "size": 619,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    public class CrmAnalyticsSummaryDto\n    {\n        public int TotalContacts { get; set; }\n        public int TaggedContacts { get; set; }\n        public int ActiveReminders { get; set; }\n        public int CompletedReminders { get; set; }\n        public int TotalNotes { get; set; }\n        public int LeadsWithTimeline { get; set; }\n        public int NewContactsToday { get; set; }\n        public int NotesAddedToday { get; set; }\n        public DateTime? LastContactAddedAt { get; set; }\n        public DateTime? LastReminderCompletedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/CrmAnalyticsService.cs",
      "sha256": "8fae1f725576dc5f6402559df557282ba8991f65bb324b614a65b4e9225167c5",
      "language": "csharp",
      "size": 4014,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\nusing xbytechat.api.Features.CrmAnalytics.Services;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Provides implementation for CRM analytics calculations.\n    /// Gathers contact, tag, note, and reminder metrics for the dashboard.\n    /// </summary>\n    public class CrmAnalyticsService : ICrmAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CrmAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        /// <summary>\n        /// Generates a summarized snapshot of CRM data for the given business.\n        /// </summary>\n        /// <param name=\"businessId\">The unique ID of the business</param>\n        /// <returns>CrmAnalyticsSummaryDto containing insights</returns>\n        public async Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalContacts = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId);\n\n            var taggedContacts = await _context.Contacts\n                .Where(c => c.BusinessId == businessId && c.Tags.Any())\n                .CountAsync();\n\n            var activeReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Pending\");\n\n            var completedReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Completed\");\n\n            var totalNotes = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId);\n\n            var leadsWithTimeline = await _context.LeadTimelines\n                .Where(t => t.BusinessId == businessId)\n                .Select(t => t.ContactId)\n                .Distinct()\n                .CountAsync();\n\n            var newContactsToday = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId && c.CreatedAt.Date == today);\n\n            var notesAddedToday = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId && n.CreatedAt.Date == today);\n\n            var lastContactAddedAt = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => (DateTime?)c.CreatedAt)\n                .FirstOrDefaultAsync();\n\n            var lastReminderCompletedAt = await _context.Reminders\n                .Where(r => r.BusinessId == businessId && r.Status == \"Completed\")\n                .OrderByDescending(r => r.CompletedAt)\n                .Select(r => (DateTime?)r.CompletedAt)\n                .FirstOrDefaultAsync();\n\n            return new CrmAnalyticsSummaryDto\n            {\n                TotalContacts = totalContacts,\n                TaggedContacts = taggedContacts,\n                ActiveReminders = activeReminders,\n                CompletedReminders = completedReminders,\n                TotalNotes = totalNotes,\n                LeadsWithTimeline = leadsWithTimeline,\n                NewContactsToday = newContactsToday,\n                NotesAddedToday = notesAddedToday,\n                LastContactAddedAt = lastContactAddedAt,\n                LastReminderCompletedAt = lastReminderCompletedAt\n            };\n        }\n        public async Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId)\n        {\n            var trends = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.CreatedAt.Date)\n                .OrderBy(g => g.Key)\n                .Select(g => new ContactTrendsDto\n                {\n                    Date = g.Key.ToString(\"yyyy-MM-dd\"),\n                    Count = g.Count()\n                })\n                .ToListAsync();\n\n            return trends;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/ICrmAnalyticsService.cs",
      "sha256": "24d70810ed26415792ab48592900090d8d1b7682d926e46f4bdc4595b24c5659",
      "language": "csharp",
      "size": 895,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Defines the contract for CRM Analytics services.\n    /// Handles lead-level analytics, summary metrics, and dashboard insights.\n    /// </summary>\n    public interface ICrmAnalyticsService\n    {\n        /// <summary>\n        /// Returns a summarized view of CRM statistics for a specific business.\n        /// This is used to power the CRM analytics dashboard.\n        /// </summary>\n        /// <param name=\"businessId\">The unique identifier of the business (tenant).</param>\n        /// <returns>A summary DTO containing contact, tag, note, and reminder insights.</returns>\n        Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId);\n        Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CsvModule/CsvBatchValidationController.cs",
      "sha256": "daf00037fbe7c0f74272fe6dd650de7918d6f2f9a1bf91e40b01039a0e04f9cc",
      "language": "csharp",
      "size": 7225,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Shared;\nusing xbytechat_api.WhatsAppSettings.Services; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CsvModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/csv/batch/{batchId:guid}/validate\")]\n    [Authorize]\n    public sealed class CsvBatchValidationController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        public CsvBatchValidationController(AppDbContext db) => _db = db;\n\n        public sealed class ValidateRequest\n        {\n            public string? PhoneHeader { get; set; }              // e.g. \"phone\"\n            public List<string>? RequiredHeaders { get; set; }    // e.g. [\"parameter1\",\"headerpara1\",\"buttonpara1\"]\n            public bool NormalizePhone { get; set; } = true;\n            public bool CheckDuplicates { get; set; } = true;\n            public int? Limit { get; set; }                       // optional sample cap\n        }\n\n        public sealed class ValidateResponse\n        {\n            public bool Success { get; set; } = true;\n            public List<string> Problems { get; set; } = new();\n            public object Stats { get; set; } = new { rows = 0, missingPhone = 0, invalidPhones = 0, duplicatePhones = 0 };\n            public List<string> Headers { get; set; } = new();    // discovered headers in the batch\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Validate(Guid batchId, [FromBody] ValidateRequest req, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Load CSV rows for this batch (owned by business)\n            var rowsQ = _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex);\n\n            var total = await rowsQ.CountAsync(ct);\n            if (total == 0)\n                return Ok(new ValidateResponse\n                {\n                    Problems = new List<string> { \"CSV batch is empty.\" },\n                    Stats = new { rows = 0, missingPhone = 0, invalidPhones = 0, duplicatePhones = 0 },\n                    Headers = new List<string>()\n                });\n\n            var rows = req.Limit.HasValue && req.Limit.Value > 0\n                ? await rowsQ.Take(req.Limit.Value).ToListAsync(ct)\n                : await rowsQ.ToListAsync(ct);\n\n            // Discover header set by union of row keys (case-insensitive compare)\n            var headerSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            foreach (var r in rows)\n                foreach (var k in KeysOfJson(r.DataJson))\n                    headerSet.Add(k);\n\n            var headers = headerSet.OrderBy(x => x, StringComparer.OrdinalIgnoreCase).ToList();\n\n            var problems = new List<string>();\n\n            // Validate phone header presence\n            var phoneHeader = (req.PhoneHeader ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(phoneHeader))\n            {\n                // Try helpful guesses\n                var guesses = new[] { \"phone\", \"mobile\", \"whatsapp\", \"number\", \"phonee164\", \"msisdn\", \"whatsapp_number\" };\n                var guess = guesses.FirstOrDefault(h => headerSet.Contains(h));\n                if (!string.IsNullOrEmpty(guess))\n                    phoneHeader = guess;\n            }\n\n            if (string.IsNullOrWhiteSpace(phoneHeader))\n            {\n                problems.Add(\"Phone column not specified and could not be guessed.\");\n            }\n            else if (!headerSet.Contains(phoneHeader))\n            {\n                problems.Add($\"Phone column ‚Äú{phoneHeader}‚Äù not found in CSV.\");\n            }\n\n            // Validate requiredHeaders presence (parameterN/headerparaN/buttonparaN)\n            var required = req.RequiredHeaders ?? new List<string>();\n            foreach (var h in required)\n            {\n                if (!headerSet.Contains(h))\n                    problems.Add($\"Required column ‚Äú{h}‚Äù is missing.\");\n            }\n\n            // Row-level checks\n            int missingPhone = 0, invalidPhones = 0, duplicatePhones = 0;\n            var seen = new HashSet<string>(StringComparer.Ordinal);\n\n            foreach (var r in rows)\n            {\n                var dict = JsonToDict(r.DataJson);\n\n                // phone\n                string? rawPhone = null;\n                if (!string.IsNullOrWhiteSpace(phoneHeader))\n                    dict.TryGetValue(phoneHeader, out rawPhone);\n\n                var normPhone = NormalizePhoneMaybe(rawPhone, req.NormalizePhone);\n                if (string.IsNullOrWhiteSpace(normPhone))\n                {\n                    missingPhone++;\n                    continue;\n                }\n\n                // naive validity check\n                if (!Regex.IsMatch(normPhone, @\"^\\d{10,15}$\"))\n                {\n                    invalidPhones++;\n                }\n\n                if (req.CheckDuplicates && !seen.Add(normPhone))\n                {\n                    duplicatePhones++;\n                }\n            }\n\n            var resp = new ValidateResponse\n            {\n                Problems = problems,\n                Stats = new { rows = total, missingPhone, invalidPhones, duplicatePhones },\n                Headers = headers\n            };\n\n            return Ok(resp);\n        }\n\n        // ---------- helpers ----------\n        private static IEnumerable<string> KeysOfJson(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) yield break;\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) yield break;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                yield return p.Name;\n        }\n\n        private static Dictionary<string, string> JsonToDict(string? json)\n        {\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            if (string.IsNullOrWhiteSpace(json)) return dict;\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) return dict;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                dict[p.Name] = p.Value.ValueKind == JsonValueKind.Null ? \"\" : p.Value.ToString();\n            return dict;\n        }\n\n        private static string? NormalizePhoneMaybe(string? raw, bool normalize)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var trimmed = raw.Trim();\n            if (!normalize) return trimmed;\n\n            // simple E.164-ish cleanup\n            var digits = Regex.Replace(trimmed, \"[^0-9]\", \"\");\n            digits = digits.TrimStart('0');\n            if (digits.Length == 10) digits = \"91\" + digits; // heuristic India\n            return digits;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/CTAFlowController.cs",
      "sha256": "ae0976baa15c4292f6fdc76a5e1b8810652df67fc18524f60eaf58037c5e4038",
      "language": "csharp",
      "size": 34615,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"api/cta-flow\")]\n    public class CTAFlowController : ControllerBase\n    {\n        private readonly ICTAFlowService _flowService;\n\n        public CTAFlowController(ICTAFlowService flowService)\n        {\n            _flowService = flowService;\n        }\n\n        // CREATE (draft-only)\n        [HttpPost(\"save-visual\")]\n        public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            Log.Information(\"üì¶ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n            var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? \"\").Trim();\n\n                // map common validation/conflict by message text (no result.Code available)\n                if (m.Contains(\"already exists\", StringComparison.OrdinalIgnoreCase))\n                    return Conflict(new { message = \"‚ùå Duplicate flow name\", error = m });\n\n                if (m.Contains(\"required\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"empty flow\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"invalid\", StringComparison.OrdinalIgnoreCase))\n                    return BadRequest(new { message = \"‚ùå Failed to save flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"‚ùå Failed to save flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            Guid? flowId = null;\n            if (result.Data is not null)\n            {\n                try { dynamic d = result.Data; flowId = (Guid?)d.flowId; } catch { }\n            }\n\n            return Ok(new { message = \"‚úÖ Flow saved successfully\", flowId });\n        }\n\n        // PUBLISH (by id)\n        [HttpPost(\"{id:guid}/publish\")]\n        public async Task<IActionResult> Publish(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var ok = await _flowService.PublishFlowAsync(id, businessId, user);\n            return ok ? Ok(new { message = \"‚úÖ Flow published.\" }) : NotFound(new { message = \"‚ùå Flow not found.\" });\n        }\n\n        // DELETE (only if not attached)\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n            var deletedBy = User.FindFirst(\"name\")?.Value\n                          ?? User.FindFirst(\"email\")?.Value\n                          ?? User.FindFirst(\"sub\")?.Value\n                          ?? \"system\";\n\n            var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n            if (!result.Success)\n            {\n                var msg = (result.ErrorMessage ?? result.Message ?? string.Empty).Trim();\n\n                // If message says it's attached, return 409 and include campaigns for the modal\n                if (msg.Contains(\"attached\", StringComparison.OrdinalIgnoreCase) ||\n                    msg.Contains(\"Cannot delete\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n                    return Conflict(new { message = msg, campaigns });\n                }\n\n                if (msg.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = msg });\n\n                return BadRequest(new { message = string.IsNullOrWhiteSpace(msg) ? \"Delete failed.\" : msg });\n            }\n\n            return Ok(new { message = result.Message ?? \"‚úÖ Flow deleted.\" });\n        }\n\n        // LISTS\n        [HttpGet(\"all-published\")]\n        public async Task<IActionResult> GetPublishedFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var flows = await _flowService.GetAllPublishedFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        [HttpGet(\"all-draft\")]\n        public async Task<IActionResult> GetAllDraftFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var flows = await _flowService.GetAllDraftFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        // DETAIL\n        [HttpGet(\"by-id/{id:guid}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var dto = await _flowService.GetVisualFlowByIdAsync(id, businessId);\n            if (dto is null) return NotFound(new { message = \"‚ùå Flow not found.\" });\n\n            return Ok(dto);\n        }\n\n        [HttpGet(\"visual/{id:guid}\")]\n        public async Task<IActionResult> GetVisualFlow(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"‚ùå Invalid business ID\" });\n\n            var result = await _flowService.GetVisualFlowAsync(id, businessId);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? string.Empty).Trim();\n                if (m.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = \"‚ùå Failed to load flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"‚ùå Failed to load flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            return Ok(result.Data);\n        }\n\n        // USAGE (for delete guard)\n        [HttpGet(\"{id:guid}/usage\")]\n        public async Task<IActionResult> GetUsage(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"Invalid business.\" });\n\n            var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n            return Ok(new\n            {\n                canDelete = campaigns.Count == 0,\n                count = campaigns.Count,\n                campaigns\n            });\n        }\n    }\n}\n\n\n//// üìÑ File: Features/CTAFlowBuilder/Controllers/CTAFlowController.cs\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.EntityFrameworkCore;\n//using Serilog;\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.CTAFlowBuilder.Services;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.Features.Tracking.Models;\n//using xbytechat.api.Features.Tracking.Services;\n//using xbytechat.api.Helpers;\n//using xbytechat.api.Shared;\n\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/cta-flow\")]\n//    public class CTAFlowController : ControllerBase\n//    {\n//        private readonly ICTAFlowService _flowService;\n//        private readonly IMessageEngineService _messageEngineService;\n//        private readonly ITrackingService _trackingService;\n//        public CTAFlowController(ICTAFlowService flowService, IMessageEngineService messageEngineService, ITrackingService trackingService)\n//        {\n//            _flowService = flowService;\n//            _messageEngineService = messageEngineService;\n//            _trackingService = trackingService;\n//        }\n\n//        [HttpPost(\"create\")]\n//        public async Task<IActionResult> CreateFlow([FromBody] CreateFlowDto dto)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//            if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"‚ùå Invalid or missing businessId claim.\");\n\n//            var id = await _flowService.CreateFlowWithStepsAsync(dto, businessId, createdBy);\n//            return Ok(new { flowId = id });\n//        }\n\n//        //[HttpPost(\"publish\")]\n//        //public async Task<IActionResult> PublishFlow([FromBody] List<FlowStepDto> steps)\n//        //{\n//        //    var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//        //    var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//        //    if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n//        //        return BadRequest(\"‚ùå Invalid or missing businessId claim.\");\n\n//        //    var result = await _flowService.PublishFlowAsync(businessId, steps, createdBy);\n//        //    if (!result.Success)\n//        //        return BadRequest(result.Message);\n\n//        //    return Ok(\"‚úÖ Flow published successfully.\");\n//        //}\n\n//        [HttpGet(\"current\")]\n//        public async Task<IActionResult> GetFlow()\n//        {\n//            var businessIdHeader = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdHeader, out var businessId))\n//                return BadRequest(\"‚ùå Invalid or missing BusinessId header.\");\n\n//            var flow = await _flowService.GetFlowByBusinessAsync(businessId);\n\n//            // ‚úÖ Always return 200 even if flow is null\n//            return Ok(flow);\n//        }\n\n//        [HttpGet(\"draft\")]\n//        public async Task<IActionResult> GetDraftFlow()\n//        {\n//            var businessIdHeader = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdHeader, out var businessId))\n//                return BadRequest(\"‚ùå Invalid or missing BusinessId header.\");\n\n//            var draft = await _flowService.GetDraftFlowByBusinessAsync(businessId);\n//            if (draft == null)\n//                return NotFound(\"‚ùå No draft flow found.\");\n\n//            return Ok(draft);\n//        }\n\n//        [HttpGet(\"match\")]\n//        public async Task<IActionResult> MatchButton(\n//            [FromQuery] string text,\n//            [FromQuery] string type,\n//            [FromQuery] string currentTemplateName,\n//            [FromQuery] Guid? campaignId) // Optional\n//        {\n//            var businessId = Guid.Parse(User.FindFirst(\"businessId\")?.Value!);\n\n//            var step = await _flowService.MatchStepByButtonAsync(\n//                businessId,\n//                text,\n//                type,\n//                currentTemplateName,\n//                campaignId\n//            );\n\n//            if (step == null)\n//                return NotFound(\"‚ùå No matching step found.\");\n\n//            return Ok(new\n//            {\n//                step.TemplateToSend,\n//                step.TriggerButtonText,\n//                step.TriggerButtonType\n//            });\n//        }\n\n//        //[HttpPost(\"save-visual\")]\n//        //public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n//        //{\n//        //    var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//        //    var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//        //    if (!Guid.TryParse(businessIdClaim, out var businessId))\n//        //        return BadRequest(\"‚ùå Invalid business ID\");\n\n//        //    Log.Information(\"üì¶ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n//        //    var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n//        //    if (!result.Success)\n//        //    {\n//        //        Log.Error(\"‚ùå Failed to save flow. Error: {Error}. DTO: {@Dto}\", result.ErrorMessage, dto);\n//        //        return StatusCode(500, new\n//        //        {\n//        //            message = \"‚ùå Failed to save flow\",\n//        //            error = result.ErrorMessage,\n//        //            // skipped = result.SkippedNodes ?? 0\n//        //        });\n//        //    }\n\n//        //    return Ok(new\n//        //    {\n//        //        message = \"‚úÖ Flow saved successfully\"\n//        //    });\n//        //}\n\n//        //[HttpPost(\"save-visual\")]\n//        //public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n//        //{\n//        //    var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//        //    var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//        //    if (!Guid.TryParse(businessIdClaim, out var businessId))\n//        //        return BadRequest(\"‚ùå Invalid business ID\");\n\n//        //    Log.Information(\"üì¶ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n//        //    var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n//        //    if (!result.Success)\n//        //    {\n//        //        Log.Error(\"‚ùå Failed to save flow. Error: {Error}. DTO: {@Dto}\", result.ErrorMessage, dto);\n//        //        return StatusCode(500, new\n//        //        {\n//        //            message = \"‚ùå Failed to save flow\",\n//        //            error = result.ErrorMessage\n//        //        });\n//        //    }\n\n//        //    // Try to extract flowId from the service result (supports several shapes).\n//        //    Guid? flowId = null;\n//        //    try\n//        //    {\n//        //        switch (result.Data)\n//        //        {\n//        //            case Guid g:\n//        //                flowId = g;\n//        //                break;\n\n//        //            case string s when Guid.TryParse(s, out var gs):\n//        //                flowId = gs;\n//        //                break;\n\n//        //            case { } obj:\n//        //                // look for a property literally named \"flowId\"\n//        //                var prop = obj.GetType().GetProperty(\"flowId\")\n//        //                           ?? obj.GetType().GetProperty(\"FlowId\");\n//        //                if (prop?.GetValue(obj) is Guid pg)\n//        //                    flowId = pg;\n//        //                else if (prop?.GetValue(obj) is string ps && Guid.TryParse(ps, out var pgs))\n//        //                    flowId = pgs;\n//        //                break;\n//        //        }\n//        //    }\n//        //    catch\n//        //    {\n//        //        // non-fatal: just return without flowId if reflection fails\n//        //    }\n\n//        //    return Ok(new\n//        //    {\n//        //        message = \"‚úÖ Flow saved successfully\",\n//        //        flowId\n//        //    });\n//        //}\n//        // POST /api/cta-flow/save-visual\n//        // xbytechat.api/Features/CTAFlowBuilder/Controllers/CTAFlowController.cs\n//        [HttpPost(\"save-visual\")]\n//        public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"‚ùå Invalid business ID\");\n\n//            Log.Information(\"üì¶ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n//            var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n\n//            // Helper: classify error message to proper HTTP status\n//            IActionResult ErrorToHttp(string? msg)\n//            {\n//                var m = (msg ?? \"\").Trim();\n\n//                // Validation problems ‚Üí 400\n//                if (m.Contains(\"Flow name is required\", StringComparison.OrdinalIgnoreCase) ||\n//                    m.Contains(\"Cannot save an empty flow\", StringComparison.OrdinalIgnoreCase) ||\n//                    m.Contains(\"invalid\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    Log.Warning(\"‚ö†Ô∏è Validation error while saving flow: {Error}\", m);\n//                    return BadRequest(new { message = \"‚ùå Failed to save flow\", error = m });\n//                }\n\n//                // Duplicate name on create ‚Üí 409 (frontend will open rename modal)\n//                if (m.Contains(\"already exists\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    Log.Warning(\"‚ö†Ô∏è Duplicate flow name when creating: {Error}\", m);\n//                    return StatusCode(StatusCodes.Status409Conflict, new\n//                    {\n//                        message = \"‚ùå Duplicate flow name\",\n//                        error = m\n//                        // intentionally no 'campaigns' array here (FE uses presence of it to show fork modal)\n//                    });\n//                }\n\n//                // Unknown ‚Üí 500\n//                Log.Error(\"‚ùå Failed to save flow. Error: {Error}. DTO: {@Dto}\", m, dto);\n//                return StatusCode(StatusCodes.Status500InternalServerError, new\n//                {\n//                    message = \"‚ùå Failed to save flow\",\n//                    error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m\n//                });\n//            }\n\n//            if (!result.Success)\n//                return ErrorToHttp(result.ErrorMessage);\n\n//            // Expect service to put { flowId = <Guid> } into result.Data\n//            Guid? flowId = null;\n//            if (result.Data is not null)\n//            {\n//                try\n//                {\n//                    if (result.Data is IDictionary<string, object> dict\n//                        && dict.TryGetValue(\"flowId\", out var obj) && obj is Guid g1)\n//                    {\n//                        flowId = g1;\n//                    }\n//                    else\n//                    {\n//                        // dynamic fallback\n//                        dynamic d = result.Data;\n//                        flowId = (Guid?)d.flowId;\n//                    }\n//                }\n//                catch\n//                {\n//                    // ignore shape issues; flowId stays null\n//                }\n//            }\n\n//            return Ok(new\n//            {\n//                message = \"‚úÖ Flow saved successfully\",\n//                flowId\n//            });\n//        }\n\n\n//        //[HttpPost(\"save-visual\")]\n//        //public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n//        //{\n//        //    var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//        //    var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//        //    if (!Guid.TryParse(businessIdClaim, out var businessId))\n//        //        return BadRequest(\"‚ùå Invalid business ID\");\n\n//        //    Log.Information(\"üì¶ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n//        //    var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n//        //    if (!result.Success)\n//        //    {\n//        //        Log.Error(\"‚ùå Failed to save flow. Error: {Error}. DTO: {@Dto}\", result.ErrorMessage, dto);\n//        //        return StatusCode(500, new\n//        //        {\n//        //            message = \"‚ùå Failed to save flow\",\n//        //            error = result.ErrorMessage\n//        //        });\n//        //    }\n\n//        //    // Expect service to put { flowId = <Guid> } into result.Data\n//        //    Guid? flowId = null;\n//        //    if (result.Data is not null)\n//        //    {\n//        //        try\n//        //        {\n//        //            // Support anonymous object or dictionary\n//        //            var dict = result.Data as IDictionary<string, object>;\n//        //            if (dict != null && dict.TryGetValue(\"flowId\", out var obj) && obj is Guid g1)\n//        //                flowId = g1;\n//        //            else\n//        //            {\n//        //                // dynamic fallback\n//        //                dynamic d = result.Data;\n//        //                flowId = (Guid?)d.flowId;\n//        //            }\n//        //        }\n//        //        catch { /* ignore shape issues; flowId stays null */ }\n//        //    }\n\n//        //    return Ok(new\n//        //    {\n//        //        message = \"‚úÖ Flow saved successfully\",\n//        //        flowId\n//        //    });\n//        //}\n\n//        [HttpGet(\"{id:guid}/usage\")]\n//        public async Task<IActionResult> GetUsage(Guid id)\n//        {\n//            var biz = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(biz, out var businessId)) return BadRequest(new { message = \"Invalid business.\" });\n\n//            var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n//            return Ok(new\n//            {\n//                canDelete = campaigns.Count == 0,\n//                count = campaigns.Count,\n//                campaigns\n//            });\n//        }\n\n//        //[HttpDelete(\"{id:guid}\")]\n//        //public async Task<IActionResult> Delete(Guid id)\n//        //{\n//        //    var biz = User.FindFirst(\"businessId\")?.Value;\n//        //    if (!Guid.TryParse(biz, out var businessId)) return BadRequest(new { message = \"Invalid business.\" });\n\n//        //    // Try hard delete\n//        //    var deleted = await _flowService.HardDeleteFlowIfUnusedAsync(id, businessId);\n//        //    if (deleted) return NoContent();\n\n//        //    // If not deleted, return 409 with who‚Äôs attached\n//        //    var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n//        //    if (campaigns.Count > 0)\n//        //    {\n//        //        return Conflict(new\n//        //        {\n//        //            message = \"Flow is attached to the following campaign(s). Delete them first, then delete the flow.\",\n//        //            campaigns\n//        //        });\n//        //    }\n\n//        //    // Not found (wrong tenant or already deleted)\n//        //    return NotFound(new { message = \"Flow not found.\" });\n//        //}\n//        // KEEP ONLY THIS ONE DELETE ENDPOINT\n\n//        [HttpDelete(\"{id:guid}\")]\n//        public async Task<IActionResult> Delete(Guid id)\n//        {\n//            var biz = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(biz, out var businessId))\n//                return BadRequest(new { message = \"‚ùå Invalid business.\" });\n\n//            // who is deleting (audit)\n//            var deletedBy = User.FindFirst(\"name\")?.Value\n//                          ?? User.FindFirst(\"email\")?.Value\n//                          ?? User.FindFirst(\"sub\")?.Value\n//                          ?? \"system\";\n\n//            // Use your service that understands attachment rules and returns codes\n//            var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n//            // Frontend expects 409 to show the modal with attached campaigns\n//            if (!result.Success && result.Code == 409)\n//                return Conflict(new { message = result.Message, campaigns = result.Payload });\n\n//            if (!result.Success && result.Code == 404)\n//                return NotFound(new { message = result.Message });\n\n//            if (!result.Success)\n//                return BadRequest(new { message = result.Message });\n\n//            // FE treats 200 or 204 as success ‚Äî return 200 with a message\n//            return Ok(new { message = result.Message });\n//        }\n\n\n\n//        [HttpGet(\"all-published\")]\n//        public async Task<IActionResult> GetPublishedFlows()\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"‚ùå Invalid business ID\");\n\n//            var flows = await _flowService.GetAllPublishedFlowsAsync(businessId);\n//            return Ok(flows);\n//        }\n//        [HttpGet(\"all-draft\")]\n//        public async Task<IActionResult> GetAllDraftFlows()\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"‚ùå Invalid business ID\");\n\n//            var flows = await _flowService.GetAllDraftFlowsAsync(businessId);\n//            return Ok(flows);\n//        }\n\n\n//        [HttpPost(\"execute-visual\")]\n//        public async Task<IActionResult> ExecuteVisualFlowAsync(\n//            [FromQuery] Guid nextStepId,\n//            [FromQuery] Guid trackingLogId,\n//            // ‚úÖ 1. ADD the new optional parameter to the endpoint\n//            [FromQuery] Guid? campaignSendLogId = null)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"‚ùå Invalid business ID\");\n\n//            // ‚úÖ 2. PASS the new parameter to the service call\n//            var result = await _flowService.ExecuteVisualFlowAsync(businessId, nextStepId, trackingLogId, campaignSendLogId);\n\n//            if (result.Success)\n//                return Ok(result);\n//            else\n//                return BadRequest(result);\n//        }\n\n//        [HttpPost(\"create-config\")]\n//        public async Task<IActionResult> CreateConfigFlow([FromBody] CreateFlowDto dto)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//            if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"‚ùå Invalid or missing businessId claim.\");\n\n//            try\n//            {\n//                var id = await _flowService.CreateFlowWithStepsAsync(dto, businessId, createdBy);\n\n//                return Ok(new\n//                {\n//                    flowId = id,\n//                    message = \"‚úÖ Flow config created successfully.\"\n//                });\n//            }\n//            catch (Exception ex)\n//            {\n//                return StatusCode(500, new\n//                {\n//                    error = \"‚ùå Failed to create flow config.\",\n//                    details = ex.Message\n//                });\n//            }\n//        }\n\n//        [HttpGet(\"by-id/{id:guid}\")]\n//        public async Task<IActionResult> GetById(Guid id)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"‚ùå Invalid business ID\");\n\n//            // Prefer a tenant-aware service method\n//            var dto = await _flowService.GetVisualFlowByIdAsync(id, businessId);\n//            if (dto is null) return NotFound(\"‚ùå Flow not found.\");\n\n//            return Ok(dto); // { flowName, isPublished, nodes, edges } (camelCase via default JSON options)\n//        }\n\n//        // üìç Add this to your CTAFlowController\n//        // CTAFlowController.cs  ‚Äî drop-in replacement for \"get visual flow\" endpoint\n//        [HttpGet(\"visual/{id:guid}\")]\n//        public async Task<IActionResult> GetVisualFlow(Guid id)\n//        {\n//            // business guard\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(new { message = \"‚ùå Failed to load flow\", error = \"Invalid business ID\" });\n\n//            // ask the service ‚Äî this RETURNS YOUR ResponseResult, not a DTO\n//            var result = await _flowService.GetVisualFlowAsync(id, businessId);\n\n//            // Uniform error mapping (same style you use in SaveVisualFlow)\n//            if (!result.Success)\n//            {\n//                var m = (result.ErrorMessage ?? string.Empty).Trim();\n\n//                if (m.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    // 404 when flow id doesn‚Äôt exist / not visible for biz\n//                    return NotFound(new { message = \"‚ùå Failed to load flow\", error = m });\n//                }\n\n//                if (m.Contains(\"forbidden\", StringComparison.OrdinalIgnoreCase) ||\n//                    m.Contains(\"unauthorized\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    // 403 when biz is not allowed to see this flow\n//                    return StatusCode(StatusCodes.Status403Forbidden,\n//                        new { message = \"‚ùå Failed to load flow\", error = m });\n//                }\n\n//                // default ‚Üí 500\n//                return StatusCode(StatusCodes.Status500InternalServerError,\n//                    new { message = \"‚ùå Failed to load flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n//            }\n\n//            // SUCCESS: your service already builds the payload (FlowName, IsPublished, Nodes, Edges, etc.)\n//            // Just return it as-is so the FE can consume it.\n//            // Example shape expected by FE:\n//            // { flowName, isPublished, nodes: [...], edges: [...] }\n//            return Ok(result.Data);\n//        }\n\n\n//        //[HttpPut(\"{id:guid}\")]\n//        //public async Task<IActionResult> Update(Guid id, [FromBody] SaveVisualFlowDto dto)\n//        //{\n//        //    var biz = User.FindFirst(\"businessId\")?.Value;\n//        //    var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n//        //    if (!Guid.TryParse(biz, out var businessId)) return BadRequest(\"‚ùå Invalid business.\");\n\n//        //    var result = await _flowService.UpdateVisualFlowAsync(id, dto, businessId, user);\n//        //    return result.Status switch\n//        //    {\n//        //        \"ok\" => Ok(new { message = \"Flow updated.\", needsRepublish = result.NeedsRepublish }),\n//        //        \"requiresFork\" => Conflict(new { message = result.Message, campaigns = result.Campaigns, requiresFork = true }),\n//        //        \"notFound\" => NotFound(\"‚ùå Flow not found.\"),\n//        //        _ => BadRequest(new { message = result.Message ?? \"Unknown error\" })\n//        //    };\n//        //}\n\n\n//        [HttpPost(\"{id:guid}/publish\")]\n//        public async Task<IActionResult> Publish(Guid id)\n//        {\n//            var biz = User.FindFirst(\"businessId\")?.Value;\n//            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n//            if (!Guid.TryParse(biz, out var businessId)) return BadRequest(\"‚ùå Invalid business.\");\n\n//            var ok = await _flowService.PublishFlowAsync(id, businessId, user);\n//            return ok ? Ok(new { message = \"‚úÖ Flow published.\" }) : NotFound(\"‚ùå Flow not found.\");\n//        }\n\n\n//        //// üëá NEW: publish\n//        //[HttpPost(\"{id:guid}/publish\")]\n//        //public async Task<IActionResult> Publish(Guid id)\n//        //{\n//        //    var biz = User.FindFirst(\"businessId\")?.Value;\n//        //    var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n//        //    if (!Guid.TryParse(biz, out var businessId)) return BadRequest(\"‚ùå Invalid business.\");\n\n//        //    var ok = await _flowService.PublishFlowAsync(id, businessId, user);\n//        //    return ok ? Ok(new { message = \"‚úÖ Flow published.\" }) : NotFound(\"‚ùå Flow not found.\");\n//        //}\n\n\n\n//        // üëá NEW: fork (create new draft from live-locked flow)\n//        [HttpPost(\"{id:guid}/fork\")]\n//        public async Task<IActionResult> Fork(Guid id)\n//        {\n//            var biz = User.FindFirst(\"businessId\")?.Value;\n//            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n//            if (!Guid.TryParse(biz, out var businessId)) return BadRequest(\"‚ùå Invalid business.\");\n\n//            var forkId = await _flowService.ForkFlowAsync(id, businessId, user);\n//            if (forkId == Guid.Empty) return NotFound(\"‚ùå Flow not found.\");\n//            return Ok(new { flowId = forkId });\n//        }\n\n//        // üëá BACK-COMPAT: keep existing delete route AND add /{id}\n//       // [HttpDelete(\"{id:guid}\")]\n//        //public async Task<IActionResult> DeletePlain(Guid id)\n//        //{\n//        //    var biz = User.FindFirst(\"businessId\")?.Value;\n//        //    if (!Guid.TryParse(biz, out var businessId))\n//        //        return BadRequest(\"‚ùå Invalid business ID\");\n\n//        //    // Capture the user performing the delete\n//        //    var deletedBy = User.FindFirst(\"name\")?.Value\n//        //                 ?? User.FindFirst(\"email\")?.Value\n//        //                 ?? User.FindFirst(\"sub\")?.Value\n//        //                 ?? \"system\";\n\n//        //    var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n//        //    if (!result.Success && result.Code == 409)\n//        //        return Conflict(new { message = result.Message, campaigns = result.Payload });\n\n//        //    if (!result.Success && result.Code == 404)\n//        //        return NotFound(new { message = result.Message });\n\n//        //    if (!result.Success)\n//        //        return BadRequest(new { message = result.Message });\n\n//        //    return Ok(new { message = result.Message });\n//        //}\n\n//    }\n\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs",
      "sha256": "8d5442a0a0fdb92dc7d69837cd74af882b22c6cf35ce999a7b87bfde5b27e7ca",
      "language": "csharp",
      "size": 2686,
      "content": "// üìÑ Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Infrastructure.Flows;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"r/flow\")]\n    public class FlowRedirectController : ControllerBase\n    {\n        private readonly IFlowClickTokenService _tokens;\n        private readonly ICTAFlowService _flows;           // service to read flow steps/links\n        private readonly IFlowRuntimeService _runtime;     // service to execute next step\n\n        public FlowRedirectController(\n            IFlowClickTokenService tokens,\n            ICTAFlowService flows,\n            IFlowRuntimeService runtime)\n        {\n            _tokens = tokens;\n            _flows = flows;\n            _runtime = runtime;\n        }\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous] // secure by token, tenant checks inside\n        public async Task<IActionResult> RedirectByToken(string token)\n        {\n            FlowClickPayload p;\n            try\n            {\n                p = _tokens.Validate(token);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest($\"Invalid or expired token: {ex.Message}\");\n            }\n\n            // üîí Tenant isolation: make sure the business in the token matches the current request context\n            // (if you have multi-tenant enforcement middleware, call it here)\n\n            // 1) Resolve the button link\n            var link = await _flows.GetLinkAsync(p.fid, p.sid, p.bi);\n            if (link is null)\n                return NotFound(\"Link not found for this flow step\");\n\n            var requestId = Guid.NewGuid(); // for idempotency\n            var exec = await _runtime.ExecuteNextAsync(new NextStepContext\n            {\n                BusinessId = p.biz,\n                FlowId = p.fid,\n                Version = p.ver,\n                SourceStepId = p.sid,\n                TargetStepId = link.NextStepId, // may be null ‚Üí terminal\n                ButtonIndex = p.bi,\n                MessageLogId = p.mlid,\n                ContactPhone = p.cp,\n                RequestId = requestId,\n\n                // üÜï Pass the clicked button for runtime decision\n                ClickedButton = link\n            });\n\n\n            // 3) Redirect the user\n            // If button was a URL, use that; else go to a generic \"thank you\" page\n            var dest = exec.RedirectUrl ?? \"/thank-you\";\n            return Redirect(dest);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/AttachedCampaignDto.cs",
      "sha256": "0d3666aab91197bf746299620d01d22712744acbbcb28b0a787a8e399eaf123f",
      "language": "csharp",
      "size": 341,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed record AttachedCampaignDto(\n        Guid Id,\n        string Name,\n        string Status,\n        DateTime? ScheduledAt,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? FirstSentAt   // earliest non-null SentAt from CampaignSendLogs\n    );\n\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs",
      "sha256": "c23400a06816a2adc8886fa8d20dd77f12b8b93f993b5a772d81cb12d6612a1f",
      "language": "csharp",
      "size": 897,
      "content": "// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CreateFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowStepDto> Steps { get; set; } = new();\n        public bool IsPublished { get; set; } = false; // ‚úÖ NEW: Draft vs Published\n    }\n\n    public class FlowStepDto\n    {\n        public string TriggerButtonText { get; set; } = string.Empty;\n        public string TriggerButtonType { get; set; } = string.Empty;\n        public string TemplateToSend { get; set; } = string.Empty;\n        public int StepOrder { get; set; }\n        public List<ButtonLinkDto> ButtonLinks { get; set; } = new();\n    }\n\n    public class ButtonLinkDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid NextStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAButtonClickDto.cs",
      "sha256": "da355d853887193eb1d2b3e3fafcf076e6df764f0220cbf10f5c050d42b91df6",
      "language": "csharp",
      "size": 432,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAButtonClickDto\n    {\n        [Required]\n        public string ButtonText { get; set; } = string.Empty;\n\n        [Required]\n        public string ButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\", \"url\", etc.\n\n        [Required]\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAFlowExecutionRequest.cs",
      "sha256": "43fc0e1c1674d188b1a5385539f1314176ff81449d4547ea6665df9909a223bb",
      "language": "csharp",
      "size": 297,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAFlowExecutionRequest\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"cta\";\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CtaFlowRunResult.cs",
      "sha256": "2a042b3a78e66a762ca685c50cc13508c063fd3076e291597275bbc64620e6a1",
      "language": "csharp",
      "size": 433,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class CtaFlowRunResult\n    {\n        /// <summary>\n        /// True if the CTA flow was started/executed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Optional human-readable error message when Success = false.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowEdgeDto.cs",
      "sha256": "27e76e22a8aba502d5727d9959bec58ea011d2a1f0d4388a141bfa8108043eea",
      "language": "csharp",
      "size": 272,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowEdgeDto\n    {\n        public string FromNodeId { get; set; } = string.Empty;\n        public string ToNodeId { get; set; } = string.Empty;\n        public string? SourceHandle { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowNodeDto.cs",
      "sha256": "93c74e7a37bfe6a0a4538a39a3a942b2cf1c38fd11747714ba384590a18e2ec5",
      "language": "csharp",
      "size": 1221,
      "content": "    namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowNodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n\n        public string TemplateName { get; set; } = string.Empty;\n        public string? TemplateType { get; set; } // ‚úÖ e.g., \"image_template\", \"text_template\"\n        public string MessageBody { get; set; } = string.Empty;\n        public string? TriggerButtonText { get; set; }\n        public string? TriggerButtonType { get; set; }\n        public float PositionX { get; set; }\n        public float PositionY { get; set; }\n\n        public string? RequiredTag { get; set; }         \n        public string? RequiredSource { get; set; }      \n        public List<LinkButtonDto> Buttons { get; set; } = new();\n        public bool UseProfileName { get; set; }\n        public int? ProfileNameSlot { get; set; }\n        //(for flow trigger mapping)\n        // ‚úÖ NEW: ReactFlow expects this structure\n        public PositionDto Position => new PositionDto\n        {\n            x = PositionX,\n            y = PositionY\n        };\n        public class PositionDto\n        {\n            public float x { get; set; }\n            public float y { get; set; }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowUpdateResult.cs",
      "sha256": "54f722166617e3353652e949aa4a89c87878d4a1d30d2e208a1fb816668d0dde",
      "language": "csharp",
      "size": 443,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class FlowUpdateResult\n    {\n        // ok | requiresFork | notFound | error\n        public string Status { get; set; } = \"ok\";\n        public string? Message { get; set; }\n        public bool NeedsRepublish { get; set; } // true when we flipped published->draft to allow editing\n        public object? Campaigns { get; set; }   // list for UI when requiresFork\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/LinkButtonDto.cs",
      "sha256": "e02e2c927a96e1e02c0537fb205fd7595289bdfaa9de15c0d7a55de64a90fbc5",
      "language": "csharp",
      "size": 522,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class LinkButtonDto\n    {\n        public string Text { get; set; } = string.Empty;\n        public int Index { get; set; } = -1;\n        public string? Type { get; set; } // üî• e.g., \"URL\", \"QUICK_REPLY\"\n        public string? SubType { get; set; } // üî• e.g., \"STATIC\", \"DYNAMIC\"\n        public string? Value { get; set; } // üî• the parameter or url or payload\n\n        public string? TargetNodeId { get; set; } // üîÑ used for flow linking\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/SaveVisualFlowDto.cs",
      "sha256": "7de59d222a97efeaf9dc23dea2ef351d852087539cec12e7c946b02e11f1bd21",
      "language": "csharp",
      "size": 403,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class SaveVisualFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n        public Guid? CampaignId { get; set; } // ‚úÖ Add this line\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowLoadDto.cs",
      "sha256": "10bfe378ffd4c8fb74a0746f2abafec88897072e7a974d680396bde281aaf4af",
      "language": "csharp",
      "size": 289,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowLoadDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowSummaryDto.cs",
      "sha256": "70dcedd3219a474a4b38927e0f0fd4ff3e21ba16632d409f146a9d0d60d685a5",
      "language": "csharp",
      "size": 300,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowClickLog.cs",
      "sha256": "ecbd408e613e8ef88e2bb39fdf60bc188163e209d8242317203dfb2bff8cebb8",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class CTAFlowClickLog\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs",
      "sha256": "a36019c3ace9f06dcc785152a4ea8e2acc280b169f9e831a28fd6efd2f9d2551",
      "language": "csharp",
      "size": 3404,
      "content": "// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n    /// </summary>\n    public class CTAFlowConfig\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string FlowName { get; set; } = string.Empty;\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsPublished { get; set; } = false; // ‚úÖ NEW: Support draft/published\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n        public DateTime? UpdatedAt { get; set; }  // ‚úÖ Add this line\n\n        // üîÅ Navigation to steps\n        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n    }\n}\n\n// üìÑ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\n//using System.ComponentModel.DataAnnotations;\n//using System.Text.Json.Serialization;\n//using Microsoft.EntityFrameworkCore;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Models\n//{\n//    /// <summary>\n//    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n//    /// </summary>\n//    [Index(nameof(BusinessId), nameof(IsActive), nameof(FlowName), Name = \"ix_ctaflowconfigs_biz_active_name\")]\n//    [Index(nameof(BusinessId), nameof(IsPublished), Name = \"ix_ctaflowconfigs_biz_published\")]\n//    public class CTAFlowConfig\n//    {\n//        [Key]\n//        public Guid Id { get; set; }\n\n//        [Required]\n//        public Guid BusinessId { get; set; }\n\n//        [Required, MaxLength(100)]\n//        public string FlowName { get; set; } = string.Empty;\n\n//        /// <summary>\n//        /// Soft ‚Äúenabled/disabled‚Äù flag for listing/selection. We still hard-delete unused flows on request.\n//        /// </summary>\n//        public bool IsActive { get; set; } = true;\n\n//        /// <summary>\n//        /// Draft vs published for the builder.\n//        /// </summary>\n//        public bool IsPublished { get; set; } = false;\n\n//        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n//        public string? CreatedBy { get; set; }\n\n//        /// <summary>\n//        /// Last modification timestamp (updated in service on edits).\n//        /// </summary>\n//        public DateTime? UpdatedAt { get; set; }\n\n//        /// <summary>\n//        /// Optimistic concurrency token to avoid race conditions (e.g., editing while someone tries to delete).\n//        /// </summary>\n//        [Timestamp]\n//        public byte[]? RowVersion { get; set; }\n\n//        // üîÅ Navigation to steps\n//        // Cascade delete is configured in OnModelCreating:\n//        // modelBuilder.Entity<CTAFlowConfig>()\n//        //   .HasMany(f => f.Steps).WithOne(s => s.Flow)\n//        //   .HasForeignKey(s => s.FlowId)\n//        //   .OnDelete(DeleteBehavior.Cascade);\n//        [JsonIgnore] // prevent huge payloads if you serialize configs somewhere else\n//        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowStep.cs",
      "sha256": "a0c230aa38fa4980c6dff6a4bfc2466ae805f9179280d41cc7b1ca975054e03f",
      "language": "csharp",
      "size": 1608,
      "content": "// üìÑ File: Features/CTAFlowBuilder/Models/CTAFlowStep.cs\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a single step in a CTA flow, triggered by a button.\n    /// </summary>\n    public class CTAFlowStep\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid CTAFlowConfigId { get; set; }\n\n        [ForeignKey(nameof(CTAFlowConfigId))]\n        public CTAFlowConfig Flow { get; set; } = null!;\n\n        public string TriggerButtonText { get; set; } = string.Empty;\n\n        public string TriggerButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\"\n\n        public string TemplateToSend { get; set; } = string.Empty;\n\n        public int StepOrder { get; set; }\n\n        public string? RequiredTag { get; set; }        // e.g., \"interested\"\n        public string? RequiredSource { get; set; }     // e.g., \"ads\", \"qr\", \"manual\"\n\n        // üîÄ Multiple buttons linking to different steps\n        public List<FlowButtonLink> ButtonLinks { get; set; } = new();\n\n        public float? PositionX { get; set; }\n        public float? PositionY { get; set; }\n        public string? TemplateType { get; set; }\n\n        // ‚úÖ Use WhatsApp Profile Name in this step's template?\n        public bool UseProfileName { get; set; } = false;\n\n        // ‚úÖ 1-based placeholder index in the template body (e.g., {{1}})\n        public int? ProfileNameSlot { get; set; } = 1;\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowButtonLink.cs",
      "sha256": "6b265bc48b8286ca84e5937f9f8f6fe99b8b6580ca59a43aedda8290fc685aaa",
      "language": "csharp",
      "size": 807,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class FlowButtonLink\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? NextStepId { get; set; }\n        // ‚úÖ NEW FIELDS FOR FUTURE AUTOMATION\n        public string ButtonType { get; set; } = \"QUICK_REPLY\";    // e.g., URL, QUICK_REPLY, FLOW\n        public string ButtonSubType { get; set; } = \"\";            // Optional: e.g., \"Catalog\", \"PricingCTA\"\n        public string ButtonValue { get; set; } = \"\";              // e.g., URL or deep link\n\n        // Optional FK back to Step if needed\n        public Guid CTAFlowStepId { get; set; }\n        public CTAFlowStep? Step { get; set; }\n\n        public short ButtonIndex { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionContext.cs",
      "sha256": "3b09934afbf7d4d7844c890fde23a96a3ba4d932fa506268da131b78ac6b5385",
      "language": "csharp",
      "size": 4023,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Canonical context/payload for logging a single flow step execution.\n    /// This wraps all the information we want to write into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionContext\n    {\n        /// <summary>\n        /// Tenant / business that owns this flow execution.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional contact this journey is associated with.\n        /// </summary>\n        public Guid? ContactId { get; set; }   // üëà ADD THIS\n\n        /// <summary>\n        /// Which engine started this journey (Campaign, AutoReply, etc.).\n        /// </summary>\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown;\n\n        /// <summary>\n        /// Logical flow definition. For CTA flows this is CTAFlowConfig.Id.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// Step being executed.\n        /// </summary>\n        public Guid StepId { get; set; }\n\n        /// <summary>\n        /// Optional friendly name for the step.\n        /// </summary>\n        public string? StepName { get; set; }\n\n        /// <summary>\n        /// Optional correlation id for one \"run\" of a journey.\n        /// Multiple steps in the same journey can share RunId.\n        /// </summary>\n        public Guid? RunId { get; set; }\n\n        /// <summary>\n        /// Optional higher-level campaign this journey belongs to.\n        /// </summary>\n        public Guid? CampaignId { get; set; }\n\n        /// <summary>\n        /// Optional AutoReplyFlow id when journey started from keyword matching.\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// Optional specific send log (CampaignSendLog) if this was tied to a blast.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; set; }\n\n        /// <summary>\n        /// Optional tracking log id (CTA click tracking, etc.).\n        /// </summary>\n        public Guid? TrackingLogId { get; set; }\n\n        /// <summary>\n        /// Optional link to underlying MessageLog row.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n\n        /// <summary>\n        /// Phone number in E.164 form that this step is interacting with.\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        /// <summary>\n        /// Human-readable label of the button that triggered the step, if any.\n        /// </summary>\n        public string? TriggeredByButton { get; set; }\n\n        /// <summary>\n        /// Index of the clicked button (0..2) where applicable.\n        /// </summary>\n        public short? ButtonIndex { get; set; }\n\n        /// <summary>\n        /// Template name that was used in this step (if any).\n        /// </summary>\n        public string? TemplateName { get; set; }\n\n        /// <summary>\n        /// Template type / category (e.g. \"image_template\", \"text_template\").\n        /// </summary>\n        public string? TemplateType { get; set; }\n\n        /// <summary>\n        /// Per-request correlation id (can come from message engine, HTTP request, etc.).\n        /// </summary>\n        public Guid? RequestId { get; set; }\n\n        /// <summary>\n        /// Whether the step action completed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Error message when the step failed.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n\n        /// <summary>\n        /// Raw provider response or internal payload for debugging.\n        /// </summary>\n        public string? RawResponse { get; set; }\n\n        /// <summary>\n        /// When the step was executed (UTC).\n        /// If null, the logger will default to DateTime.UtcNow.\n        /// </summary>\n        public DateTime? ExecutedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionLog.cs",
      "sha256": "d859aa17be20179548d281edae56a6d0fb7b5321f5bd49144ada2ba82ad8e5a4",
      "language": "csharp",
      "size": 1635,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Logs when a visual flow step is executed (useful for analytics, debugging, audit).\n    /// </summary>\n    public class FlowExecutionLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n\n        public Guid? FlowId { get; set; }\n\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown; //new\n\n        public Guid? CampaignId { get; set; } // new \n        public Guid? AutoReplyFlowId { get; set; } // new\n\n        public Guid? CampaignSendLogId { get; set; }\n\n\n        public Guid? TrackingLogId { get; set; }\n\n        public string? ContactPhone { get; set; }\n\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        public bool Success { get; set; }\n\n        public string? ErrorMessage { get; set; }\n\n        public string? RawResponse { get; set; }\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n\n        public Guid? MessageLogId { get; set; }              // tie to originating message\n        public short? ButtonIndex { get; set; }              // which button was clicked (0..2)\n        public Guid? RequestId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionOrigin.cs",
      "sha256": "34b36adc1c0b157360c81e219a5fc265c18612efb937a62fcbea1405a41280a7",
      "language": "csharp",
      "size": 1131,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Describes where a flow execution was started from.\n    /// This is the key for analytics segmentation.\n    /// </summary>\n    public enum FlowExecutionOrigin\n    {\n        /// <summary>\n        /// Default / legacy rows before origin tracking was introduced.\n        /// </summary>\n        Unknown = 0,\n\n        /// <summary>\n        /// Flow started as part of a Campaign CTA (button click, deep link, etc.).\n        /// </summary>\n        Campaign = 1,\n\n        /// <summary>\n        /// Flow started from AutoReply word matching (keyword ‚Üí flow).\n        /// </summary>\n        AutoReply = 2,\n\n        /// <summary>\n        /// Flow started from a future ‚ÄúJourneyBot‚Äù or similar orchestration engine.\n        /// </summary>\n        JourneyBot = 3,\n\n        /// <summary>\n        /// Flow started manually from Inbox or agent tools.\n        /// </summary>\n        Inbox = 4,\n\n        /// <summary>\n        /// System-driven or other internal triggers (backfill, test, etc.).\n        /// </summary>\n        System = 5\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs",
      "sha256": "380d5227b25215b5baaf9496aa9410b6dbec2b75c883bf875ec25f707dd0b5d6",
      "language": "csharp",
      "size": 19163,
      "content": "// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // üëà Keep this if AppDbContext is in the root namespace\n// If AppDbContext lives under xbytechat.api.Data, then use:\n// using xbytechat.api.Data;\n\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Enums;\nusing xbytechat.api.Features.MessagesEngine.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Minimal CTA flow runtime engine (v1).\n    ///\n    /// Responsibilities:\n    /// - Load CTAFlowConfig + steps from DB.\n    /// - Execute the first step (template send) using IMessageEngineService.\n    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n    ///\n    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n    /// can later separate:\n    ///   - \"CTA flow started by AutoReply\"\n    ///   - \"CTA flow started by Campaign button\"\n    ///   - other origins (JourneyBot, Inbox, System).\n    /// </summary>\n    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly IFlowExecutionLogger _flowLogger;\n        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n        public CtaFlowRuntimeService(\n            AppDbContext db,\n            IMessageEngineService messageEngine,\n            IFlowExecutionLogger flowLogger,\n            ILogger<CtaFlowRuntimeService> logger)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n            if (configId == Guid.Empty)\n                throw new ArgumentException(\"configId is required\", nameof(configId));\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n            _logger.LogInformation(\n                \"üöÄ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n                businessId,\n                contactId,\n                contactPhone,\n                configId,\n                origin,\n                autoReplyFlowId);\n\n            // 1Ô∏è‚É£ Load the CTA flow (must be active + published) with its steps\n            var flow = await _db.CTAFlowConfigs\n                .AsNoTracking()\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(\n                    f => f.Id == configId\n                         && f.BusinessId == businessId\n                         && f.IsActive\n                         && f.IsPublished,\n                    cancellationToken);\n\n            if (flow == null)\n            {\n                var message =\n                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                // Log a failed \"meta-step\" so analytics can see the failure\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = configId,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log which contact we tried to start for\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = configId,          // no specific step; use flow id as placeholder\n                    StepName = \"FLOW_NOT_FOUND\",\n\n                    // No template here\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            // 2Ô∏è‚É£ Pick the first step (v1 = simple linear flow)\n            var firstStep = flow.Steps\n                .OrderBy(s => s.StepOrder)\n                .FirstOrDefault();\n\n            if (firstStep == null)\n            {\n                var message =\n                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = flow.Id,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log contact context even on failure\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = flow.Id,\n                    StepName = \"NO_STEPS\",\n\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            _logger.LogInformation(\n                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n                firstStep.Id,\n                firstStep.TemplateToSend,\n                flow.Id,\n                flow.FlowName);\n\n            // 3Ô∏è‚É£ Build SimpleTemplateMessageDto with CTA tracking fields\n            var templateDto = new SimpleTemplateMessageDto\n            {\n                RecipientNumber = contactPhone,\n                TemplateName = firstStep.TemplateToSend,\n\n                // v1: no dynamic params here ‚Äì flows can be extended later\n                TemplateParameters = new List<string>(),\n\n                // v1: let MessageEngine choose routing / provider\n                HasStaticButtons = false,\n                Provider = string.Empty,\n                PhoneNumberId = null,\n\n                // üîó Link back to CTA flow config + step\n                CTAFlowConfigId = flow.Id,\n                CTAFlowStepId = firstStep.Id,\n\n                // Optional fields ‚Äì keep null for now\n                TemplateBody = null,\n                LanguageCode = null\n            };\n\n            // 4Ô∏è‚É£ Send the message via MessageEngine (conversational ‚Üí Immediate)\n            var sendResult = await _messageEngine\n                .SendTemplateMessageSimpleAsync(\n                    businessId,\n                    templateDto,\n                    DeliveryMode.Immediate);\n\n            // 5Ô∏è‚É£ Log the step into FlowExecutionLogs\n            var logCtx = new FlowExecutionContext\n            {\n                BusinessId = businessId,\n                FlowId = flow.Id,\n                AutoReplyFlowId = autoReplyFlowId,\n                Origin = origin,\n\n                // Contact context\n                ContactId = contactId,\n                ContactPhone = contactPhone,\n\n                // Step context\n                StepId = firstStep.Id,\n                StepName = firstStep.TemplateToSend,\n\n                // Template metadata for analytics\n                TemplateName = firstStep.TemplateToSend,\n                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n                // Result\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                ExecutedAtUtc = DateTime.UtcNow\n\n                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n                // can be wired later once message engine returns those ids.\n            };\n\n            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n            return new CtaFlowRunResult\n            {\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message\n            };\n        }\n    }\n}\n\n\n//// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api; // üëà Keep this if AppDbContext is in the root namespace\n//// If AppDbContext lives under xbytechat.api.Data, then use:\n//// using xbytechat.api.Data;\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Minimal CTA flow runtime engine (v1).\n//    ///\n//    /// Responsibilities:\n//    /// - Load CTAFlowConfig + steps from DB.\n//    /// - Execute the first step (template send) using IMessageEngineService.\n//    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n//    ///\n//    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n//    /// can later separate:\n//    ///   - \"CTA flow started by AutoReply\"\n//    ///   - \"CTA flow started by Campaign button\"\n//    ///   - other origins (JourneyBot, Inbox, System).\n//    /// </summary>\n//    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IMessageEngineService _messageEngine;\n//        private readonly IFlowExecutionLogger _flowLogger;\n//        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n//        public CtaFlowRuntimeService(\n//            AppDbContext db,\n//            IMessageEngineService messageEngine,\n//            IFlowExecutionLogger flowLogger,\n//            ILogger<CtaFlowRuntimeService> logger)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n//            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n//            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n//        }\n\n//        public async Task<CtaFlowRunResult> StartFlowAsync(\n//            Guid businessId,\n//            Guid contactId,\n//            string contactPhone,\n//            Guid configId,\n//            FlowExecutionOrigin origin,\n//            Guid? autoReplyFlowId,\n//            CancellationToken cancellationToken = default)\n//        {\n//            if (businessId == Guid.Empty)\n//                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n//            if (configId == Guid.Empty)\n//                throw new ArgumentException(\"configId is required\", nameof(configId));\n//            if (string.IsNullOrWhiteSpace(contactPhone))\n//                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n//            _logger.LogInformation(\n//                \"üöÄ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n//                businessId,\n//                contactId,\n//                contactPhone,\n//                configId,\n//                origin,\n//                autoReplyFlowId);\n\n//            // 1Ô∏è‚É£ Load the CTA flow (must be active + published) with its steps\n//            var flow = await _db.CTAFlowConfigs\n//                .AsNoTracking()\n//                .Include(f => f.Steps)\n//                .FirstOrDefaultAsync(\n//                    f => f.Id == configId\n//                         && f.BusinessId == businessId\n//                         && f.IsActive\n//                         && f.IsPublished,\n//                    cancellationToken);\n\n//            if (flow == null)\n//            {\n//                var message =\n//                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                // Log a failed \"meta-step\" so analytics can see the failure\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = configId,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log which contact we tried to start for\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = configId,          // no specific step; use flow id as placeholder\n//                    StepName = \"FLOW_NOT_FOUND\",\n\n//                    // No template here\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            // 2Ô∏è‚É£ Pick the first step (v1 = simple linear flow)\n//            var firstStep = flow.Steps\n//                .OrderBy(s => s.StepOrder)\n//                .FirstOrDefault();\n\n//            if (firstStep == null)\n//            {\n//                var message =\n//                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = flow.Id,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log contact context even on failure\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = flow.Id,\n//                    StepName = \"NO_STEPS\",\n\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            _logger.LogInformation(\n//                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n//                firstStep.Id,\n//                firstStep.TemplateToSend,\n//                flow.Id,\n//                flow.FlowName);\n\n//            // 3Ô∏è‚É£ Build SimpleTemplateMessageDto with CTA tracking fields\n//            var templateDto = new SimpleTemplateMessageDto\n//            {\n//                RecipientNumber = contactPhone,\n//                TemplateName = firstStep.TemplateToSend,\n\n//                // v1: no dynamic params here ‚Äì flows can be extended later\n//                TemplateParameters = new List<string>(),\n\n//                // v1: let MessageEngine choose routing / provider\n//                HasStaticButtons = false,\n//                Provider = string.Empty,\n//                PhoneNumberId = null,\n\n//                // üîó Link back to CTA flow config + step\n//                CTAFlowConfigId = flow.Id,\n//                CTAFlowStepId = firstStep.Id,\n\n//                // Optional fields ‚Äì keep null for now\n//                TemplateBody = null,\n//                LanguageCode = null\n//            };\n\n//            // 4Ô∏è‚É£ Send the message via MessageEngine\n//            var sendResult = await _messageEngine\n//                .SendTemplateMessageSimpleAsync(businessId, templateDto);\n\n//            // 5Ô∏è‚É£ Log the step into FlowExecutionLogs\n//            var logCtx = new FlowExecutionContext\n//            {\n//                BusinessId = businessId,\n//                FlowId = flow.Id,\n//                AutoReplyFlowId = autoReplyFlowId,\n//                Origin = origin,\n\n//                // Contact context\n//                ContactId = contactId,\n//                ContactPhone = contactPhone,\n\n//                // Step context\n//                StepId = firstStep.Id,\n//                StepName = firstStep.TemplateToSend,\n\n//                // Template metadata for analytics\n//                TemplateName = firstStep.TemplateToSend,\n//                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n//                // Result\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n//                ExecutedAtUtc = DateTime.UtcNow\n\n//                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n//                // can be wired later once message engine returns those ids.\n//            };\n\n//            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n//            return new CtaFlowRunResult\n//            {\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message\n//            };\n//        }\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CTAFlowService.cs",
      "sha256": "647faa0c1f8d4e2e42ac6ffae7449e92587cd1a31ec8e1f59e294e3f55c21d1d",
      "language": "csharp",
      "size": 102836,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class CTAFlowService : ICTAFlowService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n        public CTAFlowService(\n            AppDbContext context,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService)\n        {\n            _context = context;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n        }\n\n        // ---------------------------\n        // CREATE (draft-only, no edit)\n        // ---------------------------\n        public async Task<ResponseResult> SaveVisualFlowAsync(\n            SaveVisualFlowDto dto,\n            Guid businessId,\n            string createdBy)\n        {\n            try\n            {\n                Log.Information(\"üß† SaveVisualFlow (create-only) | FlowName: {FlowName} | Biz: {BusinessId}\",\n                    dto.FlowName, businessId);\n\n                // 0) Validate\n                if (dto.Nodes == null || !dto.Nodes.Any())\n                    return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n\n                var trimmedName = (dto.FlowName ?? \"\").Trim();\n                if (trimmedName.Length == 0)\n                    return ResponseResult.ErrorInfo(\"‚ùå Flow name is required.\");\n\n                // 1) Enforce unique active name per business (create-only)\n                var nameExists = await _context.CTAFlowConfigs\n                    .AnyAsync(f => f.BusinessId == businessId && f.FlowName == trimmedName && f.IsActive);\n                if (nameExists)\n                {\n                    Log.Warning(\"‚ö†Ô∏è Duplicate flow name '{Name}' for business {Biz}.\", trimmedName, businessId);\n                    return ResponseResult.ErrorInfo(\"‚ùå A flow with this name already exists.\");\n                }\n\n                await using var tx = await _context.Database.BeginTransactionAsync();\n\n                // 2) Insert FlowConfig AS DRAFT (force IsPublished=false)\n                var flow = new CTAFlowConfig\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    FlowName = trimmedName,\n                    CreatedBy = createdBy,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    IsActive = true,\n                    IsPublished = false // << always draft on create\n                };\n                _context.CTAFlowConfigs.Add(flow);\n\n                // 3) Steps (map incoming node ids so we can wire links)\n                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n                var orderIndex = 0;\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n                    var step = new CTAFlowStep\n                    {\n                        Id = Guid.NewGuid(),\n                        CTAFlowConfigId = flow.Id,\n                        StepOrder = orderIndex++,\n                        TemplateToSend = node.TemplateName,\n                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n                        UseProfileName = node.UseProfileName,\n                        ProfileNameSlot = node.ProfileNameSlot,\n                        ButtonLinks = new List<FlowButtonLink>()\n                    };\n\n                    // Only text templates may use profile name slot\n                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n                    if (!isTextTemplate)\n                    {\n                        step.UseProfileName = false;\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.UseProfileName)\n                    {\n                        step.ProfileNameSlot = null;\n                    }\n                    else if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n                    {\n                        step.ProfileNameSlot = 1;\n                    }\n\n                    stepMap[node.Id] = step;\n                    _context.CTAFlowSteps.Add(step);\n                }\n\n                // 4) Wire links per node via edges (SourceHandle == button text)\n                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n                foreach (var node in dto.Nodes)\n                {\n                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n                        continue;\n\n                    var outEdges = edges\n                        .Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase))\n                        .ToList();\n\n                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n                        .ThenBy(b => b.Text ?? string.Empty)\n                        .ToList();\n\n                    short nextIdx = 0;\n\n                    foreach (var btn in orderedButtons)\n                    {\n                        var text = (btn.Text ?? string.Empty).Trim();\n                        if (string.IsNullOrEmpty(text)) continue;\n                        if (!seenTexts.Add(text)) continue; // dedupe\n\n                        var edge = outEdges.FirstOrDefault(e =>\n                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n                        if (edge == null) continue;\n\n                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n                        nextIdx = (short)(finalIndex + 1);\n\n                        var link = new FlowButtonLink\n                        {\n                            Id = Guid.NewGuid(),\n                            CTAFlowStepId = fromStep.Id,\n                            NextStepId = toStep.Id,\n                            ButtonText = text,\n                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n                            ButtonSubType = btn.SubType ?? string.Empty,\n                            ButtonValue = btn.Value ?? string.Empty,\n                            ButtonIndex = (short)finalIndex\n                        };\n\n                        _context.FlowButtonLinks.Add(link);\n                        fromStep.ButtonLinks.Add(link);\n\n                        // convenience: populate target's trigger info\n                        toStep.TriggerButtonText = text;\n                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n                    }\n                }\n\n                await _context.SaveChangesAsync();\n                await tx.CommitAsync();\n\n                Log.Information(\"‚úÖ Flow created '{Flow}' | Steps: {Steps} | Links: {Links}\",\n                    flow.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Flow created.\", new { flowId = flow.Id });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while saving (create) flow\");\n                return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n            }\n        }\n\n        // ---------------------------\n        // LISTS\n        // ---------------------------\n        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && f.IsPublished)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    IsPublished = f.IsPublished,\n                    CreatedAt = f.CreatedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n        {\n            return await _context.CTAFlowConfigs\n                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new VisualFlowSummaryDto\n                {\n                    Id = f.Id,\n                    FlowName = f.FlowName,\n                    CreatedAt = f.CreatedAt,\n                    IsPublished = f.IsPublished\n                })\n                .ToListAsync();\n        }\n\n        // ---------------------------\n        // DETAIL LOADERS\n        // ---------------------------\n        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(c => c.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(c => c.Id == flowId && c.BusinessId == businessId && c.IsActive);\n\n            if (flow == null) return null;\n\n            // Prefetch template metadata\n            var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n            var uniqueNames = flow.Steps\n                .Select(s => s.TemplateToSend)\n                .Where(n => !string.IsNullOrWhiteSpace(n))\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            foreach (var name in uniqueNames)\n            {\n                try\n                {\n                    var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n                        businessId, name!, includeButtons: true);\n                    if (tpl != null) templateMap[name!] = tpl;\n                }\n                catch (Exception ex)\n                {\n                    Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template metadata for {Template}\", name);\n                }\n            }\n\n            var nodes = flow.Steps.Select(step =>\n            {\n                templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var tpl);\n\n                var dbLinks = step.ButtonLinks ?? new List<FlowButtonLink>();\n                var dbButtons = dbLinks\n                    .OrderBy(b => b.ButtonIndex)\n                    .Select(link => new LinkButtonDto\n                    {\n                        Text = link.ButtonText,\n                        Type = link.ButtonType,\n                        SubType = link.ButtonSubType,\n                        Value = link.ButtonValue,\n                        Index = link.ButtonIndex,\n                        TargetNodeId = link.NextStepId?.ToString()\n                    });\n\n                var templateButtons = (tpl?.ButtonParams ?? new List<ButtonMetadataDto>())\n                    .Where(btn => !dbLinks.Any(bl => string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n                    .Select(btn => new LinkButtonDto { Text = btn.Text });\n\n                return new FlowNodeDto\n                {\n                    Id = step.Id.ToString(),\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    MessageBody = string.IsNullOrWhiteSpace(tpl?.Body) ? \"‚Äî no body found ‚Äî\" : tpl!.Body,\n                    TriggerButtonText = step.TriggerButtonText,\n                    TriggerButtonType = step.TriggerButtonType,\n                    PositionX = step.PositionX ?? 100,\n                    PositionY = step.PositionY ?? 100,\n                    RequiredTag = step.RequiredTag,\n                    RequiredSource = step.RequiredSource,\n                    UseProfileName = step.UseProfileName,\n                    ProfileNameSlot = step.ProfileNameSlot,\n                    Buttons = dbButtons.Concat(templateButtons).ToList()\n                };\n            }).ToList();\n\n            var edges = flow.Steps\n                .SelectMany(step =>\n                    (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n                    .Where(l => l.NextStepId.HasValue)\n                    .Select(l => new FlowEdgeDto\n                    {\n                        FromNodeId = step.Id.ToString(),\n                        ToNodeId = l.NextStepId!.Value.ToString(),\n                        SourceHandle = l.ButtonText\n                    }))\n                .ToList();\n\n            return new SaveVisualFlowDto\n            {\n                FlowName = flow.FlowName,\n                IsPublished = flow.IsPublished,\n                Nodes = nodes,\n                Edges = edges\n            };\n        }\n\n        public async Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId)\n        {\n            try\n            {\n                var flow = await _context.CTAFlowConfigs\n                    .AsNoTracking()\n                    .Where(f => f.IsActive && f.BusinessId == businessId && f.Id == flowId)\n                    .Select(f => new\n                    {\n                        f.Id,\n                        f.FlowName,\n                        f.IsPublished,\n                        Steps = _context.CTAFlowSteps\n                            .Where(s => s.CTAFlowConfigId == f.Id)\n                            .OrderBy(s => s.StepOrder)\n                            .Select(s => new\n                            {\n                                s.Id,\n                                s.StepOrder,\n                                s.TemplateToSend,\n                                s.TemplateType,\n                                s.TriggerButtonText,\n                                s.TriggerButtonType,\n                                s.PositionX,\n                                s.PositionY,\n                                s.UseProfileName,\n                                s.ProfileNameSlot,\n                                Buttons = _context.FlowButtonLinks\n                                    .Where(b => b.CTAFlowStepId == s.Id)\n                                    .OrderBy(b => b.ButtonIndex)\n                                    .Select(b => new\n                                    {\n                                        b.ButtonText,\n                                        b.ButtonType,\n                                        b.ButtonSubType,\n                                        b.ButtonValue,\n                                        b.ButtonIndex,\n                                        b.NextStepId\n                                    })\n                                    .ToList()\n                            })\n                            .ToList()\n                    })\n                    .FirstOrDefaultAsync();\n\n                if (flow == null)\n                    return ResponseResult.ErrorInfo(\"Flow not found.\");\n\n                var nodes = flow.Steps.Select(s => new\n                {\n                    id = s.Id.ToString(),\n                    positionX = s.PositionX ?? 0,\n                    positionY = s.PositionY ?? 0,\n                    templateName = s.TemplateToSend,\n                    templateType = s.TemplateType,\n                    triggerButtonText = s.TriggerButtonText ?? string.Empty,\n                    triggerButtonType = s.TriggerButtonType ?? \"cta\",\n                    requiredTag = string.Empty,\n                    requiredSource = string.Empty,\n                    useProfileName = s.UseProfileName,\n                    profileNameSlot = (s.ProfileNameSlot.HasValue && s.ProfileNameSlot.Value > 0) ? s.ProfileNameSlot.Value : 1,\n                    buttons = s.Buttons.Select(b => new\n                    {\n                        text = b.ButtonText,\n                        type = b.ButtonType,\n                        subType = b.ButtonSubType,\n                        value = b.ButtonValue,\n                        targetNodeId = b.NextStepId == Guid.Empty ? null : b.NextStepId.ToString(),\n                        index = (int)(b.ButtonIndex)\n                    })\n                });\n\n                var edges = flow.Steps\n                    .SelectMany(s => s.Buttons\n                        .Where(b => b.NextStepId != Guid.Empty)\n                        .Select(b => new\n                        {\n                            fromNodeId = s.Id.ToString(),\n                            toNodeId = b.NextStepId.ToString(),\n                            sourceHandle = b.ButtonText\n                        }));\n\n                var payload = new\n                {\n                    flowName = flow.FlowName,\n                    isPublished = flow.IsPublished,\n                    nodes,\n                    edges\n                };\n\n                return ResponseResult.SuccessInfo(\"Flow loaded.\", payload);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while loading visual flow {FlowId}\", flowId);\n                return ResponseResult.ErrorInfo(\"Internal error while loading flow.\");\n            }\n        }\n\n        // ---------------------------\n        // DELETE (only if not attached)\n        // ---------------------------\n        public async Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Flow not found or does not belong to you.\");\n\n            var inUseQuery = _context.Campaigns\n                .Where(c => c.BusinessId == businessId &&\n                            !c.IsDeleted &&\n                            c.CTAFlowConfigId == flowId);\n\n            var inUseCount = await inUseQuery.CountAsync();\n            if (inUseCount > 0)\n            {\n                Log.Warning(\"‚ùå Delete flow blocked. Flow {FlowId} is used by {Count} campaigns.\", flowId, inUseCount);\n                // Keep message; controller will fetch campaigns for modal\n                return ResponseResult.ErrorInfo(\n                    $\"‚ùå Cannot delete. This flow is attached to {inUseCount} campaign(s). Delete those campaigns first.\");\n            }\n\n            foreach (var step in flow.Steps)\n                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n            _context.CTAFlowConfigs.Remove(flow);\n\n            await _context.SaveChangesAsync();\n            return ResponseResult.SuccessInfo(\"‚úÖ Flow deleted.\");\n        }\n\n        public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n        {\n            var q = _context.Campaigns\n                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId);\n\n            var firstSends = await _context.CampaignSendLogs\n                .Where(s => s.BusinessId == businessId && s.CampaignId != Guid.Empty)\n                .GroupBy(s => s.CampaignId)\n                .Select(g => new { CampaignId = g.Key, FirstSentAt = (DateTime?)g.Min(s => s.CreatedAt) })\n                .ToListAsync();\n\n            var firstSendMap = firstSends.ToDictionary(x => x.CampaignId, x => x.FirstSentAt);\n\n            var list = await q\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => new\n                {\n                    c.Id,\n                    c.Name,\n                    c.Status,\n                    c.ScheduledAt,\n                    c.CreatedAt,\n                    c.CreatedBy\n                })\n                .ToListAsync();\n\n            return list.Select(x => new AttachedCampaignDto(\n                x.Id,\n                x.Name,\n                x.Status,\n                x.ScheduledAt,\n                x.CreatedAt,\n                x.CreatedBy,\n                firstSendMap.TryGetValue(x.Id, out var ts) ? ts : null\n            )).ToList();\n        }\n\n        public async Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                    .ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow is null) return false;\n\n            var attached = await _context.Campaigns\n                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId)\n                .AnyAsync();\n            if (attached) return false;\n\n            foreach (var step in flow.Steps)\n                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n            _context.CTAFlowConfigs.Remove(flow);\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ---------------------------\n        // PUBLISH (by id, flip flag)\n        // ---------------------------\n        public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n        {\n            var flow = await _context.CTAFlowConfigs\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n            if (flow is null) return false;\n\n            flow.IsPublished = true;\n            flow.UpdatedAt = DateTime.UtcNow;\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ---------------------------\n        // RUNTIME / Matching / Execute\n        // ---------------------------\n        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n            Guid businessId,\n            string buttonText,\n            string buttonType,\n            string templateName,\n            Guid? campaignId = null)\n        {\n            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n            var normalizedTemplateName = templateName?.Trim().ToLower() ?? \"\";\n\n            if (campaignId.HasValue)\n            {\n                var overrideStep = await _context.CampaignFlowOverrides\n                    .Where(o =>\n                        o.CampaignId == campaignId &&\n                        o.ButtonText.ToLower() == normalizedButtonText &&\n                        o.TemplateName.ToLower() == normalizedTemplateName)\n                    .FirstOrDefaultAsync();\n\n                if (overrideStep != null)\n                {\n                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n                    var matched = await _context.CTAFlowSteps\n                        .Include(s => s.Flow)\n                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n                    if (matched != null) return matched;\n                }\n            }\n\n            var fallbackStep = await _context.CTAFlowSteps\n                .Include(s => s.Flow)\n                .Where(s =>\n                    s.Flow.BusinessId == businessId &&\n                    s.Flow.IsActive &&\n                    s.Flow.IsPublished &&\n                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n                .FirstOrDefaultAsync();\n\n            return fallbackStep;\n        }\n\n        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n        {\n            try\n            {\n                var log = await _context.TrackingLogs\n                    .Include(l => l.Contact)\n                        .ThenInclude(c => c.ContactTags)\n                            .ThenInclude(ct => ct.Tag)\n                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n                if (log == null) return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n\n                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n                if (step == null) return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n\n                var args = new List<string>();\n                if (step.UseProfileName && step.ProfileNameSlot is int slot && slot >= 1)\n                {\n                    var contact = log.Contact ?? await _context.Contacts\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == (log.ContactPhone ?? \"\"));\n                    var greet = (contact?.ProfileName ?? contact?.Name)?.Trim();\n                    if (string.IsNullOrEmpty(greet)) greet = \"there\";\n                    while (args.Count < slot) args.Add(string.Empty);\n                    args[slot - 1] = greet;\n                }\n\n                ResponseResult sendResult;\n                switch (step.TemplateType?.ToLower())\n                {\n                    case \"image_template\":\n                        var imageDto = new ImageTemplateMessageDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            LanguageCode = \"en_US\"\n                        };\n                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n                        break;\n                    case \"text_template\":\n                    default:\n                        var textDto = new SimpleTemplateMessageDto\n                        {\n                            RecipientNumber = log.ContactPhone ?? \"\",\n                            TemplateName = step.TemplateToSend,\n                            TemplateParameters = args\n                        };\n                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n                        break;\n                }\n\n                var executionLog = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    StepId = step.Id,\n                    FlowId = step.CTAFlowConfigId,\n                    Origin = FlowExecutionOrigin.Campaign, // added fro autoreply flow\n                    CampaignSendLogId = campaignSendLogId,\n                    TrackingLogId = trackingLogId,\n                    ContactPhone = log.ContactPhone,\n                    TriggeredByButton = step.TriggerButtonText,\n                    TemplateName = step.TemplateToSend,\n                    TemplateType = step.TemplateType,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow\n                };\n\n                _context.FlowExecutionLogs.Add(executionLog);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception during ExecuteVisualFlowAsync()\");\n                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n            }\n        }\n\n        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n            => GetChainedStepAsync(businessId, nextStepId, null, null);\n\n        public async Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId, TrackingLog? trackingLog, Contact? contact)\n        {\n            if (nextStepId == null) return null;\n\n            var flow = await _context.CTAFlowConfigs\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(f =>\n                    f.BusinessId == businessId &&\n                    f.Steps.Any(s => s.Id == nextStepId));\n\n            var followUpStep = flow?.Steps.FirstOrDefault(s => s.Id == nextStepId);\n            if (followUpStep == null) return null;\n\n            if (trackingLog != null)\n            {\n                var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n                if (!isMatch) return null;\n            }\n\n            return followUpStep;\n        }\n\n        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId)\n        {\n            var log = await _context.TrackingLogs\n                .Include(l => l.Contact)\n                    .ThenInclude(c => c.ContactTags)\n                        .ThenInclude(ct => ct.Tag)\n                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n        }\n\n        // ‚úÖ MISSING IMPLEMENTATION (to satisfy the interface)\n        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n        {\n            return await _context.FlowButtonLinks\n                .Where(l => l.CTAFlowStepId == sourceStepId\n                            && l.NextStepId != null\n                            && l.Step.CTAFlowConfigId == flowId\n                            && l.ButtonIndex == buttonIndex)\n                .SingleOrDefaultAsync();\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.EntityFrameworkCore;\n//using Serilog;\n//using xbytechat.api.AuthModule.Models;\n//using xbytechat.api.CRM.Models;\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.Features.Tracking.Models;\n//using xbytechat.api.Helpers;\n//using xbytechat.api.WhatsAppSettings.DTOs;\n//using xbytechat_api.WhatsAppSettings.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    public class CTAFlowService : ICTAFlowService\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IMessageEngineService _messageEngineService;\n//        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n\n//        public CTAFlowService(AppDbContext context, IMessageEngineService messageEngineService,\n//            IWhatsAppTemplateFetcherService templateFetcherService\n//            )\n//        {\n//            _context = context;\n//            _messageEngineService = messageEngineService;\n//            _templateFetcherService = templateFetcherService;\n//        }\n\n//        public async Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy)\n//        {\n//            var flow = new CTAFlowConfig\n//            {\n//                Id = Guid.NewGuid(),\n//                FlowName = dto.FlowName,\n//                BusinessId = businessId,\n//                CreatedAt = DateTime.UtcNow,\n//                CreatedBy = createdBy,\n//                IsPublished = dto.IsPublished\n//            };\n\n//            foreach (var stepDto in dto.Steps)\n//            {\n//                var step = new CTAFlowStep\n//                {\n//                    Id = Guid.NewGuid(),\n//                    CTAFlowConfigId = flow.Id,\n//                    TriggerButtonText = stepDto.TriggerButtonText,\n//                    TriggerButtonType = stepDto.TriggerButtonType,\n//                    TemplateToSend = stepDto.TemplateToSend,\n//                    StepOrder = stepDto.StepOrder,\n//                    ButtonLinks = stepDto.ButtonLinks?.Select(link => new FlowButtonLink\n//                    {\n//                        ButtonText = link.ButtonText,\n//                        NextStepId = link.NextStepId\n//                    }).ToList() ?? new List<FlowButtonLink>()\n//                };\n\n//                flow.Steps.Add(step);\n//            }\n\n//            _context.CTAFlowConfigs.Add(flow);\n//            await _context.SaveChangesAsync();\n\n//            return flow.Id;\n//        }\n\n//        public async Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Include(f => f.Steps.OrderBy(s => s.StepOrder))\n//                .Where(f => f.BusinessId == businessId && f.IsActive && f.IsPublished)\n//                .FirstOrDefaultAsync();\n//        }\n\n//        public async Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .Where(f => f.BusinessId == businessId && f.IsPublished == false)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .FirstOrDefaultAsync();\n//        }\n\n\n\n//        public async Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId)\n//        {\n//            return await _context.CTAFlowSteps\n//                .Where(s => s.CTAFlowConfigId == flowId)\n//                .OrderBy(s => s.StepOrder)\n//                .ToListAsync();\n//        }\n\n//        public async Task<CTAFlowStep?> MatchStepByButtonAsync(\n//            Guid businessId,\n//            string buttonText,\n//            string buttonType,\n//            string TemplateName,\n//            Guid? campaignId = null)\n//        {\n//            var normalizedButtonText = buttonText?.Trim().ToLower() ?? \"\";\n//            var normalizedButtonType = buttonType?.Trim().ToLower() ?? \"\";\n//            var normalizedTemplateName = TemplateName?.Trim().ToLower() ?? \"\";\n\n//            // 1Ô∏è‚É£ Try campaign-specific override\n//            if (campaignId.HasValue)\n//            {\n//                var overrideStep = await _context.CampaignFlowOverrides\n//                    .Where(o =>\n//                        o.CampaignId == campaignId &&\n//                        o.ButtonText.ToLower() == normalizedButtonText &&\n//                        o.TemplateName.ToLower() == normalizedTemplateName)\n//                    .FirstOrDefaultAsync();\n\n//                if (overrideStep != null)\n//                {\n//                    var overrideTemplate = overrideStep.OverrideNextTemplate?.ToLower();\n\n//                    var matched = await _context.CTAFlowSteps\n//                        .Include(s => s.Flow)\n//                        .FirstOrDefaultAsync(s => s.TemplateToSend.ToLower() == overrideTemplate);\n\n//                    if (matched != null)\n//                    {\n//                        Log.Information(\"üîÅ Override matched: Template '{Template}' ‚Üí Step '{StepId}'\", overrideStep.OverrideNextTemplate, matched.Id);\n//                        return matched;\n//                    }\n\n//                    Log.Warning(\"‚ö†Ô∏è Override found for button '{Button}' but no matching step for template '{Template}'\", normalizedButtonText, overrideStep.OverrideNextTemplate);\n//                }\n\n//                else\n//                {\n//                    Log.Information(\"üü° No campaign override found for button '{Button}' on template '{Template}'\", normalizedButtonText, normalizedTemplateName);\n//                }\n//            }\n\n//            // 2Ô∏è‚É£ Fallback to standard flow logic\n//            var fallbackStep = await _context.CTAFlowSteps\n//                .Include(s => s.Flow)\n//                .Where(s =>\n//                    s.Flow.BusinessId == businessId &&\n//                    s.Flow.IsActive &&\n//                    s.Flow.IsPublished &&\n//                    s.TriggerButtonText.ToLower() == normalizedButtonText &&\n//                    s.TriggerButtonType.ToLower() == normalizedButtonType)\n//                .FirstOrDefaultAsync();\n\n//            if (fallbackStep != null)\n//            {\n//                Log.Information(\"‚úÖ Fallback flow step matched: StepId = {StepId}, Flow = {FlowName}\", fallbackStep.Id, fallbackStep.Flow?.FlowName);\n//            }\n//            else\n//            {\n//                Log.Warning(\"‚ùå No fallback step matched for button '{ButtonText}' of type '{ButtonType}' in BusinessId: {BusinessId}\", normalizedButtonText, normalizedButtonType, businessId);\n//            }\n\n//            return fallbackStep;\n//        }\n\n\n//        public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n//        {\n//            var flow = await _context.CTAFlowConfigs\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n//            if (flow is null) return false;\n\n//            // Optional validation: ensure it has at least 1 step, etc.\n//            flow.IsPublished = true;\n//            flow.UpdatedAt = DateTime.UtcNow;\n//            await _context.SaveChangesAsync();\n//            return true;\n//        }\n\n//        //public async Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy)\n//        //{\n//        //    try\n//        //    {\n//        //        // üî• 1. Remove existing published flow for this business\n//        //        var existingFlows = await _context.CTAFlowConfigs\n//        //            .Where(f => f.BusinessId == businessId && f.IsPublished)\n//        //            .ToListAsync();\n\n//        //        if (existingFlows.Any())\n//        //        {\n//        //            _context.CTAFlowConfigs.RemoveRange(existingFlows);\n//        //        }\n\n//        //        // üå± 2. Create new flow config\n//        //        var flowConfig = new CTAFlowConfig\n//        //        {\n//        //            Id = Guid.NewGuid(),\n//        //            BusinessId = businessId,\n//        //            FlowName = \"Published Flow - \" + DateTime.UtcNow.ToString(\"yyyyMMdd-HHmm\"),\n//        //            IsPublished = true,\n//        //            IsActive = true,\n//        //            CreatedBy = createdBy,\n//        //            CreatedAt = DateTime.UtcNow,\n//        //            Steps = new List<CTAFlowStep>()\n//        //        };\n\n//        //        // üîÅ 3. Convert each step DTO to model\n//        //        foreach (var stepDto in steps)\n//        //        {\n//        //            var step = new CTAFlowStep\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowConfigId = flowConfig.Id,\n//        //                TriggerButtonText = stepDto.TriggerButtonText,\n//        //                TriggerButtonType = stepDto.TriggerButtonType,\n//        //                TemplateToSend = stepDto.TemplateToSend,\n//        //                StepOrder = stepDto.StepOrder,\n//        //                ButtonLinks = stepDto.ButtonLinks.Select(bl => new FlowButtonLink\n//        //                {\n//        //                    Id = Guid.NewGuid(),\n//        //                    ButtonText = bl.ButtonText,\n//        //                    NextStepId = bl.NextStepId,\n//        //                }).ToList()\n//        //            };\n\n//        //            flowConfig.Steps.Add(step);\n//        //        }\n\n//        //        // üíæ 4. Save to DB\n//        //        await _context.CTAFlowConfigs.AddAsync(flowConfig);\n//        //        await _context.SaveChangesAsync();\n\n//        //        return ResponseResult.SuccessInfo(\"‚úÖ Flow published successfully.\");\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        Log.Error(ex, \"‚ùå Error while publishing CTA flow.\");\n//        //        return ResponseResult.ErrorInfo(\"‚ùå Could not publish flow.\");\n//        //    }\n//        //}\n\n\n//        private static int CountBodyPlaceholders(string? body)\n//        {\n//            if (string.IsNullOrWhiteSpace(body)) return 0;\n//            // counts {{1}}, {{2}}, ... ; ignores any non-numeric moustaches\n//            var m = System.Text.RegularExpressions.Regex.Matches(body, @\"\\{\\{\\s*\\d+\\s*\\}\\}\");\n//            return m.Count;\n//        }\n//        public async Task<ResponseResult> SaveVisualFlowAsync(\n//    SaveVisualFlowDto dto,\n//    Guid businessId,\n//    string createdBy)\n//        {\n//            try\n//            {\n//                Log.Information(\"üß† SaveVisualFlow (create-only) | FlowName: {FlowName} | Biz: {BusinessId}\",\n//                    dto.FlowName, businessId);\n\n//                // 0) Basic validation\n//                if (dto.Nodes == null || !dto.Nodes.Any())\n//                    return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n\n//                var trimmedName = (dto.FlowName ?? \"\").Trim();\n//                if (trimmedName.Length == 0)\n//                    return ResponseResult.ErrorInfo(\"‚ùå Flow name is required.\");\n\n//                // 1) CREATE-ONLY: refuse duplicate name for this business\n//                var nameExists = await _context.CTAFlowConfigs\n//                    .AnyAsync(f => f.BusinessId == businessId && f.FlowName == trimmedName && f.IsActive);\n\n//                if (nameExists)\n//                {\n//                    // IMPORTANT: this method is only for *new* flows.\n//                    // If the user is editing an existing flow, the UI should call PUT /cta-flow/{id}.\n//                    Log.Warning(\"‚ö†Ô∏è Duplicate flow name '{Name}' for business {Biz}.\", trimmedName, businessId);\n//                    return ResponseResult.ErrorInfo(\n//                        \"‚ùå A flow with this name already exists. Open that flow and edit it, or choose a different name.\");\n//                }\n\n//                await using var tx = await _context.Database.BeginTransactionAsync();\n\n//                // 2) Insert FlowConfig\n//                var flow = new CTAFlowConfig\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    FlowName = trimmedName,\n//                    CreatedBy = createdBy,\n//                    CreatedAt = DateTime.UtcNow,\n//                    UpdatedAt = DateTime.UtcNow,\n//                    IsActive = true,\n//                    // You *can* allow creating as published, but most teams prefer create-as-draft:\n//                    IsPublished = dto.IsPublished\n//                };\n//                _context.CTAFlowConfigs.Add(flow);\n\n//                // 3) Build Steps\n//                var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n//                var orderIndex = 0;\n\n//                foreach (var node in dto.Nodes)\n//                {\n//                    if (string.IsNullOrWhiteSpace(node.Id)) continue;\n\n//                    var step = new CTAFlowStep\n//                    {\n//                        Id = Guid.NewGuid(),\n//                        CTAFlowConfigId = flow.Id,\n//                        StepOrder = orderIndex++,\n//                        TemplateToSend = node.TemplateName,\n//                        TemplateType = node.TemplateType ?? \"UNKNOWN\",\n//                        TriggerButtonText = node.TriggerButtonText ?? \"\",\n//                        TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n//                        PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n//                        PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n//                        UseProfileName = node.UseProfileName,\n//                        ProfileNameSlot = node.ProfileNameSlot,\n//                        ButtonLinks = new List<FlowButtonLink>()\n//                    };\n\n//                    // Harden profile-name config per template type\n//                    var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n//                    if (!isTextTemplate)\n//                    {\n//                        step.UseProfileName = false;\n//                        step.ProfileNameSlot = null;\n//                    }\n//                    else\n//                    {\n//                        if (!step.UseProfileName)\n//                        {\n//                            step.ProfileNameSlot = null;\n//                        }\n//                        else\n//                        {\n//                            if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//                                step.ProfileNameSlot = 1;\n//                        }\n//                    }\n\n//                    stepMap[node.Id] = step;\n//                    _context.CTAFlowSteps.Add(step);\n//                }\n\n//                // 4) Build Links (per-node buttons, matched by SourceHandle == button text)\n//                var edges = dto.Edges ?? new List<FlowEdgeDto>();\n\n//                foreach (var node in dto.Nodes)\n//                {\n//                    if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n//                        continue;\n\n//                    var outEdges = edges.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList();\n//                    var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n//                    var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n//                        .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n//                        .ThenBy(b => b.Text ?? string.Empty)\n//                        .ToList();\n\n//                    short nextIdx = 0;\n\n//                    foreach (var btn in orderedButtons)\n//                    {\n//                        var text = (btn.Text ?? string.Empty).Trim();\n//                        if (string.IsNullOrEmpty(text)) continue;\n\n//                        if (!seenTexts.Add(text))\n//                        {\n//                            Log.Warning(\"‚ö†Ô∏è Duplicate button text '{Text}' on node {NodeId}; first wins.\", text, node.Id);\n//                            continue;\n//                        }\n\n//                        var edge = outEdges.FirstOrDefault(e =>\n//                            string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n//                        if (edge == null) continue;\n\n//                        if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep)) continue;\n\n//                        var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n//                        nextIdx = (short)(finalIndex + 1);\n\n//                        var link = new FlowButtonLink\n//                        {\n//                            Id = Guid.NewGuid(),\n//                            CTAFlowStepId = fromStep.Id,\n//                            NextStepId = toStep.Id,\n//                            ButtonText = text,\n//                            ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n//                            ButtonSubType = btn.SubType ?? string.Empty,\n//                            ButtonValue = btn.Value ?? string.Empty,\n//                            ButtonIndex = (short)finalIndex\n//                        };\n\n//                        _context.FlowButtonLinks.Add(link);\n//                        fromStep.ButtonLinks.Add(link);\n\n//                        // convenience: target step \"entry trigger\"\n//                        toStep.TriggerButtonText = text;\n//                        toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n//                    }\n//                }\n\n//                await _context.SaveChangesAsync();\n//                await tx.CommitAsync();\n\n//                Log.Information(\"‚úÖ Flow created '{Flow}' | Steps: {Steps} | Links: {Links}\",\n//                    flow.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n//                // Return new flowId so the FE can redirect/open it if desired\n//                return ResponseResult.SuccessInfo(\"‚úÖ Flow created.\", new { flowId = flow.Id });\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while saving (create) flow\");\n//                return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n//            }\n//        }\n\n//        //public async Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy)\n//        //{\n//        //    try\n//        //    {\n//        //        Log.Information(\"üß† SaveVisualFlow started | FlowName: {FlowName} | BusinessId: {BusinessId}\", dto.FlowName, businessId);\n\n//        //        if (dto.Nodes == null || !dto.Nodes.Any())\n//        //        {\n//        //            Log.Warning(\"‚ùå No nodes found in flow. Aborting save.\");\n//        //            return ResponseResult.ErrorInfo(\"‚ùå Cannot save an empty flow. Please add at least one step.\");\n//        //        }\n\n//        //        // 1) Upsert FlowConfig\n//        //        var flow = await _context.CTAFlowConfigs\n//        //            .FirstOrDefaultAsync(f => f.FlowName == dto.FlowName && f.BusinessId == businessId);\n\n//        //        if (flow == null)\n//        //        {\n//        //            flow = new CTAFlowConfig\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                BusinessId = businessId,\n//        //                FlowName = dto.FlowName,\n//        //                CreatedBy = createdBy,\n//        //                CreatedAt = DateTime.UtcNow,\n//        //                UpdatedAt = DateTime.UtcNow,\n//        //                IsActive = true,\n//        //                IsPublished = dto.IsPublished\n//        //            };\n//        //            _context.CTAFlowConfigs.Add(flow);\n//        //            Log.Information(\"‚úÖ New FlowConfig created with ID: {Id}\", flow.Id);\n//        //        }\n//        //        else\n//        //        {\n//        //            // wipe old steps+links for a clean replace\n//        //            var oldSteps = await _context.CTAFlowSteps\n//        //                .Where(s => s.CTAFlowConfigId == flow.Id)\n//        //                .Include(s => s.ButtonLinks)\n//        //                .ToListAsync();\n\n//        //            foreach (var step in oldSteps)\n//        //                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//        //            _context.CTAFlowSteps.RemoveRange(oldSteps);\n\n//        //            flow.IsPublished = dto.IsPublished;\n//        //            flow.UpdatedAt = DateTime.UtcNow;\n//        //        }\n\n//        //        // 2) Build Steps (map by incoming node.Id string)\n//        //        var stepMap = new Dictionary<string, CTAFlowStep>(StringComparer.OrdinalIgnoreCase);\n\n//        //        foreach (var (node, index) in dto.Nodes.Select((n, i) => (n, i)))\n//        //        {\n//        //            if (string.IsNullOrWhiteSpace(node.Id))\n//        //                continue;\n\n//        //            var step = new CTAFlowStep\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowConfigId = flow.Id,\n//        //                StepOrder = index,\n//        //                TemplateToSend = node.TemplateName,\n//        //                TemplateType = node.TemplateType ?? \"UNKNOWN\",\n//        //                TriggerButtonText = node.TriggerButtonText ?? \"\",\n//        //                TriggerButtonType = node.TriggerButtonType ?? \"cta\",\n//        //                PositionX = node.PositionX == 0 ? Random.Shared.Next(100, 600) : node.PositionX,\n//        //                PositionY = node.PositionY == 0 ? Random.Shared.Next(100, 400) : node.PositionY,\n//        //                UseProfileName = node.UseProfileName,\n//        //                ProfileNameSlot = node.ProfileNameSlot,\n//        //                //ProfileNameSlot = node.ProfileNameSlot ?? 1,\n//        //                ButtonLinks = new List<FlowButtonLink>()\n//        //            };\n\n//        //            // ‚úÖ Harden profile-name config per step\n//        //            var isTextTemplate = string.Equals(step.TemplateType, \"text_template\", StringComparison.OrdinalIgnoreCase);\n//        //            if (!isTextTemplate)\n//        //            {\n//        //                // Only text templates support body placeholders; disable on others\n//        //                step.UseProfileName = false;\n//        //                step.ProfileNameSlot = null;\n//        //            }\n//        //            //else if (step.UseProfileName)\n//        //            //{\n//        //            //    // Clamp to minimum valid slot\n//        //            //    if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//        //            //        step.ProfileNameSlot = 1;\n//        //            //}\n//        //            else\n//        //            {\n//        //                // Text template:\n//        //                if (!step.UseProfileName)\n//        //                {\n//        //                    // Toggle OFF ‚Üí always null the slot\n//        //                    step.ProfileNameSlot = null;\n//        //                }\n//        //                else\n//        //                {\n//        //                    // Toggle ON ‚Üí clamp to minimum valid\n//        //                    if (!step.ProfileNameSlot.HasValue || step.ProfileNameSlot.Value < 1)\n//        //                        step.ProfileNameSlot = 1;\n//        //                    // (Optional) upper clamp if you want: e.g., step.ProfileNameSlot = Math.Min(step.ProfileNameSlot.Value, 50);\n//        //                }\n//        //            }\n//        //            stepMap[node.Id] = step;\n//        //            _context.CTAFlowSteps.Add(step);\n//        //        }\n\n//        //        // 3) Build Links PER NODE using buttons order (with Index), not per-edge blindly\n//        //        foreach (var node in dto.Nodes)\n//        //        {\n//        //            if (string.IsNullOrWhiteSpace(node.Id) || !stepMap.TryGetValue(node.Id, out var fromStep))\n//        //                continue;\n\n//        //            // outgoing edges from this node\n//        //            var outEdges = dto.Edges?.Where(e => string.Equals(e.FromNodeId, node.Id, StringComparison.OrdinalIgnoreCase)).ToList()\n//        //                           ?? new List<FlowEdgeDto>();\n\n//        //            // dedupe by button text to avoid ambiguous routing\n//        //            var seenTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n//        //            // stable ordering: by provided Index (0..N), then by Text\n//        //            var orderedButtons = (node.Buttons ?? new List<LinkButtonDto>())\n//        //                .OrderBy(b => b.Index < 0 ? int.MaxValue : b.Index)\n//        //                .ThenBy(b => b.Text ?? string.Empty)\n//        //                .ToList();\n\n//        //            short nextIdx = 0;\n\n//        //            foreach (var btn in orderedButtons)\n//        //            {\n//        //                var text = (btn.Text ?? string.Empty).Trim();\n//        //                if (string.IsNullOrEmpty(text))\n//        //                    continue;\n\n//        //                if (!seenTexts.Add(text))\n//        //                {\n//        //                    Log.Warning(\"‚ö†Ô∏è Duplicate button text '{Text}' on node {NodeId}; keeping first, skipping duplicates.\", text, node.Id);\n//        //                    continue;\n//        //                }\n\n//        //                // match edge by SourceHandle == button text (how ReactFlow wires handles)\n//        //                var edge = outEdges.FirstOrDefault(e =>\n//        //                    string.Equals(e.SourceHandle ?? string.Empty, text, StringComparison.OrdinalIgnoreCase));\n//        //                if (edge == null)\n//        //                {\n//        //                    // no wire from this button ‚Üí skip link creation but keep button metadata in UI on reload\n//        //                    continue;\n//        //                }\n\n//        //                if (!stepMap.TryGetValue(edge.ToNodeId, out var toStep))\n//        //                    continue;\n\n//        //                // final index: prefer incoming payload Index; else fallback to a sequential counter\n//        //                var finalIndex = btn.Index >= 0 ? btn.Index : nextIdx;\n//        //                nextIdx = (short)(finalIndex + 1);\n\n//        //                var link = new FlowButtonLink\n//        //                {\n//        //                    Id = Guid.NewGuid(),\n//        //                    CTAFlowStepId = fromStep.Id,\n//        //                    NextStepId = toStep.Id,\n//        //                    ButtonText = text,\n//        //                    ButtonType = string.IsNullOrWhiteSpace(btn.Type) ? \"QUICK_REPLY\" : btn.Type,\n//        //                    ButtonSubType = btn.SubType ?? string.Empty,\n//        //                    ButtonValue = btn.Value ?? string.Empty,\n//        //                    ButtonIndex = (short)finalIndex // üîë persist the index\n//        //                };\n\n//        //                _context.FlowButtonLinks.Add(link);\n//        //                fromStep.ButtonLinks.Add(link);\n\n//        //                // propagate trigger info on the target step for convenience\n//        //                toStep.TriggerButtonText = text;\n//        //                toStep.TriggerButtonType = (btn.Type ?? \"QUICK_REPLY\").ToLowerInvariant();\n//        //            }\n//        //        }\n\n//        //        await _context.SaveChangesAsync();\n\n//        //        Log.Information(\"‚úÖ Flow '{Flow}' saved | Steps: {StepCount} | Links: {LinkCount}\",\n//        //            dto.FlowName, stepMap.Count, stepMap.Values.Sum(s => s.ButtonLinks.Count));\n\n//        //        return ResponseResult.SuccessInfo(\"‚úÖ Flow saved successfully.\");\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        Log.Error(ex, \"‚ùå Exception while saving flow\");\n//        //        return ResponseResult.ErrorInfo(\"‚ùå Internal error while saving flow.\");\n//        //    }\n//        //}\n\n\n//        //public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .Include(c => c.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(c =>\n//        //            c.Id == flowId &&\n//        //            c.BusinessId == businessId &&   // üëà tenant scoping\n//        //            c.IsActive);\n\n//        //    if (flow == null) return null;\n\n//        //    // ---- Pre-fetch unique template names (defensive) ----\n//        //    var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n//        //    foreach (var name in flow.Steps\n//        //                             .Select(s => s.TemplateToSend)\n//        //                             .Where(n => !string.IsNullOrWhiteSpace(n))\n//        //                             .Distinct(StringComparer.OrdinalIgnoreCase))\n//        //    {\n//        //        try\n//        //        {\n//        //            var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n//        //                businessId, name!, includeButtons: true);\n//        //            if (tpl != null) templateMap[name!] = tpl;\n//        //        }\n//        //        catch (Exception ex)\n//        //        {\n//        //            Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template from Meta for {Template}\", name);\n//        //        }\n//        //    }\n\n//        //    // ---- Nodes ----\n//        //    var nodes = flow.Steps.Select(step =>\n//        //    {\n//        //        templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var template);\n\n//        //        IEnumerable<FlowButtonLink> links =\n//        //            step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>();\n\n//        //        var dbButtons = links.Select(link => new LinkButtonDto\n//        //        {\n//        //            Text = link.ButtonText,\n//        //            Type = link.ButtonType,\n//        //            SubType = link.ButtonSubType,\n//        //            Value = link.ButtonValue,\n//        //            TargetNodeId = link.NextStepId?.ToString() // null-safe\n//        //        });\n\n//        //        var templateButtons = (template?.ButtonParams ?? new List<ButtonMetadataDto>())\n//        //            .Where(btn => !links.Any(bl =>\n//        //                        string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n//        //            .Select(btn => new LinkButtonDto\n//        //            {\n//        //                Text = btn.Text,\n//        //                TargetNodeId = null\n//        //            });\n\n//        //        return new FlowNodeDto\n//        //        {\n//        //            Id = step.Id.ToString(),\n//        //            TemplateName = step.TemplateToSend,\n//        //            TemplateType = step.TemplateType,\n//        //            MessageBody = template?.Body ?? \"Message body preview...\",\n//        //            TriggerButtonText = step.TriggerButtonText,\n//        //            TriggerButtonType = step.TriggerButtonType,\n//        //            PositionX = step.PositionX ?? 100,\n//        //            PositionY = step.PositionY ?? 100,\n\n//        //            // Conditional logic\n//        //            RequiredTag = step.RequiredTag,\n//        //            RequiredSource = step.RequiredSource,\n\n//        //            UseProfileName = step.UseProfileName,\n//        //            ProfileNameSlot = step.ProfileNameSlot,\n\n//        //            Buttons = dbButtons.Concat(templateButtons).ToList()\n//        //        };\n//        //    }).ToList();\n\n//        //    // ---- Edges (skip links without a target) ----\n//        //    var edges = flow.Steps\n//        //        .SelectMany(step =>\n//        //            (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n//        //            .Where(link => link.NextStepId.HasValue)\n//        //            .Select(link => new FlowEdgeDto\n//        //            {\n//        //                FromNodeId = step.Id.ToString(),\n//        //                ToNodeId = link.NextStepId!.Value.ToString(),\n//        //                SourceHandle = link.ButtonText\n//        //            }))\n//        //        .ToList();\n\n//        //    return new SaveVisualFlowDto\n//        //    {\n//        //        FlowName = flow.FlowName,\n//        //        IsPublished = flow.IsPublished,\n//        //        Nodes = nodes,\n//        //        Edges = edges\n//        //    };\n//        //}\n\n//        public async Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId)\n//        {\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(c => c.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(c => c.Id == flowId && c.BusinessId == businessId && c.IsActive);\n\n//            if (flow == null) return null;\n\n//            // 1) Prefetch template metadata for all unique names (defensive, fast)\n//            var templateMap = new Dictionary<string, TemplateMetadataDto>(StringComparer.OrdinalIgnoreCase);\n//            var uniqueNames = flow.Steps\n//                .Select(s => s.TemplateToSend)\n//                .Where(n => !string.IsNullOrWhiteSpace(n))\n//                .Distinct(StringComparer.OrdinalIgnoreCase)\n//                .ToList();\n\n//            foreach (var name in uniqueNames)\n//            {\n//                try\n//                {\n//                    var tpl = await _templateFetcherService.GetTemplateByNameAsync(\n//                        businessId, name!, includeButtons: true);\n//                    if (tpl != null) templateMap[name!] = tpl;\n//                }\n//                catch (Exception ex)\n//                {\n//                    Log.Warning(ex, \"‚ö†Ô∏è Failed to fetch template from provider for {Template}\", name);\n//                }\n//            }\n\n//            // 2) Build nodes with real body + merged buttons (DB links first, then any unlinked template buttons)\n//            var nodes = flow.Steps.Select(step =>\n//            {\n//                templateMap.TryGetValue(step.TemplateToSend ?? \"\", out var tpl);\n\n//                var dbLinks = step.ButtonLinks ?? new List<FlowButtonLink>();\n\n//                var dbButtons = dbLinks\n//                    .OrderBy(b => b.ButtonIndex)\n//                    .Select(link => new LinkButtonDto\n//                    {\n//                        Text = link.ButtonText,\n//                        Type = link.ButtonType,\n//                        SubType = link.ButtonSubType,\n//                        Value = link.ButtonValue,\n//                        Index = link.ButtonIndex,\n//                        TargetNodeId = link.NextStepId?.ToString()\n//                    });\n\n//                var templateButtons = (tpl?.ButtonParams ?? new List<ButtonMetadataDto>())\n//                    .Where(btn => !dbLinks.Any(bl => string.Equals(bl.ButtonText, btn.Text, StringComparison.OrdinalIgnoreCase)))\n//                    .Select(btn => new LinkButtonDto\n//                    {\n//                        Text = btn.Text,\n//                        // no TargetNodeId: not wired\n//                    });\n\n//                return new FlowNodeDto\n//                {\n//                    Id = step.Id.ToString(),\n//                    TemplateName = step.TemplateToSend,\n//                    TemplateType = step.TemplateType,\n//                    MessageBody = string.IsNullOrWhiteSpace(tpl?.Body) ? \"‚Äî no body found ‚Äî\" : tpl!.Body, // ‚Üê REAL BODY\n//                    TriggerButtonText = step.TriggerButtonText,\n//                    TriggerButtonType = step.TriggerButtonType,\n//                    PositionX = step.PositionX ?? 100,\n//                    PositionY = step.PositionY ?? 100,\n//                    RequiredTag = step.RequiredTag,\n//                    RequiredSource = step.RequiredSource,\n//                    UseProfileName = step.UseProfileName,\n//                    ProfileNameSlot = step.ProfileNameSlot,\n//                    Buttons = dbButtons.Concat(templateButtons).ToList()\n//                };\n//            }).ToList();\n\n//            // 3) Build edges\n//            var edges = flow.Steps\n//                .SelectMany(step => (step.ButtonLinks ?? Enumerable.Empty<FlowButtonLink>())\n//                    .Where(l => l.NextStepId.HasValue)\n//                    .Select(l => new FlowEdgeDto\n//                    {\n//                        FromNodeId = step.Id.ToString(),\n//                        ToNodeId = l.NextStepId!.Value.ToString(),\n//                        SourceHandle = l.ButtonText\n//                    }))\n//                .ToList();\n\n//            return new SaveVisualFlowDto\n//            {\n//                FlowName = flow.FlowName,\n//                IsPublished = flow.IsPublished,\n//                Nodes = nodes,\n//                Edges = edges\n//            };\n//        }\n\n//        public async Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy)\n//        {\n//            // Load flow with children so we can remove in the right order\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//            if (flow == null)\n//                return ResponseResult.ErrorInfo(\"‚ùå Flow not found or does not belong to you.\");\n\n//            // Is this flow used by any active campaign?\n//            var inUseQuery = _context.Campaigns\n//                .Where(c => c.BusinessId == businessId &&\n//                            !c.IsDeleted &&\n//                            c.CTAFlowConfigId == flowId);\n\n//            var inUseCount = await inUseQuery.CountAsync();\n//            if (inUseCount > 0)\n//            {\n//                // Optional: show a few campaign names in the error for the UI\n//                var sample = await inUseQuery\n//                    .OrderByDescending(c => c.CreatedAt)\n//                    .Select(c => new { c.Id, c.Name, c.Status })\n//                    .Take(5)\n//                    .ToListAsync();\n\n//                Log.Warning(\"‚ùå Delete flow blocked. Flow {FlowId} is used by {Count} campaigns: {@Sample}\",\n//                    flowId, inUseCount, sample);\n\n//                return ResponseResult.ErrorInfo(\n//                    $\"‚ùå Cannot delete. This flow is attached to {inUseCount} campaign(s). \" +\n//                    $\"Delete those campaigns first.\"\n//                );\n//            }\n\n//            // Safe to remove: delete children first, then the flow\n//            foreach (var step in flow.Steps)\n//                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//            _context.CTAFlowConfigs.Remove(flow);\n\n//            await _context.SaveChangesAsync();\n//            return ResponseResult.SuccessInfo(\"‚úÖ Flow deleted.\");\n//        }\n\n\n//        public async Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Where(f => f.BusinessId == businessId && f.IsPublished)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .Select(f => new VisualFlowSummaryDto\n//                {\n//                    Id = f.Id,\n//                    FlowName = f.FlowName,\n//                    IsPublished = f.IsPublished,\n//                    CreatedAt = f.CreatedAt\n//                })\n//                .ToListAsync();\n//        }\n\n//        public async Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId)\n//        {\n//            return await _context.CTAFlowConfigs\n//                .Where(f => f.BusinessId == businessId && !f.IsPublished && f.IsActive)\n//                .OrderByDescending(f => f.CreatedAt)\n//                .Select(f => new VisualFlowSummaryDto\n//                {\n//                    Id = f.Id,\n//                    FlowName = f.FlowName,\n//                    CreatedAt = f.CreatedAt,\n//                    IsPublished = f.IsPublished\n//                })\n//                .ToListAsync();\n//        }\n\n//        public async Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber)\n//        {\n//            // Log.Information(\"üöÄ Executing follow-up for BusinessId: {BusinessId}, CurrentStepId: {StepId}\", businessId);\n//            if (currentStep == null)\n//            {\n//                Log.Warning(\"‚ö†Ô∏è Cannot execute follow-up. Current step is null.\");\n//                return ResponseResult.ErrorInfo(\"Current step not found.\");\n//            }\n\n//            // üß† Step: Look through all button links for a valid NextStepId\n//            var nextLink = currentStep.ButtonLinks.FirstOrDefault(link => link.NextStepId != null);\n\n//            if (nextLink == null)\n//            {\n//                Log.Information(\"‚ÑπÔ∏è No NextStepId defined in any ButtonLinks for StepId: {StepId}\", currentStep.Id);\n//                return ResponseResult.SuccessInfo(\"No follow-up step to execute.\");\n//            }\n\n//            // üîç Fetch the next step using new logic (via CTAFlowConfig + Steps)\n//            // 1Ô∏è‚É£ Try to resolve with smart condition check\n//            var followUpStep = await GetChainedStepAsync(businessId, nextLink.NextStepId, null, null);\n\n//            if (followUpStep == null)\n//            {\n//                Log.Warning(\"‚ùå Follow-up step skipped due to condition mismatch ‚Üí StepId: {StepId}\", nextLink.NextStepId);\n\n//                // 2Ô∏è‚É£ Optional fallback: Try same flow ‚Üí Any step without conditions\n//                var flow = await _context.CTAFlowConfigs\n//                    .Include(f => f.Steps)\n//                    .FirstOrDefaultAsync(f => f.BusinessId == businessId && f.IsPublished);\n\n//                followUpStep = flow?.Steps\n//                    .Where(s => string.IsNullOrEmpty(s.RequiredTag) && string.IsNullOrEmpty(s.RequiredSource))\n//                    .OrderBy(s => s.StepOrder)\n//                    .FirstOrDefault();\n\n//                if (followUpStep != null)\n//                {\n//                    Log.Information(\"üîÅ Fallback step selected ‚Üí StepId: {StepId}, Template: {Template}\",\n//                        followUpStep.Id, followUpStep.TemplateToSend);\n//                }\n//                else\n//                {\n//                    Log.Warning(\"üö´ No suitable fallback found in flow. Skipping follow-up.\");\n//                    return ResponseResult.SuccessInfo(\"No matching follow-up step based on user context.\");\n//                }\n//            }\n\n\n//            // üì® Send the follow-up message using the TemplateToSend field\n//            try\n//            {\n//                var template = followUpStep.TemplateToSend;\n\n//                Log.Information(\"üì§ Sending follow-up message ‚Üí Template: {Template}, To: {Recipient}\", template, recipientNumber);\n\n//                // üß™ Replace this with actual message engine call\n//                var sendDto = new SimpleTemplateMessageDto\n//                {\n//                    RecipientNumber = recipientNumber,\n//                    TemplateName = template,\n//                    TemplateParameters = new List<string>() // Add dynamic params later if needed\n//                };\n\n//                var sendResult = await _messageEngineService\n//     .SendTemplateMessageSimpleAsync(businessId, sendDto);\n\n//                if (!sendResult.Success)\n//                {\n//                    Log.Warning(\"‚ùå Follow-up message send failed ‚Üí {Template}\", template);\n//                    return ResponseResult.ErrorInfo(\"Follow-up send failed.\", sendResult.ErrorMessage);\n//                }\n\n\n//                return ResponseResult.SuccessInfo($\"Follow-up message sent using template: {template}\", null, sendResult.RawResponse);\n\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Error sending follow-up message for StepId: {StepId}\", followUpStep.Id);\n//                return ResponseResult.ErrorInfo(\"Failed to send follow-up.\");\n//            }\n//        }\n//        public Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId)\n//        {\n//            return GetChainedStepAsync(businessId, nextStepId, null, null); // Forward to full logic\n//        }\n\n//        // ‚úÖ Extended logic with condition check (Tag + Source)\n//        public async Task<CTAFlowStep?> GetChainedStepAsync(\n//            Guid businessId,\n//            Guid? nextStepId,\n//            TrackingLog? trackingLog = null,\n//            Contact? contact = null)\n//        {\n//            if (nextStepId == null)\n//            {\n//                Log.Information(\"‚ÑπÔ∏è No NextStepId provided ‚Äî skipping follow-up.\");\n//                return null;\n//            }\n\n//            try\n//            {\n//                var flow = await _context.CTAFlowConfigs\n//                    .Include(f => f.Steps)\n//                    .FirstOrDefaultAsync(f =>\n//                        f.BusinessId == businessId &&\n//                        f.Steps.Any(s => s.Id == nextStepId));\n\n//                if (flow == null)\n//                {\n//                    Log.Warning(\"‚ö†Ô∏è No flow found containing NextStepId: {NextStepId} for business: {BusinessId}\", nextStepId, businessId);\n//                    return null;\n//                }\n\n//                var followUpStep = flow.Steps.FirstOrDefault(s => s.Id == nextStepId);\n\n//                if (followUpStep == null)\n//                {\n//                    Log.Warning(\"‚ùå Step matched in flow but not found in step list: {NextStepId}\", nextStepId);\n//                    return null;\n//                }\n\n//                // ‚úÖ Check RequiredTag / Source match\n//                if (trackingLog != null)\n//                {\n//                    var isMatch = StepMatchingHelper.IsStepMatched(followUpStep, trackingLog, contact);\n\n//                    if (!isMatch)\n//                    {\n//                        Log.Information(\"üö´ Step {StepId} skipped due to condition mismatch [Tag: {Tag}, Source: {Source}]\",\n//                            followUpStep.Id, followUpStep.RequiredTag, followUpStep.RequiredSource);\n//                        return null;\n//                    }\n//                }\n\n//                Log.Information(\"‚úÖ Follow-up step found and matched ‚Üí StepId: {StepId}, Template: {Template}\",\n//                    followUpStep.Id, followUpStep.TemplateToSend);\n\n//                return followUpStep;\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while fetching chained step for NextStepId: {NextStepId}\", nextStepId);\n//                throw;\n//            }\n//        }\n\n//        // ‚úÖ Optional helper for resolving from TrackingLogId\n//        public async Task<CTAFlowStep?> GetChainedStepWithContextAsync(\n//            Guid businessId,\n//            Guid? nextStepId,\n//            Guid? trackingLogId)\n//        {\n//            var log = await _context.TrackingLogs\n//                .Include(l => l.Contact)\n//                    .ThenInclude(c => c.ContactTags)\n//                        .ThenInclude(ct => ct.Tag)\n//                .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n//            return await GetChainedStepAsync(businessId, nextStepId, log, log?.Contact);\n//        }\n\n\n//        public async Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId)\n//        {\n//            try\n//            {\n//                Log.Information(\"üö¶ Executing Visual Flow ‚Üí StepId: {StepId} | TrackingLogId: {TrackingLogId}\", startStepId, trackingLogId);\n\n//                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n//                static string ResolveGreeting(string? profileName, string? contactName)\n//                {\n//                    var s = (profileName ?? contactName)?.Trim();\n//                    return string.IsNullOrEmpty(s) ? \"there\" : s;\n//                }\n//                static void EnsureArgsLength(List<string> args, int slot1Based)\n//                {\n//                    while (args.Count < slot1Based) args.Add(string.Empty);\n//                }\n//                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n//                var log = await _context.TrackingLogs\n//                    .Include(l => l.Contact)\n//                        .ThenInclude(c => c.ContactTags)\n//                            .ThenInclude(ct => ct.Tag)\n//                    .FirstOrDefaultAsync(l => l.Id == trackingLogId);\n\n//                if (log == null)\n//                {\n//                    Log.Warning(\"‚ùå TrackingLog not found for ID: {TrackingLogId}\", trackingLogId);\n//                    return ResponseResult.ErrorInfo(\"Tracking log not found.\");\n//                }\n\n//                var step = await GetChainedStepAsync(businessId, startStepId, log, log?.Contact);\n\n//                if (step == null)\n//                {\n//                    Log.Warning(\"‚ùå No flow step matched or conditions failed ‚Üí StepId: {StepId}\", startStepId);\n//                    return ResponseResult.ErrorInfo(\"Step conditions not satisfied.\");\n//                }\n\n//                // ‚úÖ Build profile-aware args for this step (used for text templates)\n//                var args = new List<string>();\n//                if (step.UseProfileName && step.ProfileNameSlot is int slot && slot >= 1)\n//                {\n//                    // Prefer the already-loaded contact on the tracking log; fallback to DB lookup\n//                    var contact = log.Contact ?? await _context.Contacts\n//                        .AsNoTracking()\n//                        .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == (log.ContactPhone ?? \"\"));\n\n//                    var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n//                    EnsureArgsLength(args, slot);\n//                    args[slot - 1] = greet; // 1-based slot -> 0-based index\n//                }\n\n//                ResponseResult sendResult;\n\n//                // This switch block remains unchanged, except we pass args for text templates\n//                switch (step.TemplateType?.ToLower())\n//                {\n//                    case \"image_template\":\n//                        var imageDto = new ImageTemplateMessageDto\n//                        {\n//                            BusinessId = businessId,\n//                            RecipientNumber = log.ContactPhone ?? \"\",\n//                            TemplateName = step.TemplateToSend,\n//                            LanguageCode = \"en_US\"\n//                            // If your image templates support body params, you can also pass args here.\n//                        };\n//                        sendResult = await _messageEngineService.SendImageTemplateMessageAsync(imageDto, businessId);\n//                        break;\n\n//                    case \"text_template\":\n//                    default:\n//                        var textDto = new SimpleTemplateMessageDto\n//                        {\n//                            RecipientNumber = log.ContactPhone ?? \"\",\n//                            TemplateName = step.TemplateToSend,\n//                            TemplateParameters = args // ‚úÖ inject ProfileName here when configured\n//                        };\n//                        sendResult = await _messageEngineService.SendTemplateMessageSimpleAsync(businessId, textDto);\n//                        break;\n//                }\n\n//                // ‚úÖ 2. SAVE the new ID to the log\n//                var executionLog = new FlowExecutionLog\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessId,\n//                    StepId = step.Id,\n//                    FlowId = step.CTAFlowConfigId,\n//                    CampaignSendLogId = campaignSendLogId, // <-- THE NEW VALUE IS SAVED HERE\n//                    TrackingLogId = trackingLogId,\n//                    ContactPhone = log.ContactPhone,\n//                    TriggeredByButton = step.TriggerButtonText,\n//                    TemplateName = step.TemplateToSend,\n//                    TemplateType = step.TemplateType,\n//                    Success = sendResult.Success,\n//                    ErrorMessage = sendResult.ErrorMessage,\n//                    RawResponse = sendResult.RawResponse,\n//                    ExecutedAt = DateTime.UtcNow\n//                };\n\n//                _context.FlowExecutionLogs.Add(executionLog);\n//                await _context.SaveChangesAsync();\n\n//                if (sendResult.Success)\n//                {\n//                    Log.Information(\"‚úÖ Flow step executed ‚Üí Template: {Template} sent to {To}\", step.TemplateToSend, log.ContactPhone);\n//                }\n//                else\n//                {\n//                    Log.Warning(\"‚ùå Failed to send template from flow ‚Üí {Reason}\", sendResult.ErrorMessage);\n//                }\n\n//                return ResponseResult.SuccessInfo($\"Flow step executed. Sent: {sendResult.Success}\", null, sendResult.RawResponse);\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception during ExecuteVisualFlowAsync()\");\n//                return ResponseResult.ErrorInfo(\"Internal error during flow execution.\");\n//            }\n//        }\n\n//        public async Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex)\n//        {\n//            return await _context.FlowButtonLinks\n//                 .Where(l => l.CTAFlowStepId == sourceStepId\n//              && l.NextStepId != null\n//              && l.Step.CTAFlowConfigId == flowId\n//              && l.ButtonIndex == buttonIndex)\n//                .SingleOrDefaultAsync();\n\n//        }\n//        //public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n//        //{\n//        //    return await _context.Campaigns\n//        //        .Where(c => c.BusinessId == businessId\n//        //                    && !c.IsDeleted\n//        //                    && c.CTAFlowConfigId == flowId)\n//        //        .OrderByDescending(c => c.CreatedAt)\n//        //        .Select(c => new AttachedCampaignDto(c.Id, c.Name, c.Status, c.ScheduledAt))\n//        //        .ToListAsync();\n//        //}\n\n//        public async Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId)\n//        {\n//            try\n//            {\n//                // Load the flow + steps + button links (no tracking for view)\n//                var flow = await _context.CTAFlowConfigs\n//                    .AsNoTracking()\n//                    .Where(f => f.IsActive && f.BusinessId == businessId && f.Id == flowId)\n//                    .Select(f => new\n//                    {\n//                        f.Id,\n//                        f.FlowName,\n//                        f.IsPublished,\n//                        Steps = _context.CTAFlowSteps\n//                            .Where(s => s.CTAFlowConfigId == f.Id)\n//                            .OrderBy(s => s.StepOrder)\n//                            .Select(s => new\n//                            {\n//                                s.Id,\n//                                s.StepOrder,\n//                                s.TemplateToSend,\n//                                s.TemplateType,\n//                                s.TriggerButtonText,\n//                                s.TriggerButtonType,\n//                                s.PositionX,\n//                                s.PositionY,\n//                                s.UseProfileName,\n//                                s.ProfileNameSlot,\n//                                Buttons = _context.FlowButtonLinks\n//                                    .Where(b => b.CTAFlowStepId == s.Id)\n//                                    .OrderBy(b => b.ButtonIndex)\n//                                    .Select(b => new\n//                                    {\n//                                        b.ButtonText,\n//                                        b.ButtonType,\n//                                        b.ButtonSubType,\n//                                        b.ButtonValue,\n//                                        b.ButtonIndex,\n//                                        b.NextStepId\n//                                    })\n//                                    .ToList()\n//                            })\n//                            .ToList()\n//                    })\n//                    .FirstOrDefaultAsync();\n\n//                if (flow == null)\n//                {\n//                    return ResponseResult.ErrorInfo(\"Flow not found.\");\n//                }\n\n//                // Map to FE shape\n//                var nodes = flow.Steps.Select(s => new\n//                {\n//                    id = s.Id.ToString(), // node id = step id\n//                    positionX = s.PositionX ?? 0,\n//                    positionY = s.PositionY ?? 0,\n//                    templateName = s.TemplateToSend,\n//                    templateType = s.TemplateType,\n//                    triggerButtonText = s.TriggerButtonText ?? string.Empty,\n//                    triggerButtonType = s.TriggerButtonType ?? \"cta\",\n//                    requiredTag = string.Empty,       // not used in your model; keep empty\n//                    requiredSource = string.Empty,    // not used; keep empty\n//                    useProfileName = s.UseProfileName,\n//                    profileNameSlot = (s.ProfileNameSlot.HasValue && s.ProfileNameSlot.Value > 0) ? s.ProfileNameSlot.Value : 1,\n//                    buttons = s.Buttons.Select(b => new\n//                    {\n//                        text = b.ButtonText,\n//                        type = b.ButtonType,\n//                        subType = b.ButtonSubType,\n//                        value = b.ButtonValue,\n//                        targetNodeId = b.NextStepId == Guid.Empty ? null : b.NextStepId.ToString(),\n//                        index = (int)(b.ButtonIndex)\n//                    })\n//                });\n\n//                // Build edges from button links\n//                var edges = flow.Steps\n//                    .SelectMany(s => s.Buttons\n//                        .Where(b => b.NextStepId != Guid.Empty)\n//                        .Select(b => new\n//                        {\n//                            fromNodeId = s.Id.ToString(),\n//                            toNodeId = b.NextStepId.ToString(),\n//                            sourceHandle = b.ButtonText // label/handle = button text\n//                        }));\n\n//                var payload = new\n//                {\n//                    flowName = flow.FlowName,\n//                    isPublished = flow.IsPublished,\n//                    nodes,\n//                    edges\n//                };\n\n//                return ResponseResult.SuccessInfo(\"Flow loaded.\", payload);\n//            }\n//            catch (Exception ex)\n//            {\n//                Log.Error(ex, \"‚ùå Exception while loading visual flow {FlowId}\", flowId);\n//                return ResponseResult.ErrorInfo(\"Internal error while loading flow.\");\n//            }\n//        }\n//        public async Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId)\n//        {\n//            // base query: attached, non-deleted\n//            var q = _context.Campaigns\n//                .Where(c => c.BusinessId == businessId && !c.IsDeleted && c.CTAFlowConfigId == flowId);\n\n//            // earliest send per campaign\n//            var firstSends = await _context.CampaignSendLogs\n//                .Where(s => s.BusinessId == businessId && s.CampaignId != Guid.Empty)\n//                .GroupBy(s => s.CampaignId)\n//                .Select(g => new { CampaignId = g.Key, FirstSentAt = (DateTime?)g.Min(s => s.CreatedAt) })\n//                .ToListAsync();\n\n//            var firstSendMap = firstSends.ToDictionary(x => x.CampaignId, x => x.FirstSentAt);\n\n//            var list = await q\n//                .OrderByDescending(c => c.CreatedAt)\n//                .Select(c => new\n//                {\n//                    c.Id,\n//                    c.Name,\n//                    c.Status,\n//                    c.ScheduledAt,\n//                    c.CreatedAt,\n//                    c.CreatedBy\n//                })\n//                .ToListAsync();\n\n//            return list.Select(x => new AttachedCampaignDto(\n//                x.Id,\n//                x.Name,\n//                x.Status,\n//                x.ScheduledAt,\n//                x.CreatedAt,\n//                x.CreatedBy,\n//                firstSendMap.TryGetValue(x.Id, out var ts) ? ts : null\n//            )).ToList();\n//        }\n//        public async Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId)\n//        {\n//            // Load flow + children\n//            var flow = await _context.CTAFlowConfigs\n//                .Include(f => f.Steps)\n//                    .ThenInclude(s => s.ButtonLinks)\n//                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//            if (flow is null) return false;\n\n//            // Guard: any active campaign still attached?\n//            var attached = await _context.Campaigns\n//                .Where(c => c.BusinessId == businessId\n//                            && !c.IsDeleted\n//                            && c.CTAFlowConfigId == flowId)\n//                .Select(c => c.Id)\n//                .Take(1)\n//                .AnyAsync();\n\n//            if (attached) return false;\n\n//            // Hard delete (children first; FK-safe)\n//            foreach (var step in flow.Steps)\n//                _context.FlowButtonLinks.RemoveRange(step.ButtonLinks);\n\n//            _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//            _context.CTAFlowConfigs.Remove(flow);\n\n//            await _context.SaveChangesAsync();\n//            return true;\n//        }\n\n//        //public async Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .Include(f => f.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (flow is null)\n//        //        return new FlowUpdateResult { Status = \"notFound\", Message = \"Flow not found.\" };\n\n//        //    var attached = await _context.Campaigns\n//        //        .Where(c => !c.IsDeleted && c.BusinessId == businessId && c.CTAFlowConfigId == flowId)\n//        //        .Select(c => new { c.Id, c.Name, c.Status, c.ScheduledAt, c.CreatedAt, c.CreatedBy })\n//        //        .ToListAsync();\n\n//        //    if (flow.IsPublished && attached.Count > 0)\n//        //    {\n//        //        return new FlowUpdateResult\n//        //        {\n//        //            Status = \"requiresFork\",\n//        //            Message = \"This flow is published and attached to campaign(s). Create a new draft version.\",\n//        //            Campaigns = attached\n//        //        };\n//        //    }\n\n//        //    var needsRepublish = flow.IsPublished && attached.Count == 0;\n//        //    if (needsRepublish) flow.IsPublished = false; // flip to draft during edit\n\n//        //    // wipe & rebuild steps (simplest and consistent with your builder payload)\n//        //    _context.FlowButtonLinks.RemoveRange(flow.Steps.SelectMany(s => s.ButtonLinks));\n//        //    _context.CTAFlowSteps.RemoveRange(flow.Steps);\n//        //    await _context.SaveChangesAsync();\n\n//        //    flow.FlowName = string.IsNullOrWhiteSpace(dto.FlowName) ? flow.FlowName : dto.FlowName.Trim();\n//        //    flow.UpdatedAt = DateTime.UtcNow;\n\n//        //    var newSteps = new List<CTAFlowStep>();\n//        //    var nodeIdToNewGuid = new Dictionary<string, Guid>();\n\n//        //    // 1) create steps with new IDs but keep mapping from incoming node.Id\n//        //    foreach (var n in dto.Nodes)\n//        //    {\n//        //        var stepId = Guid.TryParse(n.Id, out var parsed) ? parsed : Guid.NewGuid();\n//        //        nodeIdToNewGuid[n.Id] = stepId;\n\n//        //        var s = new CTAFlowStep\n//        //        {\n//        //            Id = stepId,\n//        //            CTAFlowConfigId = flow.Id,\n//        //            TemplateToSend = n.TemplateName ?? string.Empty,\n//        //            TemplateType = n.TemplateType,\n//        //            TriggerButtonText = n.TriggerButtonText ?? \"\",\n//        //            TriggerButtonType = n.TriggerButtonType ?? \"\",\n//        //            StepOrder = 0,\n//        //            RequiredTag = n.RequiredTag,\n//        //            RequiredSource = n.RequiredSource,\n//        //            PositionX = n.PositionX,\n//        //            PositionY = n.PositionY,\n//        //            UseProfileName = n.UseProfileName,\n//        //            ProfileNameSlot = n.ProfileNameSlot\n//        //        };\n\n//        //        s.ButtonLinks = (n.Buttons ?? new List<LinkButtonDto>())\n//        //            .Select((b, idx) => new FlowButtonLink\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowStepId = s.Id,\n//        //                Step = s,\n//        //                ButtonText = b.Text ?? \"\",\n//        //                ButtonType = b.Type ?? \"QUICK_REPLY\",\n//        //                ButtonSubType = b.SubType ?? \"\",\n//        //                ButtonValue = b.Value ?? \"\",\n//        //                ButtonIndex = (short)(b.Index >= 0 ? b.Index : idx),\n//        //                NextStepId = string.IsNullOrWhiteSpace(b.TargetNodeId) ? null :\n//        //                             (Guid.TryParse(b.TargetNodeId, out var t) ? t : null)\n//        //            }).ToList();\n\n//        //        newSteps.Add(s);\n//        //    }\n\n//        //    flow.Steps = newSteps;\n//        //    await _context.SaveChangesAsync();\n\n//        //    return new FlowUpdateResult { Status = \"ok\", NeedsRepublish = needsRepublish };\n//        //}\n\n//        //public async Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user)\n//        //{\n//        //    var flow = await _context.CTAFlowConfigs\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (flow is null) return false;\n\n//        //    // sanity: basic validation can be added here (has steps, etc.)\n//        //    flow.IsPublished = true;\n//        //    flow.UpdatedAt = DateTime.UtcNow;\n//        //    await _context.SaveChangesAsync();\n//        //    return true;\n//        //}\n\n//        // ---------- FORK (create draft copy) ----------\n//        //public async Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user)\n//        //{\n//        //    var src = await _context.CTAFlowConfigs\n//        //        .Include(f => f.Steps)\n//        //            .ThenInclude(s => s.ButtonLinks)\n//        //        .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n\n//        //    if (src is null) return Guid.Empty;\n\n//        //    var dst = new CTAFlowConfig\n//        //    {\n//        //        Id = Guid.NewGuid(),\n//        //        BusinessId = src.BusinessId,\n//        //        FlowName = src.FlowName + \" (copy)\",\n//        //        IsActive = true,\n//        //        IsPublished = false, // new draft\n//        //        CreatedAt = DateTime.UtcNow,\n//        //        CreatedBy = user,\n//        //        UpdatedAt = DateTime.UtcNow\n//        //    };\n\n//        //    var oldToNew = new Dictionary<Guid, Guid>();\n\n//        //    // Clone steps first\n//        //    foreach (var s in src.Steps)\n//        //    {\n//        //        var nsId = Guid.NewGuid();\n//        //        oldToNew[s.Id] = nsId;\n\n//        //        var ns = new CTAFlowStep\n//        //        {\n//        //            Id = nsId,\n//        //            CTAFlowConfigId = dst.Id,\n//        //            TriggerButtonText = s.TriggerButtonText,\n//        //            TriggerButtonType = s.TriggerButtonType,\n//        //            TemplateToSend = s.TemplateToSend,\n//        //            TemplateType = s.TemplateType,\n//        //            StepOrder = s.StepOrder,\n//        //            RequiredTag = s.RequiredTag,\n//        //            RequiredSource = s.RequiredSource,\n//        //            PositionX = s.PositionX,\n//        //            PositionY = s.PositionY,\n//        //            UseProfileName = s.UseProfileName,\n//        //            ProfileNameSlot = s.ProfileNameSlot,\n//        //            ButtonLinks = new List<FlowButtonLink>()\n//        //        };\n\n//        //        dst.Steps.Add(ns);\n//        //    }\n\n//        //    // Clone links and rewire targets if possible\n//        //    foreach (var s in src.Steps)\n//        //    {\n//        //        var ns = dst.Steps.First(x => x.Id == oldToNew[s.Id]);\n//        //        foreach (var b in s.ButtonLinks.OrderBy(x => x.ButtonIndex))\n//        //        {\n//        //            ns.ButtonLinks.Add(new FlowButtonLink\n//        //            {\n//        //                Id = Guid.NewGuid(),\n//        //                CTAFlowStepId = ns.Id,\n//        //                Step = ns,\n//        //                ButtonText = b.ButtonText,\n//        //                ButtonType = b.ButtonType,\n//        //                ButtonSubType = b.ButtonSubType,\n//        //                ButtonValue = b.ButtonValue,\n//        //                ButtonIndex = b.ButtonIndex,\n//        //                NextStepId = b.NextStepId.HasValue && oldToNew.ContainsKey(b.NextStepId.Value)\n//        //                    ? oldToNew[b.NextStepId.Value]\n//        //                    : null\n//        //            });\n//        //        }\n//        //    }\n\n//        //    _context.CTAFlowConfigs.Add(dst);\n//        //    await _context.SaveChangesAsync();\n//        //    return dst.Id;\n//        //}\n\n\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ExtrackAllFiles.bat",
      "sha256": "3d14ccc013b9fd82ff0759820acc71da52821878e664cb4daa9418062278e799",
      "language": "bat",
      "size": 922,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\" 2>nul\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowExecutionLogger.cs",
      "sha256": "3b6ad9e86868b5c7f7f39fca399fb43a86693d088ae149f2ea9d14b7adb7a933",
      "language": "csharp",
      "size": 6046,
      "content": "// üìÑ xbytechat-api/Features/CTAFlowBuilder/Services/FlowExecutionLogger.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Serilog;\nusing xbytechat.api; // ‚úÖ Needed so AppDbContext is in scope\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Default implementation of IFlowExecutionLogger.\n    /// Writes origin-tagged rows into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionLogger : IFlowExecutionLogger\n    {\n        private readonly AppDbContext _db;\n\n        public FlowExecutionLogger(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default)\n        {\n            if (context == null) throw new ArgumentNullException(nameof(context));\n\n            try\n            {\n                var entity = new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n\n                    // core identifiers\n                    RunId = context.RunId,\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = context.StepId,\n                    StepName = context.StepName ?? string.Empty,\n\n                    // origin + linkage\n                    Origin = context.Origin,\n                    CampaignId = context.CampaignId,\n                    AutoReplyFlowId = context.AutoReplyFlowId,\n                    CampaignSendLogId = context.CampaignSendLogId,\n                    TrackingLogId = context.TrackingLogId,\n                    MessageLogId = context.MessageLogId,\n\n                    // contact + button context\n                    ContactPhone = context.ContactPhone,\n                    TriggeredByButton = context.TriggeredByButton,\n                    ButtonIndex = context.ButtonIndex,\n\n                    // template / execution info\n                    TemplateName = context.TemplateName,\n                    TemplateType = context.TemplateType,\n                    Success = context.Success,\n                    ErrorMessage = context.ErrorMessage,\n                    RawResponse = context.RawResponse,\n\n                    // timestamps + tracing\n                    ExecutedAt = context.ExecutedAtUtc ?? DateTime.UtcNow,\n                    RequestId = context.RequestId\n                };\n\n                _db.FlowExecutionLogs.Add(entity);\n                await _db.SaveChangesAsync(cancellationToken);\n            }\n            catch (Exception ex)\n            {\n                // Never let logging failures break main flow execution.\n                Log.Error(\n                    ex,\n                    \"‚ùå Failed to write FlowExecutionLog | Biz={BusinessId} Origin={Origin} Flow={FlowId} Step={StepId}\",\n                    context.BusinessId,\n                    context.Origin,\n                    context.FlowId,\n                    context.StepId\n                );\n            }\n        }\n    }\n}\n\n\n//using System;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Serilog;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Default implementation of IFlowExecutionLogger.\n//    /// Writes origin-tagged rows into FlowExecutionLogs.\n//    /// </summary>\n//    public sealed class FlowExecutionLogger : IFlowExecutionLogger\n//    {\n//        private readonly AppDbContext _db;\n\n//        public FlowExecutionLogger(AppDbContext db)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//        }\n\n//        public async Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default)\n//        {\n//            if (context == null) throw new ArgumentNullException(nameof(context));\n\n//            try\n//            {\n//                var entity = new FlowExecutionLog\n//                {\n//                    Id = Guid.NewGuid(),\n//                    RunId = context.RunId,\n//                    BusinessId = context.BusinessId,\n//                    StepId = context.StepId,\n//                    StepName = context.StepName ?? string.Empty,\n//                    FlowId = context.FlowId,\n//                    Origin = context.Origin,\n//                    CampaignId = context.CampaignId,\n//                    AutoReplyFlowId = context.AutoReplyFlowId,\n//                    CampaignSendLogId = context.CampaignSendLogId,\n//                    TrackingLogId = context.TrackingLogId,\n//                    ContactPhone = context.ContactPhone,\n//                    TriggeredByButton = context.TriggeredByButton,\n//                    TemplateName = context.TemplateName,\n//                    TemplateType = context.TemplateType,\n//                    Success = context.Success,\n//                    ErrorMessage = context.ErrorMessage,\n//                    RawResponse = context.RawResponse,\n//                    ExecutedAt = context.ExecutedAtUtc ?? DateTime.UtcNow,\n//                    MessageLogId = context.MessageLogId,\n//                    ButtonIndex = context.ButtonIndex,\n//                    RequestId = context.RequestId\n//                };\n\n//                _db.FlowExecutionLogs.Add(entity);\n//                await _db.SaveChangesAsync(cancellationToken);\n//            }\n//            catch (Exception ex)\n//            {\n//                // We never want logging failures to break the main flow.\n//                Log.Error(ex,\n//                    \"‚ùå Failed to write FlowExecutionLog | Biz={BusinessId} Origin={Origin} Flow={FlowId} Step={StepId}\",\n//                    context.BusinessId,\n//                    context.Origin,\n//                    context.FlowId,\n//                    context.StepId);\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/FlowRuntimeService.cs",
      "sha256": "2270c91af7509ae9d2638310138207b4dcb3cb7b037df59402caf14b4972dfa6",
      "language": "csharp",
      "size": 27100,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System.Text.Json;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Features.CustomeApi.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public class FlowRuntimeService : IFlowRuntimeService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IMessageEngineService _messageEngineService;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcherService;\n        private readonly ILogger<FlowRuntimeService> _logger;\n        private readonly ICtaJourneyPublisher _ctaPublisher;\n        private readonly IWhatsAppSettingsService _whatsAppSettingsService;\n        public FlowRuntimeService(\n            AppDbContext dbContext,\n            IMessageEngineService messageEngineService,\n            IWhatsAppTemplateFetcherService templateFetcherService,  ILogger<FlowRuntimeService> logger, ICtaJourneyPublisher ctaPublisher, IWhatsAppSettingsService whatsAppSettingsService)\n        {\n            _dbContext = dbContext;\n            _messageEngineService = messageEngineService;\n            _templateFetcherService = templateFetcherService;\n            _logger = logger;\n            _ctaPublisher = ctaPublisher;\n            _whatsAppSettingsService = whatsAppSettingsService;\n        }\n\n        private static string ResolveGreeting(string? profileName, string? contactName)\n        {\n            var s = (profileName ?? contactName)?.Trim();\n            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        }\n        private static void EnsureArgsLength(List<string> args, int slot1Based)\n        {\n            while (args.Count < slot1Based) args.Add(string.Empty);\n        }\n\n\n        //public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        //{\n        //    try\n        //    {\n        //        // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //        string ResolveGreeting(string? profileName, string? contactName)\n        //        {\n        //            var s = (profileName ?? contactName)?.Trim();\n        //            return string.IsNullOrEmpty(s) ? \"there\" : s;\n        //        }\n        //        void EnsureArgsLength(List<string> args, int slot1Based)\n        //        {\n        //            while (args.Count < slot1Based) args.Add(string.Empty);\n        //        }\n        //        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n        //        // 1) URL-only buttons ‚Üí no WA send, just record and return redirect\n        //        if (context.ClickedButton != null &&\n        //            context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n        //        {\n        //            _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = context.BusinessId,\n        //                FlowId = context.FlowId,\n        //                StepId = context.SourceStepId,\n        //                StepName = \"URL_REDIRECT\",\n        //                MessageLogId = context.MessageLogId,\n        //                ButtonIndex = context.ButtonIndex,\n        //                ContactPhone = context.ContactPhone,\n        //                Success = true,\n        //                ExecutedAt = DateTime.UtcNow,\n        //                RequestId = context.RequestId\n        //            });\n        //            await _dbContext.SaveChangesAsync();\n\n        //            return new NextStepResult { Success = true, RedirectUrl = context.ClickedButton.ButtonValue };\n\n\n\n        //        }\n\n        //        // 2) Load next step in the same flow (no dedupe/loop guard ‚Äî always proceed)\n        //        var targetStep = await _dbContext.CTAFlowSteps\n        //            .Include(s => s.ButtonLinks)\n        //            .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n        //                                      s.CTAFlowConfigId == context.FlowId);\n\n        //        if (targetStep == null)\n        //            return new NextStepResult { Success = false, Error = \"Target step not found.\" };\n\n        //        if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n        //            return new NextStepResult { Success = false, Error = \"Target step has no template assigned.\" };\n\n        //        var templateName = targetStep.TemplateToSend.Trim();\n\n        //        // 3) Preflight the template (resolve language and catch 132001 early)\n        //        var meta = await _templateFetcherService.GetTemplateByNameAsync(\n        //            context.BusinessId, templateName, includeButtons: true);\n\n        //        if (meta == null)\n        //        {\n        //            _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = context.BusinessId,\n        //                FlowId = context.FlowId,\n        //                StepId = targetStep.Id,\n        //                StepName = templateName,\n        //                MessageLogId = null,\n        //                ButtonIndex = context.ButtonIndex,\n        //                ContactPhone = context.ContactPhone,\n        //                Success = false,\n        //                ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n        //                RawResponse = null,\n        //                ExecutedAt = DateTime.UtcNow,\n        //                RequestId = context.RequestId\n        //            });\n        //            await _dbContext.SaveChangesAsync();\n\n        //            return new NextStepResult { Success = false, Error = $\"Template '{templateName}' not found or not approved.\" };\n        //        }\n\n        //        var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n        //        // 3.1) üî• Determine sender with failsafes (NO early return for missing context)\n        //        var provider = (context.Provider ?? string.Empty).Trim().ToUpperInvariant();\n        //        var phoneNumberId = context.PhoneNumberId;\n\n        //        // If provider missing/invalid ‚Üí try active WhatsAppSettings (fast path)\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //        {\n        //            var w = await _dbContext.WhatsAppSettings\n        //                .AsNoTracking()\n        //                .Where(x => x.BusinessId == context.BusinessId && x.IsActive)\n        //                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n        //                .FirstOrDefaultAsync();\n\n        //            if (w != null)\n        //            {\n        //                provider = (w.Provider ?? \"\").Trim().ToUpperInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = w.PhoneNumberId;\n        //            }\n        //        }\n\n        //        // If still missing provider ‚Üí hard resolve via numbers table\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //        {\n        //            var pn = await _dbContext.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == context.BusinessId && n.IsActive)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenBy(n => n.WhatsAppBusinessNumber)\n        //                .Select(n => new { n.Provider, n.PhoneNumberId })\n        //                .FirstOrDefaultAsync();\n\n        //            if (pn != null)\n        //            {\n        //                provider = (pn.Provider ?? \"\").Trim().ToUpperInvariant();\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                    phoneNumberId = pn.PhoneNumberId;\n        //            }\n        //        }\n\n        //        if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n        //            return new NextStepResult { Success = false, Error = \"No active WhatsApp sender configured (provider could not be resolved).\" };\n\n        //        // Ensure we have a sender id\n        //        if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //        {\n        //            phoneNumberId = await _dbContext.WhatsAppPhoneNumbers\n        //                .AsNoTracking()\n        //                .Where(n => n.BusinessId == context.BusinessId\n        //                            && n.IsActive\n        //                            && n.Provider.ToUpper() == provider)\n        //                .OrderByDescending(n => n.IsDefault)\n        //                .ThenBy(n => n.WhatsAppBusinessNumber)\n        //                .Select(n => n.PhoneNumberId)\n        //                .FirstOrDefaultAsync();\n\n        //            if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                return new NextStepResult { Success = false, Error = \"Missing PhoneNumberId (no default sender configured for this provider).\" };\n        //        }\n\n        //        // ‚îÄ‚îÄ Profile-name injection into body params (optional) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //        var args = new List<string>();\n        //        if (targetStep.UseProfileName && targetStep.ProfileNameSlot is int slot && slot >= 1)\n        //        {\n        //            var contact = await _dbContext.Contacts\n        //                .AsNoTracking()\n        //                .FirstOrDefaultAsync(c => c.BusinessId == context.BusinessId\n        //                                          && c.PhoneNumber == context.ContactPhone);\n\n        //            var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n        //            EnsureArgsLength(args, slot);\n        //            args[slot - 1] = greet;\n        //        }\n\n        //        var components = new List<object>();\n        //        if (args.Count > 0)\n        //        {\n        //            components.Add(new\n        //            {\n        //                type = \"body\",\n        //                parameters = args.Select(a => new { type = \"text\", text = a ?? string.Empty }).ToList()\n        //            });\n        //        }\n        //        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n        //        var payload = new\n        //        {\n        //            messaging_product = \"whatsapp\",\n        //            to = context.ContactPhone,\n        //            type = \"template\",\n        //            template = new\n        //            {\n        //                name = templateName,\n        //                language = new { code = languageCode },\n        //                components\n        //            }\n        //        };\n\n        //        // 4) SEND (explicit provider + sender) ‚Äî always attempt the POST\n        //        _logger.LogInformation(\"‚û°Ô∏è SEND-INTENT flow={Flow} step={Step} tmpl={T} to={To} provider={Prov}/{Pnid}\",\n        //            context.FlowId, targetStep.Id, templateName, context.ContactPhone, provider, phoneNumberId);\n\n        //        var sendResult = await _messageEngineService.SendPayloadAsync(\n        //            context.BusinessId,\n        //            provider,               // explicit\n        //            payload,\n        //            phoneNumberId           // explicit\n        //        );\n\n        //        // 5) Snapshot buttons for robust click mapping later\n        //        string? buttonBundleJson = null;\n        //        if (targetStep.ButtonLinks?.Count > 0)\n        //        {\n        //            var bundle = targetStep.ButtonLinks\n        //                .OrderBy(b => b.ButtonIndex)\n        //                .Select(b => new\n        //                {\n        //                    i = b.ButtonIndex,\n        //                    t = b.ButtonText ?? \"\",\n        //                    ty = b.ButtonType ?? \"QUICK_REPLY\",\n        //                    v = b.ButtonValue ?? \"\",\n        //                    ns = b.NextStepId\n        //                })\n        //                .ToList();\n\n        //            buttonBundleJson = JsonSerializer.Serialize(bundle);\n        //        }\n\n        //        // 6) Write MessageLog\n        //        var messageLog = new MessageLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = context.BusinessId,\n        //            RecipientNumber = context.ContactPhone,\n        //            CTAFlowConfigId = context.FlowId,\n        //            CTAFlowStepId = targetStep.Id,\n        //            FlowVersion = context.Version,\n        //            Source = \"flow\",\n        //            RefMessageId = context.MessageLogId,\n        //            CreatedAt = DateTime.UtcNow,\n        //            Status = sendResult.Success ? \"Sent\" : \"Failed\",\n        //            MessageId = sendResult.MessageId,\n        //            ErrorMessage = sendResult.ErrorMessage,\n        //            RawResponse = sendResult.RawResponse,\n        //            ButtonBundleJson = buttonBundleJson,\n        //            MessageContent = templateName,\n        //            SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null\n        //        };\n\n        //        _dbContext.MessageLogs.Add(messageLog);\n\n        //        // 7) Flow execution audit row\n        //        _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = context.BusinessId,\n        //            FlowId = context.FlowId,\n        //            StepId = targetStep.Id,\n        //            StepName = templateName,\n        //            MessageLogId = messageLog.Id,\n        //            ButtonIndex = context.ButtonIndex,\n        //            ContactPhone = context.ContactPhone,\n        //            Success = sendResult.Success,\n        //            ErrorMessage = sendResult.ErrorMessage,\n        //            RawResponse = sendResult.RawResponse,\n        //            ExecutedAt = DateTime.UtcNow,\n        //            RequestId = context.RequestId\n        //        });\n\n        //        await _dbContext.SaveChangesAsync();\n\n        //        return new NextStepResult\n        //        {\n        //            Success = sendResult.Success,\n        //            Error = sendResult.ErrorMessage,\n        //            RedirectUrl = null\n        //        };\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        return new NextStepResult { Success = false, Error = ex.Message };\n        //    }\n        //}\n        public async Task<NextStepResult> ExecuteNextAsync(NextStepContext context)\n        {\n            try\n            {\n                // ‚îÄ‚îÄ local helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                string ResolveGreeting(string? profileName, string? contactName)\n                {\n                    var s = (profileName ?? contactName)?.Trim();\n                    return string.IsNullOrEmpty(s) ? \"there\" : s;\n                }\n                void EnsureArgsLength(List<string> args, int slot1Based)\n                {\n                    while (args.Count < slot1Based) args.Add(string.Empty);\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // 1) URL-only buttons ‚Üí no WA send, just record and return redirect\n                if (context.ClickedButton != null &&\n                    context.ClickedButton.ButtonType?.Equals(\"URL\", StringComparison.OrdinalIgnoreCase) == true)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = context.SourceStepId,\n                        StepName = \"URL_REDIRECT\",\n                        MessageLogId = context.MessageLogId,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = true,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult { Success = true, RedirectUrl = context.ClickedButton.ButtonValue };\n                }\n\n                // 2) Load next step in the same flow\n                var targetStep = await _dbContext.CTAFlowSteps\n                    .Include(s => s.ButtonLinks)\n                    .FirstOrDefaultAsync(s => s.Id == context.TargetStepId &&\n                                              s.CTAFlowConfigId == context.FlowId);\n\n                if (targetStep == null)\n                    return new NextStepResult { Success = false, Error = \"Target step not found.\" };\n\n                if (string.IsNullOrWhiteSpace(targetStep.TemplateToSend))\n                    return new NextStepResult { Success = false, Error = \"Target step has no template assigned.\" };\n\n                var templateName = targetStep.TemplateToSend.Trim();\n\n                // 3) Preflight the template (you can replace with a DB read later if desired)\n                var meta = await _templateFetcherService.GetTemplateByNameAsync(\n                    context.BusinessId, templateName, includeButtons: true);\n\n                if (meta == null)\n                {\n                    _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = context.BusinessId,\n                        FlowId = context.FlowId,\n                        StepId = targetStep.Id,\n                        StepName = templateName,\n                        MessageLogId = null,\n                        ButtonIndex = context.ButtonIndex,\n                        ContactPhone = context.ContactPhone,\n                        Success = false,\n                        ErrorMessage = $\"Template '{templateName}' not found for this WABA.\",\n                        RawResponse = null,\n                        ExecutedAt = DateTime.UtcNow,\n                        RequestId = context.RequestId\n                    });\n                    await _dbContext.SaveChangesAsync();\n\n                    return new NextStepResult { Success = false, Error = $\"Template '{templateName}' not found or not approved.\" };\n                }\n\n                var languageCode = string.IsNullOrWhiteSpace(meta.Language) ? \"en_US\" : meta.Language;\n\n                // 3.1) Sender resolution (single source of truth via DTO, with context overrides)\n                string provider = (context.Provider ?? string.Empty).Trim().ToUpperInvariant();\n                string? phoneNumberId = context.PhoneNumberId;\n\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\" || string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    // Pull unified settings (provider + default phone for that provider)\n                    var wa = await _whatsAppSettingsService.GetSettingsByBusinessIdAsync(context.BusinessId);\n                    if (wa == null)\n                        return new NextStepResult { Success = false, Error = \"No active WhatsApp settings found.\" };\n\n                    // Context wins if valid, else fall back to DTO\n                    if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                    {\n                        var key = (wa.Provider ?? string.Empty).Trim().ToLowerInvariant();\n                        provider = key switch\n                        {\n                            \"meta_cloud\" => \"META_CLOUD\",\n                            \"pinnacle\" => \"PINNACLE\",\n                            _ => (wa.Provider ?? string.Empty).Trim().ToUpperInvariant()\n                        };\n                    }\n\n                    if (string.IsNullOrWhiteSpace(phoneNumberId))\n                        phoneNumberId = wa.PhoneNumberId; // can be null for non-meta providers\n                }\n\n                if (provider != \"PINNACLE\" && provider != \"META_CLOUD\")\n                    return new NextStepResult { Success = false, Error = \"No active WhatsApp sender configured (provider could not be resolved).\" };\n\n                if (provider == \"META_CLOUD\" && string.IsNullOrWhiteSpace(phoneNumberId))\n                    return new NextStepResult { Success = false, Error = \"Missing PhoneNumberId (no default Meta sender configured).\" };\n\n                // ‚îÄ‚îÄ Optional profile-name injection into body params ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                var args = new List<string>();\n                if (targetStep.UseProfileName && targetStep.ProfileNameSlot is int slot && slot >= 1)\n                {\n                    var contact = await _dbContext.Contacts\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(c => c.BusinessId == context.BusinessId\n                                                  && c.PhoneNumber == context.ContactPhone);\n\n                    var greet = ResolveGreeting(contact?.ProfileName, contact?.Name);\n                    EnsureArgsLength(args, slot);\n                    args[slot - 1] = greet;\n                }\n\n                var components = new List<object>();\n                if (args.Count > 0)\n                {\n                    components.Add(new\n                    {\n                        type = \"body\",\n                        parameters = args.Select(a => new { type = \"text\", text = a ?? string.Empty }).ToList()\n                    });\n                }\n                // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = context.ContactPhone,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = templateName,\n                        language = new { code = languageCode },\n                        components\n                    }\n                };\n\n                // 4) SEND (explicit provider + sender)\n                _logger.LogInformation(\"‚û°Ô∏è SEND-INTENT flow={Flow} step={Step} tmpl={T} to={To} provider={Prov}/{Pnid}\",\n                    context.FlowId, targetStep.Id, templateName, context.ContactPhone, provider, phoneNumberId);\n\n                var sendResult = await _messageEngineService.SendPayloadAsync(\n                    context.BusinessId,\n                    provider,\n                    payload,\n                    phoneNumberId\n                );\n\n                // 5) Snapshot buttons for click mapping\n                string? buttonBundleJson = null;\n                if (targetStep.ButtonLinks?.Count > 0)\n                {\n                    var bundle = targetStep.ButtonLinks\n                        .OrderBy(b => b.ButtonIndex)\n                        .Select(b => new\n                        {\n                            i = b.ButtonIndex,\n                            t = b.ButtonText ?? \"\",\n                            ty = b.ButtonType ?? \"QUICK_REPLY\",\n                            v = b.ButtonValue ?? \"\",\n                            ns = b.NextStepId\n                        })\n                        .ToList();\n\n                    buttonBundleJson = JsonSerializer.Serialize(bundle);\n                }\n\n                // 6) MessageLog\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    RecipientNumber = context.ContactPhone,\n                    CTAFlowConfigId = context.FlowId,\n                    CTAFlowStepId = targetStep.Id,\n                    FlowVersion = context.Version,\n                    Source = \"flow\",\n                    RefMessageId = context.MessageLogId,\n                    CreatedAt = DateTime.UtcNow,\n                    Status = sendResult.Success ? \"Sent\" : \"Failed\",\n                    MessageId = sendResult.MessageId,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ButtonBundleJson = buttonBundleJson,\n                    MessageContent = templateName,\n                    SentAt = sendResult.Success ? DateTime.UtcNow : (DateTime?)null\n                };\n\n                _dbContext.MessageLogs.Add(messageLog);\n\n                // 7) Flow execution audit\n                _dbContext.FlowExecutionLogs.Add(new FlowExecutionLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = context.BusinessId,\n                    FlowId = context.FlowId,\n                    StepId = targetStep.Id,\n                    StepName = templateName,\n                    MessageLogId = messageLog.Id,\n                    ButtonIndex = context.ButtonIndex,\n                    ContactPhone = context.ContactPhone,\n                    Success = sendResult.Success,\n                    ErrorMessage = sendResult.ErrorMessage,\n                    RawResponse = sendResult.RawResponse,\n                    ExecutedAt = DateTime.UtcNow,\n                    RequestId = context.RequestId\n                });\n\n                await _dbContext.SaveChangesAsync();\n\n                return new NextStepResult\n                {\n                    Success = sendResult.Success,\n                    Error = sendResult.ErrorMessage\n                };\n            }\n            catch (Exception ex)\n            {\n                return new NextStepResult { Success = false, Error = ex.Message };\n            }\n        }\n\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICtaFlowRuntimeService.cs",
      "sha256": "ba7f6a253e9b5e3af197db5060f0879595cef09e7e8e7e796b9fae4028c0f284",
      "language": "csharp",
      "size": 1518,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Runtime engine for executing CTA flows (journey flows).\n    /// \n    /// This is the single entry point used by other modules:\n    /// - AutoReply (CTA_FLOW nodes)\n    /// - Campaigns (button-click journeys)\n    /// - Future JourneyBot / Inbox actions\n    /// </summary>\n    public interface ICtaFlowRuntimeService\n    {\n        /// <summary>\n        /// Starts a CTA flow journey for a given contact.\n        /// </summary>\n        /// <param name=\"businessId\">Tenant business id.</param>\n        /// <param name=\"contactId\">Contact id in CRM (if known).</param>\n        /// <param name=\"contactPhone\">Contact phone number (WhatsApp).</param>\n        /// <param name=\"configId\">CTA flow config id (visual flow definition).</param>\n        /// <param name=\"origin\">Where this journey was triggered from.</param>\n        /// <param name=\"autoReplyFlowId\">\n        /// Optional AutoReplyFlow id when origin = AutoReply; otherwise null.\n        /// </param>\n        Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/ICTAFlowService.cs",
      "sha256": "5ea1243676c853781cb165c52e3474658a6153a617ed9b22eabf5f961d40affe",
      "language": "csharp",
      "size": 4950,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface ICTAFlowService\n    {\n        // Create-only (draft)\n        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n        // Load flows (lists)\n        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n        // Load flow (detail)\n        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId);  // for editor/view\n        Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId);          // alt payload\n\n        // Runtime\n        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText, string buttonType, string currentTemplateName, Guid? campaignId = null);\n        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n        // Delete (only if not attached)\n        Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy);\n\n        // Publish\n        Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user);\n\n        // Attached campaigns (for usage checks / modal)\n        Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId);\n\n        // (Optional utility)\n        Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId);\n    }\n}\n\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Helpers;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    public interface ICTAFlowService\n//    {\n//        // ‚úÖ Used for flow creation and saving\n//        Task<Guid> CreateFlowWithStepsAsync(CreateFlowDto dto, Guid businessId, string createdBy);\n//        Task<ResponseResult> SaveVisualFlowAsync(SaveVisualFlowDto dto, Guid businessId, string createdBy);\n\n//        // ‚úÖ Load flows\n//        Task<CTAFlowConfig?> GetFlowByBusinessAsync(Guid businessId);\n//        Task<CTAFlowConfig?> GetDraftFlowByBusinessAsync(Guid businessId);\n//        Task<List<VisualFlowSummaryDto>> GetAllPublishedFlowsAsync(Guid businessId);\n//        Task<List<VisualFlowSummaryDto>> GetAllDraftFlowsAsync(Guid businessId);\n\n//        // ‚úÖ Load and manage flow steps\n//        Task<List<CTAFlowStep>> GetStepsForFlowAsync(Guid flowId);\n\n\n//        Task<CTAFlowStep?> MatchStepByButtonAsync(Guid businessId, string buttonText,string buttonType,string currentTemplateName,Guid? campaignId = null);\n\n\n//        Task<CTAFlowStep?> GetChainedStepAsync(Guid businessId, Guid? nextStepId);\n//        Task<CTAFlowStep?> GetChainedStepWithContextAsync(Guid businessId, Guid? nextStepId, Guid? trackingLogId);\n//        // ‚úÖ Runtime logic\n//        Task<ResponseResult> ExecuteFollowUpStepAsync(Guid businessId, CTAFlowStep? currentStep, string recipientNumber);\n\n//        // ‚úÖ Flow management\n//        Task<ResponseResult> PublishFlowAsync(Guid businessId, List<FlowStepDto> steps, string createdBy);\n\n//        Task<ResponseResult> DeleteFlowAsync(Guid flowId, Guid businessId, string deletedBy);\n\n//        // ‚úÖ Editor loading (visual builder)\n//       // Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid id, Guid businessId);\n//        Task<SaveVisualFlowDto?> GetVisualFlowByIdAsync(Guid flowId, Guid businessId);\n//        Task<ResponseResult> GetVisualFlowAsync(Guid flowId, Guid businessId);\n//        Task<ResponseResult> ExecuteVisualFlowAsync(Guid businessId, Guid startStepId, Guid trackingLogId, Guid? campaignSendLogId);\n//        Task<FlowButtonLink?> GetLinkAsync(Guid flowId, Guid sourceStepId, short buttonIndex);\n\n//        public interface IFlowRuntimeService\n//        {\n//            Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n//        }\n//        Task<IReadOnlyList<AttachedCampaignDto>> GetAttachedCampaignsAsync(Guid flowId, Guid businessId);\n//        Task<bool> HardDeleteFlowIfUnusedAsync(Guid flowId, Guid businessId);\n//        //Task<FlowUpdateResult> UpdateVisualFlowAsync(Guid flowId, SaveVisualFlowDto dto, Guid businessId, string user);\n\n//        // Explicit publish after edits\n//        Task<bool> PublishFlowAsync(Guid flowId, Guid businessId, string user);\n\n//        // Create a new draft copy when live flow is attached\n//        Task<Guid> ForkFlowAsync(Guid flowId, Guid businessId, string user);\n//    }\n//}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowExecutionLogger.cs",
      "sha256": "f55acecb74866f1c84445d8583541fd60f0436c02f1f1e87815fce4ce5acf9b9",
      "language": "csharp",
      "size": 717,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Abstraction for writing origin-tagged FlowExecutionLog rows.\n    /// Different engines (Campaign, AutoReply, Inbox, JourneyBot)\n    /// will call this with a FlowExecutionContext.\n    /// </summary>\n    public interface IFlowExecutionLogger\n    {\n        /// <summary>\n        /// Persist a single step execution into FlowExecutionLogs.\n        /// </summary>\n        Task LogStepAsync(FlowExecutionContext context, CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/IFlowRuntimeService.cs",
      "sha256": "8d2c05306af47b21e2651c822e6c24d58c7a7d650b2450c09ca229416bbce7c4",
      "language": "csharp",
      "size": 1142,
      "content": "using xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public interface IFlowRuntimeService\n    {\n        Task<NextStepResult> ExecuteNextAsync(NextStepContext context);\n\n    }\n    public record NextStepContext\n    {\n        public Guid BusinessId { get; set; }\n        public Guid FlowId { get; set; }\n        public int Version { get; set; }\n        public Guid SourceStepId { get; set; }\n        public Guid? TargetStepId { get; set; }\n        public short ButtonIndex { get; set; }\n        public Guid MessageLogId { get; set; }\n        public string ContactPhone { get; set; } = string.Empty;\n        public Guid RequestId { get; set; }\n        public FlowButtonLink? ClickedButton { get; set; }\n        public string? Provider { get; set; }          // \"META_CLOUD\" | \"PINNACLE\"\n        public string? PhoneNumberId { get; set; }\n            public bool AlwaysSend { get; set; } = true;\n    }\n\n    public record NextStepResult\n    {\n        public bool Success { get; set; }\n        public string? Error { get; set; }\n        public string? RedirectUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/StepMatchingHelper.cs",
      "sha256": "4bd66fa2f33211a05e7a5a3c49de0886ae0859cbb081cacd2f4dd431be005182",
      "language": "csharp",
      "size": 1827,
      "content": "using Serilog;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.Tracking.Models;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    public static class StepMatchingHelper\n    {\n        public static bool IsStepMatched(CTAFlowStep step, TrackingLog log, Contact? contact)\n        {\n            if (!string.IsNullOrWhiteSpace(step.RequiredSource) &&\n                !string.Equals(step.RequiredSource, log.SourceType, StringComparison.OrdinalIgnoreCase))\n            {\n                Log.Information(\"üö´ Step [{StepId}] skipped: RequiredSource '{Required}' ‚â† ClickedSource '{Actual}'\",\n                    step.Id, step.RequiredSource, log.SourceType);\n                return false;\n            }\n\n            if (!string.IsNullOrWhiteSpace(step.RequiredTag))\n            {\n                if (contact == null || contact.ContactTags == null || !contact.ContactTags.Any())\n                {\n                    Log.Information(\"üö´ Step [{StepId}] skipped: Contact or Tags missing (RequiredTag: {RequiredTag})\",\n                        step.Id, step.RequiredTag);\n                    return false;\n                }\n\n                var hasTag = contact.ContactTags.Any(ct =>\n                    string.Equals(ct.Tag.Name, step.RequiredTag, StringComparison.OrdinalIgnoreCase));\n\n                if (!hasTag)\n                {\n                    var contactTags = string.Join(\", \", contact.ContactTags.Select(ct => ct.Tag.Name));\n                    Log.Information(\"üö´ Step [{StepId}] skipped: Contact tags [{Tags}] do not include RequiredTag '{Required}'\",\n                        step.Id, contactTags, step.RequiredTag);\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Controllers/CTAManagementController.cs",
      "sha256": "3d06022ca06d6b4e214bf6e571b79d311da0902eeadebddc1f7d48c18a1ecb99",
      "language": "csharp",
      "size": 2535,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.CTAManagement.Services;\n\nnamespace xbytechat.api.Features.CTAManagement.Controllers\n{\n    [ApiController]\n    [Route(\"api/ctamanagement\")]\n    [Authorize] // ‚úÖ Ensures only authenticated users can access\n    public class CTAManagementController : ControllerBase\n    {\n        private readonly ICTAManagementService _ctaService;\n\n        public CTAManagementController(ICTAManagementService ctaService)\n        {\n            _ctaService = ctaService;\n        }\n\n        // ‚úÖ GET: api/ctamanagement/get-all\n        [HttpGet(\"get-all\")]\n        public async Task<IActionResult> GetAll()\n        {\n            var data = await _ctaService.GetAllAsync();\n            return Ok(data);\n        }\n\n        // üìå GET: api/ctamanagement/get/{id}\n        [HttpGet(\"get/{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var result = await _ctaService.GetByIdAsync(id);\n            return result == null ? NotFound(\"CTA not found\") : Ok(result);\n        }\n\n        // ‚úÖ POST: api/ctamanagement/create\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> Create([FromBody] CTADefinitionDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(\"‚ùå Invalid CTA payload.\");\n\n            var success = await _ctaService.AddAsync(dto);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA created.\" })\n                : StatusCode(500, \"‚ùå Failed to create CTA.\");\n        }\n\n        // ‚úèÔ∏è PUT: api/ctamanagement/update/{id}\n        [HttpPut(\"update/{id}\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] CTADefinitionDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(\"‚ùå Invalid CTA payload.\");\n\n            var success = await _ctaService.UpdateAsync(id, dto);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA updated.\" })\n                : NotFound(\"CTA not found or update failed.\");\n        }\n\n        // üóëÔ∏è DELETE: api/ctamanagement/delete/{id}\n        [HttpDelete(\"delete/{id}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var success = await _ctaService.DeleteAsync(id);\n            return success\n                ? Ok(new { message = \"‚úÖ CTA deleted (soft).\" })\n                : NotFound(\"CTA not found or delete failed.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/DTOs/CTADefinitionDto.cs",
      "sha256": "1472d3694a4cebf363c3a632675fe61b8646f610f7a96a2687286bfb47d8eacf",
      "language": "csharp",
      "size": 707,
      "content": "namespace xbytechat.api.Features.CTAManagement.DTOs\n{\n    public class CTADefinitionDto\n    {\n        public Guid Id { get; set; }\n\n        public string Title { get; set; } = string.Empty; // üè∑Ô∏è CTA label (e.g., \"Buy Now\")\n\n        public string ButtonText { get; set; } = string.Empty; // üí¨ Visible button label (e.g., \"Buy Now\")\n\n        public string ButtonType { get; set; } = \"url\"; // üîò Expected values: \"url\", \"quick_reply\", etc.\n\n        public string TargetUrl { get; set; } = string.Empty; // üåê Redirect or action target\n\n        public string? Description { get; set; } // üìù Optional description (for context/tooltip)\n\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Models/CTADefinition.cs",
      "sha256": "96216798bd31e2098b9a2ba43dac62e067f7062f5e5c36bb318a8dab2f74da38",
      "language": "csharp",
      "size": 913,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAManagement.Models\n{\n    public class CTADefinition\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; } // üîó Business that owns this CTA\n\n        public string Title { get; set; } = string.Empty; // üè∑Ô∏è CTA label/title, e.g., \"Buy Now\"\n\n        public string ButtonText { get; set; } = string.Empty; // üí¨ Visible button label\n\n        public string ButtonType { get; set; } = \"url\"; // üîò Options: \"url\", \"quick_reply\", etc.\n\n        public string TargetUrl { get; set; } = string.Empty; // üåê Action URL or value (depending on type)\n\n        public string Description { get; set; } = string.Empty; // üìù Optional additional context\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Services/CTAManagementService.cs",
      "sha256": "a9388986726208c45f05afa2bd4ed3c74b33d7d79eb0e5863b7256e061ba4081",
      "language": "csharp",
      "size": 4621,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.CTAManagement.Models;\n\nnamespace xbytechat.api.Features.CTAManagement.Services\n{\n    public class CTAManagementService : ICTAManagementService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public CTAManagementService(AppDbContext dbContext, IHttpContextAccessor httpContextAccessor)\n        {\n            _dbContext = dbContext;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        // üîÑ Get all active CTAs for the current business\n        public async Task<List<CTADefinitionDto>> GetAllAsync()\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            return await _dbContext.CTADefinitions\n                .Where(c => c.IsActive && c.BusinessId == businessId)\n                .Select(c => new CTADefinitionDto\n                {\n                    Id = c.Id,\n                    Title = c.Title,\n                    ButtonText = c.ButtonText,\n                    ButtonType = c.ButtonType,\n                    TargetUrl = c.TargetUrl,\n                    Description = c.Description,\n                    IsActive = c.IsActive\n                }).ToListAsync();\n        }\n\n        // ‚úÖ Add new CTA\n        public async Task<bool> AddAsync(CTADefinitionDto dto)\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            var cta = new CTADefinition\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Title = dto.Title,\n                ButtonText = dto.ButtonText,\n                ButtonType = dto.ButtonType,\n                TargetUrl = dto.TargetUrl,\n                Description = dto.Description ?? \"\",\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            await _dbContext.CTADefinitions.AddAsync(cta);\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üìå Get CTA by ID\n        public async Task<CTADefinitionDto?> GetByIdAsync(Guid id)\n        {\n            var businessId = GetBusinessIdFromClaims();\n\n            var cta = await _dbContext.CTADefinitions\n                .FirstOrDefaultAsync(c => c.Id == id && c.IsActive && c.BusinessId == businessId);\n\n            if (cta == null) return null;\n\n            return new CTADefinitionDto\n            {\n                Id = cta.Id,\n                Title = cta.Title,\n                ButtonText = cta.ButtonText,\n                ButtonType = cta.ButtonType,\n                TargetUrl = cta.TargetUrl,\n                Description = cta.Description,\n                IsActive = cta.IsActive\n            };\n        }\n\n\n        // ‚úèÔ∏è Update CTA\n        public async Task<bool> UpdateAsync(Guid id, CTADefinitionDto dto)\n        {\n            var cta = await _dbContext.CTADefinitions.FindAsync(id);\n            if (cta == null) return false;\n\n            var businessId = GetBusinessIdFromClaims();\n            if (cta.BusinessId != businessId) throw new UnauthorizedAccessException(\"Unauthorized to modify this CTA.\");\n\n            cta.Title = dto.Title;\n            cta.ButtonText = dto.ButtonText;\n            cta.ButtonType = dto.ButtonType;\n            cta.TargetUrl = dto.TargetUrl;\n            cta.Description = dto.Description ?? \"\";\n            cta.IsActive = dto.IsActive;\n            cta.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üóëÔ∏è Soft Delete CTA\n        public async Task<bool> DeleteAsync(Guid id)\n        {\n            var cta = await _dbContext.CTADefinitions.FindAsync(id);\n            if (cta == null) return false;\n\n            var businessId = GetBusinessIdFromClaims();\n            if (cta.BusinessId != businessId) throw new UnauthorizedAccessException(\"Unauthorized to delete this CTA.\");\n\n            cta.IsActive = false;\n            cta.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n\n        // üîê Reusable method to extract BusinessId\n        private Guid GetBusinessIdFromClaims()\n        {\n            var claim = _httpContextAccessor.HttpContext?.User?.FindFirst(\"businessId\");\n            if (claim == null || string.IsNullOrWhiteSpace(claim.Value) || !Guid.TryParse(claim.Value, out var businessId))\n                throw new UnauthorizedAccessException(\"‚ùå Invalid or missing BusinessId claim.\");\n\n            return businessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAManagement/Services/ICTAManagementService.cs",
      "sha256": "f05abf40bdd4a593e8c8f8980c288884dc5701a5c9ba29261588816002758bcd",
      "language": "csharp",
      "size": 814,
      "content": "using xbytechat.api.Features.CTAManagement.DTOs;\n\nnamespace xbytechat.api.Features.CTAManagement.Services\n{\n    public interface ICTAManagementService\n    {\n        /// <summary>Returns all active CTAs for the current business.</summary>\n        Task<List<CTADefinitionDto>> GetAllAsync();\n\n        /// <summary>Returns a single CTA by ID (if exists).</summary>\n        Task<CTADefinitionDto?> GetByIdAsync(Guid id);\n\n        /// <summary>Adds a new CTA for the logged-in business.</summary>\n        Task<bool> AddAsync(CTADefinitionDto dto);\n\n        /// <summary>Updates an existing CTA if it belongs to the business.</summary>\n        Task<bool> UpdateAsync(Guid id, CTADefinitionDto dto);\n\n        /// <summary>Soft deletes (deactivates) a CTA entry.</summary>\n        Task<bool> DeleteAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Auth/StaticApiKeyOptions.cs",
      "sha256": "ecf8c607a6022271bcd7228448d61a6fc16c9422cd51362b665a875413409fb9",
      "language": "csharp",
      "size": 196,
      "content": "namespace xbytechat.api.Features.CustomeApi.Auth\n{\n    public sealed class StaticApiKeyOptions\n    {\n        public string? Key { get; set; }\n        public Guid? BusinessId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Controllers/CustomApiController.cs",
      "sha256": "bfd039e2c624dbefbd14dbaef2d68318799fee81a833094d7bd401b6b1c8a995",
      "language": "csharp",
      "size": 2694,
      "content": "using System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CustomeApi.Auth;\nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Features.CustomeApi.Services;\n\nnamespace xbytechat.api.Features.CustomeApi.Controllers\n{\n    [ApiController]\n    [Route(\"api/custom\")]\n    public sealed class CustomApiController : ControllerBase\n    {\n        private readonly ICustomApiService _service;\n        private readonly StaticApiKeyOptions _api;\n        private readonly CtaJourneyPublisher _journeyPublisher;\n        public CustomApiController(ICustomApiService service, IOptions<StaticApiKeyOptions> api, CtaJourneyPublisher journeyPublisher)\n        {\n            _service = service;\n            _api = api.Value;\n            _journeyPublisher = journeyPublisher;\n        }\n\n        /// <summary>\n        /// Sends a WhatsApp template (optionally with VIDEO header) by phoneNumberId.\n        /// Body: { phoneNumberId, to, templateId, variables:{ \"1\":\"...\" }, videoUrl, flowConfigId }\n        /// </summary>\n        [HttpPost(\"sendflow\")]\n        [Consumes(\"application/json\")]\n        [Produces(\"application/json\")]\n        [ProducesResponseType(typeof(object), 200)]\n        [ProducesResponseType(typeof(object), 400)]\n        [ProducesResponseType(401)]\n        public async Task<IActionResult> SendTemplate([FromBody] DirectTemplateSendRequest req, CancellationToken ct = default)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(new { success = false, message = \"‚ùå Invalid request body.\", errors = ModelState });\n\n            // Minimal shared-secret auth\n            var provided = Request.Headers[\"X-Auth-Key\"].FirstOrDefault()\n                           ?? Request.Headers[\"Authorization\"].FirstOrDefault();\n\n            if (string.IsNullOrWhiteSpace(_api.Key) ||\n                string.IsNullOrWhiteSpace(provided) ||\n                !string.Equals(provided, _api.Key, System.StringComparison.Ordinal))\n            {\n                return Unauthorized(new { success = false, message = \"üîí Invalid or missing key.\" });\n            }\n\n            var result = await _service.SendTemplateAsync(req, ct);\n            return result.Success ? Ok(result) : BadRequest(result);\n        }\n        [HttpPost(\"test-webhook\")]\n        public async Task<IActionResult> TestWebhook([FromQuery] Guid businessId, CancellationToken ct)\n        {\n            var (ok, msg) = await _journeyPublisher.ValidateAndPingAsync(businessId, ct);\n            return ok ? Ok(new { ok, message = msg }) : BadRequest(new { ok, message = msg });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Controllers/DevCustomerWebhookConfigController.cs",
      "sha256": "91f4787045211df3c7a8dea1c7dce85901295b74050cad5ddf9c55c6b72f100e",
      "language": "csharp",
      "size": 674,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\n[ApiController]\n[Route(\"api/getflow\")]\npublic class DevCustomerWebhookConfigController : ControllerBase\n{\n    private readonly AppDbContext _db;\n    public DevCustomerWebhookConfigController(AppDbContext db) => _db = db;\n\n    [HttpGet(\"{businessId:guid}\")]\n    public async Task<IActionResult> Get(Guid businessId)\n    {\n        var cfg = await _db.CustomerWebhookConfigs\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.IsActive);\n        return Ok(cfg is null ? new { found = false } : new { found = true, url = cfg.Url });\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/CtaJourneyEventDto.cs",
      "sha256": "460d6c60802762d203fe59b21a58b49a9cdc29cb9758edb878da461b5bf22f4c",
      "language": "csharp",
      "size": 964,
      "content": "using System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    public sealed class CtaJourneyEventDto\n    {\n        // User‚Äôs expected fields (nulls allowed when we don‚Äôt have them)\n        public string? userId { get; set; }            // we don‚Äôt have this ‚Üí null\n        public string? userName { get; set; }          // our Contact.ProfileName or Contact.Name\n        public string? userPhone { get; set; }         // digits only\n        public string? botId { get; set; }             // your WA PhoneNumberId or BusinessNumber (see 2.4)\n        public string? categoryBrowsed { get; set; }   // optional, keep null\n        public string? productBrowsed { get; set; }    // optional, keep null\n\n        // REQUIRED by partner: this is the key we must match\n        //public string CTAJourney { get; set; } = string.Empty;\n        [JsonPropertyName(\"CTAJourney\")]\n        public string? CTAJourney { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/DirectTemplateSendRequest.cs",
      "sha256": "d6d17b04a27f1798034ac60813911ab6b34f19e39a5ee69b272d8c88da4f85f1",
      "language": "csharp",
      "size": 2015,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CustomeApi.DTOs\n{\n    public sealed class DirectTemplateSendRequest\n    {\n        [Required] public string PhoneNumberId { get; set; } = string.Empty;\n        [Required] public string To { get; set; } = string.Empty;\n        [Required] public string TemplateId { get; set; } = string.Empty;\n\n        /// <summary>Body variable map for {{1}}, {{2}}, ...</summary>\n        public Dictionary<string, string>? Variables { get; set; }\n\n        /// <summary>Optional: provide a https .mp4 to attach a VIDEO header.</summary>\n        public string? VideoUrl { get; set; }\n\n        /// <summary>Optional CTA flow to link with this send (for click‚Üínext-step mapping and analytics).</summary>\n        public Guid? FlowConfigId { get; set; }\n    }\n}\n\n\n//using System; // <-- needed for Guid\n//using System.Collections.Generic;\n//using System.ComponentModel.DataAnnotations;\n\n//namespace xbytechat.api.Features.CustomeApi.DTOs\n//{\n//    public sealed class DirectTemplateSendRequest\n//    {\n//        [Required] public string PhoneNumberId { get; set; } = string.Empty;\n//        [Required] public string To { get; set; } = string.Empty;\n//        [Required] public string TemplateId { get; set; } = string.Empty;\n\n//        // Optional: start (link) a CTA flow on this send (we'll stamp CTAFlowConfigId/StepId on MessageLog)\n//        public Guid? FlowConfigId { get; set; }   // <---- add this\n\n//        // Body variables as WhatsApp {{1}}, {{2}}, ...\n//        public Dictionary<string, string>? Variables { get; set; }\n\n//        // Optional header media, validated based on template header type:\n//        public string? ImageUrl { get; set; } // IMAGE header\n//        public string? VideoUrl { get; set; } // VIDEO header\n//        public string? DocumentUrl { get; set; } // DOCUMENT/PDF header\n//        public string? DocumentFilename { get; set; } // optional nice filename\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/DTOs/DirectTemplateSendRequestValidator.cs",
      "sha256": "613a944117e95f84b8286c1d19d3945f5d54eb046324aba873d203a3893ec584",
      "language": "csharp",
      "size": 629,
      "content": "using FluentValidation;\n\nnamespace xbytechat.api.Features.CustomeApi.DTOs\n{\n    public sealed class DirectTemplateSendRequestValidator : AbstractValidator<DirectTemplateSendRequest>\n    {\n        public DirectTemplateSendRequestValidator()\n        {\n            RuleFor(x => x.PhoneNumberId).NotEmpty().WithMessage(\"phoneNumberId is required.\");\n            RuleFor(x => x.To).NotEmpty().WithMessage(\"'to' (recipient) is required.\");\n            RuleFor(x => x.TemplateId).NotEmpty().WithMessage(\"templateId is required.\");\n            // videoUrl required only if template header == VIDEO (checked in service)\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Models/ContactJourneyState.cs",
      "sha256": "133720f1453770ad09bd2c9bd2551f343f20df6ce27a0b88a2a7234a20e3157c",
      "language": "csharp",
      "size": 1101,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    // One row per (business, flow, contact). Enforce single row via unique index.\n    [Index(nameof(BusinessId), nameof(FlowId), nameof(ContactPhone), IsUnique = true)]\n    public class ContactJourneyState\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required] public Guid FlowId { get; set; }\n\n        // Store digits-only (same as your click processor does).\n        [Required, MaxLength(32)]\n        public string ContactPhone { get; set; } = default!;\n\n        // Running journey like: \"Yes/No/Bahut Achha\"\n        [Required] public string JourneyText { get; set; } = string.Empty;\n\n        public int ClickCount { get; set; } = 0;\n\n        [MaxLength(256)]\n        public string? LastButtonText { get; set; }\n\n        [Required] public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        [Required] public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Models/CustomerWebhookConfig.cs",
      "sha256": "c08fa705d23cd231999b48da0668ec8e9aef6db72aec24a10a7c583ee7db94e4",
      "language": "csharp",
      "size": 693,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CustomeApi.Models\n{\n    public class CustomerWebhookConfig\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(1024)]\n        public string Url { get; set; } = default!;  // customer API endpoint to receive CTAJourney\n\n        [MaxLength(2048)]\n        public string? BearerToken { get; set; }     // optional \"Authorization: Bearer <token>\"\n\n        public bool IsActive { get; set; } = true;\n\n        [Required] public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CtaJourneyMapper.cs",
      "sha256": "6a97ebadd1575997d1bd2a675cfde50b63361d45137b66242e90672084bc21b5",
      "language": "csharp",
      "size": 1719,
      "content": "using System.Text.RegularExpressions;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public static class CtaJourneyMapper\n    {\n        private static string Digits(string? s) =>\n            string.IsNullOrWhiteSpace(s) ? \"\" : Regex.Replace(s, \"[^0-9]\", \"\");\n\n    \n        public static Models.CtaJourneyEventDto Build(\n            string journeyKey,          // REQUIRED -> \"product_view_to_interest\" (your must-match)\n            Contact? contact = null,\n            string? profileName = null,\n            string? userId = null,      // we don‚Äôt have: pass null\n            string? phoneNumberId = null,   // Meta phone_number_id\n            string? businessDisplayPhone = null, // WhatsAppBusinessNumber\n            string? categoryBrowsed = null,\n            string? productBrowsed = null\n        )\n        {\n            // Choose botId priority: phoneNumberId (Meta) -> business WA number -> null\n            var botId = !string.IsNullOrWhiteSpace(phoneNumberId)\n                ? phoneNumberId!.Trim()\n                : (!string.IsNullOrWhiteSpace(businessDisplayPhone) ? Digits(businessDisplayPhone) : null);\n\n            return new Models.CtaJourneyEventDto\n            {\n                userId = userId, // normally null (we don‚Äôt store)\n                userName = profileName ?? contact?.ProfileName ?? contact?.Name,\n                userPhone = Digits(contact?.PhoneNumber),\n                botId = botId,\n                categoryBrowsed = categoryBrowsed,   // keep null \n                productBrowsed = productBrowsed,     // keep null \n                CTAJourney = journeyKey               // e.g. \"Button Name\"\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CtaJourneyPublisher.cs",
      "sha256": "d6cc88d790dc147459324a25a78082d154f457abec1fd7011683edc9e77994b9",
      "language": "csharp",
      "size": 13867,
      "content": "using System;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public class CtaJourneyPublisher : ICtaJourneyPublisher\n    {\n        private readonly AppDbContext _db;\n        private readonly IHttpClientFactory _httpFactory;\n        private readonly ILogger<CtaJourneyPublisher> _log;\n\n        private static readonly JsonSerializerOptions _json = new(JsonSerializerDefaults.Web);\n\n        public CtaJourneyPublisher(\n            AppDbContext db,\n            IHttpClientFactory httpFactory,\n            ILogger<CtaJourneyPublisher> log)\n        {\n            _db = db;\n            _httpFactory = httpFactory;\n            _log = log;\n        }\n\n        public async Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default)\n        {\n            // Load all active endpoints (only for this one customer right now)\n            var endpoints = await _db.CustomerWebhookConfigs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.IsActive)\n                .ToListAsync(ct);\n\n            if (endpoints.Count == 0)\n            {\n                _log.LogInformation(\"CTA Journey: no active endpoints for business {Biz}\", businessId);\n                return;\n            }\n\n            var client = _httpFactory.CreateClient(\"customapi-webhooks\"); // registered in DI\n\n            foreach (var ep in endpoints)\n            {\n                // Serialize once per endpoint\n                var body = JsonSerializer.Serialize(dto, _json);\n\n                const int maxAttempts = 3;\n                for (int attempt = 1; attempt <= maxAttempts; attempt++)\n                {\n                    try\n                    {\n                        using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n                        {\n                            Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n                        };\n\n                        if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n                            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n                        var resp = await client.SendAsync(req, ct);\n                        var code = (int)resp.StatusCode;\n\n                        if (code >= 200 && code < 300)\n                        {\n                            _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, code);\n                            break; // success; stop retrying this endpoint\n                        }\n\n                        var errText = await resp.Content.ReadAsStringAsync(ct);\n                        _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\", code, ep.Url, errText);\n\n                        if (attempt == maxAttempts) break;\n                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct); // 2s, 4s backoff\n                    }\n                    catch (Exception ex)\n                    {\n                        _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n                        if (attempt == maxAttempts) break;\n                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n                    }\n                }\n            }\n        }\n\n        public async Task<(bool ok, string message)> ValidateAndPingAsync(Guid businessId, CancellationToken ct = default)\n        {\n            var ep = await _db.CustomerWebhookConfigs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.IsActive)\n                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n                .FirstOrDefaultAsync(ct);\n\n            if (ep == null) return (false, \"No active CustomerWebhookConfig found for this business.\");\n            if (string.IsNullOrWhiteSpace(ep.Url)) return (false, \"Endpoint URL is empty.\");\n            if (!Uri.TryCreate(ep.Url, UriKind.Absolute, out var uri) || uri.Scheme != Uri.UriSchemeHttps)\n                return (false, \"Endpoint URL must be an absolute https URL.\");\n\n            var probe = new Models.CtaJourneyEventDto\n            {\n                userId = null,\n                userName = \"probe\",\n                userPhone = \"0000000000\",\n                botId = \"0000000000\",\n                categoryBrowsed = null,\n                productBrowsed = null,\n                CTAJourney = \"probe_to_probe\"\n            };\n\n            var client = _httpFactory.CreateClient(\"customapi-webhooks\");\n            var body = JsonSerializer.Serialize(probe, _json);\n\n            using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n            {\n                Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n            };\n\n            req.Headers.TryAddWithoutValidation(\"X-XBS-Test\", \"1\");\n\n            if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n            try\n            {\n                var resp = await client.SendAsync(req, ct);\n                var code = (int)resp.StatusCode;\n\n                if (code >= 200 && code < 300) return (true, $\"OK ({code})\");\n\n                var text = await resp.Content.ReadAsStringAsync(ct);\n                return (false, $\"HTTP {code}: {text}\");\n            }\n            catch (Exception ex)\n            {\n                return (false, $\"Exception: {ex.Message}\");\n            }\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Net.Http;\n//using System.Net.Http.Headers;\n//using System.Text;\n//using System.Text.Json;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n\n//namespace xbytechat.api.Features.CustomeApi.Services\n//{\n//    public class CtaJourneyPublisher : ICtaJourneyPublisher\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IHttpClientFactory _httpFactory;\n//        private readonly ILogger<CtaJourneyPublisher> _log;\n\n//        private static readonly JsonSerializerOptions _json =\n//            new(JsonSerializerDefaults.Web);\n\n//        public CtaJourneyPublisher(AppDbContext db, IHttpClientFactory httpFactory, ILogger<CtaJourneyPublisher> log)\n//        {\n//            _db = db;\n//            _httpFactory = httpFactory;\n//            _log = log;\n//        }\n\n\n//        public async Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default)\n//        {\n//            // load all active endpoints (only for this one customer right now)\n//            var endpoints = await _db.CustomerWebhookConfigs\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId && x.IsActive)\n//                .ToListAsync(ct);\n\n//            if (endpoints.Count == 0)\n//            {\n//                _log.LogInformation(\"CTA Journey: no active endpoints for business {Biz}\", businessId);\n//                return;\n//            }\n\n//            var client = _httpFactory.CreateClient(\"customapi-webhooks\"); // registered in DI\n//            var body = JsonSerializer.Serialize(dto, _json);\n//            using var content = new StringContent(body, Encoding.UTF8, \"application/json\");\n//            foreach (var ep in endpoints)\n//            {\n//                // simple retry (3 attempts, 2s/4s backoff)\n//                const int maxAttempts = 3;\n//                for (int attempt = 1; attempt <= maxAttempts; attempt++)\n//                {\n//                    try\n//                    {\n//                        using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n//                        {\n//                            Content = new StringContent(\n//                                JsonSerializer.Serialize(dto, _json),   // fresh content every send\n//                                Encoding.UTF8,\n//                                \"application/json\")\n//                        };\n\n//                        if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//                            req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//                        var resp = await client.SendAsync(req, ct);\n//                        if ((int)resp.StatusCode >= 200 && (int)resp.StatusCode < 300)\n//                        {\n//                            _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, (int)resp.StatusCode);\n//                            break;\n//                        }\n\n//                        var bodyText = await resp.Content.ReadAsStringAsync(ct);\n//                        _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\",\n//                            (int)resp.StatusCode, ep.Url, bodyText);\n\n//                        if (attempt == maxAttempts) break;\n//                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//                    }\n//                    catch (Exception ex)\n//                    {\n//                        _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n//                        if (attempt == maxAttempts) break;\n//                        await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//                    }\n//                }\n//            }\n\n//            //foreach (var ep in endpoints)\n//            //{\n//            //    using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url) { Content = content };\n\n//            //    // optional Bearer only (we're keeping it simple)\n//            //    if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//            //        req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//            //    // simple retry (3 attempts, 2s/4s backoff)\n//            //    const int maxAttempts = 3;\n//            //    for (int attempt = 1; attempt <= maxAttempts; attempt++)\n//            //    {\n//            //        try\n//            //        {\n//            //            var resp = await client.SendAsync(req, ct);\n//            //            if ((int)resp.StatusCode >= 200 && (int)resp.StatusCode < 300)\n//            //            {\n//            //                _log.LogInformation(\"CTA Journey posted to {Url} | {Status}\", ep.Url, (int)resp.StatusCode);\n//            //                break;\n//            //            }\n\n//            //            var bodyText = await resp.Content.ReadAsStringAsync(ct);\n//            //            _log.LogWarning(\"CTA Journey post failed ({Code}) to {Url}: {Body}\",\n//            //                (int)resp.StatusCode, ep.Url, bodyText);\n\n//            //            if (attempt == maxAttempts) break;\n//            //            await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//            //        }\n//            //        catch (Exception ex)\n//            //        {\n//            //            _log.LogWarning(ex, \"CTA Journey post exception to {Url} (attempt {Attempt})\", ep.Url, attempt);\n//            //            if (attempt == maxAttempts) break;\n//            //            await Task.Delay(TimeSpan.FromSeconds(2 * attempt), ct);\n//            //        }\n//            //    }\n//            //}\n//        }\n//        public async Task<(bool ok, string message)> ValidateAndPingAsync(Guid businessId, CancellationToken ct = default)\n//        {\n//            var ep = await _db.CustomerWebhookConfigs\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId && x.IsActive)\n//                .OrderByDescending(x => x.UpdatedAt ?? x.CreatedAt)\n//                .FirstOrDefaultAsync(ct);\n\n//            if (ep == null) return (false, \"No active CustomerWebhookConfig found for this business.\");\n//            if (string.IsNullOrWhiteSpace(ep.Url)) return (false, \"Endpoint URL is empty.\");\n//            if (!Uri.TryCreate(ep.Url, UriKind.Absolute, out var uri) || uri.Scheme != Uri.UriSchemeHttps)\n//                return (false, \"Endpoint URL must be an absolute https URL.\");\n\n//            var probe = new Models.CtaJourneyEventDto\n//            {\n//                userId = null,\n//                userName = \"probe\",\n//                userPhone = \"0000000000\",\n//                botId = \"0000000000\",\n//                categoryBrowsed = null,\n//                productBrowsed = null,\n//                CTAJourney = \"probe_to_probe\"\n//            };\n\n//            var client = _httpFactory.CreateClient(\"customapi-webhooks\");\n//            var body = JsonSerializer.Serialize(probe, _json);\n\n//            using var req = new HttpRequestMessage(HttpMethod.Post, ep.Url)\n//            {\n//                Content = new StringContent(body, Encoding.UTF8, \"application/json\")\n//            };\n//            req.Headers.TryAddWithoutValidation(\"X-XBS-Test\", \"1\");\n\n//            if (!string.IsNullOrWhiteSpace(ep.BearerToken))\n//                req.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", ep.BearerToken);\n\n//            try\n//            {\n//                var resp = await client.SendAsync(req, ct);\n//                var code = (int)resp.StatusCode;\n//                if (code >= 200 && code < 300) return (true, $\"OK ({code})\");\n//                var text = await resp.Content.ReadAsStringAsync(ct);\n//                return (false, $\"HTTP {code}: {text}\");\n//            }\n//            catch (Exception ex)\n//            {\n//                return (false, $\"Exception: {ex.Message}\");\n//            }\n//        }\n\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/CustomApiService.cs",
      "sha256": "78a7353f5a8e6c720e2640c507df52730cd9b75e8803abe3590bf51c67a63259",
      "language": "csharp",
      "size": 27860,
      "content": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Newtonsoft.Json; \nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;                       \nusing xbytechat_api.Features.Billing.Services;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Helpers;\nusing System.Text.RegularExpressions;      \n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public sealed class CustomApiService : ICustomApiService\n    {\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly IBillingIngestService _billingIngest;\n        private readonly ILogger<CustomApiService> _logger;\n\n        public CustomApiService(\n            AppDbContext context,\n            IWhatsAppTemplateFetcherService templateFetcher,\n            IMessageEngineService messageEngine,\n            IBillingIngestService billingIngest,\n            ILogger<CustomApiService> logger)\n        {\n            _context = context;\n            _templateFetcher = templateFetcher;\n            _messageEngine = messageEngine;\n            _billingIngest = billingIngest;\n            _logger = logger;\n        }\n\n        public async Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default)\n        {\n            try\n            {\n                var toNormalized = NormalizePhone(req.To);\n                var reqId = Guid.NewGuid();\n\n                // 1) Resolve WhatsApp sender by phoneNumberId (across all businesses)\n                //var ws = await _context.WhatsAppPhoneNumbers.AsNoTracking()\n                //    .Where(s => s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n                //    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                //    .FirstOrDefaultAsync(ct);\n\n                var ws = await _context.WhatsAppPhoneNumbers.AsNoTracking()\n                    .Where(s =>  s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                   .FirstOrDefaultAsync(ct);\n\n\n\n                if (ws == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Active WhatsApp sender (phoneNumberId) not found.\");\n\n                var businessId = ws.BusinessId;\n                var provider = (ws.Provider ?? \"\").Trim().ToUpperInvariant(); // \"META_CLOUD\" | \"PINNACLE\"\n                if (provider != \"META_CLOUD\" && provider != \"PINNACLE\")\n                    return ResponseResult.ErrorInfo($\"‚ùå Unsupported provider: {provider}\");\n\n                _logger.LogInformation(\n                    \"[CustomAPI:{ReqId}] Begin send. biz={BusinessId} pnid={PhoneNumberId} to={MaskedTo} template={TemplateId}\",\n                    reqId, businessId, req.PhoneNumberId, Mask(toNormalized), req.TemplateId);\n\n                // 2) Fetch template meta (for language + buttons)\n                var meta = await _templateFetcher.GetTemplateByNameAsync(businessId, req.TemplateId, includeButtons: true);\n                if (meta == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Template metadata not found for the given templateId.\");\n\n                var languageCode = (meta.Language ?? \"\").Trim();\n                if (string.IsNullOrWhiteSpace(languageCode))\n                    return ResponseResult.ErrorInfo(\"‚ùå Template language not resolved from provider metadata.\");\n\n                // 3) Header decision\n                var isVideoHeader = !string.IsNullOrWhiteSpace(req.VideoUrl);\n                if (isVideoHeader && !IsHttpsMp4Url(req.VideoUrl, out var vErr))\n                    return ResponseResult.ErrorInfo(\"üö´ Invalid VideoUrl.\", vErr);\n\n                // 4) Build components\n                var (components, whyBuildFail) = BuildComponents(isVideoHeader, req.Variables, req.VideoUrl);\n                if (components == null)\n                {\n                    _logger.LogWarning(\"[CustomAPI:{ReqId}] Component build failed: {Err}\", reqId, whyBuildFail);\n                    return ResponseResult.ErrorInfo($\"üö´ Component build failed: {whyBuildFail}\");\n                }\n\n                // 5) Snapshot first 3 buttons (optional analytics)\n                string? buttonBundleJson = null;\n                try\n                {\n                    if (meta.ButtonParams is { Count: > 0 })\n                    {\n                        var bundle = meta.ButtonParams.Take(3)\n                            .Select((b, i) => new\n                            {\n                                i,\n                                position = i + 1,\n                                text = (b.Text ?? \"\").Trim(),\n                                type = b.Type,\n                                subType = b.SubType\n                            }).ToList();\n                        buttonBundleJson = JsonConvert.SerializeObject(bundle);\n                    }\n                }\n                catch { /* best-effort snapshot */ }\n\n                // 6) Entry step for linked flow (optional)\n                Guid? entryStepId = null;\n                if (req.FlowConfigId.HasValue)\n                {\n                    entryStepId = await _context.CTAFlowSteps\n                        .Where(s => s.CTAFlowConfigId == req.FlowConfigId.Value)\n                        .OrderBy(s => s.StepOrder)\n                        .Select(s => (Guid?)s.Id)\n                        .FirstOrDefaultAsync(ct);\n                }\n\n                // 7) Build provider payload\n                var languageField = new { policy = \"deterministic\", code = string.IsNullOrWhiteSpace(languageCode) ? \"en_US\" : languageCode };\n                var payload = new\n                {\n                    messaging_product = \"whatsapp\",\n                    to = toNormalized,\n                    type = \"template\",\n                    template = new\n                    {\n                        name = req.TemplateId,\n                        language = languageField,\n                        components\n                    }\n                };\n\n                _logger.LogInformation(\"[CustomAPI:{ReqId}] Sending {Template} to {To} via {Provider} (PNID={PNID}) video={Video}\",\n                    reqId, req.TemplateId, Mask(toNormalized), provider, req.PhoneNumberId, isVideoHeader);\n\n                // 8) Send\n                var result = await _messageEngine.SendPayloadAsync(\n                    businessId: businessId,\n                    provider: provider,\n                    payload: payload,\n                    phoneNumberId: req.PhoneNumberId\n                );\n\n                // 9) Log + billing\n                var now = DateTime.UtcNow;\n                var logId = Guid.NewGuid();\n\n                _context.MessageLogs.Add(new MessageLog\n                {\n                    Id = logId,\n                    BusinessId = businessId,\n                    CampaignId = null,\n                    RecipientNumber = toNormalized,\n                    MessageContent = req.TemplateId,\n                    MediaUrl = isVideoHeader ? req.VideoUrl : null,\n                    Status = result.Success ? \"Sent\" : \"Failed\",\n                    MessageId = result.MessageId,          // or just ProviderMessageId; keep one if you want to de-dup\n                    ProviderMessageId = result.MessageId,\n                    ErrorMessage = result.ErrorMessage,\n                    RawResponse = result.RawResponse,\n                    CreatedAt = now,\n                    SentAt = result.Success ? now : (DateTime?)null,\n                    Source = \"custom_api\",\n                    Provider = provider,\n                    CTAFlowConfigId = req.FlowConfigId,\n                    CTAFlowStepId = entryStepId,\n                    ButtonBundleJson = buttonBundleJson\n                });\n\n                await _context.SaveChangesAsync(ct);\n\n                await _billingIngest.IngestFromSendResponseAsync(\n                    businessId: businessId,\n                    messageLogId: logId,\n                    provider: provider,\n                    rawResponseJson: result.RawResponse ?? \"{}\"\n                );\n\n                _logger.LogInformation(\"[CustomAPI:{ReqId}] Done. success={Success} msgId={MessageId} flow={Flow} step={Step}\",\n                    reqId, result.Success, result.MessageId, req.FlowConfigId, entryStepId);\n\n                return result.Success\n                    ? ResponseResult.SuccessInfo(\"üöÄ Template sent.\",\n                        new\n                        {\n                            messageId = result.MessageId,\n                            to = toNormalized,\n                            templateId = req.TemplateId,\n                            flowConfigId = req.FlowConfigId,\n                            flowEntryStepId = entryStepId\n                        })\n                    : ResponseResult.ErrorInfo(\"‚ùå Send failed.\", result.ErrorMessage);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Exception in CustomApiService.SendTemplateAsync\");\n                return ResponseResult.ErrorInfo(\"üö® Server error while sending template.\", ex.ToString());\n            }\n        }\n\n        // ===== helpers (unchanged) =====\n        private static string NormalizePhone(string raw) => raw.StartsWith(\"+\") ? raw[1..] : raw;\n        private static string Mask(string phone) => phone.Length <= 6 ? phone : $\"{new string('*', phone.Length - 4)}{phone[^4..]}\";\n        private static bool IsHttpsMp4Url(string? url, out string? err)\n        {\n            err = null;\n            if (string.IsNullOrWhiteSpace(url)) { err = \"VideoUrl is required when sending a VIDEO header.\"; return false; }\n            if (!Uri.TryCreate(url, UriKind.Absolute, out var u)) { err = \"VideoUrl must be an absolute URL.\"; return false; }\n            if (u.Scheme != Uri.UriSchemeHttps) { err = \"VideoUrl must be HTTPS.\"; return false; }\n            if (!u.AbsolutePath.EndsWith(\".mp4\", StringComparison.OrdinalIgnoreCase)) { err = \"VideoUrl must point to an .mp4 file.\"; return false; }\n            return true;\n        }\n        //private static (List<object>? components, string? whyFail) BuildComponents(bool addVideoHeader, Dictionary<string, string>? variables, string? videoUrl)\n        //{\n        //    try\n        //    {\n        //        var components = new List<object>();\n        //        if (addVideoHeader)\n        //        {\n        //            components.Add(new\n        //            {\n        //                type = \"header\",\n        //                parameters = new object[] { new { type = \"video\", video = new { link = videoUrl } } }\n        //            });\n        //        }\n        //        if (variables is { Count: > 0 })\n        //        {\n        //            var bodyParams = variables\n        //                .Select(kv => (Index: int.TryParse(kv.Key, out var n) ? n : int.MaxValue, Text: kv.Value ?? string.Empty))\n        //                .OrderBy(x => x.Index)\n        //                .Select(x => new { type = \"text\", text = x.Text })\n        //                .ToArray();\n\n        //            if (bodyParams.Length > 0)\n        //                components.Add(new { type = \"body\", parameters = bodyParams });\n        //        }\n        //        return (components, null);\n        //    }\n        //    catch (Exception ex) { return (null, ex.Message); }\n        //}\n        private static (List<object>? components, string? whyFail) BuildComponents(\n         bool addVideoHeader,\n         Dictionary<string, string>? variables,\n         string? videoUrl)\n        {\n            try\n            {\n                var components = new List<object>();\n\n                // Header (optional video)\n                if (addVideoHeader)\n                {\n                    components.Add(new\n                    {\n                        type = \"header\",\n                        parameters = new object[]\n                        {\n                    new { type = \"video\", video = new { link = videoUrl } }\n                        }\n                    });\n                }\n\n                // Body params ({{1}}, {{2}}, ...) ‚Äî tolerate keys like \"1\", \"2\", \"para1\", \"foo2\"\n                if (variables is { Count: > 0 })\n                {\n                    var list = variables.ToList(); // preserves insertion order for non-numbered keys\n\n                    var bodyParams = list\n                        .Select((kv, idx) =>\n                        {\n                            var m = Regex.Match(kv.Key ?? string.Empty, @\"\\d+\");\n\n                            int n = 0; // declare first so it's always definitely assigned\n                            bool hasNum = m.Success && int.TryParse(m.Value, out n) && n > 0;\n\n                            // Numbered keys come first ordered by n; others follow in insertion order\n                            int orderKey = hasNum ? n : int.MaxValue - (list.Count - idx);\n\n                            return new { Order = orderKey, Text = kv.Value ?? string.Empty };\n                        })\n                        .OrderBy(x => x.Order)\n                        .Select(x => new { type = \"text\", text = x.Text })\n                        .ToArray();\n\n                    if (bodyParams.Length > 0)\n                        components.Add(new { type = \"body\", parameters = bodyParams });\n                }\n\n\n                return (components, null);\n            }\n            catch (Exception ex)\n            {\n                return (null, ex.Message);\n            }\n        }\n\n\n    }\n}\n\n//using System;\n//using System.Linq;\n//using System.Collections.Generic;\n//using System.Security.Claims;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using Microsoft.AspNetCore.Http;\n//using Newtonsoft.Json;\n//using xbytechat.api.Features.CustomeApi.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services; // IMessageEngineService\n//using xbytechat.api.Features.TemplateModule.Services; // IWhatsAppTemplateFetcherService\n//using xbytechat.api.Models;                         // MessageLog\n//using xbytechat.api.Shared;                         // ResponseResult\n//using xbytechat_api.Features.Billing.Services;\n//using xbytechat.api.Helpers;      // IBillingIngestService\n//using xbytechat.api.WhatsAppSettings;\n//using xbytechat_api.WhatsAppSettings.Services;\n//namespace xbytechat.api.Features.CustomeApi.Services\n//{\n//    public sealed class CustomApiService : ICustomApiService\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IHttpContextAccessor _http;\n//        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n//        private readonly IMessageEngineService _messageEngine;\n//        private readonly IBillingIngestService _billingIngest;\n//        private readonly ILogger<CustomApiService> _logger;\n\n//        public CustomApiService(\n//            AppDbContext context,\n//            IHttpContextAccessor http,\n//            IWhatsAppTemplateFetcherService templateFetcher,\n//            IMessageEngineService messageEngine,\n//            IBillingIngestService billingIngest,\n//            ILogger<CustomApiService> logger)\n//        {\n//            _context = context;\n//            _http = http;\n//            _templateFetcher = templateFetcher;\n//            _messageEngine = messageEngine;\n//            _billingIngest = billingIngest;\n//            _logger = logger;\n//        }\n\n//        public async Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default)\n//        {\n//            try\n//            {\n//                // --- 0) Basic validation\n//                if (string.IsNullOrWhiteSpace(req.PhoneNumberId))\n//                    return ResponseResult.ErrorInfo(\"‚ùå phoneNumberId is required.\");\n//                if (string.IsNullOrWhiteSpace(req.To))\n//                    return ResponseResult.ErrorInfo(\"‚ùå 'to' (recipient) is required.\");\n//                if (string.IsNullOrWhiteSpace(req.TemplateId))\n//                    return ResponseResult.ErrorInfo(\"‚ùå templateId is required.\");\n\n//                var businessId = GetBusinessIdOrThrow();\n//                var toNormalized = NormalizePhone(req.To);\n\n//                var reqId = Guid.NewGuid();\n//                _logger.LogInformation(\n//                    \"[CustomAPI:{ReqId}] Begin send. biz={BusinessId} pnid={PhoneNumberId} to={MaskedTo} template={TemplateId}\",\n//                    reqId, businessId, req.PhoneNumberId, Mask(toNormalized), req.TemplateId);\n\n//                // --- 1) Resolve provider by phoneNumberId for this Business\n//                var ws = await _context.WhatsAppSettings.AsNoTracking()\n//                    .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId == req.PhoneNumberId)\n//                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n//                    .FirstOrDefaultAsync(ct);\n\n//                if (ws == null)\n//                    return ResponseResult.ErrorInfo(\"‚ùå Active WhatsApp sender (phoneNumberId) not found for this Business.\");\n\n//                var provider = (ws.Provider ?? \"\").Trim().ToUpperInvariant(); // \"META_CLOUD\" | \"PINNACLE\"\n//                if (provider != \"META_CLOUD\" && provider != \"PINNACLE\")\n//                    return ResponseResult.ErrorInfo($\"‚ùå Unsupported provider configured for this sender: {provider}\");\n\n//                // --- 2) Fetch template meta\n//                // NOTE: your metadata doesn't expose HeaderType; we just read language & buttons. \n//                var meta = await _templateFetcher.GetTemplateByNameAsync(businessId, req.TemplateId, includeButtons: true);\n//                if (meta == null)\n//                    return ResponseResult.ErrorInfo(\"‚ùå Template metadata not found for the given templateId.\");\n\n//                var languageCode = (meta.Language ?? \"\").Trim();\n//                if (string.IsNullOrWhiteSpace(languageCode))\n//                    return ResponseResult.ErrorInfo(\"‚ùå Template language not resolved from provider metadata.\");\n\n//                // Decide header by request: if VideoUrl present -> add VIDEO header; otherwise TEXT-only\n//                var isVideoHeader = !string.IsNullOrWhiteSpace(req.VideoUrl);\n//                if (isVideoHeader && !IsHttpsMp4Url(req.VideoUrl, out var vErr))\n//                    return ResponseResult.ErrorInfo(\"üö´ Invalid VideoUrl.\", vErr);\n\n//                // --- 3) Build components (TEXT or VIDEO)\n//                var (components, whyBuildFail) = BuildComponents(isVideoHeader, req.Variables, req.VideoUrl);\n//                if (components == null)\n//                {\n//                    _logger.LogWarning(\"[CustomAPI:{ReqId}] Component build failed: {Err}\", reqId, whyBuildFail);\n//                    return ResponseResult.ErrorInfo($\"üö´ Component build failed: {whyBuildFail}\");\n//                }\n\n//                // Snapshot first 3 buttons (if any) for analytics/click mapping (same as campaigns)\n//                string? buttonBundleJson = null;\n//                try\n//                {\n//                    if (meta.ButtonParams is { Count: > 0 })\n//                    {\n//                        var bundle = meta.ButtonParams.Take(3)\n//                            .Select((b, i) => new\n//                            {\n//                                i,\n//                                position = i + 1,\n//                                text = (b.Text ?? \"\").Trim(),\n//                                type = b.Type,\n//                                subType = b.SubType\n//                            }).ToList();\n//                        buttonBundleJson = JsonConvert.SerializeObject(bundle);\n//                    }\n//                }\n//                catch { /* best-effort snapshot */ }\n\n//                // Find entry step of the linked flow (if provided)\n//                Guid? entryStepId = null;\n//                if (req.FlowConfigId.HasValue)\n//                {\n//                    entryStepId = await _context.CTAFlowSteps\n//                        .Where(s => s.CTAFlowConfigId == req.FlowConfigId.Value)\n//                        .OrderBy(s => s.StepOrder)\n//                        .Select(s => (Guid?)s.Id)\n//                        .FirstOrDefaultAsync(ct);\n//                }\n\n\n//                // Always object. Meta accepts { code: \"en_US\" } and ignores policy if present.\n//                // Pinnacle REQUIRES an object.\n//                var languageField = new\n//                {\n//                    policy = \"deterministic\",\n//                    code = string.IsNullOrWhiteSpace(languageCode) ? \"en_US\" : languageCode\n//                };\n\n//                var payload = new\n//                {\n//                    messaging_product = \"whatsapp\",\n//                    to = toNormalized,\n//                    type = \"template\",\n//                    template = new\n//                    {\n//                        name = req.TemplateId,\n//                        language = languageField,\n//                        components\n//                    }\n//                };\n\n\n//                _logger.LogInformation(\"[CustomAPI:{ReqId}] Sending {Template} to {To} via {Provider} (PNID={PNID}) video={Video}\",\n//                    reqId, req.TemplateId, Mask(toNormalized), provider, req.PhoneNumberId, isVideoHeader);\n\n//                var result = await _messageEngine.SendPayloadAsync(\n//                    businessId: businessId,\n//                    provider: provider,\n//                    payload: payload,\n//                    phoneNumberId: req.PhoneNumberId   // ‚úÖ correct parameter\n//                );\n\n//                // --- 5) Persist MessageLog (and flow linkage), then billing\n//                var now = DateTime.UtcNow;\n//                var logId = Guid.NewGuid();\n\n//                _context.MessageLogs.Add(new MessageLog\n//                {\n//                    Id = logId,\n//                    BusinessId = businessId,\n//                    CampaignId = null,                         // direct API path\n//                    RecipientNumber = toNormalized,\n//                    MessageContent = req.TemplateId,\n//                    MediaUrl = isVideoHeader ? req.VideoUrl : null,\n//                    Status = result.Success ? \"Sent\" : \"Failed\",\n//                    MessageId = result.MessageId,\n//                    ErrorMessage = result.ErrorMessage,\n//                    RawResponse = result.RawResponse,\n//                    CreatedAt = now,\n//                    SentAt = result.Success ? now : (DateTime?)null,\n//                    Source = \"custom_api\",\n//                    Provider = provider,\n//                    ProviderMessageId = result.MessageId,\n\n//                    // üîó Store flow linkage like campaigns do\n//                    CTAFlowConfigId = req.FlowConfigId,\n//                    CTAFlowStepId = entryStepId,\n//                    ButtonBundleJson = buttonBundleJson\n//                });\n\n//                await _context.SaveChangesAsync(ct);\n\n//                await _billingIngest.IngestFromSendResponseAsync(\n//                    businessId: businessId,\n//                    messageLogId: logId,\n//                    provider: provider,\n//                    rawResponseJson: result.RawResponse ?? \"{}\"\n//                );\n\n//                _logger.LogInformation(\"[CustomAPI:{ReqId}] Done. success={Success} msgId={MessageId} flow={Flow} step={Step}\",\n//                    reqId, result.Success, result.MessageId, req.FlowConfigId, entryStepId);\n\n//                return result.Success\n//                    ? ResponseResult.SuccessInfo(\"üöÄ Template sent.\",\n//                        new\n//                        {\n//                            messageId = result.MessageId,\n//                            to = toNormalized,\n//                            templateId = req.TemplateId,\n//                            flowConfigId = req.FlowConfigId,\n//                            flowEntryStepId = entryStepId\n//                        })\n//                    : ResponseResult.ErrorInfo(\"‚ùå Send failed.\", result.ErrorMessage);\n//            }\n//            catch (Exception ex)\n//            {\n//                _logger.LogError(ex, \"‚ùå Exception in CustomApiService.SendTemplateAsync\");\n//                return ResponseResult.ErrorInfo(\"üö® Server error while sending template.\", ex.ToString());\n//            }\n//        }\n\n//        // ===== helpers =====\n\n//        private Guid GetBusinessIdOrThrow()\n//        {\n//            var user = _http.HttpContext?.User;\n//            if (user == null) throw new InvalidOperationException(\"Missing HttpContext/User.\");\n\n//            var bid = user.FindFirstValue(\"BusinessId\") ?? user.FindFirstValue(\"bid\") ?? user.FindFirstValue(\"business_id\");\n//            if (string.IsNullOrWhiteSpace(bid)) throw new InvalidOperationException(\"BusinessId claim is missing.\");\n//            return Guid.Parse(bid);\n//        }\n\n//        private static string NormalizePhone(string raw) => raw.StartsWith(\"+\") ? raw[1..] : raw;\n\n//        private static string Mask(string phone)\n//            => phone.Length <= 6 ? phone : $\"{new string('*', phone.Length - 4)}{phone[^4..]}\";\n\n//        private static bool IsHttpsMp4Url(string? url, out string? err)\n//        {\n//            err = null;\n//            if (string.IsNullOrWhiteSpace(url)) { err = \"VideoUrl is required when sending a VIDEO header.\"; return false; }\n//            if (!Uri.TryCreate(url, UriKind.Absolute, out var u)) { err = \"VideoUrl must be an absolute URL.\"; return false; }\n//            if (u.Scheme != Uri.UriSchemeHttps) { err = \"VideoUrl must be HTTPS.\"; return false; }\n//            if (!u.AbsolutePath.EndsWith(\".mp4\", StringComparison.OrdinalIgnoreCase)) { err = \"VideoUrl must point to an .mp4 file.\"; return false; }\n//            return true;\n//        }\n\n//        private static (List<object>? components, string? whyFail) BuildComponents(\n//            bool addVideoHeader,\n//            Dictionary<string, string>? variables,\n//            string? videoUrl)\n//        {\n//            try\n//            {\n//                var components = new List<object>();\n\n//                // Header (optional video)\n//                if (addVideoHeader)\n//                {\n//                    components.Add(new\n//                    {\n//                        type = \"header\",\n//                        parameters = new object[]\n//                        {\n//                            new { type = \"video\", video = new { link = videoUrl } }\n//                        }\n//                    });\n//                }\n\n//                // Body params ({{1}}, {{2}}, ...)\n//                if (variables is { Count: > 0 })\n//                {\n//                    var bodyParams = variables\n//                        .Select(kv => (Index: int.TryParse(kv.Key, out var n) ? n : int.MaxValue, Text: kv.Value ?? string.Empty))\n//                        .OrderBy(x => x.Index)\n//                        .Select(x => new { type = \"text\", text = x.Text })\n//                        .ToArray();\n\n//                    if (bodyParams.Length > 0)\n//                        components.Add(new { type = \"body\", parameters = bodyParams });\n//                }\n\n//                return (components, null);\n//            }\n//            catch (Exception ex)\n//            {\n//                return (null, ex.Message);\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/ICtaJourneyPublisher.cs",
      "sha256": "179ba5f2372125cfe3c2aed455b5c8efa5b8f6de13ef2478d2e7e6df7890cd8e",
      "language": "csharp",
      "size": 443,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public interface ICtaJourneyPublisher\n    {\n        /// <summary>\n        /// Posts a CTAJourney event for the given business to all active endpoints in CustomerWebhookConfigs.\n        /// </summary>\n        Task PublishAsync(Guid businessId, Models.CtaJourneyEventDto dto, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CustomeApi/Services/ICustomApiService.cs",
      "sha256": "76cd53ece80c088bec742c33974d8a8be781cd297d3d68e474150b19707e1f1e",
      "language": "csharp",
      "size": 377,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CustomeApi.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CustomeApi.Services\n{\n    public interface ICustomApiService\n    {\n        Task<ResponseResult> SendTemplateAsync(DirectTemplateSendRequest req, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/EntitlementsController.cs",
      "sha256": "0c435fe50cb96bd08c30f57eb23775a506bd85d7555798508742e38ecc668977",
      "language": "csharp",
      "size": 3151,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Helpers; // ‚úÖ Use shared helpers for claims\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    [ApiController]\n    [Route(\"api/entitlements\")]\n    [Authorize]\n    public sealed class EntitlementsController : ControllerBase\n    {\n        private readonly IQuotaService _quota;\n\n        // Roles are stored lower-case in JWT (JwtTokenService),\n        // so we treat \"admin\" and \"superadmin\" as global admins.\n        private const string AdminRoleAdmin = \"admin\";\n        private const string AdminRoleSuperAdmin = \"superadmin\";\n\n        public EntitlementsController(IQuotaService quota)\n        {\n            _quota = quota;\n        }\n\n        // Helpers\n        private Guid? TryGetCallerBusinessId()\n        {\n            // Centralized logic: reads \"businessId\" claim.\n            var id = UserContextHelper.GetBusinessId(User);\n            return id == Guid.Empty ? (Guid?)null : id;\n        }\n\n        private bool IsAdmin()\n        {\n            return User.IsInRole(AdminRoleAdmin) || User.IsInRole(AdminRoleSuperAdmin);\n        }\n\n        private bool IsAuthorizedFor(Guid targetBusinessId)\n        {\n            if (IsAdmin()) return true;\n\n            var callerBiz = TryGetCallerBusinessId();\n            return callerBiz.HasValue && callerBiz.Value == targetBusinessId;\n        }\n\n        // GET /api/entitlements/{businessId}\n        [HttpGet(\"{businessId:guid}\")]\n        public async Task<ActionResult<EntitlementsSnapshotDto>> GetSnapshot(\n            Guid businessId,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            var dto = await _quota.GetSnapshotAsync(businessId, ct);\n            return Ok(dto);\n        }\n\n        // POST /api/entitlements/{businessId}/check\n        [HttpPost(\"{businessId:guid}/check\")]\n        public async Task<ActionResult<EntitlementResultDto>> Check(\n            Guid businessId,\n            [FromBody] EntitlementCheckDto? req,\n            CancellationToken ct)\n        {\n            if (!IsAuthorizedFor(businessId))\n                return Forbid();\n\n            if (req is null)\n                return BadRequest(\"Request body is required.\");\n\n            if (string.IsNullOrWhiteSpace(req.QuotaKey))\n                return BadRequest(\"QuotaKey required.\");\n\n            var amount = Math.Max(1, req.Amount);\n\n            var result = req.ConsumeOnSuccess\n                ? await _quota.CheckAndConsumeAsync(businessId, req.QuotaKey, amount, ct)\n                : await _quota.CheckAsync(businessId, req.QuotaKey, amount, ct);\n\n            if (!result.Allowed)\n                // 429 payload shape is already what your axios interceptor expects:\n                // { allowed:false, quotaKey, limit, remaining, message }\n                return StatusCode(429, result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Controllers/PlanQuotasAdminController.cs",
      "sha256": "615f8f0b670d3e8aef239a57b9a5125959a2a63e18f417e08a8b52d2b99da7c3",
      "language": "csharp",
      "size": 5876,
      "content": "// üìÑ Features/Entitlements/Controllers/PlanQuotasAdminController.cs\n#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Controllers\n{\n    /// <summary>\n    /// Admin endpoints to manage default quotas per plan.\n    /// These are the rows in PlanQuotas table.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/plans/{planId:guid}/quotas\")]\n    [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n    public sealed class PlanQuotasAdminController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public PlanQuotasAdminController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // GET /admin/plans/{planId}/quotas\n        [HttpGet]\n        public async Task<ActionResult<List<PlanQuotaDto>>> GetForPlan(\n            Guid planId,\n            CancellationToken ct)\n        {\n            // Validate plan exists (defensive)\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var quotas = await _db.PlanQuotas\n                .AsNoTracking()\n                .Where(q => q.PlanId == planId)\n                .OrderBy(q => q.QuotaKey)\n                .Select(q => new PlanQuotaDto\n                {\n                    Id = q.Id,\n                    PlanId = q.PlanId,\n                    QuotaKey = q.QuotaKey,\n                    Limit = q.Limit,\n                    Period = q.Period,\n                    DenialMessage = q.DenialMessage\n                })\n                .ToListAsync(ct);\n\n            return Ok(quotas);\n        }\n\n        // PUT /admin/plans/{planId}/quotas\n        //\n        // Simple \"upsert by QuotaKey\" semantics:\n        // - Existing PlanQuota with same PlanId + QuotaKey is updated\n        // - New QuotaKey rows are inserted\n        // - Quotas not present in payload are kept (no destructive delete here)\n        [HttpPut]\n        public async Task<IActionResult> UpsertForPlan(\n            Guid planId,\n            [FromBody] List<PlanQuotaDto> payload,\n            CancellationToken ct)\n        {\n            if (payload is null)\n                return BadRequest(new { message = \"Payload is required\" });\n\n            // Normalize keys to upper-case for comparisons (used only in-memory)\n            static string Normalize(string key) =>\n                (key ?? string.Empty).Trim().ToUpperInvariant();\n\n            // Ensure plan exists\n            var planExists = await _db.Plans\n                .AsNoTracking()\n                .AnyAsync(p => p.Id == planId, ct);\n\n            if (!planExists)\n                return NotFound(new { message = \"Plan not found\" });\n\n            var incoming = payload\n                .Where(p => !string.IsNullOrWhiteSpace(p.QuotaKey))\n                .Select(p => new\n                {\n                    Raw = p,\n                    NormalizedKey = Normalize(p.QuotaKey!)\n                })\n                .ToList();\n\n            if (!incoming.Any())\n                return BadRequest(new { message = \"At least one quota with a QuotaKey is required.\" });\n\n            var keys = incoming\n                .Select(i => i.NormalizedKey)\n                .Distinct()\n                .ToList();\n\n            // ‚úÖ IMPORTANT: bring data into memory first, then call Normalize\n            var existingAllForPlan = await _db.PlanQuotas\n                .Where(q => q.PlanId == planId)\n                .ToListAsync(ct);\n\n            // optional: only keep rows whose normalized key is in payload keys\n            var existing = existingAllForPlan\n                .Where(q => keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n            // üëâ NEW: delete quotas that are no longer present in the payload\n            var toDelete = existingAllForPlan\n                .Where(q => !keys.Contains(Normalize(q.QuotaKey)))\n                .ToList();\n\n            if (toDelete.Count > 0)\n            {\n                _db.PlanQuotas.RemoveRange(toDelete);\n            }\n\n            foreach (var item in incoming)\n            {\n                var dto = item.Raw;\n                var normalizedKey = item.NormalizedKey;\n\n                var entity = existing\n                    .FirstOrDefault(q => Normalize(q.QuotaKey) == normalizedKey);\n\n                if (entity is null)\n                {\n                    // Insert new row\n                    entity = new PlanQuota\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        QuotaKey = normalizedKey,\n                        Limit = dto.Limit,\n                        Period = dto.Period,\n                        DenialMessage = dto.DenialMessage,\n                        CreatedAt = DateTime.UtcNow,\n                        UpdatedAt = DateTime.UtcNow\n                    };\n\n                    _db.PlanQuotas.Add(entity);\n                    existing.Add(entity); // keep in local list too\n                }\n                else\n                {\n                    // Update existing row\n                    entity.QuotaKey = normalizedKey;\n                    entity.Limit = dto.Limit;\n                    entity.Period = dto.Period;\n                    entity.DenialMessage = dto.DenialMessage;\n                    entity.UpdatedAt = DateTime.UtcNow;\n                }\n            }\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/EntitlementCheckDto.cs",
      "sha256": "e3c6863b705bec9193d677f8cf0d408345f812e955b06ffd375f8ef38d9fcb4f",
      "language": "csharp",
      "size": 1422,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    public sealed class EntitlementCheckDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public long Amount { get; set; } = 1;\n        public bool ConsumeOnSuccess { get; set; } = true;\n    }\n\n    public sealed class EntitlementResultDto\n    {\n        public bool Allowed { get; set; }\n        public string QuotaKey { get; set; } = default!;\n        public long? Limit { get; set; }           // null if unlimited\n        public long? Remaining { get; set; }       // null if unlimited\n        public string? Message { get; set; }\n    }\n\n    public sealed class EntitlementsSnapshotDto\n    {\n        public IEnumerable<string> GrantedPermissions { get; set; } = new List<string>();\n        public IEnumerable<QuotaSnapshotItemDto> Quotas { get; set; } = new List<QuotaSnapshotItemDto>();\n    }\n\n    public sealed class QuotaSnapshotItemDto\n    {\n        public string QuotaKey { get; set; } = default!;\n        public string Period { get; set; } = default!; // \"Daily\"/\"Monthly\"/\"Lifetime\"\n        public long? Limit { get; set; }               // null => unlimited\n        public long Consumed { get; set; }\n        public long? Remaining { get; set; }           // null => unlimited\n        public string? DenialMessage { get; set; }\n        public string WindowStartUtc { get; set; } = default!;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/DTOs/PlanQuotaDto.cs",
      "sha256": "eb3560e2218f3b7d2750e2a68fdf6a3f140f99a35665bf31e9d34671ad1611e3",
      "language": "csharp",
      "size": 738,
      "content": "// üìÑ Features/Entitlements/DTOs/PlanQuotaDto.cs\nusing System;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.DTOs\n{\n    /// <summary>\n    /// Admin-facing DTO for default quotas configured per plan.\n    /// </summary>\n    public sealed class PlanQuotaDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n\n        // Canonical key, e.g. \"MESSAGES_PER_MONTH\"\n        public string QuotaKey { get; set; } = string.Empty;\n\n        // -1 => unlimited\n        public long Limit { get; set; }\n\n        public QuotaPeriod Period { get; set; }\n\n        // Optional UX text used when quota is denied\n        public string? DenialMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessQuotaOverride.cs",
      "sha256": "b1f87eedb2763fc2bb19f50e1a992e2d4adb2e86477ab1f04f0b3bd6f9a17fb6",
      "language": "csharp",
      "size": 848,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessQuotaOverrides\")]\n    public sealed class BusinessQuotaOverride\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!; // same key as PlanQuota\n\n        public long? Limit { get; set; }     // null => fallback to plan\n        public bool? IsUnlimited { get; set; } // true => unlimited regardless of plan\n\n        public DateTime? ExpiresAt { get; set; } // null => permanent\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/BusinessUsageCounter.cs",
      "sha256": "85f37a61b7bf3227782bc452a7088746e129334cf37722d55a788faac363a1fc",
      "language": "csharp",
      "size": 928,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"BusinessUsageCounters\")]\n    public sealed class BusinessUsageCounter\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public QuotaPeriod Period { get; set; }\n\n        // To support resets, store the window start for this counter.\n        public DateTime WindowStartUtc { get; set; }\n\n        // Current consumed units within the window.\n        public long Consumed { get; set; }\n\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/PlanQuota.cs",
      "sha256": "215c4b1b07bd49b5499c1f3f1435739fd47ce44cc493aca1925d91e20c441573",
      "language": "csharp",
      "size": 989,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.Entitlements.Models;\n\nnamespace xbytechat.api.Features.Entitlements.Models\n{\n    [Table(\"PlanQuotas\")]\n    public sealed class PlanQuota\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid PlanId { get; set; } // FK to AccessControl Plan\n\n        // Case-insensitive programmatic key, e.g., \"MessagesPerMonth\"\n        [Required, MaxLength(128)]\n        public string QuotaKey { get; set; } = default!;\n\n        public long Limit { get; set; }            // -1 => unlimited\n        public QuotaPeriod Period { get; set; }    // Daily/Monthly/Lifetime\n\n        // Optional UX copy shown to user on denial\n        [MaxLength(256)]\n        public string? DenialMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Models/QuotaPeriod.cs",
      "sha256": "375d8f9e16fc912410137ae6208999b6580602bb4635bd5180e67f40ca8a1da7",
      "language": "csharp",
      "size": 189,
      "content": "namespace xbytechat.api.Features.Entitlements.Models\n{\n    public enum QuotaPeriod\n    {\n        Lifetime = 0,  // never resets automatically\n        Daily = 1,\n        Monthly = 2\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/QuotaKeys.cs",
      "sha256": "14149e987392ec3d22e757e52540d860518860a40a594846459035ec0428eec6",
      "language": "csharp",
      "size": 591,
      "content": "// üìÑ Features/Entitlements/QuotaKeys.cs\nnamespace xbytechat.api.Features.Entitlements\n{\n\n    public static class QuotaKeys\n    {\n        // How many messages a business can send in a given period (usually Monthly)\n        public const string MessagesPerMonth = \"MESSAGES_PER_MONTH\";\n\n        public const string MessagesPerDay = \"MESSAGES_PER_DAY\";\n        // How many campaigns can be sent per day\n        public const string CampaignsPerDay = \"CAMPAIGNS_PER_DAY\";\n\n        // How many templates can exist in total\n        public const string TemplatesTotal = \"TEMPLATES_TOTAL\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Seed/EntitlementsSeeder.cs",
      "sha256": "39a6c25c6d3cda63542eea996b67df2e21973a2afb10a93da008b33613f626d5",
      "language": "csharp",
      "size": 1273,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Entitlements.Seed\n{\n    public static class EntitlementsSeeder\n    {\n        public static async Task SeedAsync(AppDbContext db, Guid planId)\n        {\n            var defaults = new[]\n            {\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"MESSAGES_PER_MONTH\", Limit = 10000, Period = QuotaPeriod.Monthly, DenialMessage = \"Monthly message limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"CAMPAIGNS_PER_DAY\",   Limit = 10,    Period = QuotaPeriod.Daily,   DenialMessage = \"Daily campaign limit reached.\" },\n                new PlanQuota { Id = Guid.NewGuid(), PlanId = planId, QuotaKey = \"TEMPLATES_TOTAL\",     Limit = -1,    Period = QuotaPeriod.Lifetime } // unlimited\n            };\n\n            foreach (var q in defaults)\n            {\n                var exists = await db.PlanQuotas.AnyAsync(p => p.PlanId == planId && p.QuotaKey.ToUpper() == q.QuotaKey.ToUpper());\n                if (!exists) db.PlanQuotas.Add(q);\n            }\n            await db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/IQuotaService.cs",
      "sha256": "55c9229cb163efbc7ef1621a7f2fa061a1299f8b85046402a2e3708327f41648",
      "language": "csharp",
      "size": 784,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Entitlements.DTOs;\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public interface IQuotaService\n    {\n        Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n        Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct);\n\n        Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct);\n\n        // Utility to ensure counters are on the correct window (creates or rolls window if needed)\n        Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Entitlements/Services/QuotaService.cs",
      "sha256": "bf77b3fee43d514c4d28b81732cd41857fc8afd29afe72f5f6b05f5cdf81af76",
      "language": "csharp",
      "size": 13906,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Entitlements.DTOs;\nusing xbytechat.api.Features.Entitlements.Models;\nusing xbytechat.api.Features.Entitlements.Services;\nusing xbytechat.api.Features.AccessControl.Models; // your Plan/PlanPermission namespace as applicable\n\nnamespace xbytechat.api.Features.Entitlements.Services\n{\n    public sealed class QuotaService : IQuotaService\n    {\n        private readonly AppDbContext _db;\n\n        public QuotaService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // Normalize keys to uppercase to keep lookups stable on non-CI collations\n        private static string NK(string key) => key.Trim().ToUpperInvariant();\n\n        private static DateTime CurrentWindowStartUtc(QuotaPeriod p, DateTime nowUtc)\n        {\n            return p switch\n            {\n                QuotaPeriod.Daily => new DateTime(nowUtc.Year, nowUtc.Month, nowUtc.Day, 0, 0, 0, DateTimeKind.Utc),\n                QuotaPeriod.Monthly => new DateTime(nowUtc.Year, nowUtc.Month, 1, 0, 0, 0, DateTimeKind.Utc),\n                _ => DateTime.UnixEpoch\n            };\n        }\n\n        private async Task<(QuotaPeriod Period, long? Limit, string? Denial)> ResolveEffectiveLimitAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n\n            // resolve business planId\n            var business = await _db.Businesses\n                .AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => new { b.Id, b.PlanId })\n                .FirstOrDefaultAsync(ct);\n\n            if (business is null)\n                return (QuotaPeriod.Lifetime, 0, \"Business not found.\");\n\n            // override first\n            var ovr = await _db.BusinessQuotaOverrides\n                .AsNoTracking()\n                .Where(o => o.BusinessId == businessId && o.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (ovr is not null && (ovr.ExpiresAt == null || ovr.ExpiresAt > DateTime.UtcNow))\n            {\n                if (ovr.IsUnlimited == true)\n                    return (QuotaPeriod.Lifetime, null, null); // unlimited\n\n                if (ovr.Limit.HasValue)\n                {\n                    // Need period: fall back to plan period (must exist)\n                    var pq = await _db.PlanQuotas.AsNoTracking()\n                        .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                        .Select(p => new { p.Period, p.DenialMessage })\n                        .FirstOrDefaultAsync(ct);\n\n                    if (pq is null)\n                        return (QuotaPeriod.Lifetime, ovr.Limit!.Value, null); // custom limit without period -> treat as lifetime\n\n                    return (pq.Period, ovr.Limit!.Value, pq.DenialMessage);\n                }\n                // if override exists but no limit/isUnlimited set, fall back to plan\n            }\n\n            // plan default\n            var planQuota = await _db.PlanQuotas.AsNoTracking()\n                .Where(p => p.PlanId == business.PlanId && p.QuotaKey.ToUpper() == quotaKey)\n                .FirstOrDefaultAsync(ct);\n\n            if (planQuota is null)\n                return (QuotaPeriod.Lifetime, 0, \"Quota not defined for plan.\"); // deny by default\n\n            if (planQuota.Limit < 0)\n                return (planQuota.Period, null, planQuota.DenialMessage); // unlimited\n\n            return (planQuota.Period, planQuota.Limit, planQuota.DenialMessage);\n        }\n\n        private async Task<BusinessUsageCounter> GetOrCreateCounterAsync(Guid businessId, string quotaKey, QuotaPeriod period, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            var counter = await _db.BusinessUsageCounters.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                     c.Period == period && c.WindowStartUtc == winStart, ct);\n\n            if (counter is not null) return counter;\n\n            counter = new BusinessUsageCounter\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                QuotaKey = quotaKey,\n                Period = period,\n                WindowStartUtc = winStart,\n                Consumed = 0,\n                CreatedAt = now,\n                UpdatedAt = now\n            };\n            _db.BusinessUsageCounters.Add(counter);\n\n            try\n            {\n                await _db.SaveChangesAsync(ct);\n                return counter;\n            }\n            catch (DbUpdateException)\n            {\n                // Another thread created it; fetch the existing row\n                return await _db.BusinessUsageCounters.FirstAsync(\n                    c => c.BusinessId == businessId && c.QuotaKey.ToUpper() == quotaKey &&\n                         c.Period == period && c.WindowStartUtc == winStart, ct);\n            }\n        }\n\n        public async Task EnsureWindowAsync(Guid businessId, string quotaKey, CancellationToken ct)\n        {\n            var (period, _, _) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n            await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n        }\n\n        public async Task<EntitlementResultDto> CheckAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                return new EntitlementResultDto\n                {\n                    Allowed = true,\n                    QuotaKey = quotaKey,\n                    Limit = null,\n                    Remaining = null\n                };\n            }\n\n            var counter = await GetOrCreateCounterAsync(businessId, quotaKey, period, ct);\n\n            var remaining = limit.Value - counter.Consumed;\n            var allowed = remaining >= amount;\n\n            return new EntitlementResultDto\n            {\n                Allowed = allowed,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, remaining),\n                Message = allowed ? null : (denial ?? \"Quota limit reached.\")\n            };\n        }\n\n        public async Task<EntitlementResultDto> CheckAndConsumeAsync(Guid businessId, string quotaKey, long amount, CancellationToken ct)\n        {\n            quotaKey = NK(quotaKey);\n            var (period, limit, denial) = await ResolveEffectiveLimitAsync(businessId, quotaKey, ct);\n\n            if (limit is null) // unlimited\n            {\n                // No increment needed; still return success\n                return new EntitlementResultDto { Allowed = true, QuotaKey = quotaKey, Limit = null, Remaining = null };\n            }\n\n            var now = DateTime.UtcNow;\n            var winStart = CurrentWindowStartUtc(period, now);\n\n            // Atomic consume in a single SQL statement\n            // UPDATE ... SET Consumed = Consumed + @amount WHERE ... AND Consumed + @amount <= @limit\n            var updated = await _db.BusinessUsageCounters\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart &&\n                    c.Consumed + amount <= limit.Value)\n                .ExecuteUpdateAsync(up =>\n                    up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                      .SetProperty(c => c.UpdatedAt, _ => now), ct);\n\n            if (updated == 0)\n            {\n                // Ensure the row exists; if missing, create and retry once\n                var existed = await _db.BusinessUsageCounters.AnyAsync(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart, ct);\n\n                if (!existed)\n                {\n                    var counter = new BusinessUsageCounter\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        QuotaKey = quotaKey,\n                        Period = period,\n                        WindowStartUtc = winStart,\n                        Consumed = 0,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n                    _db.BusinessUsageCounters.Add(counter);\n                    await _db.SaveChangesAsync(ct);\n\n                    // retry atomic consume\n                    updated = await _db.BusinessUsageCounters\n                        .Where(c =>\n                            c.BusinessId == businessId &&\n                            c.QuotaKey.ToUpper() == quotaKey &&\n                            c.Period == period &&\n                            c.WindowStartUtc == winStart &&\n                            c.Consumed + amount <= limit.Value)\n                        .ExecuteUpdateAsync(up =>\n                            up.SetProperty(c => c.Consumed, c => c.Consumed + amount)\n                              .SetProperty(c => c.UpdatedAt, _ => now), ct);\n                }\n            }\n\n            if (updated == 0)\n            {\n                // Denied\n                var current = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c =>\n                        c.BusinessId == businessId &&\n                        c.QuotaKey.ToUpper() == quotaKey &&\n                        c.Period == period &&\n                        c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                var remaining = Math.Max(0, limit.Value - current);\n\n                return new EntitlementResultDto\n                {\n                    Allowed = false,\n                    QuotaKey = quotaKey,\n                    Limit = limit.Value,\n                    Remaining = remaining,\n                    Message = denial ?? \"Quota limit reached.\"\n                };\n            }\n\n            // Success path‚Äîfetch updated consumed to compute remaining\n            var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                .Where(c =>\n                    c.BusinessId == businessId &&\n                    c.QuotaKey.ToUpper() == quotaKey &&\n                    c.Period == period &&\n                    c.WindowStartUtc == winStart)\n                .Select(c => c.Consumed)\n                .FirstAsync(ct);\n\n            return new EntitlementResultDto\n            {\n                Allowed = true,\n                QuotaKey = quotaKey,\n                Limit = limit.Value,\n                Remaining = Math.Max(0, limit.Value - consumed)\n            };\n        }\n\n        public async Task<EntitlementsSnapshotDto> GetSnapshotAsync(Guid businessId, CancellationToken ct)\n        {\n            // Resolve plan once\n            var planId = await _db.Businesses.AsNoTracking()\n                .Where(b => b.Id == businessId)\n                .Select(b => b.PlanId)\n                .FirstAsync(ct);\n\n            // Permission codes for this plan\n            var grantedPerms = await _db.PlanPermissions\n                .AsNoTracking()\n                .Where(pp => pp.PlanId == planId && pp.IsActive && pp.Permission.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync(ct);\n\n            // Quotas ‚Äì sequential to avoid DbContext concurrency issues\n            var planQuotas = await _db.PlanQuotas.AsNoTracking()\n                .Where(pq => pq.PlanId == planId)\n                .ToListAsync(ct);\n\n            var overrides = await _db.BusinessQuotaOverrides.AsNoTracking()\n                .Where(o => o.BusinessId == businessId &&\n                            (o.ExpiresAt == null || o.ExpiresAt > DateTime.UtcNow))\n                .ToListAsync(ct);\n\n            var now = DateTime.UtcNow;\n\n            var items = new List<QuotaSnapshotItemDto>();\n\n            foreach (var pq in planQuotas)\n            {\n                var key = NK(pq.QuotaKey);\n\n                long? limit = overrides.FirstOrDefault(o => NK(o.QuotaKey) == key) is { } o\n                    ? (o.IsUnlimited == true ? null : o.Limit ?? (pq.Limit < 0 ? (long?)null : pq.Limit))\n                    : (pq.Limit < 0 ? (long?)null : pq.Limit);\n\n                var winStart = CurrentWindowStartUtc(pq.Period, now);\n\n                var consumed = await _db.BusinessUsageCounters.AsNoTracking()\n                    .Where(c => c.BusinessId == businessId &&\n                                c.QuotaKey.ToUpper() == key &&\n                                c.Period == pq.Period &&\n                                c.WindowStartUtc == winStart)\n                    .Select(c => c.Consumed)\n                    .FirstOrDefaultAsync(ct);\n\n                items.Add(new QuotaSnapshotItemDto\n                {\n                    QuotaKey = key,\n                    Period = pq.Period.ToString(),\n                    Limit = limit,\n                    Consumed = consumed,\n                    Remaining = limit is null ? null : Math.Max(0, limit.Value - consumed),\n                    DenialMessage = pq.DenialMessage,\n                    WindowStartUtc = winStart.ToString(\"u\")\n                });\n            }\n\n            return new EntitlementsSnapshotDto\n            {\n                GrantedPermissions = grantedPerms,\n                Quotas = items\n            };\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IEsuStatusService.cs",
      "sha256": "825a494d506b60064b1f3811f94cece207f3feb402079cf5371171bb0752d168",
      "language": "csharp",
      "size": 420,
      "content": "#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.DTOs;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    public interface IEsuStatusService\n    {\n        Task<EsuStatusDto> GetStatusAsync(Guid businessId, CancellationToken ct = default);\n        Task DeauthorizeAsync(Guid businessId, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IEsuTokenStore.cs",
      "sha256": "19575329bfc016c7842b626d8c6403ee75cb77797bf8caad98b983aa2eed6af2",
      "language": "csharp",
      "size": 517,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ESU.Facebook.Models;\n\npublic interface IEsuTokenStore\n{\n    Task<EsuToken?> GetAsync(Guid businessId, string provider, CancellationToken ct);\n    Task UpsertAsync(Guid businessId, string provider, string token, DateTime? expiresAtUtc, CancellationToken ct);\n    Task RevokeAsync(Guid businessId, string provider, CancellationToken ct);\n\n    Task DeleteAsync(Guid biz, string provider, CancellationToken ct = default);\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ESU/Facebook/Abstractions/IFacebookGraphClient.cs",
      "sha256": "448400005f2e87088712cdae60bb312c7a1474b18d8702fb89188c8bbf6cee4a",
      "language": "csharp",
      "size": 421,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.ESU.Facebook.Abstractions\n{\n    public interface IFacebookGraphClient\n    {\n        Task<T> GetAsync<T>(\n            Guid businessId,\n            string path,\n            IDictionary<string, string?>? query = null,\n            CancellationToken ct = default);\n    }\n}\n"
    }
  ]
}
