{
  "name": "xbytechat-api/Features",
  "part": 5,
  "of": 5,
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/TemplateDraftLifecycleService.cs",
      "sha256": "2666d108237bdcc3f78dd6e85e8e7a4ca4c0f19531bce326eeb1b92ee5abe974",
      "language": "csharp",
      "size": 4916,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\nusing xbytechat.api.Features.TemplateModule.Models;\nusing xbytechat.api.Features.TemplateModule.Services;\nusing xbytechat.api.Features.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.TemplateModule.Services;\n\npublic sealed class TemplateDraftLifecycleService : ITemplateDraftLifecycleService\n{\n    private readonly AppDbContext _db;\n    private readonly IMetaTemplateClient _meta;\n\n    public TemplateDraftLifecycleService(AppDbContext db, IMetaTemplateClient meta)\n    {\n        _db = db;\n        _meta = meta;\n    }\n\n    public async Task<TemplateDraft> DuplicateDraftAsync(Guid businessId, Guid draftId, CancellationToken ct = default)\n    {\n        var src = await _db.TemplateDrafts.AsNoTracking()\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n        if (src is null) throw new KeyNotFoundException(\"Draft not found.\");\n\n        var keyBase = src.Key;\n        var suffix = 2;\n        var newKey = $\"{keyBase}_copy\";\n        while (await _db.TemplateDrafts.AnyAsync(x => x.BusinessId == businessId && x.Key == newKey, ct))\n        {\n            newKey = $\"{keyBase}_copy{suffix}\";\n            suffix++;\n        }\n\n        var now = DateTime.UtcNow;\n        var dup = new TemplateDraft\n        {\n            Id = Guid.NewGuid(),\n            BusinessId = businessId,\n            Key = newKey,\n            Category = src.Category,\n            DefaultLanguage = src.DefaultLanguage,\n            CreatedAt = now,\n            UpdatedAt = now\n        };\n\n        _db.TemplateDrafts.Add(dup);\n\n        var variants = await _db.TemplateDraftVariants\n            .AsNoTracking()\n            .Where(v => v.TemplateDraftId == src.Id)\n            .ToListAsync(ct);\n\n        foreach (var v in variants)\n        {\n            _db.TemplateDraftVariants.Add(new TemplateDraftVariant\n            {\n                Id = Guid.NewGuid(),\n                TemplateDraftId = dup.Id,\n                Language = v.Language,\n                HeaderType = v.HeaderType,\n                HeaderText = v.HeaderText,\n                HeaderMediaLocalUrl = v.HeaderMediaLocalUrl, // keep handle if present; user can replace\n                BodyText = v.BodyText,\n                FooterText = v.FooterText,\n                ButtonsJson = v.ButtonsJson,\n                ExampleParamsJson = v.ExampleParamsJson,\n                IsReadyForSubmission = v.IsReadyForSubmission,\n                ValidationErrorsJson = v.ValidationErrorsJson\n            });\n        }\n\n        await _db.SaveChangesAsync(ct);\n        return dup;\n    }\n\n\n    public async Task<bool> DeleteDraftAsync(Guid businessId, Guid draftId, CancellationToken ct = default)\n    {\n        // 1) Find the draft scoped to the tenant\n        var draft = await _db.TemplateDrafts\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n\n        if (draft is null) return false;\n\n        // 2) Hard-delete variants explicitly (no nav needed)\n\n        // If you're on EF Core 7+, this is the fastest way:\n        try\n        {\n            await _db.TemplateDraftVariants\n                .Where(v => v.TemplateDraftId == draft.Id)\n                .ExecuteDeleteAsync(ct);\n        }\n        catch (NotSupportedException)\n        {\n            // Fallback for EF Core < 7: load + RemoveRange\n            var children = await _db.TemplateDraftVariants\n                .Where(v => v.TemplateDraftId == draft.Id)\n                .ToListAsync(ct);\n            if (children.Count > 0)\n                _db.TemplateDraftVariants.RemoveRange(children);\n        }\n\n        // 3) Delete the parent draft\n        _db.TemplateDrafts.Remove(draft);\n\n        // 4) Commit\n        await _db.SaveChangesAsync(ct);\n        return true;\n    }\n\n\n    public async Task<bool> DeleteApprovedTemplateAsync(Guid businessId, string name, string language, CancellationToken ct = default)\n    {\n        if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(language))\n            throw new ArgumentException(\"Name and language are required.\");\n\n        // 1) Ask Meta to delete\n        var okMeta = await _meta.DeleteTemplateAsync(businessId, name, language, ct);\n\n        // 2) Soft-delete locally even if Meta already deleted (idempotent UX)\n        var rows = await _db.WhatsAppTemplates\n            .Where(t => t.BusinessId == businessId && t.Name == name && t.LanguageCode == language)\n            .ToListAsync(ct);\n\n        if (rows.Count > 0)\n        {\n            var now = DateTime.UtcNow;\n            foreach (var t in rows)\n            {\n                t.IsActive = false;\n                t.Status = \"DELETED\"; // keep a conventional marker\n                t.UpdatedAt = now;\n                t.LastSyncedAt = now;\n            }\n            await _db.SaveChangesAsync(ct);\n        }\n\n        return okMeta;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/TemplateDraftService.cs",
      "sha256": "9ab4518740e79733ed3f5ae2c338e373d953fe540ece2caf65420387152b45ef",
      "language": "csharp",
      "size": 11874,
      "content": "using System.Text.Json;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\nusing xbytechat.api.Features.TemplateModule.DTOs;\nusing xbytechat.api.Features.TemplateModule.Models;\nusing xbytechat.api.Features.TemplateModule.Payload;\nusing xbytechat.api.Features.TemplateModule.Validators;\n\nnamespace xbytechat.api.Features.TemplateModule.Services;\n\npublic sealed class TemplateDraftService : ITemplateDraftService\n{\n    private readonly AppDbContext _db;\n    private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web);\n\n    public TemplateDraftService(AppDbContext db)\n    {\n        _db = db;\n    }\n\n    public async Task<TemplateDraft> CreateDraftAsync(Guid businessId, TemplateDraftCreateDto dto, CancellationToken ct = default)\n    {\n        var exists = await _db.TemplateDrafts\n            .AnyAsync(x => x.BusinessId == businessId && x.Key == dto.Key, ct);\n        if (exists)\n            throw new InvalidOperationException(\"A draft with the same Key already exists for this business.\");\n\n        var draft = new TemplateDraft\n        {\n            Id = Guid.NewGuid(),\n            BusinessId = businessId,\n            Key = dto.Key.Trim(),\n            Category = string.IsNullOrWhiteSpace(dto.Category) ? \"UTILITY\" : dto.Category.Trim().ToUpperInvariant(),\n            DefaultLanguage = string.IsNullOrWhiteSpace(dto.DefaultLanguage) ? \"en_US\" : dto.DefaultLanguage.Trim(),\n            CreatedAt = DateTime.UtcNow,\n            UpdatedAt = DateTime.UtcNow\n        };\n\n        _db.TemplateDrafts.Add(draft);\n        await _db.SaveChangesAsync(ct);\n        return draft;\n    }\n\n    public async Task<TemplateDraftVariant> UpsertVariantAsync(Guid businessId, Guid draftId, TemplateDraftVariantUpsertDto dto, CancellationToken ct = default)\n    {\n        var draft = await _db.TemplateDrafts\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n\n        if (draft is null)\n            throw new KeyNotFoundException(\"Draft not found for this business.\");\n\n        var validation = VariantValidator.Validate(dto);\n        if (!validation.Ok)\n            throw new InvalidOperationException(string.Join(\" | \", validation.Errors));\n\n        var lang = dto.Language.Trim();\n\n        var variant = await _db.TemplateDraftVariants\n            .FirstOrDefaultAsync(v => v.TemplateDraftId == draft.Id && v.Language == lang, ct);\n\n        var buttonsJson = JsonSerializer.Serialize(dto.Buttons ?? new List<ButtonDto>(), JsonOpts);\n        var examplesJson = JsonSerializer.Serialize(dto.Examples ?? new Dictionary<string, string>(), JsonOpts);\n\n        if (variant is null)\n        {\n            variant = new TemplateDraftVariant\n            {\n                Id = Guid.NewGuid(),\n                TemplateDraftId = draft.Id,\n                Language = lang,\n                BodyText = dto.BodyText,\n                HeaderType = dto.HeaderType,\n                HeaderText = dto.HeaderText,\n                HeaderMediaLocalUrl = dto.HeaderMediaLocalUrl,\n                FooterText = dto.FooterText,\n                ButtonsJson = buttonsJson,\n                ExampleParamsJson = examplesJson,\n                IsReadyForSubmission = true,\n                ValidationErrorsJson = null\n            };\n            _db.TemplateDraftVariants.Add(variant);\n        }\n        else\n        {\n            variant.BodyText = dto.BodyText;\n            variant.HeaderType = dto.HeaderType;\n            variant.HeaderText = dto.HeaderText;\n            variant.HeaderMediaLocalUrl = dto.HeaderMediaLocalUrl;\n            variant.FooterText = dto.FooterText;\n            variant.ButtonsJson = buttonsJson;\n            variant.ExampleParamsJson = examplesJson;\n            variant.IsReadyForSubmission = true;\n            variant.ValidationErrorsJson = null;\n        }\n\n        draft.UpdatedAt = DateTime.UtcNow;\n\n        await _db.SaveChangesAsync(ct);\n        return variant;\n    }\n\n    public async Task<bool> ValidateAsync(Guid businessId, Guid draftId, CancellationToken ct = default)\n    {\n        var draft = await _db.TemplateDrafts\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n        if (draft is null) return false;\n\n        var variants = await _db.TemplateDraftVariants\n            .Where(v => v.TemplateDraftId == draft.Id)\n            .ToListAsync(ct);\n\n        return variants.Any(v => v.IsReadyForSubmission);\n    }\n\n    public async Task<(bool ok, Dictionary<string, List<string>> errors)> ValidateAllAsync(Guid businessId, Guid draftId, CancellationToken ct = default)\n    {\n        var draft = await _db.TemplateDrafts\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n        if (draft is null) return (false, new() { { \"global\", new() { \"Draft not found.\" } } });\n\n        var variants = await _db.TemplateDraftVariants\n            .Where(v => v.TemplateDraftId == draft.Id)\n            .ToListAsync(ct);\n\n        if (variants.Count == 0)\n            return (false, new() { { \"global\", new() { \"No language variants found.\" } } });\n\n        // Map DB rows to validator view\n        var views = variants.Select(v => new MultiLanguageValidator.VariantView\n        {\n            Language = v.Language,\n            BodyText = v.BodyText,\n            HeaderType = v.HeaderType,\n            HeaderText = v.HeaderText,\n            HeaderMediaLocalUrl = v.HeaderMediaLocalUrl,\n            FooterText = v.FooterText,\n            Buttons = SafeDeserialize<List<ButtonDto>>(v.ButtonsJson) ?? new(),\n            Examples = SafeDeserialize<Dictionary<string, string>>(v.ExampleParamsJson) ?? new()\n        }).ToList();\n\n        var (ok, errors) = MultiLanguageValidator.Validate(views);\n\n        // Persist per-variant readiness & last validation errors (optional but helpful)\n        foreach (var v in variants)\n        {\n            v.IsReadyForSubmission = !errors.ContainsKey(v.Language) || errors[v.Language].Count == 0;\n            v.ValidationErrorsJson = errors.ContainsKey(v.Language)\n                ? JsonSerializer.Serialize(errors[v.Language], JsonOpts)\n                : null;\n        }\n        await _db.SaveChangesAsync(ct);\n\n        return (ok, errors);\n    }\n\n    public Task<TemplateDraft?> GetDraftAsync(Guid businessId, Guid draftId, CancellationToken ct = default)\n        => _db.TemplateDrafts.AsNoTracking()\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n\n    public async Task<IReadOnlyList<TemplateDraft>> ListDraftsAsync(Guid businessId, CancellationToken ct = default)\n    {\n        var list = await _db.TemplateDrafts.AsNoTracking()\n            .Where(x => x.BusinessId == businessId)\n            .OrderByDescending(x => x.UpdatedAt)\n            .ThenByDescending(x => x.CreatedAt)\n            .ToListAsync(ct);\n\n        return list;\n    }\n\n    private static T? SafeDeserialize<T>(string? json)\n    {\n        if (string.IsNullOrWhiteSpace(json)) return default;\n        try { return JsonSerializer.Deserialize<T>(json!, JsonOpts); } catch { return default; }\n    }\n\n    public async Task<bool> SetHeaderHandleAsync(\n    Guid businessId,\n    Guid draftId,\n    string language,\n    string mediaType,\n    string assetHandle,\n    CancellationToken ct = default)\n    {\n        var draft = await _db.TemplateDrafts\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n        if (draft is null) return false;\n\n        var lang = language.Trim();\n        var variant = await _db.TemplateDraftVariants\n            .FirstOrDefaultAsync(v => v.TemplateDraftId == draft.Id && v.Language == lang, ct);\n\n        if (variant is null)\n        {\n            // create the variant if it doesn't exist yet (handy UX)\n            variant = new TemplateDraftVariant\n            {\n                Id = Guid.NewGuid(),\n                TemplateDraftId = draft.Id,\n                Language = lang,\n                BodyText = string.Empty,\n                HeaderType = mediaType.ToUpperInvariant(),\n                HeaderText = null,\n                HeaderMediaLocalUrl = $\"handle:{assetHandle}\",\n                FooterText = null,\n                ButtonsJson = \"[]\",\n                ExampleParamsJson = \"{}\",\n                IsReadyForSubmission = false,\n                ValidationErrorsJson = null\n            };\n            _db.TemplateDraftVariants.Add(variant);\n        }\n        else\n        {\n            variant.HeaderType = mediaType.ToUpperInvariant(); // IMAGE|VIDEO|DOCUMENT\n            variant.HeaderMediaLocalUrl = $\"handle:{assetHandle}\";\n            // don't force IsReadyForSubmission here; Validate/Submit will compute it\n        }\n\n        draft.UpdatedAt = DateTime.UtcNow;\n        await _db.SaveChangesAsync(ct);\n        return true;\n    }\n    // xbytechat-api/Features/TemplateModule/Services/TemplateDraftService.cs\n    // (inside the class; no local SafeDeserialize here — reuse your existing one)\n\n\n    public async Task<TemplatePreviewDto?> GetPreviewAsync(\n        Guid businessId, Guid draftId, string language, CancellationToken ct = default)\n    {\n        var draft = await _db.TemplateDrafts\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n        if (draft is null) return null;\n\n        var variant = await _db.TemplateDraftVariants\n            .AsNoTracking()\n            .FirstOrDefaultAsync(v => v.TemplateDraftId == draft.Id && v.Language == language, ct);\n        if (variant is null) return null;\n\n        // Reuse your existing SafeDeserialize<T>(json, JsonOpts)\n        var buttons = SafeDeserialize<List<ButtonDto>>(variant.ButtonsJson) ?? new();\n        var examples = SafeDeserialize<Dictionary<string, string>>(variant.ExampleParamsJson) ?? new();\n\n        // Preview: no binary fetch; just mark media header types\n        string? headerHandleOrNull = null;\n\n        var (components, examplesPayload) = MetaComponentsBuilder.Build(\n            variant.HeaderType,\n            variant.HeaderText,\n            headerHandleOrNull,\n            variant.BodyText,\n            variant.FooterText,\n            buttons,\n            examples\n        );\n\n        string ResolveVars(string s)\n        {\n            if (string.IsNullOrEmpty(s)) return string.Empty;\n            var result = s;\n            foreach (var kv in examples)\n                result = result.Replace(\"{{\" + kv.Key + \"}}\", kv.Value ?? string.Empty, StringComparison.Ordinal);\n            return result;\n        }\n\n        string headerPreview = variant.HeaderType?.ToUpperInvariant() switch\n        {\n            \"TEXT\" => ResolveVars(variant.HeaderText ?? string.Empty),\n            \"IMAGE\" => \"[IMAGE HEADER]\",\n            \"VIDEO\" => \"[VIDEO HEADER]\",\n            \"DOCUMENT\" => \"[DOCUMENT HEADER]\",\n            _ => string.Empty\n        };\n\n        var buttonLabels = new List<string>();\n        foreach (var b in buttons)\n        {\n            if (string.Equals(b.Type, \"QUICK_REPLY\", StringComparison.OrdinalIgnoreCase))\n                buttonLabels.Add($\"[Quick Reply] {b.Text}\");\n            else if (string.Equals(b.Type, \"URL\", StringComparison.OrdinalIgnoreCase))\n                buttonLabels.Add($\"[URL] {b.Text}\");\n            else if (string.Equals(b.Type, \"PHONE\", StringComparison.OrdinalIgnoreCase))\n                buttonLabels.Add($\"[Phone] {b.Text}\");\n        }\n\n        return new TemplatePreviewDto\n        {\n            Language = language,\n            Header = headerPreview,\n            Body = ResolveVars(variant.BodyText ?? string.Empty),\n            Footer = ResolveVars(variant.FooterText ?? string.Empty),\n            Buttons = buttonLabels,\n            ComponentsPayload = components,\n            ExamplesPayload = examplesPayload\n        };\n    }\n\n    // Keep your SafeDeserialize helper in this class:\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/TemplateLibraryService.cs",
      "sha256": "d4a3ed47d7007a941610dc2049ce2ce65fc856babfe6ecea30305520ce51f1b6",
      "language": "csharp",
      "size": 21431,
      "content": "using System.Text.Json;\nusing System.Text.RegularExpressions;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\nusing xbytechat.api.Features.TemplateModule.DTOs;\nusing xbytechat.api.Features.TemplateModule.Models;\nusing System.Text.Json;\nnamespace xbytechat.api.Features.TemplateModule.Services;\n\npublic sealed class TemplateLibraryService : ITemplateLibraryService\n{\n    private readonly AppDbContext _db;\n    private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web);\n\n    public TemplateLibraryService(AppDbContext db)\n    {\n        _db = db;\n    }\n\n    public async Task<IReadOnlyList<TemplateLibraryItem>> ListAsync(string? industry, CancellationToken ct = default)\n    {\n        var q = _db.TemplateLibraryItems.AsNoTracking();\n        if (!string.IsNullOrWhiteSpace(industry))\n        {\n            var ind = industry.Trim().ToUpperInvariant();\n            q = q.Where(x => x.Industry == ind);\n        }\n\n        return await q\n            .OrderByDescending(x => x.IsFeatured)\n            .ThenBy(x => x.Industry)\n            .ThenBy(x => x.Key)\n            .ToListAsync(ct);\n    }\n\n    public async Task<TemplateDraft> InstantiateDraftAsync(\n      Guid businessId,\n      Guid libraryItemId,\n      IEnumerable<string> languages,\n      CancellationToken ct = default)\n    {\n        var item = await _db.TemplateLibraryItems\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.Id == libraryItemId, ct);\n\n        if (item is null)\n            throw new KeyNotFoundException(\"Library item not found.\");\n\n        // ---- Normalize incoming languages ----\n        var requested = (languages ?? Array.Empty<string>())\n            .Where(l => !string.IsNullOrWhiteSpace(l))\n            .Select(l => l.Trim())\n            .ToArray();\n\n        // Load all variants for this item once\n        var allLibVariants = await _db.TemplateLibraryVariants\n            .AsNoTracking()\n            .Where(v => v.LibraryItemId == item.Id)\n            .ToListAsync(ct);\n\n        if (allLibVariants.Count == 0)\n            throw new InvalidOperationException(\"Selected library item has no language variants.\");\n\n        // If \"ALL\" is requested (case-insensitive), use all languages available\n        bool wantsAll = requested.Any(l => string.Equals(l, \"ALL\", StringComparison.OrdinalIgnoreCase));\n        var targetLangs = wantsAll\n            ? allLibVariants.Select(v => v.Language).Distinct(StringComparer.OrdinalIgnoreCase).ToArray()\n            : requested;\n\n        // Validate: ensure at least one requested language exists\n        var availableLangs = new HashSet<string>(\n            allLibVariants.Select(v => v.Language),\n            StringComparer.OrdinalIgnoreCase);\n\n        var matchedLangs = targetLangs.Where(l => availableLangs.Contains(l)).Distinct(StringComparer.OrdinalIgnoreCase).ToArray();\n\n        if (matchedLangs.Length == 0)\n            throw new InvalidOperationException(\n                $\"None of the requested languages exist for this template. \" +\n                $\"Requested: [{string.Join(\", \", targetLangs)}]; \" +\n                $\"Available: [{string.Join(\", \", availableLangs)}]\");\n\n        // ---- Make a unique key for the business if needed ----\n        var key = item.Key;\n        var suffix = 1;\n        while (await _db.TemplateDrafts.AnyAsync(x => x.BusinessId == businessId && x.Key == key, ct))\n        {\n            suffix++;\n            key = $\"{item.Key}_{suffix}\";\n        }\n\n        // ---- Create draft ----\n        var defaultLang = matchedLangs[0];\n        var draft = new TemplateDraft\n        {\n            Id = Guid.NewGuid(),\n            BusinessId = businessId,\n            Key = key,\n            Category = item.Category,\n            DefaultLanguage = defaultLang,\n            CreatedAt = DateTime.UtcNow,\n            UpdatedAt = DateTime.UtcNow\n        };\n        _db.TemplateDrafts.Add(draft);\n\n        // ---- Clone only the matched languages ----\n        var libVariants = allLibVariants\n            .Where(v => matchedLangs.Contains(v.Language, StringComparer.OrdinalIgnoreCase))\n            .ToList();\n\n        foreach (var lv in libVariants)\n        {\n            var variant = new TemplateDraftVariant\n            {\n                Id = Guid.NewGuid(),\n                TemplateDraftId = draft.Id,\n                Language = lv.Language,\n                BodyText = lv.BodyText,\n                HeaderType = lv.HeaderType,\n                HeaderText = lv.HeaderText,\n                HeaderMediaLocalUrl = null,         // Library media is preview-only; users upload their own\n                FooterText = lv.FooterText,\n                ButtonsJson = lv.ButtonsJson ?? \"[]\",\n                // IMPORTANT: examples are a map/object -> \"{}\" by default\n                ExampleParamsJson = lv.ExampleParamsJson ?? \"{}\",\n                IsReadyForSubmission = true,\n                ValidationErrorsJson = null\n            };\n            _db.TemplateDraftVariants.Add(variant);\n        }\n\n        await _db.SaveChangesAsync(ct);\n        return draft;\n    }\n\n    public async Task<(TemplateLibraryItem item, List<TemplateLibraryVariant> variants)> GetItemAsync(\n    Guid libraryItemId,\n    CancellationToken ct = default)\n    {\n        var item = await _db.TemplateLibraryItems\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.Id == libraryItemId, ct);\n\n        if (item is null)\n            throw new KeyNotFoundException(\"Library item not found.\");\n\n        var variants = await _db.TemplateLibraryVariants\n            .AsNoTracking()\n            .Where(v => v.LibraryItemId == item.Id)\n            .OrderBy(v => v.Language)\n            .ToListAsync(ct);\n\n        return (item, variants);\n    }\n    public async Task<IReadOnlyList<string>> ListIndustriesAsync(CancellationToken ct = default)\n    {\n        var raw = await _db.TemplateLibraryItems\n            .AsNoTracking()\n            .Select(x => x.Industry)\n            .Where(x => x != null && x != \"\")\n            .ToListAsync(ct);\n\n        // Normalize to upper (your storage uses UPPER), then distinct & sort for UX\n        var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n        foreach (var s in raw)\n        {\n            var v = s!.Trim();\n            if (v.Length == 0) continue;\n            set.Add(v.ToUpperInvariant());\n        }\n        return set.OrderBy(x => x).ToList();\n    }\n    //public async Task<LibraryImportResult> ImportAsync(LibraryImportRequest request, CancellationToken ct = default)\n    public async Task<LibraryImportResult> ImportAsync(LibraryImportRequest request, bool dryRun = false, CancellationToken ct = default)\n    {\n        var res = new LibraryImportResult();\n        if (request?.Items == null || request.Items.Count == 0)\n        {\n            res.Success = true;\n            return res;\n        }\n\n        // reasonable safety cap; adjust if needed\n        if (request.Items.Count > 1000)\n            throw new InvalidOperationException(\"Too many items in one import. Split into smaller batches (≤1000).\");\n\n        using var tx = await _db.Database.BeginTransactionAsync(ct);\n\n        var jsonOpts = new JsonSerializerOptions(JsonSerializerDefaults.Web) { WriteIndented = false };\n\n        string NormalizeCategory(string cat)\n        {\n            var c = (cat ?? \"\").Trim().ToUpperInvariant();\n            return c switch\n            {\n                \"UTILITY\" or \"MARKETING\" or \"AUTHENTICATION\" => c,\n                _ => throw new InvalidOperationException(\"category must be one of UTILITY, MARKETING, AUTHENTICATION\")\n            };\n        }\n\n        string NormalizeHeaderType(string? ht)\n        {\n            var t = (ht ?? \"NONE\").Trim().ToUpperInvariant();\n            return t switch\n            {\n                \"NONE\" or \"TEXT\" or \"IMAGE\" or \"VIDEO\" or \"DOCUMENT\" => t,\n                _ => throw new InvalidOperationException(\"headerType must be NONE|TEXT|IMAGE|VIDEO|DOCUMENT\")\n            };\n        }\n\n        string ButtonsToJson(List<LibraryImportButton> buttons)\n        {\n            // light validation: max 3; text required; type-specific fields\n            if (buttons is { Count: > 3 })\n                throw new InvalidOperationException(\"A variant cannot have more than 3 buttons.\");\n\n            foreach (var b in buttons)\n            {\n                if (string.IsNullOrWhiteSpace(b.Type)) throw new InvalidOperationException(\"button.type is required.\");\n                if (string.IsNullOrWhiteSpace(b.Text)) throw new InvalidOperationException(\"button.text is required.\");\n\n                var t = b.Type.Trim().ToUpperInvariant();\n                if (t == \"URL\" && string.IsNullOrWhiteSpace(b.Url))\n                    throw new InvalidOperationException(\"URL button requires url.\");\n                if (t == \"PHONE\" && string.IsNullOrWhiteSpace(b.Phone))\n                    throw new InvalidOperationException(\"PHONE button requires phone.\");\n            }\n\n            return JsonSerializer.Serialize(buttons ?? new(), jsonOpts);\n        }\n\n        string ExamplesToJson(Dictionary<string, string>? map)\n            => JsonSerializer.Serialize(map ?? new Dictionary<string, string>(), jsonOpts); // {} default\n\n        for (int i = 0; i < request.Items.Count; i++)\n        {\n            var raw = request.Items[i];\n            try\n            {\n                // ---- normalize + validate item ----\n                var industry = (raw.Industry ?? \"\").Trim().ToUpperInvariant();\n                if (string.IsNullOrWhiteSpace(industry)) throw new InvalidOperationException(\"industry is required.\");\n\n                var key = (raw.Key ?? \"\").Trim();\n                if (string.IsNullOrWhiteSpace(key)) throw new InvalidOperationException(\"key is required.\");\n\n                var category = NormalizeCategory(raw.Category);\n\n                if (raw.Variants == null || raw.Variants.Count == 0)\n                    throw new InvalidOperationException(\"at least one variant is required.\");\n\n                // ---- upsert item by (Industry, Key) ----\n                var item = await _db.TemplateLibraryItems\n                    .FirstOrDefaultAsync(x => x.Industry == industry && x.Key == key, ct);\n\n                if (item == null)\n                {\n                    item = new TemplateLibraryItem\n                    {\n                        Id = Guid.NewGuid(),\n                        Industry = industry,\n                        Key = key,\n                        Category = category,\n                        IsFeatured = raw.IsFeatured\n                    };\n                    _db.TemplateLibraryItems.Add(item);\n                    res.CreatedItems++;\n                    await _db.SaveChangesAsync(ct); // ensure item.Id for variants\n                }\n                else\n                {\n                    // update mutable fields\n                    item.Category = category;\n                    item.IsFeatured = raw.IsFeatured;\n                    res.UpdatedItems++;\n                    await _db.SaveChangesAsync(ct);\n                }\n\n                // ---- per-variant upsert by (LibraryItemId, Language) ----\n                for (int v = 0; v < raw.Variants.Count; v++)\n                {\n                    var vv = raw.Variants[v];\n\n                    var lang = (vv.Language ?? \"\").Trim();\n                    if (string.IsNullOrWhiteSpace(lang))\n                        throw new InvalidOperationException(\"variant.language is required.\");\n\n                    var headerType = NormalizeHeaderType(vv.HeaderType);\n                    var bodyText = (vv.BodyText ?? \"\").Trim();\n                    if (string.IsNullOrWhiteSpace(bodyText))\n                        throw new InvalidOperationException(\"variant.bodyText is required.\");\n\n                    if (headerType == \"TEXT\" && string.IsNullOrWhiteSpace(vv.HeaderText))\n                        throw new InvalidOperationException(\"headerText is required when headerType=TEXT.\");\n\n                    var buttonsJson = ButtonsToJson(vv.Buttons ?? new());\n                    var examplesJson = ExamplesToJson(vv.Examples);\n\n                    var existing = await _db.TemplateLibraryVariants\n                        .FirstOrDefaultAsync(x => x.LibraryItemId == item.Id && x.Language == lang, ct);\n\n                    if (existing == null)\n                    {\n                        _db.TemplateLibraryVariants.Add(new TemplateLibraryVariant\n                        {\n                            Id = Guid.NewGuid(),\n                            LibraryItemId = item.Id,\n                            Language = lang,\n                            HeaderType = headerType,\n                            HeaderText = vv.HeaderText,\n                            BodyText = bodyText,\n                            FooterText = vv.FooterText,\n                            ButtonsJson = buttonsJson,\n                            ExampleParamsJson = examplesJson\n                        });\n                        res.CreatedVariants++;\n                    }\n                    else\n                    {\n                        existing.HeaderType = headerType;\n                        existing.HeaderText = vv.HeaderText;\n                        existing.BodyText = bodyText;\n                        existing.FooterText = vv.FooterText;\n                        existing.ButtonsJson = buttonsJson;\n                        existing.ExampleParamsJson = examplesJson;\n                        res.UpdatedVariants++;\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                res.Errors.Add(new LibraryImportError\n                {\n                    ItemIndex = i,\n                    Message = ex.Message\n                });\n            }\n        }\n\n        //await _db.SaveChangesAsync(ct);\n        //await tx.CommitAsync(ct);\n        await _db.SaveChangesAsync(ct);\n        if (dryRun)\n        {\n            // Undo all writes made within this transaction\n            await tx.RollbackAsync(ct);\n        }\n        else\n        {\n            await tx.CommitAsync(ct);\n        }\n        res.TotalItems = request.Items.Count;\n        res.Success = res.Errors.Count == 0;\n        return res;\n    }\n\n    public async Task<TemplateLibraryListResponse> SearchAsync(\n    string? industry, string? q, string? sort, int page, int pageSize, CancellationToken ct = default)\n    {\n        page = page <= 0 ? 1 : page;\n        pageSize = pageSize <= 0 ? 20 : Math.Min(pageSize, 100);\n\n        var query = _db.TemplateLibraryItems.AsNoTracking().AsQueryable();\n\n        if (!string.IsNullOrWhiteSpace(industry))\n        {\n            var ind = industry.Trim().ToUpperInvariant();\n            query = query.Where(x => x.Industry == ind);\n        }\n\n        if (!string.IsNullOrWhiteSpace(q))\n        {\n            var tq = q.Trim();\n            query = query.Where(x =>\n                x.Key.Contains(tq) ||\n                x.Category.Contains(tq) ||\n                x.Industry.Contains(tq));\n        }\n\n        // Sorting\n        sort = (sort ?? \"featured\").ToLowerInvariant();\n        query = sort switch\n        {\n            \"name\" => query.OrderBy(x => x.Key).ThenBy(x => x.Industry),\n            \"featured\" => query.OrderByDescending(x => x.IsFeatured).ThenBy(x => x.Key),\n            _ => query.OrderByDescending(x => x.IsFeatured).ThenBy(x => x.Key)\n        };\n\n        var total = await query.CountAsync(ct);\n\n        var pageItems = await query\n            .Skip((page - 1) * pageSize)\n            .Take(pageSize)\n            .Select(x => new\n            {\n                x.Id,\n                x.Industry,\n                x.Key,\n                x.Category,\n                x.IsFeatured,\n                // representative variant: prefer en_US if present; otherwise first by language asc\n                Variant = _db.TemplateLibraryVariants\n                            .AsNoTracking()\n                            .Where(v => v.LibraryItemId == x.Id)\n                            .OrderByDescending(v => v.Language == \"en_US\")\n                            .ThenBy(v => v.Language)\n                            .Select(v => new { v.Language, v.HeaderType, v.BodyText, v.ButtonsJson })\n                            .FirstOrDefault()\n            })\n            .ToListAsync(ct);\n\n        var items = new List<TemplateLibraryListItemDto>(pageItems.Count);\n\n        foreach (var row in pageItems)\n        {\n            var lang = row.Variant?.Language ?? \"en_US\";\n            var headerType = row.Variant?.HeaderType ?? \"NONE\";\n            var body = row.Variant?.BodyText ?? \"\";\n\n            // Placeholder count in body {{n}}\n            var ph = Regex.Matches(body, @\"\\{\\{\\d+\\}\\}\").Count;\n\n            // Body preview (first 120 chars, one-line)\n            var preview = body.Replace(\"\\r\", \" \").Replace(\"\\n\", \" \");\n            if (preview.Length > 120) preview = preview.Substring(0, 120) + \"…\";\n\n            // Buttons summary from JSON (keep simple & resilient)\n            string btnSummary = \"\";\n            try\n            {\n                var rawJson = row.Variant?.ButtonsJson ?? \"[]\";\n                var btns = System.Text.Json.JsonSerializer.Deserialize<List<ButtonDto>>(rawJson)\n                           ?? new List<ButtonDto>();\n\n                if (btns.Count > 0)\n                {\n                    btnSummary = string.Join(\", \",\n                        btns.Select(b => (b.Type ?? \"\").ToUpperInvariant())\n                            .Distinct());\n                }\n            }\n            catch { /* ignore malformed buttons json */ }\n\n            items.Add(new TemplateLibraryListItemDto\n            {\n                Id = row.Id,\n                Industry = row.Industry,\n                Key = row.Key,\n                Category = row.Category,\n                IsFeatured = row.IsFeatured,\n                Language = lang,\n                HeaderType = headerType,\n                Placeholders = ph,\n                BodyPreview = preview,\n                ButtonsSummary = btnSummary\n            });\n        }\n\n        return new TemplateLibraryListResponse\n        {\n            Page = page,\n            PageSize = pageSize,\n            Total = total,\n            Items = items\n        };\n    }\n\n\n\n    public async Task<LibraryImportRequest> ExportAsync(string? industry, CancellationToken ct = default)\n    {\n        var request = new LibraryImportRequest();\n\n        var q = _db.TemplateLibraryItems.AsNoTracking();\n        if (!string.IsNullOrWhiteSpace(industry))\n        {\n            var ind = industry.Trim().ToUpperInvariant();\n            q = q.Where(x => x.Industry == ind);\n        }\n\n        var items = await q\n            .OrderByDescending(x => x.IsFeatured)\n            .ThenBy(x => x.Industry)\n            .ThenBy(x => x.Key)\n            .ToListAsync(ct);\n\n        if (items.Count == 0)\n            return request;\n\n        var variantsLookup = await _db.TemplateLibraryVariants\n            .AsNoTracking()\n            .Where(v => items.Select(i => i.Id).Contains(v.LibraryItemId))\n            .GroupBy(v => v.LibraryItemId)\n            .ToDictionaryAsync(g => g.Key, g => g.ToList(), ct);\n\n        foreach (var it in items)\n        {\n            variantsLookup.TryGetValue(it.Id, out var vs);\n            var dto = new LibraryImportItem\n            {\n                Industry = it.Industry,\n                Key = it.Key,\n                Category = it.Category,\n                IsFeatured = it.IsFeatured,\n                Variants = new List<LibraryImportVariant>()\n            };\n\n            if (vs != null)\n            {\n                foreach (var v in vs.OrderBy(v => v.Language))\n                {\n                    List<LibraryImportButton> buttons;\n                    try\n                    {\n                        buttons = string.IsNullOrWhiteSpace(v.ButtonsJson)\n                            ? new List<LibraryImportButton>()\n                            : System.Text.Json.JsonSerializer.Deserialize<List<LibraryImportButton>>(v.ButtonsJson)\n                              ?? new List<LibraryImportButton>();\n                    }\n                    catch\n                    {\n                        buttons = new List<LibraryImportButton>();\n                    }\n\n                    Dictionary<string, string>? examples;\n                    try\n                    {\n                        examples = string.IsNullOrWhiteSpace(v.ExampleParamsJson)\n                            ? new Dictionary<string, string>()\n                            : System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, string>>(v.ExampleParamsJson)\n                              ?? new Dictionary<string, string>();\n                    }\n                    catch\n                    {\n                        examples = new Dictionary<string, string>();\n                    }\n\n                    dto.Variants.Add(new LibraryImportVariant\n                    {\n                        Language = v.Language,\n                        HeaderType = v.HeaderType,\n                        HeaderText = v.HeaderText,\n                        BodyText = v.BodyText ?? string.Empty,\n                        FooterText = v.FooterText,\n                        Buttons = buttons,\n                        Examples = examples\n                    });\n                }\n            }\n\n            request.Items.Add(dto);\n        }\n\n        return request;\n    }\n\n}"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/TemplateNameCheckService.cs",
      "sha256": "37f8f1562eaa6dc29b4a1253c718db698bf8551a7ff052d12e8ca7d206e4a4ad",
      "language": "csharp",
      "size": 2906,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.TemplateModule.DTOs;\nusing xbytechat.api.Features.TemplateModule.Models;\nusing xbytechat.api.Features.TemplateModule.Utils;\n\nnamespace xbytechat.api.Features.TemplateModule.Services;\n\npublic interface ITemplateNameCheckService\n{\n    Task<TemplateNameCheckResponse?> CheckAsync(Guid businessId, Guid draftId, string language, CancellationToken ct = default);\n}\n\npublic sealed class TemplateNameCheckService : ITemplateNameCheckService\n{\n    private readonly AppDbContext _db;\n\n    public TemplateNameCheckService(AppDbContext db) => _db = db;\n\n    public async Task<TemplateNameCheckResponse?> CheckAsync(Guid businessId, Guid draftId, string language, CancellationToken ct = default)\n    {\n        language = string.IsNullOrWhiteSpace(language) ? \"en_US\" : language;\n\n        var draft = await _db.TemplateDrafts\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n\n        if (draft is null) return null;\n\n        // Compute the Meta template name we use during Submit\n        var baseName = MetaNameHelper.FromKey(draft.Key, businessId, MetaNameHelper.ShortBizSuffix(businessId));\n\n        var available = !await ExistsAsync(businessId, baseName, language, ct);\n        if (available)\n        {\n            return new TemplateNameCheckResponse\n            {\n                DraftId = draft.Id,\n                Language = language,\n                Name = baseName,\n                Available = true,\n                Suggestion = null\n            };\n        }\n\n        // Find first available suggestion by appending _2, _3, ...\n        var suggestion = await FirstAvailableAsync(businessId, baseName, language, ct);\n\n        return new TemplateNameCheckResponse\n        {\n            DraftId = draft.Id,\n            Language = language,\n            Name = baseName,\n            Available = false,\n            Suggestion = suggestion\n        };\n    }\n\n    private Task<bool> ExistsAsync(Guid businessId, string name, string language, CancellationToken ct)\n        => _db.WhatsAppTemplates.AsNoTracking()\n            .AnyAsync(t => t.BusinessId == businessId\n                        && t.Name == name\n                        && t.LanguageCode == language, ct);\n\n    private async Task<string> FirstAvailableAsync(Guid businessId, string baseName, string language, CancellationToken ct)\n    {\n        // avoid unbounded loops; Meta’s name limit is generous, but we keep it sane\n        for (int i = 2; i <= 1000; i++)\n        {\n            var candidate = $\"{baseName}_{i}\";\n            var exists = await ExistsAsync(businessId, candidate, language, ct);\n            if (!exists)\n                return candidate;\n        }\n        // fallback: add random short suffix\n        return $\"{baseName}_{Guid.NewGuid():N}\".Substring(0, Math.Min(baseName.Length + 9, 50));\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/TemplateStatusService.cs",
      "sha256": "bbfb0a6d1dc9bf2c148231c85459999c68d7956b8095da9a36d804716cf10fc4",
      "language": "csharp",
      "size": 1518,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\nusing xbytechat.api.Features.TemplateModule.Utils;\n\nnamespace xbytechat.api.Features.TemplateModule.Services;\n\npublic sealed class TemplateStatusService : ITemplateStatusService\n{\n    private readonly AppDbContext _db;\n\n    public TemplateStatusService(AppDbContext db)\n    {\n        _db = db;\n    }\n\n    public async Task<(string metaName, IReadOnlyList<TemplateStatusItemDto> items)> GetStatusAsync(\n        Guid businessId, Guid draftId, CancellationToken ct = default)\n    {\n        // Load draft (to get Key for Meta name derivation)\n        var draft = await _db.TemplateDrafts\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n\n        if (draft is null)\n            throw new KeyNotFoundException(\"Draft not found.\");\n\n        var name = MetaNameHelper.FromKey(draft.Key, businessId, MetaNameHelper.ShortBizSuffix(businessId));\n\n        // Query your SoT table\n        var rows = await _db.WhatsAppTemplates\n            .AsNoTracking()\n            .Where(t => t.BusinessId == businessId && t.Name == name)\n            .OrderBy(t => t.LanguageCode)\n            .Select(t => new TemplateStatusItemDto(\n                t.LanguageCode,\n                t.Status ?? string.Empty,\n                t.TemplateId,\n                t.UpdatedAt,\n                t.LastSyncedAt\n            ))\n            .ToListAsync(ct);\n\n        return (name, rows);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/TemplateSubmissionService.cs",
      "sha256": "6e9b65e65657759dddf3bc883deeaf9a7ca313887f62894226b939bd38ce0f39",
      "language": "csharp",
      "size": 6549,
      "content": "using System.Text.Json;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.TemplateModule.Abstractions;\nusing xbytechat.api.Features.TemplateModule.DTOs;\nusing xbytechat.api.Features.TemplateModule.Payload;\nusing xbytechat.api.Features.TemplateModule.Utils;\nusing xbytechat.api.Features.TemplateModule.Validators;\nusing xbytechat.api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.TemplateModule.Services;\n\npublic sealed class TemplateSubmissionService : ITemplateSubmissionService\n{\n    private readonly AppDbContext _db;\n    private readonly IMetaTemplateClient _meta;\n    private readonly ITemplateSyncService _templateSyncService;\n    public TemplateSubmissionService(AppDbContext db, IMetaTemplateClient meta, ITemplateSyncService templateSyncService)\n    {\n        _db = db;\n        _meta = meta;\n        _templateSyncService = templateSyncService;\n        \n    }\n\n    public async Task<TemplateSubmitResponseDto> SubmitAsync(Guid businessId, Guid draftId, CancellationToken ct = default)\n    {\n        // 1) Load draft + variants\n        var draft = await _db.TemplateDrafts\n            .AsNoTracking()\n            .FirstOrDefaultAsync(x => x.Id == draftId && x.BusinessId == businessId, ct);\n        if (draft is null)\n            return new TemplateSubmitResponseDto { Success = false, Message = \"Draft not found.\" };\n\n        var variants = await _db.TemplateDraftVariants\n            .AsNoTracking()\n            .Where(v => v.TemplateDraftId == draft.Id)\n            .ToListAsync(ct);\n        if (variants.Count == 0)\n            return new TemplateSubmitResponseDto { Success = false, Message = \"No language variants to submit.\" };\n\n        // 2) Validate cross-language parity\n        var views = variants.Select(v => new MultiLanguageValidator.VariantView\n        {\n            Language = v.Language,\n            BodyText = v.BodyText,\n            HeaderType = v.HeaderType,\n            HeaderText = v.HeaderText,\n            HeaderMediaLocalUrl = v.HeaderMediaLocalUrl,\n            FooterText = v.FooterText,\n            Buttons = SafeDeserialize<List<ButtonDto>>(v.ButtonsJson) ?? new(),\n            Examples = SafeDeserialize<Dictionary<string, string>>(v.ExampleParamsJson) ?? new()\n        }).ToList();\n\n        var (ok, errors) = MultiLanguageValidator.Validate(views);\n        if (!ok)\n        {\n            var errMsg = string.Join(\" | \", errors.Select(kv => $\"{kv.Key}: {string.Join(\" ; \", kv.Value)}\"));\n            return new TemplateSubmitResponseDto\n            {\n                Success = false,\n                Message = \"Validation failed before submission.\",\n                Variants = variants.Select(v => new SubmittedVariantResult\n                {\n                    Language = v.Language,\n                    Status = errors.ContainsKey(v.Language) ? \"INVALID\" : \"READY\",\n                    RejectionReason = errors.ContainsKey(v.Language) ? string.Join(\" ; \", errors[v.Language]) : null\n                }).ToList()\n            };\n        }\n\n        // 3) Derive Meta template name from Key (+ short biz suffix for safety)\n        var name = MetaNameHelper.FromKey(draft.Key, businessId, MetaNameHelper.ShortBizSuffix(businessId));\n\n        // 4) Submit per language\n        var results = new List<SubmittedVariantResult>();\n        foreach (var v in variants)\n        {\n            var buttons = SafeDeserialize<List<ButtonDto>>(v.ButtonsJson) ?? new();\n            var examples = SafeDeserialize<Dictionary<string, string>>(v.ExampleParamsJson) ?? new();\n\n            // For media headers, HeaderMediaLocalUrl must be uploaded before CreateTemplate\n            string? headerMetaId = null;\n            if (!v.HeaderType.Equals(\"NONE\", StringComparison.OrdinalIgnoreCase) &&\n                !v.HeaderType.Equals(\"TEXT\", StringComparison.OrdinalIgnoreCase))\n            {\n                if (string.IsNullOrWhiteSpace(v.HeaderMediaLocalUrl))\n                {\n                    results.Add(new SubmittedVariantResult\n                    {\n                        Language = v.Language,\n                        Status = \"FAILED\",\n                        RejectionReason = \"Missing media for header.\"\n                    });\n                    continue;\n                }\n                headerMetaId = await _meta.UploadMediaAsync(businessId, v.HeaderMediaLocalUrl!, v.HeaderType, ct);\n            }\n\n            var (components, examplePayload) =\n                MetaComponentsBuilder.Build(v.HeaderType, v.HeaderText, headerMetaId, v.BodyText, v.FooterText, buttons, examples);\n\n            var created = await _meta.CreateTemplateAsync(\n                businessId: businessId,\n                name: name,\n                category: draft.Category,\n                language: v.Language,\n                componentsPayload: components,\n                examplesPayload: examplePayload,\n                ct: ct\n            );\n\n            results.Add(new SubmittedVariantResult\n            {\n                Language = v.Language,\n                Status = created ? \"PENDING\" : \"FAILED\",\n                RejectionReason = created ? null : \"Meta create call failed.\"\n            });\n        }\n\n        var success = results.All(r => r.Status == \"PENDING\");\n\n        // 🔄 Auto-sync only if every language submitted OK\n        if (success)\n        {\n            try\n            {\n                // Force = true (ignore TTL), onlyUpsert = true (don’t deactivate others)\n                await _templateSyncService.SyncBusinessTemplatesAsync(businessId, force: true, onlyUpsert: true, ct);\n            }\n            catch (Exception ex)\n            {\n                // Non-fatal: submission succeeded; sync can be retried via existing endpoint\n                Console.WriteLine($\"[Template Submit] Sync warning: {ex.Message}\");\n            }\n        }\n\n        return new TemplateSubmitResponseDto\n        {\n            Success = success,\n            Message = success ? \"Submitted to Meta. Awaiting review.\" : \"Submitted with some failures.\",\n            Variants = results\n        };\n    }\n\n    public Task<int> SyncStatusAsync(Guid businessId, CancellationToken ct = default)\n    {\n        // Placeholder: in a later step we’ll call provider ListTemplates and update your WhatsAppTemplates via your existing sync flow.\n        return Task.FromResult(0);\n    }\n\n    private static T? SafeDeserialize<T>(string? json)\n    {\n        if (string.IsNullOrWhiteSpace(json)) return default;\n        try { return JsonSerializer.Deserialize<T>(json!); } catch { return default; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Services/WhatsAppTemplateService.cs",
      "sha256": "ee70376834e701f63425a69d50a4ea5d02170321edf828fe7fd2bd5d100bf3a1",
      "language": "csharp",
      "size": 2815,
      "content": "using Microsoft.Extensions.Configuration;\nusing Newtonsoft.Json;\nusing xbytechat.api.WhatsAppSettings.DTOs;\n\nnamespace xbytechat.api.Features.TemplateModule.Services\n{\n    public class WhatsAppTemplateService : IWhatsAppTemplateService\n    {\n        private readonly HttpClient _httpClient;\n        private readonly IConfiguration _config;\n        private readonly ILogger<WhatsAppTemplateService> _logger;\n\n        public WhatsAppTemplateService(HttpClient httpClient, IConfiguration config, ILogger<WhatsAppTemplateService> logger)\n        {\n            _httpClient = httpClient;\n            _config = config;\n            _logger = logger;\n        }\n\n        public async Task<List<TemplateMetadataDto>> FetchTemplatesAsync()\n        {\n            var wabaId = _config[\"WhatsApp:WABA_ID\"];\n            var token = _config[\"WhatsApp:apiToken\"];\n            var url = $\"https://graph.facebook.com/v18.0/{wabaId}/message_templates\";\n\n            var templates = new List<TemplateMetadataDto>();\n\n            try\n            {\n                _httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(\"Bearer\", token);\n                var response = await _httpClient.GetAsync(url);\n                var json = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                {\n                    _logger.LogError(\"Failed to fetch WhatsApp templates: \" + json);\n                    return templates;\n                }\n\n                var parsed = JsonConvert.DeserializeObject<dynamic>(json);\n\n                foreach (var tpl in parsed.data)\n                {\n                    string name = tpl.name;\n                    string language = tpl.language ?? \"en_US\";\n                    string body = \"\";\n\n                    foreach (var component in tpl.components)\n                    {\n                        if (component.type == \"BODY\")\n                        {\n                            body = component.text;\n                            break;\n                        }\n                    }\n\n                    // Count {{placeholders}}\n                    var placeholderCount = System.Text.RegularExpressions.Regex.Matches(body, \"{{(.*?)}}\").Count;\n\n                    templates.Add(new TemplateMetadataDto\n                    {\n                        Name = name,\n                        Language = language,\n                        Body = body,\n                        PlaceholderCount = placeholderCount\n                    });\n                }\n\n                return templates;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\"Error while fetching templates from Meta: \" + ex.Message);\n                return templates;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Utils/MetaNameHelper.cs",
      "sha256": "49bc1bb7e8945412aae2987bb0f6c7c539131cfa1b3db78cf43132431775b7cf",
      "language": "csharp",
      "size": 1237,
      "content": "using System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace xbytechat.api.Features.TemplateModule.Utils;\n\npublic static class MetaNameHelper\n{\n    // WhatsApp template name rules: lowercase, underscores, alnum and _ only, <= 25 chars.\n    private static readonly Regex Allowed = new(@\"[^a-z0-9_]+\", RegexOptions.Compiled);\n\n    public static string FromKey(string key, Guid businessId, string? suffix = null)\n    {\n        // 1) lower + underscores\n        var s = key.Trim().ToLowerInvariant()\n            .Replace(' ', '_')\n            .Replace('-', '_');\n\n        // 2) strip invalids\n        s = Allowed.Replace(s, \"\");\n\n        // 3) ensure starts with a letter\n        if (s.Length == 0 || !char.IsLetter(s[0]))\n            s = \"t_\" + s;\n\n        // 4) add optional suffix for uniqueness (e.g., short biz hash)\n        if (!string.IsNullOrWhiteSpace(suffix))\n            s = $\"{s}_{suffix}\".TrimEnd('_');\n\n        // 5) cap length 25 (WA limit)\n        if (s.Length > 25) s = s[..25];\n\n        // fallback safety\n        if (string.IsNullOrWhiteSpace(s)) s = \"t_\" + businessId.ToString(\"N\")[..6];\n        return s;\n    }\n\n    public static string ShortBizSuffix(Guid businessId)\n        => businessId.ToString(\"N\")[..6];\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Validators/MultiLanguageValidator.cs",
      "sha256": "127b69bcf7da20b98dfa5ed636ade2a7858c176a770b5f32827e7d5f94774b76",
      "language": "csharp",
      "size": 3021,
      "content": "using System.Text.Json;\nusing xbytechat.api.Features.TemplateModule.Validation;\nusing xbytechat.api.Features.TemplateModule.DTOs;\n\nnamespace xbytechat.api.Features.TemplateModule.Validators;\n\npublic static class MultiLanguageValidator\n{\n    public sealed class VariantView\n    {\n        public required string Language { get; init; }\n        public required string BodyText { get; init; }\n        public required string HeaderType { get; init; }\n        public string? HeaderText { get; init; }\n        public string? HeaderMediaLocalUrl { get; init; }\n        public string? FooterText { get; init; }\n        public required List<ButtonDto> Buttons { get; init; }\n        public required Dictionary<string, string> Examples { get; init; }\n    }\n\n    public static (bool ok, Dictionary<string, List<string>> errors) Validate(IReadOnlyList<VariantView> variants)\n    {\n        var errors = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);\n        bool OkLang(string lang) => !errors.ContainsKey(lang) || errors[lang].Count == 0;\n        void Add(string lang, string msg)\n        {\n            if (!errors.TryGetValue(lang, out var list)) { list = new(); errors[lang] = list; }\n            list.Add(msg);\n        }\n\n        // 1) Per-variant rules (reuse VariantValidator)\n        foreach (var v in variants)\n        {\n            var dto = new TemplateDraftVariantUpsertDto\n            {\n                Language = v.Language,\n                BodyText = v.BodyText,\n                HeaderType = v.HeaderType,\n                HeaderText = v.HeaderText,\n                HeaderMediaLocalUrl = v.HeaderMediaLocalUrl,\n                FooterText = v.FooterText,\n                Buttons = v.Buttons,\n                Examples = v.Examples\n            };\n            var r = VariantValidator.Validate(dto);\n            foreach (var e in r.Errors) Add(v.Language, e);\n        }\n\n        // 2) Cross-language placeholder arity/order parity\n        if (variants.Count > 1)\n        {\n            var reference = variants[0];\n            var refSlots = PlaceholderHelper.ExtractSlots(reference.BodyText);\n            var refSet = refSlots.ToHashSet();\n\n            foreach (var v in variants.Skip(1))\n            {\n                var slots = PlaceholderHelper.ExtractSlots(v.BodyText);\n                var set = slots.ToHashSet();\n\n                // arity parity\n                if (set.Count != refSet.Count)\n                    Add(v.Language, $\"Placeholder count mismatch vs {reference.Language}: expected {refSet.Count}, got {set.Count}.\");\n\n                // exact set parity (e.g., {1,2,3})\n                if (!set.SetEquals(refSet))\n                    Add(v.Language, $\"Placeholder indices mismatch vs {reference.Language}: expected {{{string.Join(\",\", refSet.OrderBy(x => x))}}}.\");\n\n                // continuity check already handled per-variant; this ensures cross-lang equality.\n            }\n        }\n\n        var ok = errors.Values.All(l => l.Count == 0);\n        return (ok, errors);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Validators/PlaceholderHelper.cs",
      "sha256": "ed97ab0aeb570642914acf818213226b108002c5a37eff9b71b34f22f073ce08",
      "language": "csharp",
      "size": 1053,
      "content": "using System.Text.RegularExpressions;\n\nnamespace xbytechat.api.Features.TemplateModule.Validation;\n\npublic static class PlaceholderHelper\n{\n    private static readonly Regex PlaceholderRx = new(@\"\\{\\{(\\d+)\\}\\}\", RegexOptions.Compiled);\n\n    public static List<int> ExtractSlots(string? text)\n    {\n        var list = new List<int>();\n        if (string.IsNullOrEmpty(text)) return list;\n        foreach (Match m in PlaceholderRx.Matches(text))\n        {\n            if (int.TryParse(m.Groups[1].Value, out var n)) list.Add(n);\n        }\n        return list;\n    }\n\n    public static (bool ok, string? error) EnsureContinuousFrom1(IReadOnlyCollection<int> slots)\n    {\n        if (slots.Count == 0) return (true, null);\n        var max = slots.Max();\n        var set = slots.ToHashSet();\n        for (int i = 1; i <= max; i++)\n        {\n            if (!set.Contains(i)) return (false, $\"Missing placeholder {{${i}}} (placeholders must be continuous from {{1}}..{{{max}}}).\".Replace(\"${i}\", i.ToString()));\n        }\n        return (true, null);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Validators/TemplateDraftValidator.cs",
      "sha256": "b4d9c66c1acf1fd12bcfbeee9c84987acfe2a106989552e8bd9b271e3dd4df3a",
      "language": "csharp",
      "size": 170,
      "content": "namespace xbytechat.api.Features.TemplateModule.Validators;\n\npublic sealed class TemplateDraftValidator\n{\n    // TODO: implement FluentValidation rules in a later step\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Validators/TemplateDraftVariantValidator.cs",
      "sha256": "3b3c5e900711fd6a17344242b8f0e296a1e2b6f0fb1f6328718ecdf8752ec42e",
      "language": "csharp",
      "size": 196,
      "content": "namespace xbytechat.api.Features.TemplateModule.Validators;\n\npublic sealed class TemplateDraftVariantValidator\n{\n    // TODO: implement rules: placeholders, buttons, media, language codes, etc.\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Validators/TemplateRules.cs",
      "sha256": "d9236e131fabd0663a6ecf28f3a63527085fdf86ccc19ce2f63f2584586b2308",
      "language": "csharp",
      "size": 1336,
      "content": "namespace xbytechat.api.Features.TemplateModule.Validation;\n\npublic static class TemplateRules\n{\n    public const int MaxTemplateName = 25;              // applies when we later derive Meta name from Key\n    public const int MaxButtons = 3;\n    public const int MaxQuickReplyText = 25;            // conservative; WA may allow ~20-25\n    public const int MaxHeaderText = 60;                // conservative header text length\n    public const int MaxFooterText = 60;                // conservative footer text length\n    public const int MaxBodyLength = 1024;              // safe upper bound for WA template body\n\n    public static readonly HashSet<string> AllowedHeaderTypes = new(StringComparer.OrdinalIgnoreCase)\n    { \"NONE\", \"TEXT\", \"IMAGE\", \"VIDEO\", \"DOCUMENT\" };\n\n    public static readonly HashSet<string> AllowedButtonTypes = new(StringComparer.OrdinalIgnoreCase)\n    { \"QUICK_REPLY\", \"URL\", \"PHONE\" };\n\n    public static bool IsValidPhone(string? phone)\n        => !string.IsNullOrWhiteSpace(phone) && phone!.Trim().Length >= 7 && phone.Trim().Length <= 20;\n\n    public static bool IsValidUrl(string? url)\n    {\n        if (string.IsNullOrWhiteSpace(url)) return false;\n        return Uri.TryCreate(url, UriKind.Absolute, out var u)\n               && (u.Scheme == Uri.UriSchemeHttps || u.Scheme == Uri.UriSchemeHttp);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/TemplatesModule/Validators/VariantValidator.cs",
      "sha256": "4f514844e6a284d23e1f43ea866642045024bc36180dd3d4bab8ade84684edf0",
      "language": "csharp",
      "size": 4688,
      "content": "using xbytechat.api.Features.TemplateModule.DTOs;\nusing xbytechat.api.Features.TemplateModule.Validation;\nusing xbytechat.api.Features.TemplatesModule.Language;\n\nnamespace xbytechat.api.Features.TemplateModule.Validators;\n\npublic static class VariantValidator\n{\n    public sealed class Result\n    {\n        public bool Ok => Errors.Count == 0;\n        public List<string> Errors { get; } = new();\n        public void Add(string msg) { if (!string.IsNullOrWhiteSpace(msg)) Errors.Add(msg); }\n    }\n\n    public static Result Validate(TemplateDraftVariantUpsertDto dto)\n    {\n        var r = new Result();\n\n        // language\n        if (!SupportedLanguages.IsSupported(dto.Language))\n            r.Add($\"Unsupported language: {dto.Language}\");\n\n        // body\n        if (string.IsNullOrWhiteSpace(dto.BodyText))\n            r.Add(\"BodyText is required.\");\n        else if (dto.BodyText.Length > TemplateRules.MaxBodyLength)\n            r.Add($\"BodyText too long (>{TemplateRules.MaxBodyLength}).\");\n\n        // placeholders\n        var slots = PlaceholderHelper.ExtractSlots(dto.BodyText);\n        var cont = PlaceholderHelper.EnsureContinuousFrom1(slots);\n        if (!cont.ok) r.Add(cont.error!);\n\n        // header\n        if (!TemplateRules.AllowedHeaderTypes.Contains(dto.HeaderType))\n            r.Add($\"HeaderType must be one of: {string.Join(\", \", TemplateRules.AllowedHeaderTypes)}\");\n\n        if (dto.HeaderType.Equals(\"TEXT\", StringComparison.OrdinalIgnoreCase))\n        {\n            if (string.IsNullOrWhiteSpace(dto.HeaderText))\n                r.Add(\"HeaderText required for TEXT header.\");\n            else if (dto.HeaderText.Length > TemplateRules.MaxHeaderText)\n                r.Add($\"HeaderText too long (>{TemplateRules.MaxHeaderText}).\");\n        }\n        else if (!dto.HeaderType.Equals(\"NONE\", StringComparison.OrdinalIgnoreCase))\n        {\n            // media header types\n            if (string.IsNullOrWhiteSpace(dto.HeaderMediaLocalUrl))\n                r.Add($\"HeaderMediaLocalUrl required for media header type {dto.HeaderType}.\");\n        }\n\n        // footer\n        if (!string.IsNullOrWhiteSpace(dto.FooterText) && dto.FooterText.Length > TemplateRules.MaxFooterText)\n            r.Add($\"FooterText too long (>{TemplateRules.MaxFooterText}).\");\n\n        // buttons\n        if (dto.Buttons is not null)\n        {\n            if (dto.Buttons.Count > TemplateRules.MaxButtons)\n                r.Add($\"At most {TemplateRules.MaxButtons} buttons are allowed.\");\n\n            int phoneCtas = 0;\n            var quickReplyTexts = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n\n            foreach (var b in dto.Buttons)\n            {\n                if (!TemplateRules.AllowedButtonTypes.Contains(b.Type))\n                {\n                    r.Add($\"Button type '{b.Type}' is invalid.\");\n                    continue;\n                }\n\n                if (string.IsNullOrWhiteSpace(b.Text))\n                {\n                    r.Add(\"Button text is required.\");\n                }\n                else if (b.Type.Equals(\"QUICK_REPLY\", StringComparison.OrdinalIgnoreCase))\n                {\n                    if (b.Text.Length > TemplateRules.MaxQuickReplyText)\n                        r.Add($\"Quick Reply text too long (>{TemplateRules.MaxQuickReplyText}).\");\n                    if (!quickReplyTexts.Add(b.Text))\n                        r.Add(\"Duplicate Quick Reply button text not allowed.\");\n                }\n\n                if (b.Type.Equals(\"URL\", StringComparison.OrdinalIgnoreCase))\n                {\n                    if (!TemplateRules.IsValidUrl(b.Url))\n                        r.Add(\"URL button must have a valid http(s) Url.\");\n                }\n\n                if (b.Type.Equals(\"PHONE\", StringComparison.OrdinalIgnoreCase))\n                {\n                    phoneCtas++;\n                    if (!TemplateRules.IsValidPhone(b.Phone))\n                        r.Add(\"PHONE button must have a valid phone number.\");\n                }\n            }\n\n            if (phoneCtas > 1) r.Add(\"Only one PHONE CTA button is allowed.\");\n        }\n\n        // examples for placeholders\n        if (slots.Count > 0)\n        {\n            var need = slots.Max();\n            var missing = new List<string>();\n            for (int i = 1; i <= need; i++)\n            {\n                if (dto.Examples is null || !dto.Examples.ContainsKey(i.ToString()) || string.IsNullOrWhiteSpace(dto.Examples[i.ToString()]))\n                    missing.Add($\"{{{{{i}}}}}\");\n            }\n            if (missing.Count > 0)\n                r.Add($\"Examples required for placeholders: {string.Join(\", \", missing)}\");\n        }\n\n        return r;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Controllers/MessageLogsReportController.cs",
      "sha256": "57679ca179ec26b011a115fa136660702c25971ea0beb441c8805d2bdc911b49",
      "language": "csharp",
      "size": 10297,
      "content": "using System.Text;\nusing ClosedXML.Excel;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Shared; // for User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/report/message-logs\")]\n    [Authorize]\n    public sealed class MessageLogsReportController : ControllerBase\n    {\n        private readonly IMessageLogsReportService _service;\n\n        public MessageLogsReportController(IMessageLogsReportService service)\n            => _service = service;\n\n        [HttpPost(\"search\")]\n        [ProducesResponseType(typeof(PaginatedResponse<MessageLogListItemDto>), StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status401Unauthorized)]\n        public async Task<IActionResult> Search([FromBody] MessageLogReportQueryDto q, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var result = await _service.SearchAsync(businessId, q, ct);\n            return Ok(result);\n        }\n\n        [HttpPost(\"export/csv\")]\n        [Produces(\"text/csv\")]\n        public async Task<IActionResult> ExportCsv([FromBody] MessageLogReportQueryDto q, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // We’ll walk pages to get the full dataset (service clamps PageSize to <= 200).\n            var sb = new StringBuilder();\n\n            // Header\n            sb.AppendLine(string.Join(\",\", new[]\n            {\n                \"Time\",\"Recipient\",\"SenderId\",\"Channel\",\"Status\",\"Type\",\"Campaign\",\n                \"Body\",\"ProviderId\",\"DeliveredAt\",\"ReadAt\",\"Error\"\n            }.Select(EscapeCsv)));\n\n            var page = 1;\n            const int maxLoops = 10000; // safety\n            var totalWritten = 0;\n\n            while (page <= maxLoops)\n            {\n                var pageQuery = new MessageLogReportQueryDto\n                {\n                    FromUtc = q.FromUtc,\n                    ToUtc = q.ToUtc,\n                    Search = q.Search,\n                    Statuses = q.Statuses,\n                    Channels = q.Channels,\n                    SenderIds = q.SenderIds,\n                    MessageTypes = q.MessageTypes,\n                    CampaignId = q.CampaignId,\n                    SortBy = q.SortBy,\n                    SortDir = q.SortDir,\n                    Page = page,\n                    PageSize = 200 // max page supported by service\n                };\n\n                var res = await _service.SearchAsync(businessId, pageQuery, ct);\n                if (res.Items.Count == 0) break;\n\n                foreach (var r in res.Items)\n                {\n                    var time = r.SentAt ?? r.CreatedAt;\n                    var row = new[]\n                    {\n                        EscapeCsv(time.ToLocalTime().ToString(\"yyyy-MM-dd HH:mm:ss\")),\n                        EscapeCsv(r.RecipientNumber ?? \"\"),\n                        EscapeCsv(r.SenderId ?? \"\"),\n                        EscapeCsv(r.SourceChannel ?? \"\"),\n                        EscapeCsv(r.Status ?? \"\"),\n                        EscapeCsv(r.MessageType ?? \"\"),\n                        EscapeCsv(r.CampaignName ?? r.CampaignId?.ToString() ?? \"\"),\n                        EscapeCsv((r.MessageContent ?? \"\").ReplaceLineEndings(\" \")),\n                        EscapeCsv(r.ProviderMessageId ?? \"\"),\n                        EscapeCsv(r.DeliveredAt?.ToLocalTime().ToString(\"yyyy-MM-dd HH:mm:ss\") ?? \"\"),\n                        EscapeCsv(r.ReadAt?.ToLocalTime().ToString(\"yyyy-MM-dd HH:mm:ss\") ?? \"\"),\n                        EscapeCsv((r.ErrorMessage ?? \"\").ReplaceLineEndings(\" \"))\n                    };\n                    sb.AppendLine(string.Join(\",\", row));\n                }\n\n                totalWritten += res.Items.Count;\n\n                // stop when we’ve written everything\n                var total = res.TotalCount;\n                if (totalWritten >= total) break;\n\n                page++;\n            }\n\n            var bytes = Encoding.UTF8.GetBytes(sb.ToString());\n            var fileName =\n                $\"MessageLogs{(q.CampaignId.HasValue ? \"-\" + q.CampaignId.Value : \"\")}-{DateTime.UtcNow:yyyyMMddHHmmss}.csv\";\n\n            return File(bytes, \"text/csv\", fileName);\n\n            static string EscapeCsv(string s)\n            {\n                // Quote if contains comma, quote, or newline\n                if (s.Contains(',') || s.Contains('\"') || s.Contains('\\n') || s.Contains('\\r'))\n                {\n                    return $\"\\\"{s.Replace(\"\\\"\", \"\\\"\\\"\")}\\\"\";\n                }\n                return s;\n            }\n        }\n\n     \n        [HttpPost(\"export/pdf\")]\n        public IActionResult ExportPdfStub()\n        {\n            return StatusCode(StatusCodes.Status501NotImplemented, new ProblemDetails\n            {\n                Title = \"PDF export is not enabled\",\n                Detail = \"Implement in MessageLogsReportController.ExportPdf using a PDF library.\"\n            });\n        }\n\n        [HttpPost(\"export/xlsx\")]\n        [Produces(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")]\n        public async Task<IActionResult> ExportXlsx([FromBody] MessageLogReportQueryDto q, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Page through all results using the same service used by the grid.\n            const int pageSize = 200; // service already clamps; keep explicit for clarity\n            var all = new List<MessageLogListItemDto>(capacity: pageSize * 5); // small pre-alloc\n\n            var page = 1;\n            while (true)\n            {\n                var pageQuery = new MessageLogReportQueryDto\n                {\n                    FromUtc = q.FromUtc,\n                    ToUtc = q.ToUtc,\n                    Search = q.Search,\n                    Statuses = q.Statuses,\n                    Channels = q.Channels,\n                    SenderIds = q.SenderIds,\n                    MessageTypes = q.MessageTypes,\n                    CampaignId = q.CampaignId,\n                    SortBy = q.SortBy,\n                    SortDir = q.SortDir,\n                    Page = page,\n                    PageSize = pageSize\n                };\n\n                var res = await _service.SearchAsync(businessId, pageQuery, ct);\n                if (res.Items.Count == 0) break;\n\n                all.AddRange(res.Items);\n\n                if (all.Count >= res.TotalCount) break; // done\n                page++;\n            }\n\n            // Build the workbook in memory\n            using var wb = new XLWorkbook();\n            var ws = wb.Worksheets.Add(\"MessageLogs\");\n\n            // Header\n            var headers = new[]\n            {\n        \"Time\",\"Recipient\",\"SenderId\",\"Channel\",\"Status\",\"Type\",\"Campaign\",\n        \"Body\",\"ProviderId\",\"DeliveredAt\",\"ReadAt\",\"Error\"\n    };\n            for (int c = 0; c < headers.Length; c++)\n                ws.Cell(1, c + 1).Value = headers[c];\n\n            // Simple header style\n            var headerRange = ws.Range(1, 1, 1, headers.Length);\n            headerRange.Style.Font.Bold = true;\n            headerRange.Style.Fill.BackgroundColor = XLColor.FromHtml(\"#F3F4F6\"); // light gray\n            headerRange.Style.Border.BottomBorder = XLBorderStyleValues.Thin;\n\n            // Rows\n            int r = 2;\n            foreach (var it in all)\n            {\n                var time = (it.SentAt ?? it.CreatedAt).ToLocalTime();\n\n                ws.Cell(r, 1).Value = time;\n                ws.Cell(r, 1).Style.DateFormat.Format = \"yyyy-mm-dd hh:mm:ss\";\n\n                ws.Cell(r, 2).Value = it.RecipientNumber ?? \"\";\n                ws.Cell(r, 3).Value = it.SenderId ?? \"\";\n                ws.Cell(r, 4).Value = it.SourceChannel ?? \"\";\n                ws.Cell(r, 5).Value = it.Status ?? \"\";\n                ws.Cell(r, 6).Value = it.MessageType ?? \"\";\n                ws.Cell(r, 7).Value = it.CampaignName ?? (it.CampaignId?.ToString() ?? \"\");\n\n                // Body/Errors as plain text to avoid newlines breaking rows\n                ws.Cell(r, 8).Value = (it.MessageContent ?? \"\").ReplaceLineEndings(\" \");\n                ws.Cell(r, 9).Value = it.ProviderMessageId ?? \"\";\n\n                if (it.DeliveredAt.HasValue)\n                {\n                    ws.Cell(r, 10).Value = it.DeliveredAt.Value.ToLocalTime();\n                    ws.Cell(r, 10).Style.DateFormat.Format = \"yyyy-mm-dd hh:mm:ss\";\n                }\n                else ws.Cell(r, 10).Value = \"\";\n\n                if (it.ReadAt.HasValue)\n                {\n                    ws.Cell(r, 11).Value = it.ReadAt.Value.ToLocalTime();\n                    ws.Cell(r, 11).Style.DateFormat.Format = \"yyyy-mm-dd hh:mm:ss\";\n                }\n                else ws.Cell(r, 11).Value = \"\";\n\n                ws.Cell(r, 12).Value = (it.ErrorMessage ?? \"\").ReplaceLineEndings(\" \");\n                r++;\n            }\n\n            // Fit columns\n            ws.Columns().AdjustToContents();\n\n            // Stream to client\n            using var ms = new MemoryStream();\n            wb.SaveAs(ms);\n            ms.Position = 0;\n\n            var fileName = $\"MessageLogs-{DateTime.UtcNow:yyyyMMddHHmmss}.xlsx\";\n            const string contentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n            return File(ms.ToArray(), contentType, fileName);\n        }\n        [HttpGet(\"facets\")]\n        [ProducesResponseType(typeof(MessageLogFacetsDto), StatusCodes.Status200OK)]\n        [ProducesResponseType(StatusCodes.Status401Unauthorized)]\n        public async Task<IActionResult> Facets([FromQuery] int fromDays = 90, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var fromUtc = DateTime.UtcNow.AddDays(-Math.Abs(fromDays));\n            var facets = await _service.GetFacetsAsync(businessId, fromUtc, ct);\n            return Ok(facets);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Controllers/TrackingController.cs",
      "sha256": "1b1691c172affbb2a81f1699e25328337f45d1d165e08d0cd5489b168fc9b05d",
      "language": "csharp",
      "size": 7107,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api; // Your using for AppDbContext\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Worker; // Your using for DTOs\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/tracking\")]\n    public class TrackingController : ControllerBase\n    {\n        private readonly ITrackingService _tracker;\n        private readonly AppDbContext _context;\n        private readonly IContactJourneyService _journeyService;\n        private readonly IJourneyExportService _journeyExport;\n        public TrackingController(ITrackingService tracker, AppDbContext context, IContactJourneyService journeyService, IJourneyExportService journeyExport)\n        {\n            _tracker = tracker;\n            _context = context;\n            _journeyService = journeyService;\n            _journeyExport = journeyExport;\n        }\n\n        [HttpGet(\"journeys/{campaignSendLogId}\")]\n        public async Task<IActionResult> GetJourney(Guid campaignSendLogId)\n        {\n            var journeyEvents = await _journeyService.GetJourneyEventsAsync(campaignSendLogId);\n            return Ok(journeyEvents);\n        }\n\n\n        //[HttpGet(\"redirect/{campaignSendLogId}\")]\n        //public async Task<IActionResult> TrackCampaignClick(\n        //    Guid campaignSendLogId,\n        //    [FromQuery] string type,\n        //    [FromQuery] string to)\n        //{\n        //    if (string.IsNullOrWhiteSpace(to))\n        //    {\n        //        return BadRequest(\"Missing redirect target URL.\");\n        //    }\n\n        //    var log = await _context.CampaignSendLogs.FindAsync(campaignSendLogId);\n        //    if (log != null)\n        //    {\n        //        log.IsClicked = true;\n        //        log.ClickedAt = DateTime.UtcNow;\n        //        log.ClickType = type;\n        //        log.IpAddress = HttpContext.Connection.RemoteIpAddress?.ToString();\n        //        await _context.SaveChangesAsync();\n        //    }\n\n        //    return Redirect(to);\n        //}\n\n        [HttpGet(\"redirect/{campaignSendLogId}\")]\n        public async Task<IActionResult> TrackCampaignClick(\n    Guid campaignSendLogId,\n    [FromQuery] string type,\n    [FromQuery] string to,\n    [FromQuery] int? idx = null,\n    CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(to))\n                return BadRequest(\"Missing redirect target URL.\");\n\n            if (!Uri.TryCreate(to, UriKind.Absolute, out var destUri))\n                return BadRequest(\"Destination URL is invalid.\");\n\n            var clickType = string.IsNullOrWhiteSpace(type)\n                ? ClassifyClickType(destUri)\n                : type.Trim().ToLowerInvariant();\n\n            // Load parent CSL (tracked so we can update it)\n            var log = await _context.CampaignSendLogs.FindAsync(new object[] { campaignSendLogId }, ct);\n            if (log is not null)\n            {\n                var now = DateTime.UtcNow;\n                var ip = HttpContext.Connection.RemoteIpAddress?.ToString();\n                var ua = Request.Headers.UserAgent.ToString();\n\n                // First-click update on the send (idempotent enough for now)\n                log.IsClicked = true;\n                log.ClickedAt = now;\n                log.ClickType = clickType;\n                log.IpAddress = ip;\n\n                // Persist the click (ties to same run/session)\n                await _context.CampaignClickLogs.AddAsync(new CampaignClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignSendLogId = log.Id,\n                    CampaignId = log.CampaignId,// ?? Guid.Empty, // ✅ coalesce; make column Guid? to avoid this\n                    ContactId = log.ContactId,                // Guid? OK\n                    ButtonIndex = (short)(idx ?? 0),\n                    ButtonTitle = string.IsNullOrWhiteSpace(type) ? \"link\" : type,\n                    Destination = destUri.ToString(),\n                    ClickedAt = now,\n                    Ip = ip ?? \"\",\n                    UserAgent = ua ?? \"\",\n                    ClickType = clickType,\n                    RunId = log.RunId                      // remove if your schema doesn’t have RunId\n                }, ct);\n\n                await _context.SaveChangesAsync(ct);\n            }\n\n            return Redirect(destUri.ToString());\n        }\n\n        // Simple classifier used above\n        private static string ClassifyClickType(Uri u)\n        {\n            if (u == null) return \"web\";\n            var scheme = u.Scheme?.ToLowerInvariant() ?? \"\";\n            if (scheme == \"tel\") return \"call\";\n            if (scheme == \"whatsapp\") return \"whatsapp\";\n            if (scheme is \"http\" or \"https\")\n            {\n                var host = u.Host?.ToLowerInvariant() ?? \"\";\n                if (host.Contains(\"wa.me\") || host.Contains(\"api.whatsapp.com\"))\n                    return \"whatsapp\";\n            }\n            return \"web\";\n        }\n\n        /// <summary>\n        /// Gets detailed information for a specific tracking log entry.\n        /// </summary>\n        [HttpGet(\"logs/{id}/details\")]\n        public async Task<IActionResult> GetLogDetails(Guid id)\n        {\n            var result = await _tracker.GetLogDetailsAsync(id);\n            if (result == null)\n                return NotFound(\"Tracking log not found\");\n\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Retrieves click logs specifically related to automation flows.\n        /// </summary>\n        [HttpGet(\"flow-clicks\")]\n        public async Task<IActionResult> GetFlowClickLogs()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(\"❌ Invalid or missing business ID\");\n\n            var logs = await _tracker.GetFlowClickLogsAsync(businessId);\n\n            var dtoList = logs.Select(x => new\n            {\n                x.Id,\n                x.StepId,\n                x.ContactPhone,\n                x.ButtonText,\n                x.TemplateId,\n                x.FollowUpSent,\n                x.ClickedAt\n            });\n\n            return Ok(dtoList);\n        }\n        [HttpGet(\"journeys/{campaignSendLogId:guid}/export/csv\")]\n        public async Task<IActionResult> ExportJourneyCsv(Guid campaignSendLogId, CancellationToken ct)\n        {\n            var res = await _journeyExport.ExportJourneyCsvAsync(campaignSendLogId, ct);\n            return File(res.Bytes, res.ContentType, res.FileName);\n        }\n\n        [HttpGet(\"journeys/{campaignSendLogId:guid}/export/xlsx\")]\n        public async Task<IActionResult> ExportJourneyXlsx(Guid campaignSendLogId, CancellationToken ct)\n        {\n            var res = await _journeyExport.ExportJourneyXlsxAsync(campaignSendLogId, ct);\n            return File(res.Bytes, res.ContentType, res.FileName);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Controllers/TrackingViewerController.cs",
      "sha256": "6dfeff85fe69af455c90c7ae2ad1fd0614866359c0eaee39cf101ca67b819507",
      "language": "csharp",
      "size": 1584,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/tracking/logs\")]\n    public class TrackingViewerController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n\n        public TrackingViewerController(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] Guid? campaignId = null)\n        {\n            var query = _context.TrackingLogs\n                .Include(t => t.Campaign) // Optional\n                .Include(t => t.Contact)  // Optional\n                .OrderByDescending(t => t.ClickedAt)\n                .AsQueryable();\n\n            if (campaignId.HasValue)\n                query = query.Where(t => t.CampaignId == campaignId);\n\n            var results = await query\n                .Select(t => new\n                {\n                    t.Id,\n                    t.ContactPhone,\n                    ContactName = t.Contact != null ? t.Contact.Name : \"(N/A)\",\n                    t.ButtonText,\n                    t.CTAType,\n                    t.SourceType,\n                    t.ClickedAt,\n                    t.DeviceType,\n                    t.Country,\n                    CampaignName = t.Campaign != null ? t.Campaign.Name : \"(Unknown)\"\n                })\n                .ToListAsync();\n\n            return Ok(new { success = true, data = results });\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/JourneyEventDto.cs",
      "sha256": "34abc81cfaea73e66ebb64431d3723ede8e2ac5cab0fcd6e8f4a1b2bbfe20320",
      "language": "csharp",
      "size": 727,
      "content": "namespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class JourneyEventDto\n    {\n        public DateTime Timestamp { get; set; }\n        public string Source { get; set; } = \"System\"; // System/User/Provider\n        public string EventType { get; set; } = \"\";    // MessageSent/Delivered/Read/ButtonClicked/FlowStep/FlowSend/Redirect/Error\n        public string Title { get; set; } = \"\";\n        public string Details { get; set; } = \"\";\n        public Guid? StepId { get; set; }\n        public string? StepName { get; set; }\n        public int? ButtonIndex { get; set; }\n        public string? ButtonTitle { get; set; }\n        public string? Url { get; set; }\n        public string? TemplateName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/JourneyResponseDto.cs",
      "sha256": "0dd5d4a7faf319e281c5c96d6a7164a6e763aba0de03a617e58165196f48dffa",
      "language": "csharp",
      "size": 549,
      "content": "namespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class JourneyResponseDto\n    {\n        public string CampaignType { get; set; } = \"dynamic_url\"; // or \"flow\"\n        public string? FlowName { get; set; }\n        public Guid? FlowId { get; set; }\n        public Guid CampaignId { get; set; }\n        public Guid ContactId { get; set; }\n        public string ContactPhone { get; set; } = \"\";\n        public List<JourneyEventDto> Events { get; set; } = new();\n        public string? LeftOffAt { get; set; }  // step title or reason\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/MessageLogFacetsDto.cs",
      "sha256": "78f9fb1561eb81fa5af81dd2df22164d18841f71475f5d10400f18a702c8fa0f",
      "language": "csharp",
      "size": 516,
      "content": "namespace xbytechat.api.Features.Tracking.DTOs\n{\n    public sealed class MessageLogFacetsDto\n    {\n        public string[] WabaIds { get; init; } = Array.Empty<string>();     // WhatsAppBusinessNumber\n        public string[] SenderIds { get; init; } = Array.Empty<string>();   // Campaign.PhoneNumberId\n        public string[] Channels { get; init; } = Array.Empty<string>();    // provider (e.g., META, PINNACLE)\n        public string[] Statuses { get; init; } = Array.Empty<string>();    // message status\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/MessageLogReportQueryDto.cs",
      "sha256": "d92aa8928329edd484bc7c51d8c0be8b7adad6acf6e1996007b37f993214c4aa",
      "language": "csharp",
      "size": 1843,
      "content": "namespace xbytechat.api.Features.Tracking.DTOs\n{\n    public sealed class MessageLogReportQueryDto\n    {\n        public DateTime? FromUtc { get; set; }\n        public DateTime? ToUtc { get; set; }\n        public string? Search { get; set; }                 // phone or text contains\n        public string[]? Statuses { get; set; }             // Sent/Delivered/Read/Failed etc.\n        public string[]? Channels { get; set; }             // meta_cloud/sms/email…\n        public string[]? SenderIds { get; set; }            // phone_number_id\n        public string[]? MessageTypes { get; set; }         // text/image/template…\n        public Guid? CampaignId { get; set; }               // optional scope\n\n        public string? SortBy { get; set; } = \"SentAt\";     // server-whitelisted\n        public string? SortDir { get; set; } = \"desc\";      // asc|desc\n\n        public int Page { get; set; } = 1;\n        public int PageSize { get; set; } = 25;\n    }\n\n    public sealed class MessageLogListItemDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }\n\n        public string? RecipientNumber { get; set; }\n        public string? SenderId { get; set; }\n        public string? SourceChannel { get; set; }\n        public string? Status { get; set; }\n        public string? MessageType { get; set; }\n\n        public string? MessageContent { get; set; }\n        public string? TemplateName { get; set; }\n        public string? ProviderMessageId { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/TrackingLogDetailsDto.cs",
      "sha256": "d0cfbc11c40d0e6a7494b91c4bdd7676b9dc6d0fe5461634c7638f4a84cca5ac",
      "language": "csharp",
      "size": 462,
      "content": "using xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class TrackingLogDetailsDto\n    {\n        public TrackingLogDto Tracking { get; set; } = new();\n        public ContactDto? Contact { get; set; }\n        public CampaignDto? Campaign { get; set; }\n        public MessageLogDto? MessageLog { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/DTOs/TrackingLogDto.cs",
      "sha256": "bae94801851bba1bbeb94d60e81f2d20efd13b86be1391265098462d82a3c762",
      "language": "csharp",
      "size": 1798,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Tracking.DTOs\n{\n    public class TrackingLogDto\n    {\n        // 🧩 Multi-Tenant Isolation\n        public Guid BusinessId { get; set; }\n\n        // 👤 CRM Linkage\n        public Guid? ContactId { get; set; }\n        public string? ContactPhone { get; set; }\n\n        // 🔗 Source Info\n        public string SourceType { get; set; } = string.Empty; // e.g. \"campaign\", \"reminder\", \"bot\"\n        public Guid? SourceId { get; set; }\n\n        // 🔘 CTA Info\n        public string? ButtonText { get; set; }\n        public string? CTAType { get; set; }\n\n        // 📨 Message Context\n        public string? MessageId { get; set; }\n        public string? TemplateId { get; set; }\n        public Guid? MessageLogId { get; set; }\n\n        // 🧠 Meta / Behaviour\n        public string? ClickedVia { get; set; }\n        public string? Referrer { get; set; }\n        public DateTime? ClickedAt { get; set; } = DateTime.UtcNow;\n        // 📡 Tracking\n        public string? IPAddress { get; set; }\n        public string? Browser { get; set; }\n        public string? DeviceType { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // 🔖 Session context\n        public string? SessionId { get; set; }\n        public string? ThreadId { get; set; }\n\n        public Guid? CampaignId { get; set; }\n        public Guid? CampaignSendLogId { get; set; }\n\n        public string RawJson { get; set; } = string.Empty; // used in queue method\n        public DateTime EnqueuedAt { get; set; } // used in queue method\n        public string? NextStepMatched { get; set; } // ✅ Add this if not already there\n\n        public string? TemplateName { get; set; } // ✅ Needed for follow-up matcher\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Models/TrackingLog.cs",
      "sha256": "bd0559aca22f0289bf1f445973d52a25d32c68d0a7ed48ada5c7e4408850ca1d",
      "language": "csharp",
      "size": 2261,
      "content": "using xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Tracking.Models;\nnamespace xbytechat.api.Features.Tracking.Models\n{\n    public class TrackingLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // 🧩 Multi-Tenant Isolation\n        public Guid BusinessId { get; set; }\n\n        // 👤 CRM Linkage\n        public Guid? ContactId { get; set; }\n        public string? ContactPhone { get; set; }\n        public Contact? Contact { get; set; } // ✅ NEW\n\n        // 🔗 Source Info\n        public string SourceType { get; set; } = string.Empty;\n        public Guid? SourceId { get; set; }\n\n        public Guid? CampaignId { get; set; }\n        public Campaign? Campaign { get; set; } // ✅ NEW\n\n        public Guid? CampaignSendLogId { get; set; }\n        public CampaignSendLog? CampaignSendLog { get; set; } // ✅ Optional\n\n        // 🔘 Button Info\n        public string? ButtonText { get; set; }\n        public string? CTAType { get; set; }\n\n        // 📨 Message Context\n        public string? MessageId { get; set; }\n        public string? TemplateId { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public MessageLog? MessageLog { get; set; } // ✅ Optional\n\n        // 🧠 Meta / Behaviour\n        public string? ClickedVia { get; set; }\n        public string? Referrer { get; set; }\n\n        // 🕒 Audit Trail\n        public DateTime ClickedAt { get; set; } = DateTime.UtcNow;\n        public string? IPAddress { get; set; }\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // 🔖 Follow-up & Analytics\n        public bool FollowUpSent { get; set; } = false;\n        public string? LastInteractionType { get; set; }\n\n        // 🧵 Journey Tracking\n        public Guid? SessionId { get; set; }\n        public Guid? ThreadId { get; set; }\n        public Guid? StepId { get; set; } // ✅ Link to CTAFlowStep for CTA Flow tracking\n\n       //  public string? NextStepMatched { get; set; } // Logs which template system resolved\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/ContactJourneyService.cs",
      "sha256": "9a1e3dc83415ab3247dd2ab049a9b332cdad294bfcffabd80ed351ca79d8f815",
      "language": "csharp",
      "size": 16419,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\n\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class ContactJourneyService : IContactJourneyService\n    {\n        private readonly AppDbContext _context;\n\n        public ContactJourneyService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<JourneyResponseDto> GetJourneyEventsAsync(Guid initialCampaignSendLogId, CancellationToken ct = default)\n        {\n            var resp = new JourneyResponseDto { Events = new List<JourneyEventDto>() };\n            var events = resp.Events;\n\n            // 0) Load the selected send (campaign required; contact optional)\n            var sentLog = await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Include(x => x.Campaign)\n                .Include(x => x.Contact)\n                .FirstOrDefaultAsync(x => x.Id == initialCampaignSendLogId, ct);\n\n            if (sentLog is null || sentLog.Campaign is null)\n                return resp;\n\n            var campaignId = sentLog.CampaignId;\n            resp.CampaignId = campaignId;\n            resp.CampaignType = sentLog.CTAFlowConfigId.HasValue ? \"flow\" : \"dynamic_url\";\n            resp.FlowId = sentLog.CTAFlowConfigId;\n\n            if (sentLog.ContactId.HasValue)\n                resp.ContactId = sentLog.ContactId.Value;\n\n            // ---- Resolve a phone for display/flow fallback --------------------------------------------\n            string? phone = sentLog.Contact?.PhoneNumber;\n\n            // via MessageLog\n            if (string.IsNullOrWhiteSpace(phone) && sentLog.MessageLogId.HasValue)\n            {\n                phone = await _context.MessageLogs.AsNoTracking()\n                    .Where(m => m.Id == sentLog.MessageLogId.Value && m.BusinessId == sentLog.BusinessId)\n                    .Select(m => m.RecipientNumber)\n                    .FirstOrDefaultAsync(ct);\n            }\n\n            // via Recipient → Contact or AudienceMember\n            if (string.IsNullOrWhiteSpace(phone) && sentLog.RecipientId != Guid.Empty)\n            {\n                var rec = await _context.CampaignRecipients.AsNoTracking()\n                    .Where(r => r.Id == sentLog.RecipientId)\n                    .Select(r => new { r.ContactId, r.AudienceMemberId })\n                    .FirstOrDefaultAsync(ct);\n\n                if (rec is not null)\n                {\n                    if (rec.ContactId.HasValue)\n                        phone = await _context.Contacts.AsNoTracking()\n                            .Where(c => c.Id == rec.ContactId.Value)\n                            .Select(c => c.PhoneNumber)\n                            .FirstOrDefaultAsync(ct);\n                    else if (rec.AudienceMemberId.HasValue)\n                        phone = await _context.AudienceMembers.AsNoTracking()\n                            .Where(a => a.Id == rec.AudienceMemberId.Value)\n                            .Select(a => a.PhoneE164)\n                            .FirstOrDefaultAsync(ct);\n                }\n            }\n\n            resp.ContactPhone = phone ?? \"\";\n\n            // ---- 1) Session window ---------------------------------------------------------------------\n            var sessionStart = sentLog.SentAt ?? sentLog.CreatedAt;\n            DateTime sessionEnd;\n\n            if (sentLog.ContactId.HasValue)\n            {\n                var contactId = sentLog.ContactId.Value;\n\n                var nextSameCampaignAt = await _context.CampaignSendLogs.AsNoTracking()\n                    .Where(x => x.ContactId == contactId &&\n                                x.CampaignId == campaignId &&\n                                x.CreatedAt > sessionStart)\n                    .OrderBy(x => x.CreatedAt)\n                    .Select(x => (DateTime?)x.CreatedAt)\n                    .FirstOrDefaultAsync(ct);\n\n                DateTime? nextSameFlowAt = null;\n                if (sentLog.CTAFlowConfigId.HasValue)\n                {\n                    var flowId = sentLog.CTAFlowConfigId.Value;\n                    nextSameFlowAt = await _context.CampaignSendLogs.AsNoTracking()\n                        .Where(x => x.ContactId == contactId &&\n                                    x.CTAFlowConfigId == flowId &&\n                                    x.CreatedAt > sessionStart)\n                        .OrderBy(x => x.CreatedAt)\n                        .Select(x => (DateTime?)x.CreatedAt)\n                        .FirstOrDefaultAsync(ct);\n                }\n\n                sessionEnd = new[] { nextSameCampaignAt, nextSameFlowAt }\n                    .Where(dt => dt.HasValue)\n                    .Select(dt => dt!.Value)\n                    .DefaultIfEmpty(sessionStart.AddHours(24))\n                    .Min();\n            }\n            else\n            {\n                // No ContactId: keep it simple and robust\n                sessionEnd = sessionStart.AddHours(24);\n            }\n\n            // ---- 2) Initial \"sent\" + statuses from CSL -------------------------------------------------\n            events.Add(new JourneyEventDto\n            {\n                Timestamp = sessionStart,\n                Source = \"System\",\n                EventType = \"MessageSent\",\n                Title = $\"Campaign '{sentLog.Campaign?.Name ?? \"Campaign\"}' sent\",\n                Details = string.IsNullOrWhiteSpace(resp.ContactPhone) ? null :\n                               $\"Template '{sentLog.TemplateId}' to {resp.ContactPhone}\",\n                TemplateName = sentLog.TemplateId\n            });\n\n            if (sentLog.DeliveredAt is { } d1 && d1 >= sessionStart && d1 < sessionEnd)\n                events.Add(new JourneyEventDto\n                {\n                    Timestamp = d1,\n                    Source = \"Provider\",\n                    EventType = \"Delivered\",\n                    Title = \"Message delivered\",\n                    Details = string.IsNullOrWhiteSpace(resp.ContactPhone) ? null : $\"Delivered to {resp.ContactPhone}\",\n                    TemplateName = sentLog.TemplateId\n                });\n\n            if (sentLog.ReadAt is { } r1 && r1 >= sessionStart && r1 < sessionEnd)\n                events.Add(new JourneyEventDto\n                {\n                    Timestamp = r1,\n                    Source = \"Provider\",\n                    EventType = \"Read\",\n                    Title = \"Message read\",\n                    Details = string.IsNullOrWhiteSpace(resp.ContactPhone) ? null : $\"Read by {resp.ContactPhone}\",\n                    TemplateName = sentLog.TemplateId\n                });\n\n            // ---- 3) URL clicks for THIS send within the window ----------------------------------------\n            var urlClicksInitial = await _context.CampaignClickLogs\n                .AsNoTracking()\n                .Where(c => c.CampaignSendLogId == sentLog.Id &&\n                            c.ClickedAt >= sessionStart && c.ClickedAt < sessionEnd)\n                .OrderBy(c => c.ClickedAt)\n                .ToListAsync(ct);\n\n            foreach (var c in urlClicksInitial)\n            {\n                events.Add(new JourneyEventDto\n                {\n                    Timestamp = c.ClickedAt,\n                    Source = \"User\",\n                    EventType = \"Redirect\",\n                    Title = $\"Clicked URL: '{c.ButtonTitle}'\",\n                    Details = $\"Redirected to {c.Destination}\",\n                    ButtonIndex = c.ButtonIndex,\n                    ButtonTitle = c.ButtonTitle,\n                    Url = c.Destination\n                });\n            }\n\n            // ---- 4) FLOW chain & clicks — robust against EF translation bugs --------------------------\n            var flowEvents = new List<JourneyEventDto>(8);\n            Guid? detectedFlowId = sentLog.CTAFlowConfigId;\n\n            try\n            {\n                // Helper to limit to window and business\n                IQueryable<FlowExecutionLog> Window(IQueryable<FlowExecutionLog> q) =>\n                    q.AsNoTracking()\n                     .Where(f => f.BusinessId == sentLog.BusinessId &&\n                                 f.ExecutedAt >= sessionStart && f.ExecutedAt < sessionEnd);\n\n                // Helper to project only needed columns (keeps SQL simple)\n                IQueryable<FlowExecutionLog> Pick(IQueryable<FlowExecutionLog> q) =>\n                    q.Select(f => new FlowExecutionLog\n                    {\n                        Id = f.Id,\n                        FlowId = f.FlowId,\n                        ExecutedAt = f.ExecutedAt,\n                        CampaignSendLogId = f.CampaignSendLogId,\n                        MessageLogId = f.MessageLogId,\n                        StepId = f.StepId,\n                        StepName = f.StepName,\n                        TemplateName = f.TemplateName,\n                        TriggeredByButton = f.TriggeredByButton,\n                        ButtonIndex = f.ButtonIndex,\n                        BusinessId = f.BusinessId,\n                        ContactPhone = f.ContactPhone,\n                        RunId = f.RunId\n                    });\n\n                // A) Prefer RunId when present\n                var qRun = Window(_context.FlowExecutionLogs);\n                if (sentLog.RunId != null)\n                    qRun = qRun.Where(f => f.RunId == sentLog.RunId);\n\n                // B) Always include direct references to this CSL/MessageLog\n                var qDirect = Window(_context.FlowExecutionLogs)\n                    .Where(f =>\n                        (f.CampaignSendLogId.HasValue && f.CampaignSendLogId.Value == sentLog.Id) ||\n                        (sentLog.MessageLogId.HasValue && f.MessageLogId == sentLog.MessageLogId));\n\n                // C) Fallback: phone forms (+E.164 / digits only)\n                IQueryable<FlowExecutionLog> qPhone = Enumerable.Empty<FlowExecutionLog>().AsQueryable();\n                if (!string.IsNullOrWhiteSpace(phone))\n                {\n                    var digits = new string(phone.Where(char.IsDigit).ToArray());\n                    var alt = phone.StartsWith(\"+\") ? digits : \"+\" + digits;\n                    qPhone = Window(_context.FlowExecutionLogs)\n                        .Where(f => f.ContactPhone == phone ||\n                                    f.ContactPhone == digits ||\n                                    f.ContactPhone == alt);\n                }\n\n                // Materialize each branch separately (avoid EF's problematic GroupBy + Concat translation)\n                var listRun = await Pick(qRun).OrderBy(f => f.ExecutedAt).ToListAsync(ct);\n                var listDirect = await Pick(qDirect).OrderBy(f => f.ExecutedAt).ToListAsync(ct);\n                var listPhone = await Pick(qPhone).OrderBy(f => f.ExecutedAt).ToListAsync(ct);\n\n                // Merge & distinct in-\n                // \n                var felAll = listRun\n                    .Concat(listDirect)\n                    .Concat(listPhone)\n                    .GroupBy(f => f.Id)\n                    .Select(g => g.First())\n                    .OrderBy(f => f.ExecutedAt)\n                    .ToList();\n\n                if (felAll.Count > 0)\n                    detectedFlowId ??= felAll.FirstOrDefault()?.FlowId;\n\n                // If we found any flow events but original send looked Dynamic URL, upgrade the envelope\n                if (felAll.Count > 0 && !sentLog.CTAFlowConfigId.HasValue)\n                {\n                    resp.CampaignType = \"flow\";\n                    resp.FlowId = detectedFlowId;\n                }\n\n                if (resp.FlowId.HasValue && string.IsNullOrWhiteSpace(resp.FlowName))\n                {\n                    resp.FlowName = await _context.CTAFlowConfigs.AsNoTracking()\n                        .Where(f => f.Id == resp.FlowId.Value)\n                        .Select(f => f.FlowName)\n                        .FirstOrDefaultAsync(ct);\n                }\n\n                foreach (var fe in felAll)\n                {\n                    if (!string.IsNullOrWhiteSpace(fe.TriggeredByButton))\n                    {\n                        flowEvents.Add(new JourneyEventDto\n                        {\n                            Timestamp = fe.ExecutedAt,\n                            Source = \"User\",\n                            EventType = \"ButtonClicked\",\n                            Title = $\"Clicked Quick Reply: '{fe.TriggeredByButton}'\",\n                            Details = string.IsNullOrWhiteSpace(fe.TemplateName)\n                                        ? (string.IsNullOrWhiteSpace(fe.StepName) ? null : $\"Advanced in flow at step '{fe.StepName}'\")\n                                        : $\"Triggered next template: '{fe.TemplateName}'\",\n                            StepId = fe.StepId,\n                            StepName = fe.StepName,\n                            ButtonIndex = fe.ButtonIndex,\n                            ButtonTitle = fe.TriggeredByButton,\n                            TemplateName = fe.TemplateName\n                        });\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(fe.TemplateName))\n                    {\n                        flowEvents.Add(new JourneyEventDto\n                        {\n                            Timestamp = fe.ExecutedAt,\n                            Source = \"System\",\n                            EventType = \"FlowSend\",\n                            Title = $\"Flow sent template '{fe.TemplateName}'\",\n                            Details = string.IsNullOrWhiteSpace(fe.StepName) ? null : $\"Step '{fe.StepName}'\",\n                            StepId = fe.StepId,\n                            StepName = fe.StepName,\n                            TemplateName = fe.TemplateName\n                        });\n                    }\n                }\n\n                // Also include URL clicks that happened during the flow window across the chain\n                if (felAll.Count > 0)\n                {\n                    var cslIdsFromFel = felAll\n                        .Where(f => f.CampaignSendLogId.HasValue)\n                        .Select(f => f.CampaignSendLogId!.Value)\n                        .Distinct()\n                        .ToList();\n\n                    if (cslIdsFromFel.Count > 0)\n                    {\n                        var flowClicks = await _context.CampaignClickLogs.AsNoTracking()\n                            .Where(c => c.ClickedAt >= sessionStart &&\n                                        c.ClickedAt < sessionEnd &&\n                                        cslIdsFromFel.Contains(c.CampaignSendLogId))\n                            .OrderBy(c => c.ClickedAt)\n                            .ToListAsync(ct);\n\n                        foreach (var c in flowClicks)\n                        {\n                            flowEvents.Add(new JourneyEventDto\n                            {\n                                Timestamp = c.ClickedAt,\n                                Source = \"User\",\n                                EventType = \"Redirect\",\n                                Title = $\"Clicked URL: '{c.ButtonTitle}'\",\n                                Details = $\"Redirected to {c.Destination}\",\n                                ButtonIndex = c.ButtonIndex,\n                                ButtonTitle = c.ButtonTitle,\n                                Url = c.Destination\n                            });\n                        }\n                    }\n                }\n            }\n            catch (Exception ex) when (ex is InvalidOperationException || ex is KeyNotFoundException)\n            {\n                // Defensive: never bubble the EF translation issue; return what we have.\n                // You can log here if you have a logger: _logger.LogWarning(ex, \"Flow merge failed\");\n            }\n\n            events.AddRange(flowEvents);\n\n            // Left-off marker (last flow action)\n            var lastFlowEvent = flowEvents.OrderBy(e => e.Timestamp).LastOrDefault();\n            resp.LeftOffAt = lastFlowEvent?.StepName ?? lastFlowEvent?.Title;\n\n            // ---- Final ordering ------------------------------------------------------------------------\n            resp.Events = events.OrderBy(e => e.Timestamp).ToList();\n            return resp;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/IContactJourneyService.cs",
      "sha256": "c42d77aa80d0e55d821ab2afa31fdd353c5b3913e217a686b3eb01240d0bbb54",
      "language": "csharp",
      "size": 373,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs; // Updated namespace\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public interface IContactJourneyService\n    {\n        Task<JourneyResponseDto> GetJourneyEventsAsync(Guid initialCampaignSendLogId, CancellationToken ct = default);\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/IJourneyExportService.cs",
      "sha256": "f8442c2d8fbb9a4d40db57b43dd2355025aeee572a6646a5739ecc434411085f",
      "language": "csharp",
      "size": 607,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public interface IJourneyExportService\n    {\n        Task<ExportResult> ExportJourneyCsvAsync(Guid campaignSendLogId, CancellationToken ct = default);\n        Task<ExportResult> ExportJourneyXlsxAsync(Guid campaignSendLogId, CancellationToken ct = default);\n    }\n\n    public sealed class ExportResult\n    {\n        public required byte[] Bytes { get; init; }\n        public required string ContentType { get; init; }\n        public required string FileName { get; init; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/IMessageLogsReportService.cs",
      "sha256": "c9879941a987b70fa6796fad4ee97fce33c7dddc65835b8a5ec3d5115d9598c0",
      "language": "csharp",
      "size": 595,
      "content": "// 📄 Features/Tracking/Services/IMessageLogsReportService.cs\nusing xbytechat.api.Shared; // PaginatedResponse<T>\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public interface IMessageLogsReportService\n    {\n\n        Task<PaginatedResponse<MessageLogListItemDto>> SearchAsync(\n            Guid businessId,\n            MessageLogReportQueryDto q,\n            CancellationToken ct);\n\n        Task<MessageLogFacetsDto> GetFacetsAsync(\n            Guid businessId,\n            DateTime? fromUtc,\n            CancellationToken ct);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/ITrackingService.cs",
      "sha256": "7331e4a2b1fb44932573c4ed055613cc4ae21dcd9ec54bc25210c57cd340737c",
      "language": "csharp",
      "size": 528,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public interface ITrackingService\n    {\n        Task LogCTAClickAsync(TrackingLogDto dto);\n        Task<TrackingLogDetailsDto?> GetLogDetailsAsync(Guid logId);\n        Task<ResponseResult> LogCTAClickWithEnrichmentAsync(TrackingLogDto dto);\n        Task<List<TrackingLog>> GetFlowClickLogsAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/IUrlBuilderService.cs",
      "sha256": "2415363e2bcc41b916d5b2836a0c28ac68dabd407d67b63661da9feb8372bd56",
      "language": "csharp",
      "size": 273,
      "content": "namespace xbytechat.api.Features.Tracking.Services\n{\n    public interface IUrlBuilderService\n    {\n\n         string BuildTrackedButtonUrl(\n        Guid campaignSendLogId,\n        int buttonIndex,\n        string? buttonTitle,\n        string destinationUrlAbsolute);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/JourneyExportService.cs",
      "sha256": "cbdf9d9b8b3d3a1945d8b888c1afea760a932c3d18d28e256cededa9f9853874",
      "language": "csharp",
      "size": 7155,
      "content": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing ClosedXML.Excel;\nusing xbytechat.api.Features.Tracking.Services;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public sealed class JourneyExportService : IJourneyExportService\n    {\n        private readonly IContactJourneyService _journeyService;\n\n        public JourneyExportService(IContactJourneyService journeyService)\n        {\n            _journeyService = journeyService;\n        }\n\n        // ---- formatting helpers ---------------------------------------------------------------\n\n        private static string FormatIso(DateTime dt)\n        {\n            // Normalize to UTC ISO-8601. If Kind is Unspecified, treat as UTC.\n            var utc = dt.Kind == DateTimeKind.Unspecified\n                ? DateTime.SpecifyKind(dt, DateTimeKind.Utc)\n                : dt.ToUniversalTime();\n            return utc.ToString(\"O\");\n        }\n\n        private static string FormatIsoOrEmpty(DateTime dt)\n            => dt == default ? \"\" : FormatIso(dt);\n\n        // CSV escape + guard against Excel formula injection\n        private static string CsvSafe(string? s)\n        {\n            if (string.IsNullOrEmpty(s)) return \"\";\n            s = s.Replace(\"\\\"\", \"\\\"\\\"\"); // escape quotes\n            // Guard against =, +, -, @ at start (Excel formula injection)\n            if (s.Length > 0 && (s[0] == '=' || s[0] == '+' || s[0] == '-' || s[0] == '@'))\n                s = \"'\" + s;\n            var needsQuotes = s.IndexOfAny(new[] { ',', '\"', '\\n', '\\r' }) >= 0;\n            return needsQuotes ? $\"\\\"{s}\\\"\" : s;\n        }\n\n        // Put a clickable link into a cell using the HYPERLINK() formula (works on all ClosedXML versions)\n        private static void SetHyperlinkFormula(IXLCell cell, string? url)\n        {\n            if (string.IsNullOrWhiteSpace(url))\n            {\n                cell.Value = \"\";\n                return;\n            }\n            var safe = url.Replace(\"\\\"\", \"\\\"\\\"\");\n            cell.SetFormulaA1($\"HYPERLINK(\\\"{safe}\\\",\\\"{safe}\\\")\");\n        }\n\n        // ---- CSV ------------------------------------------------------------------------------\n\n        public async Task<ExportResult> ExportJourneyCsvAsync(\n            Guid campaignSendLogId,\n            CancellationToken ct = default)\n        {\n            var dto = await _journeyService.GetJourneyEventsAsync(campaignSendLogId, ct);\n\n            var sb = new StringBuilder(8 * 1024);\n            sb.AppendLine(\"Timestamp,Source,EventType,Title,Details,Url,StepName,ButtonIndex,ButtonTitle,TemplateName,CampaignType,FlowName,FlowId,CampaignId,ContactId,ContactPhone\");\n\n            // ContactId may be non-nullable Guid in your DTO; emit empty when Guid.Empty\n            string contactIdCsv = dto.ContactId == Guid.Empty ? \"\" : dto.ContactId.ToString();\n\n            foreach (var e in dto.Events.OrderBy(x => x.Timestamp))\n            {\n                var line = string.Join(\",\",\n                    CsvSafe(FormatIsoOrEmpty(e.Timestamp)),\n                    CsvSafe(e.Source),\n                    CsvSafe(e.EventType),\n                    CsvSafe(e.Title),\n                    CsvSafe(e.Details),\n                    CsvSafe(e.Url),\n                    CsvSafe(e.StepName),\n                    e.ButtonIndex.HasValue ? e.ButtonIndex.Value.ToString() : \"\",\n                    CsvSafe(e.ButtonTitle),\n                    CsvSafe(e.TemplateName),\n                    CsvSafe(dto.CampaignType),\n                    CsvSafe(dto.FlowName),\n                    dto.FlowId?.ToString() ?? \"\",\n                    dto.CampaignId.ToString(),\n                    contactIdCsv,\n                    CsvSafe(dto.ContactPhone)\n                );\n                sb.AppendLine(line);\n            }\n\n            return new ExportResult\n            {\n                Bytes = Encoding.UTF8.GetBytes(sb.ToString()),\n                ContentType = \"text/csv; charset=utf-8\",\n                FileName = $\"journey-{campaignSendLogId}.csv\"\n            };\n        }\n\n        // ---- XLSX -----------------------------------------------------------------------------\n\n        public async Task<ExportResult> ExportJourneyXlsxAsync(\n            Guid campaignSendLogId,\n            CancellationToken ct = default)\n        {\n            var dto = await _journeyService.GetJourneyEventsAsync(campaignSendLogId, ct);\n\n            using var wb = new XLWorkbook();\n            var ws = wb.Worksheets.Add(\"Journey\");\n\n            var headers = new[]\n            {\n                \"Timestamp\",\"Source\",\"EventType\",\"Title\",\"Details\",\"Url\",\"StepName\",\n                \"ButtonIndex\",\"ButtonTitle\",\"TemplateName\",\"CampaignType\",\"FlowName\",\n                \"FlowId\",\"CampaignId\",\"ContactId\",\"ContactPhone\"\n            };\n\n            // Header row\n            for (int i = 0; i < headers.Length; i++)\n                ws.Cell(1, i + 1).Value = headers[i];\n\n            var headerRange = ws.Range(1, 1, 1, headers.Length);\n            headerRange.Style.Font.Bold = true;\n            headerRange.Style.Fill.BackgroundColor = XLColor.FromHtml(\"#F3F4F6\");\n\n            // Freeze header + auto filter\n            ws.SheetView.FreezeRows(1);\n            ws.Range(1, 1, 1, headers.Length).SetAutoFilter(); // avoid RangeUsed() on empty sheets\n\n            // Data rows\n            int r = 1;\n            foreach (var e in dto.Events.OrderBy(x => x.Timestamp))\n            {\n                r++;\n                int c = 1;\n\n                ws.Cell(r, c++).Value = FormatIsoOrEmpty(e.Timestamp);\n                ws.Cell(r, c++).Value = e.Source ?? \"\";\n                ws.Cell(r, c++).Value = e.EventType ?? \"\";\n                ws.Cell(r, c++).Value = e.Title ?? \"\";\n                ws.Cell(r, c++).Value = e.Details ?? \"\";\n\n                // URL\n                SetHyperlinkFormula(ws.Cell(r, c), e.Url);\n                c++;\n\n                ws.Cell(r, c++).Value = e.StepName ?? \"\";\n                ws.Cell(r, c++).Value = e.ButtonIndex?.ToString() ?? \"\";\n                ws.Cell(r, c++).Value = e.ButtonTitle ?? \"\";\n                ws.Cell(r, c++).Value = e.TemplateName ?? \"\";\n                ws.Cell(r, c++).Value = dto.CampaignType ?? \"\";\n                ws.Cell(r, c++).Value = dto.FlowName ?? \"\";\n                ws.Cell(r, c++).Value = dto.FlowId?.ToString() ?? \"\";\n                ws.Cell(r, c++).Value = dto.CampaignId.ToString();\n                ws.Cell(r, c++).Value = (dto.ContactId == Guid.Empty ? \"\" : dto.ContactId.ToString());\n                ws.Cell(r, c++).Value = dto.ContactPhone ?? \"\";\n            }\n\n            // Column sizing\n            ws.Columns().AdjustToContents();\n            ws.Column(1).Width = Math.Max(ws.Column(1).Width, 28); // timestamp column\n\n            using var ms = new MemoryStream();\n            wb.SaveAs(ms);\n            var bytes = ms.ToArray();\n\n            return new ExportResult\n            {\n                Bytes = bytes,\n                ContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n                FileName = $\"journey-{campaignSendLogId}.xlsx\"\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/MessageLogsReportService.cs",
      "sha256": "7930f91807b3f385e1a82bc870068f9adf888c7749dcde7fd76d581c4808b47e",
      "language": "csharp",
      "size": 10202,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System.Linq.Expressions;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    \n\n    // Strongly-typed intermediate row for EF translation (avoid 'dynamic')\n    internal sealed class MessageLogRow\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }\n\n        public string? RecipientNumber { get; set; }\n        public string? SenderId { get; set; }           // Campaign.PhoneNumberId\n        public string? SourceChannel { get; set; }      // Campaign.Provider OR MessageLog.Provider\n        public string? Status { get; set; }\n\n        public string? MessageContent { get; set; }\n        public string? ProviderMessageId { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n        public DateTime? SentAt { get; set; }\n    }\n\n    public sealed class MessageLogsReportService : IMessageLogsReportService\n    {\n        private readonly AppDbContext _db;\n        public MessageLogsReportService(AppDbContext db) => _db = db;\n\n        public async Task<PaginatedResponse<MessageLogListItemDto>> SearchAsync(\n            Guid businessId, MessageLogReportQueryDto q, CancellationToken ct)\n        {\n            // normalize paging\n            q.Page = Math.Max(1, q.Page);\n            q.PageSize = Math.Clamp(q.PageSize, 1, 200);\n\n            // Base + left join to Campaign to enrich\n            var baseQuery =\n                from m in _db.MessageLogs.AsNoTracking()\n                where m.BusinessId == businessId\n                join c0 in _db.Campaigns.AsNoTracking() on m.CampaignId equals c0.Id into cj\n                from c in cj.DefaultIfEmpty()\n                select new MessageLogRow\n                {\n                    Id = m.Id,\n                    BusinessId = m.BusinessId,\n                    CampaignId = m.CampaignId,\n                    CampaignName = c != null ? c.Name : null,\n                    RecipientNumber = m.RecipientNumber,\n                    SenderId = c != null ? c.PhoneNumberId : null,\n                    SourceChannel = (c != null && c.Provider != null) ? c.Provider : m.Provider,\n                    Status = m.Status,\n                    MessageContent = m.MessageContent,\n                    ProviderMessageId = m.ProviderMessageId ?? m.MessageId,\n                    ErrorMessage = m.ErrorMessage,\n                    CreatedAt = m.CreatedAt,\n                    SentAt = m.SentAt\n                };\n\n            // Time window (prefer SentAt over CreatedAt)\n            if (q.FromUtc.HasValue)\n                baseQuery = baseQuery.Where(x => (x.SentAt ?? x.CreatedAt) >= q.FromUtc.Value);\n            if (q.ToUtc.HasValue)\n                baseQuery = baseQuery.Where(x => (x.SentAt ?? x.CreatedAt) <= q.ToUtc.Value);\n\n            // Optional scope\n            if (q.CampaignId.HasValue)\n                baseQuery = baseQuery.Where(x => x.CampaignId == q.CampaignId.Value);\n\n            // Status filter\n            if (q.Statuses is { Length: > 0 })\n            {\n                var statuses = q.Statuses.Where(s => !string.IsNullOrWhiteSpace(s)).ToArray();\n                if (statuses.Length > 0) baseQuery = baseQuery.Where(x => statuses.Contains(x.Status!));\n            }\n\n            // Channel filter (campaign.Provider preferred, else message.Provider)\n            if (q.Channels is { Length: > 0 })\n            {\n                var chans = q.Channels.Select(s => s.Trim().ToUpperInvariant())\n                                      .Where(s => s.Length > 0).ToArray();\n                if (chans.Length > 0)\n                    baseQuery = baseQuery.Where(x => x.SourceChannel != null &&\n                                                     chans.Contains(x.SourceChannel.ToUpper()));\n            }\n\n            // SenderIds → Campaign.PhoneNumberId\n            if (q.SenderIds is { Length: > 0 })\n            {\n                var senders = q.SenderIds.Select(s => s.Trim())\n                                         .Where(s => s.Length > 0).ToArray();\n                if (senders.Length > 0)\n                    baseQuery = baseQuery.Where(x => x.SenderId != null && senders.Contains(x.SenderId));\n            }\n\n            // Free-text search\n            if (!string.IsNullOrWhiteSpace(q.Search))\n            {\n                var s = q.Search.Trim().ToLower();\n                baseQuery = baseQuery.Where(x =>\n                    (x.RecipientNumber ?? \"\").ToLower().Contains(s) ||\n                    (x.MessageContent ?? \"\").ToLower().Contains(s) ||\n                    (x.ErrorMessage ?? \"\").ToLower().Contains(s) ||\n                    (x.ProviderMessageId ?? \"\").ToLower().Contains(s) ||\n                    (x.CampaignName ?? \"\").ToLower().Contains(s));\n            }\n\n            // ----- Strongly-typed sorting -----\n            var sortBy = (q.SortBy ?? \"SentAt\").Trim();\n            var sortDir = (q.SortDir ?? \"desc\").Trim().ToLower() == \"asc\" ? \"asc\" : \"desc\";\n\n            var sortMap = new Dictionary<string, Expression<Func<MessageLogRow, object>>>(\n                StringComparer.OrdinalIgnoreCase)\n            {\n                [\"Recipient\"] = x => x.RecipientNumber ?? \"\",\n                [\"SenderId\"] = x => x.SenderId ?? \"\",\n                [\"Channel\"] = x => x.SourceChannel ?? \"\",\n                [\"Status\"] = x => x.Status ?? \"\",\n                [\"CampaignName\"] = x => x.CampaignName ?? \"\",\n                [\"CreatedAt\"] = x => x.CreatedAt,\n                [\"SentAt\"] = x => x.SentAt ?? x.CreatedAt\n            };\n\n            if (!sortMap.ContainsKey(sortBy)) sortBy = \"SentAt\";\n            var keySelector = sortMap[sortBy];\n\n            IOrderedQueryable<MessageLogRow> ordered =\n                sortDir == \"asc\" ? baseQuery.OrderBy(keySelector)\n                                 : baseQuery.OrderByDescending(keySelector);\n\n            var total = await ordered.CountAsync(ct);\n\n            var items = await ordered\n                .Skip((q.Page - 1) * q.PageSize)\n                .Take(q.PageSize)\n                .Select(x => new MessageLogListItemDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    CampaignId = x.CampaignId,\n                    CampaignName = x.CampaignName,\n                    RecipientNumber = x.RecipientNumber,\n                    SenderId = x.SenderId,\n                    SourceChannel = x.SourceChannel,\n                    Status = x.Status,\n                    MessageType = null,             // not on MessageLog (can be enriched later)\n                    MessageContent = x.MessageContent,\n                    TemplateName = null,             // not on MessageLog\n                    ProviderMessageId = x.ProviderMessageId,\n                    ErrorMessage = x.ErrorMessage,\n                    CreatedAt = x.CreatedAt,\n                    SentAt = x.SentAt,\n                    DeliveredAt = null,             // not on MessageLog\n                    ReadAt = null              // not on MessageLog\n                })\n                .ToListAsync(ct);\n\n            return new PaginatedResponse<MessageLogListItemDto>\n            {\n                Items = items,\n                TotalCount = total,\n                Page = q.Page,\n                PageSize = q.PageSize\n            };\n        }\n        public async Task<MessageLogFacetsDto> GetFacetsAsync(Guid businessId, DateTime? fromUtc, CancellationToken ct)\n        {\n            // scope last 90 days by default to keep it fast\n            var from = fromUtc ?? DateTime.UtcNow.AddDays(-90);\n\n            // base query limited by business & time\n            var baseQ = _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId &&\n                            (m.SentAt ?? m.CreatedAt) >= from);\n\n            // SenderIds come from Campaign.PhoneNumberId (if available)\n\n            var senderIds = await _db.WhatsAppPhoneNumbers\n            .AsNoTracking()\n            .Where(w => w.BusinessId == businessId && w.WhatsAppBusinessNumber != null)\n            .Select(w => w.WhatsAppBusinessNumber!)\n            .Distinct()\n            .OrderBy(x => x)\n            .ToArrayAsync(ct);\n\n            //var senderIds = await (\n            //    from m in baseQ\n            //    join c0 in _db.Campaigns.AsNoTracking() on m.CampaignId equals c0.Id into cj\n            //    from c in cj.DefaultIfEmpty()\n            //    where c != null && c.PhoneNumberId != null\n            //    select c.PhoneNumberId!\n            //)\n            //.Distinct()\n            //.OrderBy(x => x)\n            //.ToArrayAsync(ct);\n\n            // Channels = provider (prefer campaign.provider, else message.provider)\n            var channels = await (\n                from m in baseQ\n                join c0 in _db.Campaigns.AsNoTracking() on m.CampaignId equals c0.Id into cj\n                from c in cj.DefaultIfEmpty()\n                let prov = (c != null && c.Provider != null) ? c.Provider : m.Provider\n                where prov != null\n                select prov!\n            )\n            .Distinct()\n            .OrderBy(x => x)\n            .ToArrayAsync(ct);\n\n            // Statuses\n            var statuses = await baseQ\n                .Where(m => m.Status != null)\n                .Select(m => m.Status!)\n                .Distinct()\n                .OrderBy(x => x)\n                .ToArrayAsync(ct);\n\n            // WABA Ids = WhatsAppBusinessNumber for this business\n            var wabaIds = await _db.WhatsAppSettings\n                .AsNoTracking()\n                .Where(w => w.BusinessId == businessId && w.WabaId != null)\n                .Select(w => w.WabaId!)\n                .Distinct()\n                .OrderBy(x => x)\n                .ToArrayAsync(ct);\n\n            return new MessageLogFacetsDto\n            {\n                WabaIds = wabaIds,\n                SenderIds = senderIds,\n                Channels = channels,\n                Statuses = statuses\n            };\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/TrackingService.cs",
      "sha256": "2f6be7f1c507fdbd555ddaecbdaaff9ff432d48f1e3e3d30c3869fba4a3ae812",
      "language": "csharp",
      "size": 9151,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Shared.TrackingUtils;\nusing Serilog;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing AutoMapper;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class TrackingService : ITrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMapper _mapper;\n        public TrackingService(AppDbContext context, IMapper mapper)\n        {\n            _context = context;\n            _mapper = mapper;\n        }\n\n\n        public async Task<ResponseResult> LogCTAClickWithEnrichmentAsync(TrackingLogDto dto)\n        {\n            try\n            {\n                // 🧠 1. Try enrich from MessageLog (if msg ID provided)\n                if (!string.IsNullOrEmpty(dto.MessageId))\n                {\n                    var messageLog = await _context.MessageLogs\n                        .FirstOrDefaultAsync(m => m.MessageId == dto.MessageId || m.Id.ToString() == dto.MessageId);\n\n                    if (messageLog != null)\n                    {\n                        dto.BusinessId = dto.BusinessId == Guid.Empty ? messageLog.BusinessId : dto.BusinessId;\n                        dto.ContactId ??= messageLog.ContactId;\n                        dto.CampaignId ??= messageLog.CampaignId;\n                        dto.MessageLogId ??= messageLog.Id;\n                    }\n                }\n\n                // 🧩 2. Enrich from CampaignSendLog if sourceType = campaign\n                CampaignSendLog? sendLog = null;\n\n                if (dto.SourceType == \"campaign\")\n                {\n                    if (!string.IsNullOrEmpty(dto.MessageId))\n                    {\n                        sendLog = await _context.CampaignSendLogs\n                            .Include(c => c.Recipient)\n                            .FirstOrDefaultAsync(c => c.MessageId == dto.MessageId);\n                    }\n\n                    if (sendLog == null && dto.CampaignId != null)\n                    {\n                        sendLog = await _context.CampaignSendLogs\n                            .Include(c => c.Recipient)\n                            .Where(c => c.CampaignId == dto.CampaignId)\n                            .OrderByDescending(c => c.CreatedAt)\n                            .FirstOrDefaultAsync();\n                    }\n\n                    if (sendLog != null)\n                    {\n                        dto.BusinessId = dto.BusinessId == Guid.Empty\n                            ? sendLog.Recipient?.BusinessId ?? Guid.Empty\n                            : dto.BusinessId;\n\n                        dto.ContactId ??= sendLog.ContactId;\n                        dto.CampaignId ??= sendLog.CampaignId;\n                        dto.CampaignSendLogId ??= sendLog.Id;\n\n                        // ✅ Update campaign send log click details\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = dto.ClickedAt ?? DateTime.UtcNow;\n                        sendLog.ClickType = dto.ButtonText;\n\n                        await _context.SaveChangesAsync();\n                    }\n                }\n\n                // ✅ 3. Validate business context\n                if (dto.BusinessId == Guid.Empty)\n                {\n                    Log.Warning(\"❌ TrackingLog failed: No BusinessId available for click.\");\n                    return ResponseResult.ErrorInfo(\"Business context is missing.\");\n                }\n\n                // 💾 4. Save tracking log (inline instead of separate method)\n                var trackingLog = new TrackingLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    ContactPhone = dto.ContactPhone,\n                    SourceType = dto.SourceType,\n                    SourceId = dto.SourceId,\n                    ButtonText = dto.ButtonText,\n                    CTAType = dto.CTAType,\n                    MessageId = dto.MessageId,\n                    TemplateId = dto.TemplateId,\n                    MessageLogId = dto.MessageLogId,\n                    ClickedVia = dto.ClickedVia ?? \"web\",\n                    Referrer = dto.Referrer,\n                    ClickedAt = dto.ClickedAt ?? DateTime.UtcNow,\n                    IPAddress = dto.IPAddress,\n                    DeviceType = dto.DeviceType,\n                    Browser = dto.Browser,\n                    Country = dto.Country,\n                    City = dto.City,\n                    FollowUpSent = false,\n                    LastInteractionType = \"Clicked\",\n                    SessionId = Guid.TryParse(dto.SessionId, out var sid) ? sid : (Guid?)null,\n                    ThreadId = Guid.TryParse(dto.ThreadId, out var tid) ? tid : (Guid?)null,\n                    CampaignId = dto.CampaignId,\n                    CampaignSendLogId = dto.CampaignSendLogId\n                };\n\n                await _context.TrackingLogs.AddAsync(trackingLog);\n                await _context.SaveChangesAsync();\n\n                // ✅ Return the TrackingLog.Id in the response\n                return ResponseResult.SuccessInfo(\"CTA click tracked successfully.\", trackingLog.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"❌ Exception during CTA tracking enrichment\");\n                return ResponseResult.ErrorInfo(\"Exception during tracking: \" + ex.Message);\n            }\n        }\n\n        public async Task LogCTAClickAsync(TrackingLogDto dto)\n        {\n            try\n            {\n                var log = new TrackingLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    ContactPhone = dto.ContactPhone,\n                    SourceType = dto.SourceType,\n                    SourceId = dto.SourceId,\n                    ButtonText = dto.ButtonText,\n                    CTAType = dto.CTAType,\n                    MessageId = dto.MessageId,\n                    TemplateId = dto.TemplateId,\n                    MessageLogId = dto.MessageLogId,\n                    ClickedVia = dto.ClickedVia ?? \"web\",\n                    Referrer = dto.Referrer,\n                    ClickedAt = dto.ClickedAt ?? DateTime.UtcNow,\n                    IPAddress = dto.IPAddress,\n                    DeviceType = dto.DeviceType,\n                    Browser = dto.Browser,\n                    Country = dto.Country,\n                    City = dto.City,\n                    FollowUpSent = false,\n                    LastInteractionType = \"Clicked\",\n                    SessionId = Guid.TryParse(dto.SessionId, out var sid) ? sid : (Guid?)null,\n                    ThreadId = Guid.TryParse(dto.ThreadId, out var tid) ? tid : (Guid?)null,\n                    CampaignId = dto.CampaignId,\n                    CampaignSendLogId = dto.CampaignSendLogId\n                };\n\n                await _context.TrackingLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"❌ Failed to log CTA click\");\n            }\n        }\n        public async Task<TrackingLogDetailsDto?> GetLogDetailsAsync(Guid logId)\n        {\n            var tracking = await _context.TrackingLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (tracking == null)\n                return null;\n\n            var contact = tracking.ContactId != null\n                ? await _context.Contacts.AsNoTracking().FirstOrDefaultAsync(c => c.Id == tracking.ContactId)\n                : null;\n\n            var campaign = tracking.CampaignId != null\n                ? await _context.Campaigns.AsNoTracking().FirstOrDefaultAsync(c => c.Id == tracking.CampaignId)\n                : null;\n\n            var messageLog = tracking.MessageLogId != null\n                ? await _context.MessageLogs.AsNoTracking().FirstOrDefaultAsync(m => m.Id == tracking.MessageLogId)\n                : null;\n\n            return new TrackingLogDetailsDto\n            {\n                Tracking = _mapper.Map<TrackingLogDto>(tracking),\n                Contact = contact != null ? _mapper.Map<ContactDto>(contact) : null,\n                Campaign = campaign != null ? _mapper.Map<CampaignDto>(campaign) : null,\n                MessageLog = messageLog != null ? _mapper.Map<MessageLogDto>(messageLog) : null\n            };\n        }\n        public async Task<List<TrackingLog>> GetFlowClickLogsAsync(Guid businessId)\n        {\n            return await _context.TrackingLogs\n                .Where(x => x.BusinessId == businessId && x.SourceType == \"cta-flow\")\n                .OrderByDescending(x => x.ClickedAt)\n                .ToListAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/TrackingToken.cs",
      "sha256": "b5250fc25e3e0ca598d78eba428d651a345550debbc5696ceb32b55ce684019e",
      "language": "csharp",
      "size": 809,
      "content": "using System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public static class TrackingToken\n    {\n        public static string Create(object payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var bytes = System.Text.Encoding.UTF8.GetBytes(json);\n            return WebEncoders.Base64UrlEncode(bytes);\n        }\n\n        public static T Decode<T>(string token)\n        {\n            var bytes = WebEncoders.Base64UrlDecode(token);\n            var json = System.Text.Encoding.UTF8.GetString(bytes);\n            return JsonSerializer.Deserialize<T>(json)!;\n        }\n    }\n\n    // What we put inside the token:\n    public record ClickToken(Guid cid, int btnIndex, string btnTitle, string to, string phone);\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/UrlBuilderService.cs",
      "sha256": "8f3156fd79a3ab196299a3f0ebb88e74ebe340db9a0d13bd47189ecc5996109d",
      "language": "csharp",
      "size": 4999,
      "content": "// Features/Tracking/Services/UrlBuilderService.cs\nusing System;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class UrlBuilderService : IUrlBuilderService\n    {\n        private readonly IClickTokenService _token;\n        private readonly TrackingOptions _opt;\n\n        // Allowed schemes for destination links\n        private static readonly string[] AllowedSchemes = new[] { \"http\", \"https\", \"tel\", \"wa\", \"whatsapp\" };\n\n        public UrlBuilderService(IClickTokenService token, IOptions<TrackingOptions> opt)\n        {\n            _token = token;\n            _opt = opt.Value;\n        }\n\n        /// <summary>\n        /// Normalizes destination and enforces an allowlist of schemes:\n        /// http, https, tel, wa, whatsapp.\n        /// Also supports shorthand WhatsApp hosts: wa.me/... and api.whatsapp.com/...\n        /// </summary>\n        private static string NormalizeAbsoluteUrlOrThrow(string input)\n        {\n            if (input is null) throw new ArgumentException(\"Destination URL is null.\", nameof(input));\n\n            // Trim and remove any non-printable/control whitespace characters\n            var s = input.Trim();\n            s = new string(Array.FindAll(s.ToCharArray(), c => !char.IsControl(c)));\n\n            if (s.Length == 0)\n                throw new ArgumentException(\"Destination URL is empty after trimming.\", nameof(input));\n\n            // Short-circuit for already tracked links, just in case this ever gets called that way\n            if (s.Contains(\"/r/\", StringComparison.Ordinal))\n                return s;\n\n            // Support common WhatsApp shorthands without scheme\n            // e.g. \"wa.me/9170...\" or \"api.whatsapp.com/send?phone=...\"\n            if (!s.Contains(\"://\", StringComparison.Ordinal))\n            {\n                if (s.StartsWith(\"wa.me/\", StringComparison.OrdinalIgnoreCase) ||\n                    s.StartsWith(\"api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var guessWa = \"https://\" + s;\n                    if (Uri.TryCreate(guessWa, UriKind.Absolute, out var waAbs))\n                        return waAbs.AbsoluteUri;\n                }\n            }\n\n            // Accept absolute URIs with allowed schemes\n            if (Uri.TryCreate(s, UriKind.Absolute, out var abs))\n            {\n                var scheme = abs.Scheme ?? string.Empty;\n\n                // Allow only whitelisted schemes\n                var isAllowed = false;\n                for (int i = 0; i < AllowedSchemes.Length; i++)\n                {\n                    if (scheme.Equals(AllowedSchemes[i], StringComparison.OrdinalIgnoreCase))\n                    {\n                        isAllowed = true;\n                        break;\n                    }\n                }\n\n                if (!isAllowed)\n                    throw new ArgumentException(\n                        $\"Destination must use one of: http, https, tel, wa, whatsapp. Got '{scheme}:'\",\n                        nameof(input));\n\n                // http/https → return canonical AbsoluteUri\n                if (scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    return abs.AbsoluteUri;\n                }\n\n                // tel:/wa:/whatsapp://send → return as provided (trimmed), do not modify\n                return s;\n            }\n\n            // Human input like \"www.example.com/...\" or \"example.com/...\"\n            if (!s.Contains(\"://\", StringComparison.Ordinal) && s.Contains('.', StringComparison.Ordinal))\n            {\n                var guess = \"https://\" + s;\n                if (Uri.TryCreate(guess, UriKind.Absolute, out var httpAbs))\n                    return httpAbs.AbsoluteUri;\n            }\n\n            throw new ArgumentException(\n                $\"Destination must be an absolute URL or allowed deep link (http, https, tel, wa, whatsapp). Got: '{input}'\",\n                nameof(input));\n        }\n\n        public string BuildTrackedButtonUrl(\n            Guid campaignSendLogId,\n            int buttonIndex,\n            string? buttonTitle,\n            string destinationUrlAbsolute)\n        {\n            var dest = NormalizeAbsoluteUrlOrThrow(destinationUrlAbsolute);\n\n            var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n            var exp = now + (long)_opt.TokenTtl.TotalSeconds;\n\n            var payload = new ClickTokenPayload(\n                cid: campaignSendLogId,\n                bi: buttonIndex,\n                bt: buttonTitle ?? string.Empty,\n                to: dest,\n                iat: now,\n                exp: exp\n            );\n\n            var token = _token.Create(payload);\n            return $\"{_opt.BaseUrl.TrimEnd('/')}/r/{token}\";\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/WhatsAppTemplatesSyncBridge.cs",
      "sha256": "b6fb93f1c6cfe820b7384292a5e61dc29f4447a071ca704c4c7fbfa8bba2a748",
      "language": "csharp",
      "size": 1041,
      "content": "using xbytechat.api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.TemplateModule.Services\n{\n    public interface IWhatsAppTemplatesSyncBridge\n    {\n        Task<bool> SyncAfterActivationAsync(Guid businessId, CancellationToken ct = default);\n    }\n\n    public sealed class WhatsAppTemplatesSyncBridge : IWhatsAppTemplatesSyncBridge\n    {\n        private readonly ITemplateSyncService _sync;\n\n        public WhatsAppTemplatesSyncBridge(ITemplateSyncService sync)\n        {\n            _sync = sync;\n        }\n\n        public async Task<bool> SyncAfterActivationAsync(Guid businessId, CancellationToken ct = default)\n        {\n            // Force = true (ignore TTL); onlyUpsert = true (don’t deactivate others)\n            var result = await _sync.SyncBusinessTemplatesAsync(\n                businessId,\n                force: true,\n                onlyUpsert: true,\n                ct);\n\n            // Consider any change or a successful “no-op” a success here\n            return result is not null;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookAutoCleanupWorker.cs",
      "sha256": "5149c73a4fbcb11d9e501321407b1c7ae7ee660b8f7d612eca136b528f0467f2",
      "language": "csharp",
      "size": 1212,
      "content": "using xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.BackgroundWorkers\n{\n    public class WebhookAutoCleanupWorker : BackgroundService\n    {\n        private readonly ILogger<WebhookAutoCleanupWorker> _logger;\n        private readonly IServiceProvider _services;\n\n        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)\n        {\n            _services = services;\n            _logger = logger;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                using var scope = _services.CreateScope();\n                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();\n\n                if (await maintenanceService.IsAutoCleanupEnabledAsync())\n                {\n                    var count = await maintenanceService.RunCleanupAsync();\n                    _logger.LogInformation($\"🧹 Auto-cleaned {count} old webhook logs.\");\n                }\n\n                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookQueueWorker.cs",
      "sha256": "6c5ccb3f7da951f63b0828ac144f12392faabc37def6561ecfcad5a7aa253edc",
      "language": "csharp",
      "size": 3263,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\npublic class WebhookQueueWorker : BackgroundService\n{\n    private readonly IWebhookQueueService _queueService;\n    private readonly IServiceScopeFactory _scopeFactory;\n    private readonly ILogger<WebhookQueueWorker> _logger;\n\n    public WebhookQueueWorker(\n        IWebhookQueueService queueService,\n        IServiceScopeFactory scopeFactory,\n        ILogger<WebhookQueueWorker> logger)\n    {\n        _queueService = queueService;\n        _scopeFactory = scopeFactory;\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        _logger.LogInformation(\"🚀 Webhook Queue Worker started.\");\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                // Dequeue and clone once at the edge\n                var payload = await _queueService.DequeueAsync(stoppingToken);\n                var cloned = payload.Clone(); // keep independent of pooled reader\n                var rawJson = cloned.GetRawText(); // 👈 capture raw JSON up-front\n\n                using var scope = _scopeFactory.CreateScope();\n\n                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();\n                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                try\n                {\n                    await dispatcher.DispatchAsync(cloned);\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"❌ Error while dispatching webhook payload.\");\n                    // Persist the full raw JSON so we can replay/debug later\n                    var fallback = new FailedWebhookLogDto\n                    {\n                        SourceModule = \"WebhookQueueWorker\",\n                        FailureType = \"DispatchError\",\n                        ErrorMessage = ex.Message,\n                        RawJson = string.IsNullOrWhiteSpace(rawJson) ? \"{}\" : rawJson,\n                        CreatedAt = DateTime.UtcNow\n                    };\n                    try\n                    {\n                        await failureLogger.LogFailureAsync(fallback);\n                    }\n                    catch (Exception innerEx)\n                    {\n                        _logger.LogError(innerEx, \"⚠️ Failed to write to FailedWebhookLogs.\");\n                    }\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogInformation(\"🛑 Graceful shutdown requested.\");\n                break;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Queue loop error (will retry shortly).\");\n                try { await Task.Delay(TimeSpan.FromSeconds(2), stoppingToken); } catch { /* ignore */ }\n            }\n        }\n\n        _logger.LogInformation(\"🛑 Webhook Queue Worker stopped.\");\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/FailedWebhookLogsController.cs",
      "sha256": "f16ada5c238d2293688a73b0c4428da7f91567d1ca100da1809f0b95ea65c2fc",
      "language": "csharp",
      "size": 1018,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/failed-webhooks\")]\n    public class FailedWebhookLogsController : ControllerBase\n    {\n        private readonly IFailedWebhookLogService _service;\n\n        public FailedWebhookLogsController(IFailedWebhookLogService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllAsync()\n        {\n            var logs = await _service.GetAllAsync();\n            return Ok(logs);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var log = await _service.GetByIdAsync(id);\n            if (log == null)\n                return NotFound();\n\n            return Ok(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/MaintenanceController.cs",
      "sha256": "2936737cca434f20b27184b1885f94a5a90a6a94453b29dc0a597b264cc6325d",
      "language": "csharp",
      "size": 3242,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks\")]\n    public class MaintenanceController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n        private readonly IMaintenanceService _maintenance;\n\n        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)\n        {\n            _context = context;\n            _maintenance = maintenance;\n        }\n\n        // ✅ Injected Test Log for Dev Testing\n        [HttpPost(\"inject-test-log\")]\n        public async Task<IActionResult> InjectTestLog()\n        {\n            var testLog = new FailedWebhookLog\n            {\n                SourceModule = \"WebhookQueueWorker\",\n                FailureType = \"DispatchError\",\n                ErrorMessage = \"🧪 Simulated webhook dispatch failure for testing.\",\n                RawJson = \"{\\\"sample\\\":\\\"test_payload\\\",\\\"reason\\\":\\\"unit_test\\\"}\",\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.FailedWebhookLogs.Add(testLog);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = \"✅ Injected test log successfully.\" });\n        }\n\n        // ✅ Manual Cleanup Trigger\n        [HttpPost(\"cleanup-now\")]\n        public async Task<IActionResult> CleanupNow()\n        {\n            var cutoff = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(x => x.CreatedAt < cutoff)\n                .ToListAsync();\n\n            if (!oldLogs.Any())\n                return Ok(new { message = \"✅ No logs to delete.\" });\n\n            _context.FailedWebhookLogs.RemoveRange(oldLogs);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = $\"✅ Deleted {oldLogs.Count} old logs.\" });\n        }\n\n        // ✅ Count of all failed logs\n        [HttpGet(\"failed/count\")]\n        public async Task<IActionResult> GetFailedCount()\n        {\n            var count = await _context.FailedWebhookLogs.CountAsync();\n            return Ok(count);\n        }\n\n        // ✅ Cleanup Setting Status\n             [HttpGet(\"settings\")]\n        public async Task<IActionResult> GetCleanupStatus()\n        {\n            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();\n            var lastRun = await _maintenance.GetLastCleanupTimeAsync();\n\n            return Ok(new\n            {\n                enabled,\n                lastCleanupAt = lastRun\n            });\n        }\n\n        // ✅ Enable Auto Cleanup\n        [HttpPost(\"enable-cleanup\")]\n        public async Task<IActionResult> EnableCleanup()\n        {\n            await _maintenance.EnableAutoCleanupAsync();\n            return Ok(new { message = \"✅ Auto-cleanup enabled.\" });\n        }\n\n        // ✅ Disable Auto Cleanup\n        [HttpPost(\"disable-cleanup\")]\n        public async Task<IActionResult> DisableCleanup()\n        {\n            await _maintenance.DisableAutoCleanupAsync();\n            return Ok(new { message = \"✅ Auto-cleanup disabled.\" });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookCallback.cs",
      "sha256": "0353a97ed4f6c1349262de94a5e68f37d87955d3b6735e595aedc13f2b2f7365",
      "language": "csharp",
      "size": 2481,
      "content": "// 📄 File: Features/Webhooks/Controllers/WebhookCallbackController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhookcallback\")]\n    public class WebhookCallbackController : ControllerBase\n    {\n        private readonly ILogger<WebhookCallbackController> _logger;\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookCallbackController(\n            ILogger<WebhookCallbackController> logger,\n            IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _queue = queue;\n        }\n\n        // ✅ Single POST endpoint: Pinnacle (and others) send responses here\n        [HttpPost]\n        [Consumes(\"application/json\")]\n        [Produces(\"application/json\")]\n        public IActionResult Post([FromBody] JsonElement payload, CancellationToken ct)\n        {\n            if (!Request.HasJsonContentType())\n            {\n                return BadRequest(new { error = \"Content-Type must be application/json\" });\n            }\n\n            try\n            {\n                var raw = payload.GetRawText();\n                _logger.LogInformation(\"📥 Webhook received. bytes={Len}\", raw.Length);\n\n                // Clone JsonElement before queueing\n                _queue.Enqueue(payload.Clone());\n\n                // Return 200 OK so Pinnacle won’t retry unnecessarily\n                return Ok(new { received = true });\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogWarning(\"⚠️ Webhook processing cancelled by client.\");\n                return StatusCode(499);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to enqueue webhook payload.\");\n                // 500 lets BSP retry later\n                return StatusCode(500, new { error = \"webhook_enqueue_failed\" });\n            }\n        }\n    }\n\n    // Small helper for JSON content-type\n    internal static class HttpRequestContentTypeExtensions\n    {\n        public static bool HasJsonContentType(this HttpRequest request)\n        {\n            if (request?.ContentType is null) return false;\n            return request.ContentType.StartsWith(\"application/json\", StringComparison.OrdinalIgnoreCase);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookTestController.cs",
      "sha256": "d3d3ac0e403d42baaa151d62e86135b71a0116ed7231d86c04b87bbd4ae6ac61",
      "language": "csharp",
      "size": 1569,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/test\")]\n    public class WebhookTestController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookTestController(IWebhookQueueService queue)\n        {\n            _queue = queue;\n        }\n\n        [HttpPost(\"simulate-failure\")]\n        public IActionResult SimulateWebhookFailure()\n        {\n            var fakePayload = new\n            {\n                entry = new[]\n                {\n                    new\n                    {\n                        changes = new[]\n                        {\n                            new\n                            {\n                                value = new\n                                {\n                                    // This will cause dispatcher to throw due to invalid structure\n                                    unexpected = \"🧪 Simulated bad structure\"\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n\n            var json = JsonSerializer.Serialize(fakePayload);\n            var element = JsonDocument.Parse(json).RootElement;\n\n            _queue.Enqueue(element);\n\n            return Ok(new\n            {\n                message = \"✅ Test payload enqueued to simulate failure.\",\n                enqueued = true\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WhatsAppWebhookController.cs",
      "sha256": "6a489fa99a12af0a31187296c8092809b55d45ab785448366a202341263b705f",
      "language": "csharp",
      "size": 5165,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp\")]\n    public class WhatsAppWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppWebhookController> _logger;\n        private readonly IConfiguration _config;\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IWebhookQueueService _queue;\n\n        public WhatsAppWebhookController(\n            ILogger<WhatsAppWebhookController> logger,\n            IConfiguration config,\n            AppDbContext context,\n            IWhatsAppWebhookService webhookService,\n            IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _config = config;\n            _context = context;\n            _webhookService = webhookService;\n            _queue = queue;\n        }\n\n        // ✅ Step 1: Meta verification endpoint (GET)\n        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge\n        [HttpGet]\n        public IActionResult VerifyWebhook(\n            [FromQuery(Name = \"hub.mode\")] string mode,\n            [FromQuery(Name = \"hub.verify_token\")] string token,\n            [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            _logger.LogInformation(\n                \"🔎 WhatsApp webhook verification request received. mode={Mode}, tokenLength={TokenLength}\",\n                mode,\n                string.IsNullOrEmpty(token) ? 0 : token.Length);\n\n            // 🔐 Load your secret token from config or environment.\n            // Support multiple keys for safety/backward-compat:\n            //  - WhatsApp:MetaVerifyToken  (matches your appsettings)\n            //  - WhatsApp:MetaToken        (older name)\n            //  - WhatsApp:VerifyWebHookToken (what this code was using)\n            var expectedToken = _config[\"WhatsApp:VerifyWebHookToken\"];\n\n            if (string.IsNullOrWhiteSpace(expectedToken))\n            {\n                _logger.LogError(\n                    \"❌ WhatsApp webhook verification failed: no verify token configured. \" +\n                    \"Set WhatsApp:MetaVerifyToken (or WhatsApp:MetaToken / WhatsApp:VerifyWebHookToken) in configuration.\");\n                return Forbid(\"Server verify token not configured.\");\n            }\n\n            if (mode == \"subscribe\" && token == expectedToken)\n            {\n                _logger.LogInformation(\"✅ WhatsApp webhook verified successfully.\");\n                return Ok(challenge); // Meta expects a 200 OK with the challenge value\n            }\n\n            _logger.LogWarning(\n                \"❌ WhatsApp webhook verification failed. Mode={Mode}, token did not match configured value.\",\n                mode);\n            return Forbid(\"Token mismatch.\");\n        }\n\n        //[HttpPost]\n        //public IActionResult HandleStatus([FromBody] JsonElement payload)\n        //{\n        //    try\n        //    {\n        //        // Log that we actually got a POST. This is what we care about for inbound messages.\n        //        var bodyString = payload.ToString();\n        //        _logger.LogInformation(\n        //            \"📥 WhatsApp webhook POST received at controller. Payload length={Length} chars.\",\n        //            bodyString?.Length ?? 0);\n\n        //        // Important: clone before enqueue\n        //        var cloned = payload.Clone();\n        //        _queue.Enqueue(cloned);\n\n        //        _logger.LogInformation(\"📥 Webhook payload enqueued successfully.\");\n        //        return Ok(new { received = true });\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"❌ Failed to enqueue WhatsApp webhook payload.\");\n        //        return StatusCode(500, new { error = \"Webhook queue failed\" });\n        //    }\n        //}\n\n        [HttpPost]\n        public IActionResult HandleStatus([FromBody] JsonElement payload)\n        {\n            try\n            {\n                var bodyString = payload.ToString();\n\n                _logger.LogInformation(\n                    \"📥 WhatsApp webhook POST received. Path={Path}, Query={Query}, Length={Length} chars.\",\n                    HttpContext.Request.Path,\n                    HttpContext.Request.QueryString.ToString(),\n                    bodyString?.Length ?? 0\n                );\n\n                var cloned = payload.Clone();\n                _queue.Enqueue(cloned);\n\n                _logger.LogInformation(\"📥 Webhook payload enqueued successfully.\");\n                return Ok(new { received = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to enqueue WhatsApp webhook payload.\");\n                return StatusCode(500, new { error = \"Webhook queue failed\" });\n            }\n        }\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/IProviderDirectory.cs",
      "sha256": "9c5e07f8d7488efd67624a5d0b04fe85acf0163688ba6a704f500383e17210d4",
      "language": "csharp",
      "size": 995,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// Resolves BusinessId from provider-specific webhook identifiers.\n    /// </summary>\n    public interface IProviderDirectory\n    {\n        /// <param name=\"provider\">\"meta\" or \"pinnacle\" (lowercase preferred)</param>\n        /// <param name=\"phoneNumberId\">Meta/Pinnacle phone_number_id (strongest key)</param>\n        /// <param name=\"displayPhoneNumber\">Formatted sending number (e.g. \"+91XXXXXXXXXX\")</param>\n        /// <param name=\"wabaId\">WhatsApp Business Account ID (Meta)</param>\n        /// <param name=\"waId\">Optional WA ID (recipient); used only as a last-ditch heuristic</param>\n        Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/ProviderDirectory.cs",
      "sha256": "1cecb32490d67fedaecdd7772fac54b530f8ac1d2225f7889c32c43c5584df2b",
      "language": "csharp",
      "size": 6767,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// EF-backed resolver for mapping provider identifiers to BusinessId, with a short cache.\n    /// </summary>\n    public class ProviderDirectory : IProviderDirectory\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ProviderDirectory> _logger;\n        private readonly IMemoryCache _cache;\n\n        // reduce DB hits during webhook bursts\n        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(2);\n\n        public ProviderDirectory(AppDbContext db, ILogger<ProviderDirectory> logger, IMemoryCache cache)\n        {\n            _db = db;\n            _logger = logger;\n            _cache = cache;\n        }\n        private static string NormalizeProviderKey(string? raw)\n        {\n            var p = (raw ?? \"\").Trim().ToLowerInvariant();\n            return p switch\n            {\n                \"meta\" or \"meta-cloud\" or \"meta_cloud\" => \"meta_cloud\",\n                \"pinnacle\" => \"pinnacle\",\n                _ => p\n            };\n        }\n        public async Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default)\n        {\n            provider = NormalizeProviderKey(provider);\n            if (provider is \"meta\" or \"meta-cloud\") provider = \"meta_cloud\";\n            var cacheKey = $\"provdir:{provider}:{phoneNumberId}:{Normalize(displayPhoneNumber)}:{wabaId}\";\n            if (_cache.TryGetValue<Guid?>(cacheKey, out var cached))\n                return cached;\n\n            try\n            {\n                // ⚓ 1) Strongest match: provider + phone_number_id\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var hit = await QueryByAsync(provider, phoneNumberId: phoneNumberId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ⚓ 2) Next: provider + display_phone_number (normalized)\n                var normalizedDisplay = Normalize(displayPhoneNumber);\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(normalizedDisplay))\n                {\n                    var hit = await QueryByAsync(provider, displayPhoneNumber: normalizedDisplay, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ⚓ 3) Next: provider + wabaId (Meta)\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(wabaId))\n                {\n                    var hit = await QueryByAsync(provider, wabaId: wabaId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                _logger.LogWarning(\n                    \"ProviderDirectory: No match for provider={Provider}, pnid={PhoneId}, disp={Display}, waba={Waba}\",\n                    provider, phoneNumberId, normalizedDisplay, wabaId\n                );\n                return CacheAndReturn(cacheKey, null);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ProviderDirectory lookup failed.\");\n                return null;\n            }\n        }\n\n        private Guid? CacheAndReturn(string key, Guid? value)\n        {\n            _cache.Set(key, value, CacheTtl);\n            return value;\n        }\n\n        /// <summary>\n        /// Centralized query; now materializes candidates so Normalize() runs in-memory.\n        /// </summary>\n        private async Task<Guid?> QueryByAsync(\n         string provider,\n         string? phoneNumberId = null,\n         string? displayPhoneNumber = null,\n         string? wabaId = null,\n         CancellationToken ct = default)\n        {\n            // Canonical provider (we always store in DB as CAPS)\n            provider = (provider ?? string.Empty)\n                .Trim()\n                .Replace(\"-\", \"_\")\n                .Replace(\" \", \"_\")\n                .ToUpperInvariant();\n\n            if (provider is not (\"PINNACLE\" or \"META_CLOUD\"))\n                return null;\n\n            var normDisp = Normalize(displayPhoneNumber); // your existing normalization (digits-only etc.)\n\n            // 1) Prefer exact match by sender (PhoneNumberId or display number) from WhatsAppPhoneNumbers\n            if (!string.IsNullOrWhiteSpace(phoneNumberId) || !string.IsNullOrWhiteSpace(normDisp))\n            {\n                var byNumber = await _db.WhatsAppPhoneNumbers\n                    .AsNoTracking()\n                    .Where(n => n.Provider == provider)\n                    .Where(n =>\n                        (!string.IsNullOrWhiteSpace(phoneNumberId) && n.PhoneNumberId == phoneNumberId) ||\n                        (!string.IsNullOrWhiteSpace(normDisp) && Normalize(n.WhatsAppBusinessNumber) == normDisp))\n                    .OrderByDescending(n => n.IsDefault)\n                    .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                    .Select(n => (Guid?)n.BusinessId)\n                    .FirstOrDefaultAsync(ct);\n\n                if (byNumber.HasValue)\n                    return byNumber;\n            }\n\n            // 2) Fallback: match by WABA on the settings row (still lives on settings)\n            if (!string.IsNullOrWhiteSpace(wabaId))\n            {\n                var byWaba = await _db.WhatsAppSettings\n                    .AsNoTracking()\n                    .Where(s => s.IsActive\n                                && s.Provider.ToUpper() == provider\n                                && s.WabaId == wabaId)\n                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                    .Select(s => (Guid?)s.BusinessId)\n                    .FirstOrDefaultAsync(ct);\n\n                if (byWaba.HasValue)\n                    return byWaba;\n            }\n\n            return null;\n        }\n\n        /// <summary>\n        /// Normalize phone formatting for robust comparisons.\n        /// </summary>\n        private static string? Normalize(string? phone)\n        {\n            if (string.IsNullOrWhiteSpace(phone)) return null;\n            var trimmed = phone.Trim();\n            var hasPlus = trimmed.StartsWith(\"+\");\n            var digits = new string(trimmed.Where(char.IsDigit).ToArray());\n            return hasPlus ? \"+\" + digits : digits;\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/DTOs/FailedWebhookLogDto.cs",
      "sha256": "6b14d817a983f7eb6626a70cc5aceedd50b164ce0e0282dcf155a1d6eb4b5a51",
      "language": "csharp",
      "size": 391,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.DTOs\n{\n    public class FailedWebhookLogDto\n    {\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; }\n        public string? FailureType { get; set; }\n        public string RawJson { get; set; } = string.Empty;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/MakeDump.bat",
      "sha256": "1f0c8a79e7859146dab81f8a13dcdf495c12b54b888024e8500fefb4abd58a9e",
      "language": "bat",
      "size": 1618,
      "content": "@echo off\nREM This script will find relevant source files and output their names and contents into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh and write a small header\n> \"%outputFile%\" (\n    echo Folder and File Content Report\n    echo Root folder: %cd%\n    echo Generated at: %date% %time%\n)\necho. >> \"%outputFile%\"\n\nREM NOTE:\nREM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)\nREM This keeps the file smaller and much easier to review.\n\nREM Loop through all relevant files in the current directory and subdirectories\nREM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML\nfor /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (\n\n    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)\n    echo \"%%F\" | findstr /I /C:\"\\node_modules\\\" /C:\"\\bin\\\" /C:\"\\obj\\\" /C:\"\\.git\\\" /C:\"\\dist\\\" /C:\"\\.vs\\\" >nul\n    if errorlevel 1 (\n        echo ====================================================== >> \"%outputFile%\"\n        echo FILE: %%F >> \"%outputFile%\"\n        echo ====================================================== >> \"%outputFile%\"\n        echo. >> \"%outputFile%\"\n        type \"%%F\" >> \"%outputFile%\" 2>nul\n        echo. >> \"%outputFile%\"\n        echo. >> \"%outputFile%\"\n    )\n)\n\necho Finished! All content has been extracted to %outputFile%\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/FailedWebhookLog.cs",
      "sha256": "549e466af9a80b67809dd9e25d2bf5b9b5991ce11754225bda46dac4df1e6da6",
      "language": "csharp",
      "size": 624,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.Models\n{\n    public class FailedWebhookLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // 🧠 Debug Metadata\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor\n        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED\n\n        // 📦 Raw Data Snapshot\n        public string RawJson { get; set; } = string.Empty;\n\n        // 🕒 Timeline\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/WebhookSettings.cs",
      "sha256": "c0eeeaa5e14f839b159f28d337450f595c7604994690c66fa7df82a56c6a3093",
      "language": "csharp",
      "size": 267,
      "content": "namespace xbytechat.api.Features.Webhooks.Models\n{\n    public class WebhookSettings\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public bool AutoCleanupEnabled { get; set; } = true;\n        public DateTime? LastCleanupAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Controllers/PinnacleWebhookController.cs",
      "sha256": "347412f9e7ce91e2e2852339fcb267da0f2153f38df4bfe8902a1f0b4a678ca8",
      "language": "csharp",
      "size": 1235,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Controllers\n{\n    [ApiController]\n    [Route(\"api/pinnacle/callback\")]\n    public sealed class PinnacleWebhookController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n        private readonly IPinnacleToMetaAdapter _adapter;\n        private readonly ILogger<PinnacleWebhookController> _logger;\n\n        public PinnacleWebhookController(IWebhookQueueService queue, IPinnacleToMetaAdapter adapter, ILogger<PinnacleWebhookController> logger)\n        {\n            _queue = queue;\n            _adapter = adapter;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        public IActionResult Post([FromBody] JsonElement body)\n        {\n            // Transform to the envelope WhatsAppWebhookDispatcher already expects\n            var metaEnvelope = _adapter.ToMetaEnvelope(body);\n            _queue.Enqueue(metaEnvelope);\n            _logger.LogInformation(\"📨 Pinnacle payload transformed and enqueued.\");\n            return Ok(new { received = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/IPinnacleToMetaAdapter.cs",
      "sha256": "7daf100e2d244ce83b0c3f91f8e006bce5359eddf8fe6f7cf2b046f9e071c17b",
      "language": "csharp",
      "size": 364,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters\n{\n    public interface IPinnacleToMetaAdapter\n    {\n        /// <summary>Converts provider-native payload to Meta-like envelope:\n        /// { \"entry\":[{ \"changes\":[{ \"value\": { ... } }]}] }</summary>\n        JsonElement ToMetaEnvelope(JsonElement pinnPayload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/PinnacleToMetaAdapter.cs",
      "sha256": "38b4863c5f4881b2196ae42ce86a47b8d92904a61daad400ab8d1e7e5db2d289",
      "language": "csharp",
      "size": 9751,
      "content": "using System.Buffers;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\n\npublic sealed class PinnacleToMetaAdapter : IPinnacleToMetaAdapter\n{\n    public JsonElement ToMetaEnvelope(JsonElement p)\n    {\n        var buf = new ArrayBufferWriter<byte>();\n        using var w = new Utf8JsonWriter(buf);\n\n        w.WriteStartObject();\n        w.WritePropertyName(\"entry\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // entry[0]\n        w.WritePropertyName(\"changes\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // changes[0]\n        w.WritePropertyName(\"value\");\n        w.WriteStartObject();\n\n        // NEW: try to emit metadata up-front (harmless if not found)\n        WriteMetadata(p, w);\n\n        if (!TryMapStatuses(p, w) && !TryMapMessages(p, w))\n        {\n            w.WritePropertyName(\"provider_raw\");\n            p.WriteTo(w);\n        }\n\n        w.WriteEndObject(); // value\n        w.WriteEndObject(); // change\n        w.WriteEndArray();  // changes\n        w.WriteEndObject(); // entry[0]\n        w.WriteEndArray();  // entry\n        w.WriteEndObject(); // root\n        w.Flush();\n\n        var ros = new ReadOnlySequence<byte>(buf.WrittenMemory);\n        using var doc = JsonDocument.Parse(ros);\n        return doc.RootElement.Clone();\n    }\n\n    // ---- NEW ----\n    // Best-effort extraction; tolerate any Pinnacle layout you have.\n    // We only write fields if we can resolve them.\n    private static void WriteMetadata(JsonElement p, Utf8JsonWriter w)\n    {\n        string? displayPhone = null;\n        string? phoneNumberId = null;\n        string? wabaId = null;\n\n        // common guesses; add/rename to match your Pinnacle payload\n        // 1) flat\n        if (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) displayPhone = d1.GetString();\n        if (p.TryGetProperty(\"phone_number_id\", out var pid1) && pid1.ValueKind == JsonValueKind.String) phoneNumberId = pid1.GetString();\n        if (p.TryGetProperty(\"waba_id\", out var wa1) && wa1.ValueKind == JsonValueKind.String) wabaId = wa1.GetString();\n\n        // 2) channel\n        if (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && ch.TryGetProperty(\"display_phone_number\", out var d2) && d2.ValueKind == JsonValueKind.String) displayPhone = d2.GetString();\n            if (displayPhone is null && ch.TryGetProperty(\"phone\", out var d3) && d3.ValueKind == JsonValueKind.String) displayPhone = d3.GetString();\n\n            if (phoneNumberId is null && ch.TryGetProperty(\"phone_number_id\", out var pid2) && pid2.ValueKind == JsonValueKind.String) phoneNumberId = pid2.GetString();\n            if (phoneNumberId is null && ch.TryGetProperty(\"id\", out var pid3) && pid3.ValueKind == JsonValueKind.String) phoneNumberId = pid3.GetString();\n\n            if (wabaId is null && ch.TryGetProperty(\"waba_id\", out var wa2) && wa2.ValueKind == JsonValueKind.String) wabaId = wa2.GetString();\n        }\n\n        // 3) meta-style wrapper\n        if (p.TryGetProperty(\"metadata\", out var meta) && meta.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && meta.TryGetProperty(\"display_phone_number\", out var d4) && d4.ValueKind == JsonValueKind.String) displayPhone = d4.GetString();\n            if (phoneNumberId is null && meta.TryGetProperty(\"phone_number_id\", out var pid4) && pid4.ValueKind == JsonValueKind.String) phoneNumberId = pid4.GetString();\n            if (wabaId is null && meta.TryGetProperty(\"waba_id\", out var wa3) && wa3.ValueKind == JsonValueKind.String) wabaId = wa3.GetString();\n        }\n\n        if (displayPhone is null && p.TryGetProperty(\"business\", out var biz) && biz.ValueKind == JsonValueKind.Object)\n        {\n            if (biz.TryGetProperty(\"phone\", out var d5) && d5.ValueKind == JsonValueKind.String) displayPhone = d5.GetString();\n            if (biz.TryGetProperty(\"phone_id\", out var pid5) && pid5.ValueKind == JsonValueKind.String) phoneNumberId = pid5.GetString();\n        }\n\n        // Only emit if we have at least one of them.\n        if (displayPhone is not null || phoneNumberId is not null || wabaId is not null)\n        {\n            w.WritePropertyName(\"metadata\");\n            w.WriteStartObject();\n            if (displayPhone is not null) w.WriteString(\"display_phone_number\", displayPhone);\n            if (phoneNumberId is not null) w.WriteString(\"phone_number_id\", phoneNumberId);\n            if (wabaId is not null) w.WriteString(\"waba_id\", wabaId);\n            w.WriteEndObject();\n        }\n    }\n    // ---- NEW END ----\n\n    private static bool TryMapStatuses(JsonElement p, Utf8JsonWriter w)\n    {\n        string? id = null, status = null;\n        long? ts = null;\n\n        if (p.TryGetProperty(\"messageId\", out var mid) && mid.ValueKind == JsonValueKind.String) id = mid.GetString();\n        if (p.TryGetProperty(\"id\", out var pid) && pid.ValueKind == JsonValueKind.String) id ??= pid.GetString();\n        if (p.TryGetProperty(\"status\", out var st) && st.ValueKind == JsonValueKind.String) status = st.GetString();\n\n        if (p.TryGetProperty(\"timestamp\", out var t))\n        {\n            if (t.ValueKind == JsonValueKind.Number) ts = t.GetInt64();\n            else if (t.ValueKind == JsonValueKind.String && long.TryParse(t.GetString(), out var n)) ts = n;\n        }\n\n        if (p.TryGetProperty(\"data\", out var d) && d.ValueKind == JsonValueKind.Object)\n        {\n            if (id is null && d.TryGetProperty(\"id\", out var did) && did.ValueKind == JsonValueKind.String) id = did.GetString();\n            if (status is null && d.TryGetProperty(\"status\", out var ds) && ds.ValueKind == JsonValueKind.String) status = ds.GetString();\n            if (ts is null && d.TryGetProperty(\"ts\", out var dts) && dts.ValueKind == JsonValueKind.Number) ts = dts.GetInt64();\n        }\n\n        if (id is null || status is null) return false;\n\n        w.WritePropertyName(\"statuses\");\n        w.WriteStartArray();\n        w.WriteStartObject();\n        w.WriteString(\"id\", id);\n        w.WriteString(\"status\", status);\n        if (ts.HasValue) w.WriteNumber(\"timestamp\", ts.Value);\n        w.WriteEndObject();\n        w.WriteEndArray();\n        return true;\n    }\n\n    \n    private static bool TryMapMessages(JsonElement p, Utf8JsonWriter w)\n    {\n        // { \"click\": { \"title\":\"Flow Test\", \"contextId\":\"wamid..\", \"from\":\"<biz_phone?>\" , \"user\":\"<customer_wa_id?>\" } }\n        if (p.TryGetProperty(\"click\", out var c) && c.ValueKind == JsonValueKind.Object)\n        {\n            var title = c.TryGetProperty(\"title\", out var t) ? t.GetString() : null;\n            var ctxId = c.TryGetProperty(\"contextId\", out var ctx) ? ctx.GetString() : null;\n\n            // customer who clicked\n            var customerFrom = c.TryGetProperty(\"user\", out var u) && u.ValueKind == JsonValueKind.String\n                ? u.GetString()\n                : (c.TryGetProperty(\"from\", out var f1) && f1.ValueKind == JsonValueKind.String ? f1.GetString() : null);\n\n            // **business** number that sent the message (Meta provides this as context.from)\n            var businessFrom =\n                (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) ? d1.GetString() :\n                (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object &&\n                 ch.TryGetProperty(\"phone\", out var d2) && d2.ValueKind == JsonValueKind.String) ? d2.GetString() :\n                (c.TryGetProperty(\"from\", out var f2) && f2.ValueKind == JsonValueKind.String ? f2.GetString() : null); // last resort\n\n            if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(ctxId))\n            {\n                w.WritePropertyName(\"messages\");\n                w.WriteStartArray();\n                w.WriteStartObject();\n                w.WriteString(\"type\", \"button\");\n                w.WriteString(\"from\", customerFrom ?? \"\");          // customer wa_id\n                w.WritePropertyName(\"button\");\n                w.WriteStartObject();\n                w.WriteString(\"text\", title!);\n                w.WriteEndObject();\n                w.WritePropertyName(\"context\");\n                w.WriteStartObject();\n                w.WriteString(\"id\", ctxId!);\n                if (!string.IsNullOrWhiteSpace(businessFrom))\n                    w.WriteString(\"from\", businessFrom!);           // **important for directory resolution**\n                w.WriteEndObject();\n                w.WriteEndObject();\n                w.WriteEndArray();\n                return true;\n            }\n        }\n\n        // { \"message\": { \"from\":\"<customer_wa_id>\", \"body\":\"hi\", \"type\":\"text\" }, \"channel\":{ \"phone\":\"<biz_phone>\" } }\n        if (p.TryGetProperty(\"message\", out var m) && m.ValueKind == JsonValueKind.Object)\n        {\n            var type = m.TryGetProperty(\"type\", out var tp) ? tp.GetString() : \"text\";\n            var from = m.TryGetProperty(\"from\", out var fr) ? fr.GetString() : \"\";\n\n            w.WritePropertyName(\"messages\");\n            w.WriteStartArray();\n            w.WriteStartObject();\n            w.WriteString(\"type\", type ?? \"text\");\n            w.WriteString(\"from\", from ?? \"\");\n            if ((type ?? \"text\") == \"text\")\n            {\n                var body = m.TryGetProperty(\"body\", out var bd) ? bd.GetString() : \"\";\n                w.WritePropertyName(\"text\");\n                w.WriteStartObject();\n                w.WriteString(\"body\", body ?? \"\");\n                w.WriteEndObject();\n            }\n            w.WriteEndObject();\n            w.WriteEndArray();\n            return true;\n        }\n\n        return false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogCleanupService.cs",
      "sha256": "c826dbce9f60dfadb71a401a0ce48f0f5e9039181f5a18b115be558e0be38b9e",
      "language": "csharp",
      "size": 3798,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    /// <summary>\n    /// Periodic cleanup of old failed webhook logs.\n    /// Runs as a background service and exits cleanly on shutdown.\n    /// </summary>\n    public sealed class FailedWebhookLogCleanupService : BackgroundService\n    {\n        private readonly ILogger<FailedWebhookLogCleanupService> _logger;\n        private readonly IServiceScopeFactory _scopeFactory;\n        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run\n\n        public FailedWebhookLogCleanupService(\n            ILogger<FailedWebhookLogCleanupService> logger,\n            IServiceScopeFactory scopeFactory)\n        {\n            _logger = logger;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _logger.LogInformation(\"🧹 FailedWebhookLogCleanupService started.\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    // If shutdown requested, bail out before touching DI / DbContext\n                    stoppingToken.ThrowIfCancellationRequested();\n\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var cutoff = DateTime.UtcNow.AddDays(-7);\n\n                    var oldLogs = await db.FailedWebhookLogs\n                        .Where(x => x.CreatedAt < cutoff)\n                        .ToListAsync(stoppingToken);\n\n                    if (oldLogs.Count > 0)\n                    {\n                        db.FailedWebhookLogs.RemoveRange(oldLogs);\n                        await db.SaveChangesAsync(stoppingToken);\n                        _logger.LogInformation(\n                            \"🧹 Deleted {Count} old failed webhook logs.\",\n                            oldLogs.Count\n                        );\n                    }\n                }\n                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)\n                {\n                    // Normal shutdown – just break the loop\n                    _logger.LogDebug(\n                        \"FailedWebhookLogCleanupService cancellation requested, exiting loop.\"\n                    );\n                    break;\n                }\n                catch (ObjectDisposedException) when (stoppingToken.IsCancellationRequested)\n                {\n                    // DI container / DbContext got disposed during shutdown; safe to ignore\n                    _logger.LogDebug(\n                        \"AppDbContext/ServiceProvider disposed during shutdown in FailedWebhookLogCleanupService.\"\n                    );\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"❌ Failed to clean up old webhook logs.\");\n                }\n\n                try\n                {\n                    await Task.Delay(_interval, stoppingToken);\n                }\n                catch (OperationCanceledException) when (stoppingToken.IsCancellationRequested)\n                {\n                    _logger.LogDebug(\n                        \"FailedWebhookLogCleanupService delay cancelled, exiting loop.\"\n                    );\n                    break;\n                }\n            }\n\n            _logger.LogInformation(\"🛑 FailedWebhookLogCleanupService stopped.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogService.cs",
      "sha256": "3da6a5ad043773f7684b6ea9bc208441cbc36a7e53f01eacdd7c17848118c2af",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogService : IFailedWebhookLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<FailedWebhookLogService> _logger;\n\n        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogFailureAsync(FailedWebhookLogDto dto)\n        {\n            try\n            {\n                var log = new FailedWebhookLog\n                {\n                    ErrorMessage = dto.ErrorMessage,\n                    SourceModule = dto.SourceModule,\n                    FailureType = dto.FailureType,\n                    RawJson = dto.RawJson,\n                    CreatedAt = dto.CreatedAt\n                };\n\n                await _context.FailedWebhookLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to persist webhook error log\");\n            }\n        }\n\n        public async Task<List<FailedWebhookLog>> GetAllAsync()\n        {\n            return await _context.FailedWebhookLogs\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100) // prevent DB overload\n                .ToListAsync();\n        }\n\n        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)\n        {\n            return await _context.FailedWebhookLogs.FindAsync(id);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IFailedWebhookLogService.cs",
      "sha256": "9366c7a087317049e7dee346a65f7ea81a76fe95fb98fe21ca457e0ed5db6a7c",
      "language": "csharp",
      "size": 396,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IFailedWebhookLogService\n    {\n        Task LogFailureAsync(FailedWebhookLogDto dto);\n        Task<List<FailedWebhookLog>> GetAllAsync();\n        Task<FailedWebhookLog?> GetByIdAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IMaintenanceService.cs",
      "sha256": "76ef1df941e3536bbdce5e7213554b593e6431592ba6527334cf274c78357e26",
      "language": "csharp",
      "size": 323,
      "content": "namespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IMaintenanceService\n    {\n        Task<bool> IsAutoCleanupEnabledAsync();\n        Task EnableAutoCleanupAsync();\n        Task DisableAutoCleanupAsync();\n        Task<DateTime?> GetLastCleanupTimeAsync();\n        Task<int> RunCleanupAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWebhookQueueService.cs",
      "sha256": "34e2e37f5ba5da57159852cecd9adde2f085640e1eb55a67116b5381ffa2e4b0",
      "language": "csharp",
      "size": 333,
      "content": "using System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWebhookQueueService\n    {\n        void Enqueue(JsonElement payload);\n        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);\n        int GetQueueLength();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookDispatcher.cs",
      "sha256": "844865d879bca5e59aa9d82cf7fabfb3ac241233391ca0544922a8902eed4a88",
      "language": "csharp",
      "size": 219,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookDispatcher\n    {\n        Task DispatchAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookService.cs",
      "sha256": "98275195ef353afc44e2ca27e1d7568450de21c0389a303b863809eee790fa99",
      "language": "csharp",
      "size": 302,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookService\n    {\n        Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default);\n   \n    \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/MaintenanceService.cs",
      "sha256": "c8c7e803e34fb97d2edfbaaf824d332f8de8b1483327e364e63d68dd0082a20e",
      "language": "csharp",
      "size": 2411,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class MaintenanceService : IMaintenanceService\n    {\n        private readonly AppDbContext _context;\n\n        public MaintenanceService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> IsAutoCleanupEnabledAsync()\n        {\n            var setting = await _context.WebhookSettings\n                .AsNoTracking()\n                .FirstOrDefaultAsync();\n\n            return setting?.AutoCleanupEnabled ?? false;\n        }\n\n        public async Task<DateTime?> GetLastCleanupTimeAsync()\n        {\n            return await _context.WebhookSettings\n                .AsNoTracking()\n                .Select(s => s.LastCleanupAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task EnableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = true;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task DisableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = false;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<int> RunCleanupAsync()\n        {\n            var threshold = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(l => l.CreatedAt < threshold)\n                .ToListAsync();\n\n            if (oldLogs.Any())\n                _context.FailedWebhookLogs.RemoveRange(oldLogs);\n\n            var setting = await GetOrCreateAsync();\n            setting.LastCleanupAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return oldLogs.Count;\n        }\n\n        private async Task<WebhookSettings> GetOrCreateAsync()\n        {\n            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();\n            if (setting == null)\n            {\n                setting = new WebhookSettings\n                {\n                    AutoCleanupEnabled = false,\n                    LastCleanupAt = null\n                };\n                _context.WebhookSettings.Add(setting);\n                await _context.SaveChangesAsync();\n            }\n            return setting;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ClickWebhookProcessor.cs",
      "sha256": "d671d0c6e0db79b3904b2158458240996c68de79a8be159c0788011d48b1ddf3",
      "language": "csharp",
      "size": 76214,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO.Pipelines;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.CustomeApi.Models;\nusing xbytechat.api.Features.CustomeApi.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared.TrackingUtils;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class ClickWebhookProcessor : IClickWebhookProcessor\n    {\n        private readonly ILogger<ClickWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly ITrackingService _trackingService;\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ICTAFlowService _flowService;\n        private readonly IFlowRuntimeService _flowRuntime;\n        private readonly IContactProfileService _contactProfile;\n        private readonly ICtaJourneyPublisher _journeyPublisher;\n        public ClickWebhookProcessor(\n            ILogger<ClickWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            ITrackingService trackingService,\n            AppDbContext context,\n            IMessageEngineService messageEngine,\n            ICTAFlowService flowService,\n                        IFlowRuntimeService flowRuntime,\n                         IContactProfileService contactProfile,\n                          ICtaJourneyPublisher journeyPublisher\n            )\n        {\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _trackingService = trackingService;\n            _context = context;\n            _messageEngine = messageEngine;\n            _flowService = flowService;\n            _flowRuntime = flowRuntime;\n            _contactProfile = contactProfile;\n            _journeyPublisher = journeyPublisher;\n\n        }\n\n        // working code\n\n        //public async Task ProcessClickAsync(JsonElement value)\n        //{\n        //    _logger.LogWarning(\"📥 [ENTERED CLICK PROCESSOR]\");\n\n        //    try\n        //    {\n        //        if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n        //            return;\n\n        //        static string Norm(string? s)\n        //        {\n        //            if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n        //            return string.Join(' ', s.Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries))\n        //                         .Trim()\n        //                         .ToLowerInvariant();\n        //        }\n\n        //        // ✅ Canonical phone: keep only digits (matches how we store & search contacts)\n        //        static string NormalizePhone(string? raw)\n        //            => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());\n\n        //        // ✅ contacts[0].profile.name (Meta shape)\n        //        static string? TryGetProfileName(JsonElement root)\n        //        {\n        //            if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n        //                contactsEl.ValueKind == JsonValueKind.Array &&\n        //                contactsEl.GetArrayLength() > 0)\n        //            {\n        //                var c0 = contactsEl[0];\n        //                if (c0.TryGetProperty(\"profile\", out var profEl) &&\n        //                    profEl.ValueKind == JsonValueKind.Object &&\n        //                    profEl.TryGetProperty(\"name\", out var nameEl) &&\n        //                    nameEl.ValueKind == JsonValueKind.String)\n        //                {\n        //                    var n = nameEl.GetString();\n        //                    return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n        //                }\n        //            }\n        //            return null;\n        //        }\n\n        //        // >>> BEGIN MOD: helpers for CTAJourney key + botId extraction\n        //        static string ToKey(string? s)\n        //        {\n        //            if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n        //            var t = s.Trim().ToLowerInvariant();\n        //            var sb = new System.Text.StringBuilder(t.Length);\n        //            foreach (var ch in t)\n        //            {\n        //                if (char.IsLetterOrDigit(ch)) sb.Append(ch);\n        //                else if (char.IsWhiteSpace(ch) || ch == '-' || ch == '_' || ch == '.') sb.Append('_');\n        //            }\n        //            var k = sb.ToString().Trim('_');\n        //            return string.IsNullOrEmpty(k) ? \"unknown\" : k;\n        //        }\n\n        //        // read WA display number once (used as botId)\n        //        string botIdFromWebhook = \"\";\n        //        if (value.TryGetProperty(\"metadata\", out var md) &&\n        //            md.TryGetProperty(\"display_phone_number\", out var dpnEl) &&\n        //            dpnEl.ValueKind == JsonValueKind.String)\n        //        {\n        //            botIdFromWebhook = NormalizePhone(dpnEl.GetString());\n        //        }\n        //        // >>> END MOD\n\n        //        foreach (var msg in messages.EnumerateArray())\n        //        {\n        //            if (!msg.TryGetProperty(\"type\", out var typeProp))\n        //                continue;\n\n        //            var type = typeProp.GetString();\n\n        //            string? clickMessageId = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n        //            string? originalMessageId = msg.TryGetProperty(\"context\", out var ctx) && ctx.TryGetProperty(\"id\", out var ctxId)\n        //                ? ctxId.GetString()\n        //                : null;\n        //            var fromRaw = msg.TryGetProperty(\"from\", out var fromProp) ? (fromProp.GetString() ?? \"\") : \"\";\n        //            var fromDigits = NormalizePhone(fromRaw);\n\n        //            // ——— button label extraction\n        //            string? buttonText = null;\n        //            if (string.Equals(type, \"button\", StringComparison.OrdinalIgnoreCase))\n        //            {\n        //                buttonText = msg.TryGetProperty(\"button\", out var btn) &&\n        //                             btn.TryGetProperty(\"text\", out var textProp)\n        //                               ? textProp.GetString()?.Trim()\n        //                               : null;\n        //            }\n        //            else if (string.Equals(type, \"interactive\", StringComparison.OrdinalIgnoreCase) &&\n        //                     msg.TryGetProperty(\"interactive\", out var interactive))\n        //            {\n        //                if (interactive.TryGetProperty(\"type\", out var intrType) &&\n        //                    string.Equals(intrType.GetString(), \"button_reply\", StringComparison.OrdinalIgnoreCase) &&\n        //                    interactive.TryGetProperty(\"button_reply\", out var br) &&\n        //                    br.TryGetProperty(\"title\", out var titleProp))\n        //                {\n        //                    buttonText = titleProp.GetString()?.Trim();\n        //                }\n        //                else if (interactive.TryGetProperty(\"list_reply\", out var lr) &&\n        //                         lr.TryGetProperty(\"title\", out var listTitleProp))\n        //                {\n        //                    buttonText = listTitleProp.GetString()?.Trim();\n        //                }\n        //            }\n\n        //            if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))\n        //            {\n        //                _logger.LogDebug(\"ℹ️ Not a recognized click or missing context.id. type={Type}\", type);\n        //                continue;\n        //            }\n\n        //            _logger.LogInformation(\"🖱️ Button Click → From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n        //                fromDigits, clickMessageId, originalMessageId, buttonText);\n\n        //            // —— Try 1: originating MessageLog (for flow-sent messages)\n        //            var origin = await _context.MessageLogs\n        //                .AsNoTracking()\n        //                .FirstOrDefaultAsync(m =>\n        //                    m.MessageId == originalMessageId &&\n        //                    m.CTAFlowConfigId != null &&\n        //                    m.CTAFlowStepId != null);\n\n        //            Guid businessId;\n        //            Guid flowId;\n        //            Guid stepId;\n        //            string? bundleJson = null;\n        //            int? flowVersion = null;\n\n        //            Guid? campaignSendLogId = null; // link the click to the shown message\n        //            Guid? runId = null;             // copy from parent CSL when available\n\n        //            if (origin != null)\n        //            {\n        //                businessId = origin.BusinessId;\n        //                flowId = origin.CTAFlowConfigId!.Value;\n        //                stepId = origin.CTAFlowStepId!.Value;\n        //                bundleJson = origin.ButtonBundleJson;\n        //                flowVersion = origin.FlowVersion;\n\n        //                // Map back to CSL via MessageLogId or WAMID and fetch RunId\n        //                var cslInfo = await _context.CampaignSendLogs\n        //                    .AsNoTracking()\n        //                    .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))\n        //                    .OrderByDescending(csl => csl.CreatedAt)\n        //                    .Select(csl => new { csl.Id, csl.RunId })\n        //                    .FirstOrDefaultAsync();\n\n        //                campaignSendLogId = cslInfo?.Id;\n        //                runId = cslInfo?.RunId;\n        //            }\n        //            else\n        //            {\n        //                // —— Try 2: first campaign message (CampaignSendLogs)\n        //                var sendLog = await _context.CampaignSendLogs\n        //                    .Include(sl => sl.Campaign)\n        //                    .AsNoTracking()\n        //                    .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);\n\n        //                if (sendLog == null)\n        //                {\n        //                    _logger.LogWarning(\"❌ No MessageLog or CampaignSendLog for original WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                businessId = sendLog.BusinessId != Guid.Empty\n        //                    ? sendLog.BusinessId\n        //                    : (sendLog.Campaign?.BusinessId ?? Guid.Empty);\n\n        //                if (businessId == Guid.Empty)\n        //                {\n        //                    _logger.LogWarning(\"❌ Could not resolve BusinessId for WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                campaignSendLogId = sendLog.Id;\n        //                runId = sendLog.RunId;\n\n        //                if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)\n        //                {\n        //                    flowId = sendLog.CTAFlowConfigId.Value;\n        //                    stepId = sendLog.CTAFlowStepId.Value;\n        //                }\n        //                else if (sendLog.Campaign?.CTAFlowConfigId != null)\n        //                {\n        //                    flowId = sendLog.Campaign.CTAFlowConfigId.Value;\n\n        //                    var entry = await _context.CTAFlowSteps\n        //                        .Where(s => s.CTAFlowConfigId == flowId)\n        //                        .OrderBy(s => s.StepOrder)\n        //                        .Select(s => s.Id)\n        //                        .FirstOrDefaultAsync();\n\n        //                    if (entry == Guid.Empty)\n        //                    {\n        //                        _logger.LogWarning(\"❌ No entry step found for flow {Flow}\", flowId);\n        //                        continue;\n        //                    }\n\n        //                    stepId = entry;\n        //                }\n        //                else\n        //                {\n        //                    _logger.LogWarning(\"❌ No flow context on CampaignSendLog for WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                bundleJson = sendLog.ButtonBundleJson;\n        //            }\n\n        //            // ─────────────────────────────────────────────────────────────\n        //            // ✅ UPSERT PROFILE NAME (create-or-update) *before* next step\n        //            //    and make sure we look up by digits-only phone.\n        //            // ─────────────────────────────────────────────────────────────\n        //            try\n        //            {\n        //                var profileName = TryGetProfileName(value);\n        //                if (!string.IsNullOrWhiteSpace(profileName))\n        //                {\n        //                    var now = DateTime.UtcNow;\n        //                    var contact = await _context.Contacts\n        //                        .FirstOrDefaultAsync(c => c.BusinessId == businessId &&\n        //                                                  (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));\n\n        //                    if (contact == null)\n        //                    {\n        //                        profileName = profileName ?? \"User\";\n        //                        contact = new Contact\n        //                        {\n        //                            Id = Guid.NewGuid(),\n        //                            BusinessId = businessId,\n        //                            PhoneNumber = fromDigits, // store canonical\n        //                            Name = profileName,\n        //                            ProfileName = profileName,\n        //                            ProfileNameUpdatedAt = now,\n        //                            CreatedAt = now,\n        //                        };\n        //                        _context.Contacts.Add(contact);\n        //                        await _context.SaveChangesAsync();\n        //                        _logger.LogInformation(\"👤 Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})\",\n        //                            profileName, fromDigits, businessId);\n        //                    }\n        //                    else\n        //                    {\n        //                        var changed = false;\n\n        //                        if (!string.Equals(contact.ProfileName, profileName, StringComparison.Ordinal))\n        //                        {\n        //                            contact.ProfileName = profileName;\n        //                            contact.ProfileNameUpdatedAt = now;\n        //                            changed = true;\n        //                        }\n\n        //                        if (string.IsNullOrWhiteSpace(contact.Name) ||\n        //                            contact.Name == \"WhatsApp User\" ||\n        //                            contact.Name == contact.PhoneNumber)\n        //                        {\n        //                            if (!string.Equals(contact.Name, profileName, StringComparison.Ordinal))\n        //                            {\n        //                                contact.Name = profileName;\n        //                                changed = true;\n        //                            }\n        //                        }\n\n        //                        if (changed)\n        //                        {\n        //                            contact.ProfileNameUpdatedAt = now;\n        //                            await _context.SaveChangesAsync();\n        //                            _logger.LogInformation(\"👤 Updated WA profile name to '{Name}' for {Phone} (biz {Biz})\",\n        //                                profileName, fromDigits, businessId);\n        //                        }\n        //                    }\n        //                }\n        //            }\n        //            catch (Exception exProf)\n        //            {\n        //                _logger.LogWarning(exProf, \"⚠️ Failed to upsert WA profile name on click webhook.\");\n        //            }\n\n        //            // —— Map clicked text -> button index via the shown bundle\n        //            short? buttonIndex = null;\n        //            FlowBtnBundleNode? hit = null;\n\n        //            if (!string.IsNullOrWhiteSpace(bundleJson))\n        //            {\n        //                try\n        //                {\n        //                    var nodes = System.Text.Json.JsonSerializer\n        //                        .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();\n\n        //                    hit = nodes.FirstOrDefault(n =>\n        //                              string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n        //                          ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));\n\n        //                    if (hit != null)\n        //                        buttonIndex = (short)hit.i;\n        //                }\n        //                catch (Exception ex)\n        //                {\n        //                    _logger.LogWarning(ex, \"⚠️ Failed to parse ButtonBundleJson\");\n        //                }\n        //            }\n\n        //            // —— Fallback: find link by TEXT for this step\n        //            FlowButtonLink? linkMatchedByText = null;\n        //            if (buttonIndex == null)\n        //            {\n        //                var stepLinks = await _context.FlowButtonLinks\n        //                    .Where(l => l.CTAFlowStepId == stepId)\n        //                    .OrderBy(l => l.ButtonIndex)\n        //                    .ToListAsync();\n\n        //                if (stepLinks.Count > 0)\n        //                {\n        //                    linkMatchedByText = stepLinks.FirstOrDefault(l =>\n        //                        string.Equals(l.ButtonText ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n        //                        ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));\n\n        //                    if (linkMatchedByText == null && stepLinks.Count == 1)\n        //                    {\n        //                        linkMatchedByText = stepLinks[0];\n        //                        _logger.LogInformation(\"🟨 Falling back to single available link for step {Step}\", stepId);\n        //                    }\n\n        //                    if (linkMatchedByText != null)\n        //                    {\n        //                        buttonIndex = (short?)linkMatchedByText.ButtonIndex;\n        //                        _logger.LogInformation(\"✅ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})\",\n        //                            buttonIndex, flowId, stepId);\n        //                    }\n        //                }\n        //            }\n\n        //            if (buttonIndex == null)\n        //            {\n        //                _logger.LogInformation(\"🟡 Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'\",\n        //                    originalMessageId, buttonText);\n        //                continue;\n        //            }\n\n        //            // —— Prefer exact link by index; otherwise use the text-matched link\n        //            var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)\n        //                       ?? linkMatchedByText;\n\n        //            if (link == null)\n        //            {\n        //                _logger.LogInformation(\"🟡 No button link for (flow={Flow}, step={Step}, idx={Idx})\",\n        //                    flowId, stepId, buttonIndex);\n        //                continue;\n        //            }\n\n        //            // —— Resolve index + step name (for logging)\n        //            short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);\n        //            var stepName = await _context.CTAFlowSteps\n        //                .Where(s => s.Id == stepId)\n        //                .Select(s => s.TemplateToSend)\n        //                .FirstOrDefaultAsync() ?? string.Empty;\n\n        //            // ————————————————\n        //            // 📝 WRITE CLICK LOG (always, even if terminal)\n        //            // ————————————————\n        //            try\n        //            {\n        //                var clickExec = new FlowExecutionLog\n        //                {\n        //                    Id = Guid.NewGuid(),\n        //                    BusinessId = businessId,\n        //                    FlowId = flowId,\n        //                    StepId = stepId,\n        //                    StepName = stepName,\n        //                    CampaignSendLogId = campaignSendLogId,\n        //                    MessageLogId = origin?.Id,\n        //                    ContactPhone = fromDigits,      // ✅ digits-only, consistent\n        //                    ButtonIndex = resolvedIndex,\n        //                    TriggeredByButton = buttonText,\n        //                    TemplateName = null,\n        //                    TemplateType = \"quick_reply\",\n        //                    Success = true,\n        //                    ExecutedAt = DateTime.UtcNow,\n        //                    RequestId = Guid.NewGuid(),\n        //                    RunId = runId\n        //                };\n\n        //                _context.FlowExecutionLogs.Add(clickExec);\n        //                await _context.SaveChangesAsync();\n        //            }\n        //            catch (Exception exSave)\n        //            {\n        //                _logger.LogWarning(exSave, \"⚠️ Failed to persist FlowExecutionLog (click). Continuing…\");\n        //            }\n        //            // ===== RUNNING CTA JOURNEY STATE UPSERT (ONLY IF THIS BIZ IS CONFIGURED) =====\n        //            string runningJourney;\n\n        //            // Check once if this business is configured to receive CTAJourney.\n        //            // If not, we won't touch ContactJourneyStates at all.\n        //            bool shouldTrackState = await _context.CustomerWebhookConfigs\n        //                .AsNoTracking()\n        //                .AnyAsync(x => x.BusinessId == businessId && x.IsActive);\n\n        //            if (shouldTrackState)\n        //            {\n        //                try\n        //                {\n        //                    // load current state for (business, flow, phone)\n        //                    var state = await _context.ContactJourneyStates\n        //                        .SingleOrDefaultAsync(s =>\n        //                            s.BusinessId == businessId &&\n        //                            s.FlowId == flowId &&\n        //                            s.ContactPhone == fromDigits);\n\n        //                    if (state == null)\n        //                    {\n        //                        // first click -> start with this button text (original casing)\n        //                        state = new ContactJourneyState\n        //                        {\n        //                            Id = Guid.NewGuid(),\n        //                            BusinessId = businessId,\n        //                            FlowId = flowId,\n        //                            ContactPhone = fromDigits,\n        //                            JourneyText = buttonText ?? string.Empty,\n        //                            ClickCount = 1,\n        //                            LastButtonText = buttonText,\n        //                            CreatedAt = DateTime.UtcNow,\n        //                            UpdatedAt = DateTime.UtcNow\n        //                        };\n        //                        _context.ContactJourneyStates.Add(state);\n        //                        await _context.SaveChangesAsync();\n        //                        runningJourney = state.JourneyText;\n        //                        _logger.LogInformation(\"🧵 Journey init: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n        //                            runningJourney, businessId, flowId, fromDigits);\n        //                    }\n        //                    else\n        //                    {\n        //                        // append EVERY press (duplicates allowed), keep original casing\n        //                        var parts = (state.JourneyText ?? string.Empty)\n        //                            .Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)\n        //                            .ToList();\n\n        //                        if (!string.IsNullOrWhiteSpace(buttonText))\n        //                            parts.Add(buttonText!);\n\n        //                        // optional safety: cap growth\n        //                        const int cap = 15;\n        //                        if (parts.Count > cap) parts = parts.Skip(parts.Count - cap).ToList();\n\n        //                        state.JourneyText = string.Join('/', parts);\n        //                        state.ClickCount += 1;\n        //                        state.LastButtonText = buttonText;\n        //                        state.UpdatedAt = DateTime.UtcNow;\n\n        //                        await _context.SaveChangesAsync();\n        //                        runningJourney = state.JourneyText ?? string.Empty;\n\n        //                        _logger.LogInformation(\"🧵 Journey update: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n        //                            runningJourney, businessId, flowId, fromDigits);\n        //                    }\n        //                }\n        //                catch (Exception exState)\n        //                {\n        //                    _logger.LogWarning(exState, \"⚠️ Failed to upsert ContactJourneyState.\");\n        //                    // fall back to this click only\n        //                    runningJourney = buttonText ?? string.Empty;\n        //                }\n        //            }\n        //            else\n        //            {\n        //                // Business not configured → do NOT save any state. Just use the current button for emit.\n        //                runningJourney = buttonText ?? string.Empty;\n        //            }\n        //            // ===== END RUNNING CTA JOURNEY STATE UPSERT =====\n\n\n        //            // ===== CTAJourney EMIT (running journey) =====\n        //            try\n        //            {\n        //                // contact (for userName / userPhone)\n        //                var contact = await _context.Contacts\n        //                    .AsNoTracking()\n        //                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n        //                // prefer PhoneNumberId (botId) from the originating send; otherwise pick any active one\n        //                string? phoneNumberId = null;\n        //                if (campaignSendLogId.HasValue)\n        //                {\n        //                    phoneNumberId = await _context.CampaignSendLogs\n        //                        .AsNoTracking()\n        //                        .Where(s => s.Id == campaignSendLogId.Value)\n        //                        .Select(s => s.Campaign.PhoneNumberId)\n        //                        .FirstOrDefaultAsync();\n        //                }\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)\n        //                {\n        //                    phoneNumberId = await _context.Campaigns\n        //                        .AsNoTracking()\n        //                        .Where(c => c.Id == origin.CampaignId.Value)\n        //                        .Select(c => c.PhoneNumberId)\n        //                        .FirstOrDefaultAsync();\n        //                }\n\n        //                //if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                //{\n        //                //    phoneNumberId = await _context.WhatsAppSettings\n        //                //        .AsNoTracking()\n        //                //        .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)\n        //                //        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //                //        .Select(s => s.PhoneNumberId)\n        //                //        .FirstOrDefaultAsync();\n        //                //}\n        //                // 2) Map PhoneNumberId -> WhatsAppBusinessNumber\n        //                string? botWaNumber = null;\n        //                if (!string.IsNullOrWhiteSpace(phoneNumberId))\n        //                {\n        //                    botWaNumber = await _context.WhatsAppPhoneNumbers\n        //                        .AsNoTracking()\n        //                        .Where(n => n.BusinessId == businessId && n.PhoneNumberId == phoneNumberId)\n        //                        .Select(n => n.WhatsAppBusinessNumber)\n        //                        .FirstOrDefaultAsync();\n        //                }\n        //                // business WA display number (fallback botId if no PhoneNumberId)\n        //                var displayProfilename = await _context.WhatsAppSettings\n        //                    .AsNoTracking()\n        //                    .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)\n        //                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //                    .Select(s => s.WhatsAppBusinessNumber)\n        //                    .FirstOrDefaultAsync();\n\n        //                // Build DTO and POST (CTAJourney = the running slash-joined string with original casing)\n        //                var dto = CtaJourneyMapper.Build(\n        //                    journeyKey: runningJourney,                    // <<—— use the running state\n        //                    contact: contact,\n        //                    profileName: contact?.ProfileName ?? contact?.Name,\n        //                    userId: null,\n        //                    phoneNumberId: botWaNumber,                  // preferred botId\n        //                    businessDisplayPhone: displayProfilename,               // fallback botId if above missing\n        //                    categoryBrowsed: null,\n        //                    productBrowsed: null\n        //                );\n\n        //                await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n        //                _logger.LogInformation(\"📤 CTAJourney posted (running): {Journey} (biz={Biz}, phone={Phone})\",\n        //                    dto.CTAJourney, businessId, dto.userPhone);\n        //            }\n        //            catch (Exception ex)\n        //            {\n        //                _logger.LogWarning(ex, \"⚠️ Failed to post CTAJourney (click). Continuing…\");\n        //            }\n\n        //            // ===== end CTAJourney EMIT =====\n\n\n        //            // ===== CTAJourney EMIT (button name) =====\n        //            //try\n        //            //{\n        //            //    CTAJourney must be the button name now\n        //            //   var journeyKey = ToKey(buttonText);\n        //            //    var journeyKey = buttonText?.Trim();\n        //            //    contact(for userName / userPhone)\n        //            //        var contact = await _context.Contacts\n        //            //            .AsNoTracking()\n        //            //            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n        //            //    prefer PhoneNumberId(botId) from the originating send; otherwise pick any active one\n        //            //    string? phoneNumberId = null;\n        //            //    if (campaignSendLogId.HasValue)\n        //            //    {\n        //            //        phoneNumberId = await _context.CampaignSendLogs\n        //            //            .AsNoTracking()\n        //            //            .Where(s => s.Id == campaignSendLogId.Value)\n        //            //            .Select(s => s.Campaign.PhoneNumberId)\n        //            //            .FirstOrDefaultAsync();\n        //            //    }\n        //            //    if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)\n        //            //    {\n        //            //        phoneNumberId = await _context.Campaigns\n        //            //            .AsNoTracking()\n        //            //            .Where(c => c.Id == origin.CampaignId.Value)\n        //            //            .Select(c => c.PhoneNumberId)\n        //            //            .FirstOrDefaultAsync();\n        //            //    }\n        //            //    if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //            //    {\n        //            //        phoneNumberId = await _context.WhatsAppSettings\n        //            //            .AsNoTracking()\n        //            //            .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)\n        //            //            .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //            //            .Select(s => s.PhoneNumberId)\n        //            //            .FirstOrDefaultAsync();\n        //            //    }\n\n        //            //    business WA display number(fallback botId if no PhoneNumberId)\n        //            //    var displayWa = await _context.WhatsAppSettings\n        //            //        .AsNoTracking()\n        //            //        .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)\n        //            //        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //            //        .Select(s => s.WhatsAppBusinessNumber)\n        //            //        .FirstOrDefaultAsync();\n\n        //            //    build DTO and POST(maps to: userName / profileName, userPhone, botId, CTAJourney)\n        //            //    var dto = CtaJourneyMapper.Build(\n        //            //        journeyKey: journeyKey,                         // <<—— button name\n        //            //        contact: contact,\n        //            //        profileName: contact?.ProfileName ?? contact?.Name,\n        //            //        userId: null,                                   // we don't have external user id\n        //            //        phoneNumberId: phoneNumberId,                   // preferred botId\n        //            //        businessDisplayPhone: displayWa,                // fallback botId if above missing\n        //            //        categoryBrowsed: null,\n        //            //        productBrowsed: null\n        //            //    );\n\n        //            //    await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n        //            //    _logger.LogInformation(\"📤 CTAJourney posted (button): {Journey} (biz={Biz}, phone={Phone})\",\n        //            //        dto.CTAJourney, businessId, dto.userPhone);\n        //            //}\n        //            //catch (Exception ex)\n        //            //{\n        //            //    _logger.LogWarning(ex, \"⚠️ Failed to post CTAJourney (click). Continuing…\");\n        //            //}\n\n\n\n\n\n        //            // —— If terminal/URL button: already logged the click\n        //            if (link.NextStepId == null)\n        //            {\n        //                _logger.LogInformation(\"🔚 Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'\",\n        //                    flowId, stepId, resolvedIndex, link.ButtonText);\n        //                continue;\n        //            }\n\n        //            if (_flowRuntime == null)\n        //            {\n        //                _logger.LogError(\"❌ _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}\", flowId, stepId, resolvedIndex);\n        //                continue;\n        //            }\n\n        //            // —— 🔎 Resolve sender from the originating campaign/send (use SAME WABA)\n        //            string? providerFromCampaign = null;\n        //            string? phoneNumberIdFromCampaign = null;\n\n        //            if (campaignSendLogId.HasValue)\n        //            {\n        //                var originSend = await _context.CampaignSendLogs\n        //                    .AsNoTracking()\n        //                    .Include(s => s.Campaign)\n        //                    .Where(s => s.Id == campaignSendLogId.Value)\n        //                    .Select(s => new\n        //                    {\n        //                        s.Campaign.Provider,\n        //                        s.Campaign.PhoneNumberId\n        //                    })\n        //                    .FirstOrDefaultAsync();\n\n        //                providerFromCampaign = originSend?.Provider;\n        //                phoneNumberIdFromCampaign = originSend?.PhoneNumberId;\n        //            }\n        //            else if (origin != null && origin.CampaignId.HasValue)\n        //            {\n        //                var originCamp = await _context.Campaigns\n        //                    .AsNoTracking()\n        //                    .Where(c => c.Id == origin.CampaignId.Value)\n        //                    .Select(c => new { c.Provider, c.PhoneNumberId })\n        //                    .FirstOrDefaultAsync();\n\n        //                providerFromCampaign = originCamp?.Provider;\n        //                phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;\n        //            }\n\n        //            // —— Execute next (carry sender forward)\n        //            var ctxObj = new NextStepContext\n        //            {\n        //                BusinessId = businessId,\n        //                FlowId = flowId,\n        //                Version = flowVersion ?? 1,\n        //                SourceStepId = stepId,\n        //                TargetStepId = link.NextStepId!.Value,\n        //                ButtonIndex = resolvedIndex,\n        //                MessageLogId = origin?.Id ?? Guid.Empty,\n        //                ContactPhone = fromDigits,     // ✅ digits-only, so runtime finds the Contact\n        //                RequestId = Guid.NewGuid(),\n        //                ClickedButton = link,\n\n        //                // 🧷 Sender from campaign so runtime won’t guess or fail with “Missing PhoneNumberId”\n        //                Provider = providerFromCampaign,\n        //                PhoneNumberId = phoneNumberIdFromCampaign,\n        //                AlwaysSend = true // 🔥 force runtime to send even if it’s a loopback/same step\n        //            };\n\n        //            try\n        //            {\n        //                var result = await _flowRuntime.ExecuteNextAsync(ctxObj);\n\n        //                if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))\n        //                {\n        //                    _logger.LogInformation(\"🔗 URL button redirect (logical): {Url}\", result.RedirectUrl);\n        //                }\n        //            }\n        //            catch (Exception exRun)\n        //            {\n        //                _logger.LogError(exRun,\n        //                    \"❌ ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'\",\n        //                    ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);\n        //            }\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"❌ Failed to process CTA button click.\");\n        //    }\n        //}\n\n        public async Task ProcessClickAsync(JsonElement value)\n        {\n            _logger.LogWarning(\"📥 [ENTERED CLICK PROCESSOR]\");\n\n            try\n            {\n                if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n                    return;\n\n                // ── local helpers ─────────────────────────────────────────────────────────\n                static string Norm(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n                    return string.Join(' ', s.Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries))\n                                 .Trim()\n                                 .ToLowerInvariant();\n                }\n\n                // canonical phone: keep only digits (matches how we store & search contacts)\n                static string NormalizePhone(string? raw)\n                    => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());\n\n                // contacts[0].profile.name (Meta shape)\n                static string? TryGetProfileName(JsonElement root)\n                {\n                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                        contactsEl.ValueKind == JsonValueKind.Array &&\n                        contactsEl.GetArrayLength() > 0)\n                    {\n                        var c0 = contactsEl[0];\n                        if (c0.TryGetProperty(\"profile\", out var profEl) &&\n                            profEl.ValueKind == JsonValueKind.Object &&\n                            profEl.TryGetProperty(\"name\", out var nameEl) &&\n                            nameEl.ValueKind == JsonValueKind.String)\n                        {\n                            var n = nameEl.GetString();\n                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                        }\n                    }\n                    return null;\n                }\n\n                // optional helper (kept for future use)\n                static string ToKey(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n                    var t = s.Trim().ToLowerInvariant();\n                    var sb = new System.Text.StringBuilder(t.Length);\n                    foreach (var ch in t)\n                    {\n                        if (char.IsLetterOrDigit(ch)) sb.Append(ch);\n                        else if (char.IsWhiteSpace(ch) || ch == '-' || ch == '_' || ch == '.') sb.Append('_');\n                    }\n                    var k = sb.ToString().Trim('_');\n                    return string.IsNullOrEmpty(k) ? \"unknown\" : k;\n                }\n                // ──────────────────────────────────────────────────────────────────────────\n\n                // read WA display number once (used as botId) – optional, not strictly required\n                string botIdFromWebhook = \"\";\n                if (value.TryGetProperty(\"metadata\", out var md) &&\n                    md.TryGetProperty(\"display_phone_number\", out var dpnEl) &&\n                    dpnEl.ValueKind == JsonValueKind.String)\n                {\n                    botIdFromWebhook = NormalizePhone(dpnEl.GetString());\n                }\n\n                foreach (var msg in messages.EnumerateArray())\n                {\n                    if (!msg.TryGetProperty(\"type\", out var typeProp))\n                        continue;\n\n                    var type = typeProp.GetString();\n\n                    string? clickMessageId = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                    string? originalMessageId = msg.TryGetProperty(\"context\", out var ctx) && ctx.TryGetProperty(\"id\", out var ctxId)\n                        ? ctxId.GetString()\n                        : null;\n\n                    var fromRaw = msg.TryGetProperty(\"from\", out var fromProp) ? (fromProp.GetString() ?? \"\") : \"\";\n                    var fromDigits = NormalizePhone(fromRaw);\n\n                    // ——— button label extraction\n                    string? buttonText = null;\n                    if (string.Equals(type, \"button\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        buttonText = msg.TryGetProperty(\"button\", out var btn) &&\n                                     btn.TryGetProperty(\"text\", out var textProp)\n                                       ? textProp.GetString()?.Trim()\n                                       : null;\n                    }\n                    else if (string.Equals(type, \"interactive\", StringComparison.OrdinalIgnoreCase) &&\n                             msg.TryGetProperty(\"interactive\", out var interactive))\n                    {\n                        if (interactive.TryGetProperty(\"type\", out var intrType) &&\n                            string.Equals(intrType.GetString(), \"button_reply\", StringComparison.OrdinalIgnoreCase) &&\n                            interactive.TryGetProperty(\"button_reply\", out var br) &&\n                            br.TryGetProperty(\"title\", out var titleProp))\n                        {\n                            buttonText = titleProp.GetString()?.Trim();\n                        }\n                        else if (interactive.TryGetProperty(\"list_reply\", out var lr) &&\n                                 lr.TryGetProperty(\"title\", out var listTitleProp))\n                        {\n                            buttonText = listTitleProp.GetString()?.Trim();\n                        }\n                    }\n\n                    if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))\n                    {\n                        _logger.LogDebug(\"ℹ️ Not a recognized click or missing context.id. type={Type}\", type);\n                        continue;\n                    }\n\n                    _logger.LogInformation(\"🖱️ Button Click → From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n                        fromDigits, clickMessageId, originalMessageId, buttonText);\n\n                    // —— Try 1: originating MessageLog (for flow-sent messages)\n                    var origin = await _context.MessageLogs\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(m =>\n                            m.MessageId == originalMessageId &&\n                            m.CTAFlowConfigId != null &&\n                            m.CTAFlowStepId != null);\n\n                    Guid businessId;\n                    Guid flowId;\n                    Guid stepId;\n                    string? bundleJson = null;\n                    int? flowVersion = null;\n\n                    Guid? campaignSendLogId = null; // link the click to the shown message\n                    Guid? runId = null;             // copy from parent CSL when available\n\n                    if (origin != null)\n                    {\n                        businessId = origin.BusinessId;\n                        flowId = origin.CTAFlowConfigId!.Value;\n                        stepId = origin.CTAFlowStepId!.Value;\n                        bundleJson = origin.ButtonBundleJson;\n                        flowVersion = origin.FlowVersion;\n\n                        // Map back to CSL via MessageLogId or WAMID and fetch RunId\n                        var cslInfo = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))\n                            .OrderByDescending(csl => csl.CreatedAt)\n                            .Select(csl => new { csl.Id, csl.RunId })\n                            .FirstOrDefaultAsync();\n\n                        campaignSendLogId = cslInfo?.Id;\n                        runId = cslInfo?.RunId;\n                    }\n                    else\n                    {\n                        // —— Try 2: first campaign message (CampaignSendLogs)\n                        var sendLog = await _context.CampaignSendLogs\n                            .Include(sl => sl.Campaign)\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);\n\n                        if (sendLog == null)\n                        {\n                            _logger.LogWarning(\"❌ No MessageLog or CampaignSendLog for original WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        businessId = sendLog.BusinessId != Guid.Empty\n                            ? sendLog.BusinessId\n                            : (sendLog.Campaign?.BusinessId ?? Guid.Empty);\n\n                        if (businessId == Guid.Empty)\n                        {\n                            _logger.LogWarning(\"❌ Could not resolve BusinessId for WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        campaignSendLogId = sendLog.Id;\n                        runId = sendLog.RunId;\n\n                        if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)\n                        {\n                            flowId = sendLog.CTAFlowConfigId.Value;\n                            stepId = sendLog.CTAFlowStepId.Value;\n                        }\n                        else if (sendLog.Campaign?.CTAFlowConfigId != null)\n                        {\n                            flowId = sendLog.Campaign.CTAFlowConfigId.Value;\n\n                            var entry = await _context.CTAFlowSteps\n                                .Where(s => s.CTAFlowConfigId == flowId)\n                                .OrderBy(s => s.StepOrder)\n                                .Select(s => s.Id)\n                                .FirstOrDefaultAsync();\n\n                            if (entry == Guid.Empty)\n                            {\n                                _logger.LogWarning(\"❌ No entry step found for flow {Flow}\", flowId);\n                                continue;\n                            }\n\n                            stepId = entry;\n                        }\n                        else\n                        {\n                            _logger.LogWarning(\"❌ No flow context on CampaignSendLog for WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        bundleJson = sendLog.ButtonBundleJson;\n                    }\n\n                    // ─────────────────────────────────────────────────────────────\n                    // ✅ UPSERT PROFILE NAME (create-or-update) *before* next step\n                    //    ensure we look up by digits-only phone.\n                    // ─────────────────────────────────────────────────────────────\n                    try\n                    {\n                        var profileName = TryGetProfileName(value);\n                        if (!string.IsNullOrWhiteSpace(profileName))\n                        {\n                            var now = DateTime.UtcNow;\n                            var contact = await _context.Contacts\n                                .FirstOrDefaultAsync(c => c.BusinessId == businessId &&\n                                                          (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));\n\n                            if (contact == null)\n                            {\n                                profileName = profileName ?? \"User\";\n                                contact = new Contact\n                                {\n                                    Id = Guid.NewGuid(),\n                                    BusinessId = businessId,\n                                    PhoneNumber = fromDigits, // store canonical\n                                    Name = profileName,\n                                    ProfileName = profileName,\n                                    ProfileNameUpdatedAt = now,\n                                    CreatedAt = now,\n                                };\n                                _context.Contacts.Add(contact);\n                                await _context.SaveChangesAsync();\n                                _logger.LogInformation(\"👤 Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})\",\n                                    profileName, fromDigits, businessId);\n                            }\n                            else\n                            {\n                                var changed = false;\n\n                                if (!string.Equals(contact.ProfileName, profileName, StringComparison.Ordinal))\n                                {\n                                    contact.ProfileName = profileName;\n                                    contact.ProfileNameUpdatedAt = now;\n                                    changed = true;\n                                }\n\n                                if (string.IsNullOrWhiteSpace(contact.Name) ||\n                                    contact.Name == \"WhatsApp User\" ||\n                                    contact.Name == contact.PhoneNumber)\n                                {\n                                    if (!string.Equals(contact.Name, profileName, StringComparison.Ordinal))\n                                    {\n                                        contact.Name = profileName;\n                                        changed = true;\n                                    }\n                                }\n\n                                if (changed)\n                                {\n                                    contact.ProfileNameUpdatedAt = now;\n                                    await _context.SaveChangesAsync();\n                                    _logger.LogInformation(\"👤 Updated WA profile name to '{Name}' for {Phone} (biz {Biz})\",\n                                        profileName, fromDigits, businessId);\n                                }\n                            }\n                        }\n                    }\n                    catch (Exception exProf)\n                    {\n                        _logger.LogWarning(exProf, \"⚠️ Failed to upsert WA profile name on click webhook.\");\n                    }\n\n                    // —— Map clicked text -> button index via the shown bundle\n                    short? buttonIndex = null;\n                    FlowBtnBundleNode? hit = null;\n\n                    if (!string.IsNullOrWhiteSpace(bundleJson))\n                    {\n                        try\n                        {\n                            var nodes = System.Text.Json.JsonSerializer\n                                .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();\n\n                            hit = nodes.FirstOrDefault(n =>\n                                      string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                  ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));\n\n                            if (hit != null)\n                                buttonIndex = (short)hit.i;\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogWarning(ex, \"⚠️ Failed to parse ButtonBundleJson\");\n                        }\n                    }\n\n                    // —— Fallback: find link by TEXT for this step\n                    FlowButtonLink? linkMatchedByText = null;\n                    if (buttonIndex == null)\n                    {\n                        var stepLinks = await _context.FlowButtonLinks\n                            .Where(l => l.CTAFlowStepId == stepId)\n                            .OrderBy(l => l.ButtonIndex)\n                            .ToListAsync();\n\n                        if (stepLinks.Count > 0)\n                        {\n                            linkMatchedByText = stepLinks.FirstOrDefault(l =>\n                                string.Equals(l.ButtonText ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));\n\n                            if (linkMatchedByText == null && stepLinks.Count == 1)\n                            {\n                                linkMatchedByText = stepLinks[0];\n                                _logger.LogInformation(\"🟨 Falling back to single available link for step {Step}\", stepId);\n                            }\n\n                            if (linkMatchedByText != null)\n                            {\n                                buttonIndex = (short?)linkMatchedByText.ButtonIndex;\n                                _logger.LogInformation(\"✅ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})\",\n                                    buttonIndex, flowId, stepId);\n                            }\n                        }\n                    }\n\n                    if (buttonIndex == null)\n                    {\n                        _logger.LogInformation(\"🟡 Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'\",\n                            originalMessageId, buttonText);\n                        continue;\n                    }\n\n                    // —— Prefer exact link by index; otherwise use the text-matched link\n                    var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)\n                               ?? linkMatchedByText;\n\n                    if (link == null)\n                    {\n                        _logger.LogInformation(\"🟡 No button link for (flow={Flow}, step={Step}, idx={Idx})\",\n                            flowId, stepId, buttonIndex);\n                        continue;\n                    }\n\n                    // —— Resolve index + step name (for logging)\n                    short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);\n                    var stepName = await _context.CTAFlowSteps\n                        .Where(s => s.Id == stepId)\n                        .Select(s => s.TemplateToSend)\n                        .FirstOrDefaultAsync() ?? string.Empty;\n\n                    // ————————————————\n                    // 📝 WRITE CLICK LOG (always, even if terminal)\n                    // ————————————————\n                    try\n                    {\n                        var clickExec = new FlowExecutionLog\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            FlowId = flowId,\n                            StepId = stepId,\n                            StepName = stepName,\n                            CampaignSendLogId = campaignSendLogId,\n                            MessageLogId = origin?.Id,\n                            ContactPhone = fromDigits,      // digits-only\n                            ButtonIndex = resolvedIndex,\n                            TriggeredByButton = buttonText,\n                            TemplateName = null,\n                            TemplateType = \"quick_reply\",\n                            Success = true,\n                            ExecutedAt = DateTime.UtcNow,\n                            RequestId = Guid.NewGuid(),\n                            RunId = runId\n                        };\n\n                        _context.FlowExecutionLogs.Add(clickExec);\n                        await _context.SaveChangesAsync();\n                    }\n                    catch (Exception exSave)\n                    {\n                        _logger.LogWarning(exSave, \"⚠️ Failed to persist FlowExecutionLog (click). Continuing…\");\n                    }\n\n                    // ===== RUNNING CTA JOURNEY STATE UPSERT (ONLY IF THIS BIZ IS CONFIGURED) =====\n                    string runningJourney;\n\n                    // Check once if this business is configured to receive CTAJourney.\n                    bool shouldTrackState = await _context.CustomerWebhookConfigs\n                        .AsNoTracking()\n                        .AnyAsync(x => x.BusinessId == businessId && x.IsActive);\n\n                    if (shouldTrackState)\n                    {\n                        try\n                        {\n                            // load current state for (business, flow, phone)\n                            var state = await _context.ContactJourneyStates\n                                .SingleOrDefaultAsync(s =>\n                                    s.BusinessId == businessId &&\n                                    s.FlowId == flowId &&\n                                    s.ContactPhone == fromDigits);\n\n                            if (state == null)\n                            {\n                                // first click -> start with this button text (original casing)\n                                state = new ContactJourneyState\n                                {\n                                    Id = Guid.NewGuid(),\n                                    BusinessId = businessId,\n                                    FlowId = flowId,\n                                    ContactPhone = fromDigits,\n                                    JourneyText = buttonText ?? string.Empty,\n                                    ClickCount = 1,\n                                    LastButtonText = buttonText,\n                                    CreatedAt = DateTime.UtcNow,\n                                    UpdatedAt = DateTime.UtcNow\n                                };\n                                _context.ContactJourneyStates.Add(state);\n                                await _context.SaveChangesAsync();\n                                runningJourney = state.JourneyText;\n                                _logger.LogInformation(\"🧵 Journey init: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n                                    runningJourney, businessId, flowId, fromDigits);\n                            }\n                            else\n                            {\n                                // append EVERY press (duplicates allowed), keep original casing\n                                var parts = (state.JourneyText ?? string.Empty)\n                                    .Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)\n                                    .ToList();\n\n                                if (!string.IsNullOrWhiteSpace(buttonText))\n                                    parts.Add(buttonText!);\n\n                                // cap growth\n                                const int cap = 15;\n                                if (parts.Count > cap) parts = parts.Skip(parts.Count - cap).ToList();\n\n                                state.JourneyText = string.Join('/', parts);\n                                state.ClickCount += 1;\n                                state.LastButtonText = buttonText;\n                                state.UpdatedAt = DateTime.UtcNow;\n\n                                await _context.SaveChangesAsync();\n                                runningJourney = state.JourneyText ?? string.Empty;\n\n                                _logger.LogInformation(\"🧵 Journey update: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n                                    runningJourney, businessId, flowId, fromDigits);\n                            }\n                        }\n                        catch (Exception exState)\n                        {\n                            _logger.LogWarning(exState, \"⚠️ Failed to upsert ContactJourneyState.\");\n                            // fall back to this click only\n                            runningJourney = buttonText ?? string.Empty;\n                        }\n                    }\n                    else\n                    {\n                        // Business not configured → do NOT save any state. Just use the current button for emit.\n                        runningJourney = buttonText ?? string.Empty;\n                    }\n                    // ===== END RUNNING CTA JOURNEY STATE UPSERT =====\n\n                    // ===== CTAJourney EMIT (running journey) =====\n                    try\n                    {\n                        // contact (for userName / userPhone)\n                        var contact = await _context.Contacts\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n                        // Prefer sender from the originating send (keeps the same WABA)\n                        string? senderProvider = null;\n                        string? senderPhoneNumberId = null;\n\n                        if (campaignSendLogId.HasValue)\n                        {\n                            var originSend = await _context.CampaignSendLogs\n                                .AsNoTracking()\n                                .Include(s => s.Campaign)\n                                .Where(s => s.Id == campaignSendLogId.Value)\n                                .Select(s => new { s.Campaign.Provider, s.Campaign.PhoneNumberId })\n                                .FirstOrDefaultAsync();\n\n                            senderProvider = originSend?.Provider;\n                            senderPhoneNumberId = originSend?.PhoneNumberId;\n                        }\n                        if (string.IsNullOrWhiteSpace(senderPhoneNumberId) && origin?.CampaignId != null)\n                        {\n                            var originCamp = await _context.Campaigns\n                                .AsNoTracking()\n                                .Where(c => c.Id == origin.CampaignId.Value)\n                                .Select(c => new { c.Provider, c.PhoneNumberId })\n                                .FirstOrDefaultAsync();\n\n                            senderProvider ??= originCamp?.Provider;\n                            senderPhoneNumberId = originCamp?.PhoneNumberId;\n                        }\n\n                        // Map PhoneNumberId -> WhatsAppBusinessNumber, or choose a default for the same provider\n                        string? waBusinessNumber = null;\n\n                        if (!string.IsNullOrWhiteSpace(senderPhoneNumberId))\n                        {\n                            waBusinessNumber = await _context.WhatsAppPhoneNumbers\n                                .AsNoTracking()\n                                .Where(n => n.BusinessId == businessId && n.PhoneNumberId == senderPhoneNumberId)\n                                .Select(n => n.WhatsAppBusinessNumber)\n                                .FirstOrDefaultAsync();\n                        }\n\n                        if (string.IsNullOrWhiteSpace(waBusinessNumber))\n                        {\n                            var row = await _context.WhatsAppPhoneNumbers\n                                .AsNoTracking()\n                                .Where(n => n.BusinessId == businessId &&\n                                            n.IsActive &&\n                                            (string.IsNullOrEmpty(senderProvider) || n.Provider == senderProvider))\n                                .OrderByDescending(n => n.IsDefault)\n                                .ThenByDescending(n => n.UpdatedAt ?? n.CreatedAt)\n                                .Select(n => new { n.PhoneNumberId, n.WhatsAppBusinessNumber })\n                                .FirstOrDefaultAsync();\n\n                            senderPhoneNumberId ??= row?.PhoneNumberId;\n                            waBusinessNumber = row?.WhatsAppBusinessNumber;\n                        }\n\n                        var dto = CtaJourneyMapper.Build(\n                            journeyKey: runningJourney,                      // running state with original casing\n                            contact: contact,\n                            profileName: contact?.ProfileName ?? contact?.Name,\n                            userId: null,\n                            phoneNumberId: waBusinessNumber,                 // publish WA display number as bot id\n                            businessDisplayPhone: waBusinessNumber,          // same as above\n                            categoryBrowsed: null,\n                            productBrowsed: null\n                        );\n\n                        await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n                        _logger.LogInformation(\"📤 CTAJourney posted (running): {Journey} (biz={Biz}, phone={Phone})\",\n                            dto.CTAJourney, businessId, dto.userPhone);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogWarning(ex, \"⚠️ Failed to post CTAJourney (click). Continuing…\");\n                    }\n                    // ===== end CTAJourney EMIT =====\n\n                    // —— If terminal/URL button: already logged the click\n                    if (link.NextStepId == null)\n                    {\n                        _logger.LogInformation(\"🔚 Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'\",\n                            flowId, stepId, resolvedIndex, link.ButtonText);\n                        continue;\n                    }\n\n                    if (_flowRuntime == null)\n                    {\n                        _logger.LogError(\"❌ _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}\", flowId, stepId, resolvedIndex);\n                        continue;\n                    }\n\n                    // —— 🔎 Resolve sender from the originating campaign/send (use SAME WABA) for next step\n                    string? providerFromCampaign = null;\n                    string? phoneNumberIdFromCampaign = null;\n\n                    if (campaignSendLogId.HasValue)\n                    {\n                        var originSend = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Include(s => s.Campaign)\n                            .Where(s => s.Id == campaignSendLogId.Value)\n                            .Select(s => new\n                            {\n                                s.Campaign.Provider,\n                                s.Campaign.PhoneNumberId\n                            })\n                            .FirstOrDefaultAsync();\n\n                        providerFromCampaign = originSend?.Provider;\n                        phoneNumberIdFromCampaign = originSend?.PhoneNumberId;\n                    }\n                    else if (origin != null && origin.CampaignId.HasValue)\n                    {\n                        var originCamp = await _context.Campaigns\n                            .AsNoTracking()\n                            .Where(c => c.Id == origin.CampaignId.Value)\n                            .Select(c => new { c.Provider, c.PhoneNumberId })\n                            .FirstOrDefaultAsync();\n\n                        providerFromCampaign = originCamp?.Provider;\n                        phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;\n                    }\n\n                    // —— Execute next (carry sender forward)\n                    var ctxObj = new NextStepContext\n                    {\n                        BusinessId = businessId,\n                        FlowId = flowId,\n                        Version = flowVersion ?? 1,\n                        SourceStepId = stepId,\n                        TargetStepId = link.NextStepId!.Value,\n                        ButtonIndex = resolvedIndex,\n                        MessageLogId = origin?.Id ?? Guid.Empty,\n                        ContactPhone = fromDigits,     // digits-only\n                        RequestId = Guid.NewGuid(),\n                        ClickedButton = link,\n\n                        // carry same sender into the next step\n                        Provider = providerFromCampaign,\n                        PhoneNumberId = phoneNumberIdFromCampaign,\n                        AlwaysSend = true // force runtime to send even if it’s a loopback/same step\n                    };\n\n                    try\n                    {\n                        var result = await _flowRuntime.ExecuteNextAsync(ctxObj);\n\n                        if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))\n                        {\n                            _logger.LogInformation(\"🔗 URL button redirect (logical): {Url}\", result.RedirectUrl);\n                        }\n                    }\n                    catch (Exception exRun)\n                    {\n                        _logger.LogError(exRun,\n                            \"❌ ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'\",\n                            ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to process CTA button click.\");\n            }\n        }\n\n        private sealed class FlowBtnBundleNode\n        {\n            public int i { get; init; }\n            public string? t { get; init; }   // button text/title\n            public string? ty { get; init; }  // button type (URL/QUICK_REPLY/FLOW)\n            public string? v { get; init; }   // value/payload (e.g., URL)\n            public Guid? ns { get; init; }    // next step id\n        }\n        private static string ToKey(string? s)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n            // letters/digits → lower, spaces/._- → underscore, strip the rest\n            var chars = s.Trim().ToLowerInvariant()\n                .Select(ch => char.IsLetterOrDigit(ch) ? ch : '_')\n                .ToArray();\n            var key = new string(chars);\n            // squeeze duplicate underscores\n            while (key.Contains(\"__\")) key = key.Replace(\"__\", \"_\");\n            return key.Trim('_');\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IClickWebhookProcessor.cs",
      "sha256": "5c42427d1e6c36dd122b3a10412eb70d7c412baf00ce54a614491a5b1590afeb",
      "language": "csharp",
      "size": 228,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IClickWebhookProcessor\n    {\n        Task ProcessClickAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IInboundMessageProcessor.cs",
      "sha256": "ec5496c7810122c99affe09fa17861d6d0c371457d9284e0ba58be6a93ea60f2",
      "language": "csharp",
      "size": 229,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IInboundMessageProcessor\n    {\n        Task ProcessChatAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/InboundMessageProcessor.cs",
      "sha256": "f3ffce0f6dbaf9f28400e14be41bb0622e4450b64a4c6eefddcb3bb0a2608310",
      "language": "csharp",
      "size": 54270,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing Microsoft.Extensions.DependencyInjection;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.CRM.Services;\nusing xbytechat.api.Features.Automation.Services;\nusing xbytechat.api.Features.Webhooks.Directory;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Services; // 🔹 NEW: provider directory\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class InboundMessageProcessor : IInboundMessageProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly ILogger<InboundMessageProcessor> _logger;\n        private readonly IInboxService _inboxService;\n        private readonly IServiceScopeFactory _serviceScopeFactory;\n        private readonly IHubContext<InboxHub> _hub;\n        private readonly IContactProfileService _contactProfile;\n        private readonly IProviderDirectory _providerDirectory; // 🔹 NEW\n\n        public InboundMessageProcessor(\n            AppDbContext context,\n            IHubContext<InboxHub> hubContext,\n            ILogger<InboundMessageProcessor> logger,\n            IInboxService inboxService,\n            IServiceScopeFactory serviceScopeFactory,\n            IHubContext<InboxHub> hub,\n            IContactProfileService contactProfile,\n            IProviderDirectory providerDirectory // 🔹 NEW\n        )\n        {\n            _context = context;\n            _hubContext = hubContext;\n            _logger = logger;\n            _inboxService = inboxService;\n            _serviceScopeFactory = serviceScopeFactory;\n            _hub = hub;\n            _contactProfile = contactProfile;\n            _providerDirectory = providerDirectory; // 🔹 NEW\n        }\n\n        public async Task ProcessChatAsync(JsonElement value)\n        {\n            try\n            {\n                using var scope = _serviceScopeFactory.CreateScope();\n                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n                var autoReplyRuntime = scope.ServiceProvider.GetRequiredService<IAutoReplyRuntimeService>();\n                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n                var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n\n                // digits-only normalizer (matches how we store/search phones)\n                static string Normalize(string? s) =>\n                    string.IsNullOrWhiteSpace(s) ? \"\" : new string(s.Where(char.IsDigit).ToArray());\n\n                // 1) Extract WA metadata + message (Meta Cloud shape)\n                if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n                {\n                    logger.LogWarning(\"Inbound WA payload has no messages array.\");\n                    return;\n                }\n\n                var msg = messages[0];\n\n                var msgType = msg.TryGetProperty(\"type\", out var typeProp)\n                    ? typeProp.GetString()\n                    : \"unknown\";\n\n                var rawContactPhone = msg.GetProperty(\"from\").GetString() ?? \"\";\n                var contactPhone = Normalize(rawContactPhone);\n\n                string? content = msgType switch\n                {\n                    \"text\" when msg.TryGetProperty(\"text\", out var t) &&\n                                t.TryGetProperty(\"body\", out var b)\n                                => b.GetString(),\n\n                    \"image\" when msg.TryGetProperty(\"image\", out var img) &&\n                                 img.TryGetProperty(\"caption\", out var cap)\n                                 => cap.GetString(),\n\n                    _ => null\n                };\n\n                logger.LogInformation(\n                    \"📥 Inbound WA message: type={MsgType}, from={From}, preview={Preview}\",\n                    msgType,\n                    rawContactPhone,\n                    content?.Length > 50 ? content[..50] : content\n                );\n\n                // 2) Resolve business via ProviderDirectory first, then fallback to WhatsAppPhoneNumbers\n                if (!value.TryGetProperty(\"metadata\", out var metadata))\n                {\n                    logger.LogWarning(\"Inbound: metadata missing on webhook payload.\");\n                    return;\n                }\n\n                string? displayNumber = metadata.TryGetProperty(\"display_phone_number\", out var dn)\n                    ? dn.GetString()\n                    : null;\n\n                string? phoneNumberId = metadata.TryGetProperty(\"phone_number_id\", out var pn)\n                    ? pn.GetString()\n                    : null;\n\n                string? wabaId = metadata.TryGetProperty(\"waba_id\", out var we)\n                    ? we.GetString()\n                    : null;\n\n                // 2.1 Prefer provider directory (uses provider + phone_number_id + waba_id)\n                Guid? businessId = await _providerDirectory.ResolveBusinessIdAsync(\n                    provider: \"meta_cloud\",          // canonical provider key for Meta Cloud\n                    phoneNumberId: phoneNumberId,\n                    displayPhoneNumber: displayNumber,\n                    wabaId: wabaId,\n                    waId: rawContactPhone           // the WA user id (\"from\")\n                );\n\n                // 2.2 Fallback to legacy WhatsAppPhoneNumbers by display number if needed\n                if (businessId == null && !string.IsNullOrWhiteSpace(displayNumber))\n                {\n                    var cleanIncomingBiz = Normalize(displayNumber);\n\n                    var candidates = await db.WhatsAppPhoneNumbers\n                        .AsNoTracking()\n                        .Where(n => n.IsActive)\n                        .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n                        .ToListAsync();\n\n                    var numHit = candidates.FirstOrDefault(n =>\n                        Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);\n\n                    if (numHit != null)\n                        businessId = numHit.BusinessId;\n                }\n\n                // 2.3 Still nothing → log and bail\n                if (businessId == null || businessId == Guid.Empty)\n                {\n                    logger.LogWarning(\n                        \"❌ Inbound: business not resolved. phone_number_id={PhoneId}, display={Display}, waba={Waba}, from={From}\",\n                        phoneNumberId,\n                        displayNumber,\n                        wabaId,\n                        rawContactPhone\n                    );\n                    return;\n                }\n\n                var resolvedBusinessId = businessId.Value;\n\n                // 3) Find or create contact\n                var contact = await contactService.FindOrCreateAsync(resolvedBusinessId, contactPhone);\n                if (contact == null)\n                {\n                    logger.LogWarning(\"❌ Could not resolve contact for phone: {Phone}\", contactPhone);\n                    return;\n                }\n\n                // Extract profile name (contacts[0].profile.name) and upsert into Contacts\n                static string? TryGetProfileName(JsonElement root)\n                {\n                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                        contactsEl.ValueKind == JsonValueKind.Array &&\n                        contactsEl.GetArrayLength() > 0)\n                    {\n                        var c0 = contactsEl[0];\n                        if (c0.TryGetProperty(\"profile\", out var prof) &&\n                            prof.ValueKind == JsonValueKind.Object &&\n                            prof.TryGetProperty(\"name\", out var nm) &&\n                            nm.ValueKind == JsonValueKind.String)\n                        {\n                            var n = nm.GetString();\n                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                        }\n                    }\n                    return null;\n                }\n\n                var profileName = TryGetProfileName(value);\n                if (!string.IsNullOrWhiteSpace(profileName))\n                {\n                    try\n                    {\n                        await contactProfileService.UpsertProfileNameAsync(\n                            resolvedBusinessId,\n                            contactPhone,\n                            profileName!,\n                            CancellationToken.None);\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.LogWarning(ex, \"⚠️ Failed to upsert ProfileName for {Phone}\", contactPhone);\n                    }\n                }\n\n                // 4) Check chat mode…\n                var mode = await chatSessionStateService.GetChatModeAsync(resolvedBusinessId, contact.Id);\n                var isAgentMode = mode == \"agent\";\n\n                // 5) Log incoming message\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = resolvedBusinessId,\n                    ContactId = contact.Id,\n                    RecipientNumber = contactPhone,\n                    MessageContent = content,\n                    Status = \"received\",\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    IsIncoming = true\n                };\n\n                db.MessageLogs.Add(messageLog);\n                await db.SaveChangesAsync();\n\n                await _hub.Clients\n                    .Group($\"business_{resolvedBusinessId}\")\n                    .SendAsync(\"ReceiveInboxMessage\", new\n                    {\n                        contactId = contact.Id,\n                        message = messageLog.MessageContent,\n                        isIncoming = true,\n                        senderId = (Guid?)null,\n                        sentAt = messageLog.CreatedAt\n                    });\n\n                // 6) Try AutoReply runtime first, then fall back to legacy automation\n                try\n                {\n                    var triggerRaw = (content ?? string.Empty).Trim();\n                    var triggerKeyword = triggerRaw.ToLowerInvariant();\n\n                    var autoHandled = false;\n\n                    // 6.1 – New AutoReply runtime (keyword → simple reply or CTA flow)\n                    if (!string.IsNullOrWhiteSpace(triggerRaw))\n                    {\n                        var autoResult = await autoReplyRuntime.TryHandleAsync(\n                            resolvedBusinessId,\n                            contact.Id,\n                            contact.PhoneNumber,\n                            triggerRaw,                // pass original text (not forced lowercase)\n                            CancellationToken.None     // you can thread a real ct later if you extend the method\n                        );\n\n                        autoHandled = autoResult.Handled;\n\n                        if (autoResult.Handled)\n                        {\n                            logger.LogInformation(\n                                \"🤖 AutoReply runtime handled inbound message. BusinessId={BusinessId}, ContactId={ContactId}, Keyword={Keyword}, SentSimpleReply={SentSimpleReply}, StartedCtaFlow={StartedCtaFlow}, AutoReplyFlowId={FlowId}, CtaFlowConfigId={CtaId}\",\n                                resolvedBusinessId,\n                                contact.Id,\n                                triggerKeyword,\n                                autoResult.SentSimpleReply,\n                                autoResult.StartedCtaFlow,\n                                autoResult.AutoReplyFlowId,\n                                autoResult.CtaFlowConfigId\n                            );\n                        }\n                        else\n                        {\n                            logger.LogInformation(\n                                \"🤖 AutoReply runtime did not handle message. Falling back to legacy automation. Keyword={Keyword}\",\n                                triggerKeyword\n                            );\n                        }\n                    }\n\n                    // 6.2 – Legacy AutomationService fallback (only if AutoReply did NOT handle)\n                    if (!autoHandled)\n                    {\n                        var handledByLegacy = await automationService.TryRunFlowByKeywordAsync(\n                            resolvedBusinessId,\n                            triggerKeyword,\n                            contact.PhoneNumber,\n                            sourceChannel: \"whatsapp\",\n                            industryTag: \"default\");\n\n                        if (!handledByLegacy)\n                        {\n                            logger.LogInformation(\"🕵️ No automation flow matched keyword (legacy): {Keyword}\", triggerKeyword);\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"❌ AutoReply / Automation flow execution failed.\");\n                }\n\n\n                // 7) Sync to inbox only if agent mode\n                if (isAgentMode)\n                {\n                    try\n                    {\n                        var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n\n                        logger.LogInformation(\n                            \"📥 Inbound: syncing message to inbox for BusinessId={BusinessId}, ContactId={ContactId}\",\n                            resolvedBusinessId,\n                            contact.Id);\n\n                        await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n                        {\n                            BusinessId = resolvedBusinessId,\n                            ContactId = contact.Id,\n                            RecipientPhone = contact.PhoneNumber,\n                            MessageBody = messageLog.MessageContent,\n                            IsIncoming = true,\n                            Status = messageLog.Status,\n                            SentAt = messageLog.CreatedAt\n                        });\n\n                        logger.LogInformation(\"✅ Message synced to inbox for contact {Phone}\", contactPhone);\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.LogError(ex, \"❌ Failed to sync inbound message to inbox.\");\n                    }\n                }\n                else\n                {\n                    logger.LogInformation(\"🚫 Skipping inbox sync: chat mode is not 'agent'\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to process inbound WhatsApp chat.\");\n            }\n        }\n\n        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)\n        {\n            using var scope = _serviceScopeFactory.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n            static string Normalize(string? number) =>\n                string.IsNullOrWhiteSpace(number) ? \"\" : new string(number.Where(char.IsDigit).ToArray());\n\n            // Safe extract of profile name (Meta Cloud shape)\n            static string? TryGetProfileName(JsonElement root)\n            {\n                if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                    contactsEl.ValueKind == JsonValueKind.Array &&\n                    contactsEl.GetArrayLength() > 0)\n                {\n                    var c0 = contactsEl[0];\n                    if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n                        profileEl.ValueKind == JsonValueKind.Object &&\n                        profileEl.TryGetProperty(\"name\", out var nameEl) &&\n                        nameEl.ValueKind == JsonValueKind.String)\n                    {\n                        var n = nameEl.GetString();\n                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                    }\n                }\n                return null;\n            }\n\n            // messages[0].from is always present for interactive/button\n            if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n                return;\n\n            var msg0 = msgs[0];\n            var fromRaw = msg0.GetProperty(\"from\").GetString() ?? \"\";\n            var fromE164 = Normalize(fromRaw);\n\n            // Resolve Business via metadata.display_phone_number → WhatsAppPhoneNumbers\n            var displayNumberRaw = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString() ?? \"\";\n            var displayNumber = Normalize(displayNumberRaw);\n\n            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers\n            var candidates = await db.WhatsAppPhoneNumbers\n                .AsNoTracking()\n                .Where(n => n.IsActive)\n                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n                .ToListAsync(ct);\n\n            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);\n            if (numHit == null)\n            {\n                logger.LogWarning(\"❌ Business not found for interactive webhook number: {Num}\", displayNumberRaw);\n                return;\n            }\n\n            var businessId = numHit.BusinessId;\n\n            // Upsert profile name if present\n            var profileName = TryGetProfileName(value);\n            if (!string.IsNullOrWhiteSpace(profileName))\n            {\n                try\n                {\n                    await contactProfileService.UpsertProfileNameAsync(businessId, fromE164, profileName!, ct);\n                }\n                catch (Exception ex)\n                {\n                    logger.LogWarning(ex, \"⚠️ Failed to upsert ProfileName on interactive webhook for {Phone}\", fromE164);\n                }\n            }\n\n            // … continue your existing interactive handling (routing to next step, etc.)\n        }\n    }\n}\n\n\n//using System;\n//using System.Text.Json;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.SignalR;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.CRM.Models;\n//using xbytechat.api.Features.Inbox.Hubs;\n//using Microsoft.Extensions.DependencyInjection;\n//using xbytechat.api.CRM.Interfaces;\n//using xbytechat.api.Features.AutoReplyBuilder.Services;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.CRM.Services;\n//using xbytechat.api.Features.Automation.Services;\n//using xbytechat.api.Features.Contacts.Services;\n\n//namespace xbytechat.api.Features.Webhooks.Services.Processors\n//{\n//    public class InboundMessageProcessor : IInboundMessageProcessor\n//    {\n//        private readonly AppDbContext _context;\n//        private readonly IHubContext<InboxHub> _hubContext;\n//        private readonly ILogger<InboundMessageProcessor> _logger;\n//        private readonly IInboxService _inboxService;\n//        private readonly IServiceScopeFactory _serviceScopeFactory;\n//        private readonly IHubContext<InboxHub> _hub;\n//        private readonly IContactProfileService _contactProfile;\n\n//        public InboundMessageProcessor(\n//            AppDbContext context,\n//            IHubContext<InboxHub> hubContext,\n//            ILogger<InboundMessageProcessor> logger,\n//            IInboxService inboxService,\n//            IServiceScopeFactory serviceScopeFactory,\n//            IHubContext<InboxHub> hub,\n//            IContactProfileService contactProfile)\n//        {\n//            _context = context;\n//            _hubContext = hubContext;\n//            _logger = logger;\n//            _inboxService = inboxService;\n//            _serviceScopeFactory = serviceScopeFactory;\n//            _hub = hub;\n//            _contactProfile = contactProfile;\n//        }\n\n//        //public async Task ProcessChatAsync(JsonElement value)\n//        //{\n//        //    // High-level trace for every inbound chat\n//        //    try\n//        //    {\n//        //        var rawText = value.GetRawText();\n//        //        _logger.LogInformation(\n//        //            \"💬 InboundMessageProcessor.ProcessChatAsync started. PayloadLength={Length}\",\n//        //            rawText?.Length ?? 0);\n//        //    }\n//        //    catch\n//        //    {\n//        //        // ignore any GetRawText failures – not critical\n//        //    }\n\n//        //    try\n//        //    {\n//        //        using var scope = _serviceScopeFactory.CreateScope();\n//        //        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//        //        var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n//        //        var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n//        //        var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n//        //        var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n//        //        var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n\n//        //        // digits-only normalizer (matches how we store/search phones)\n//        //        static string Normalize(string? s) =>\n//        //            string.IsNullOrWhiteSpace(s) ? \"\" : new string(s.Where(char.IsDigit).ToArray());\n\n//        //        // 1) Extract WA metadata + message (Meta Cloud shape)\n//        //        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n//        //        {\n//        //            logger.LogWarning(\"❌ Inbound payload has no 'messages' array or it is empty.\");\n//        //            return;\n//        //        }\n\n//        //        var msg = msgs[0];\n\n//        //        var rawContactPhone = msg.GetProperty(\"from\").GetString() ?? \"\";\n//        //        var contactPhone = Normalize(rawContactPhone);\n//        //        var content = msg.TryGetProperty(\"text\", out var t) && t.TryGetProperty(\"body\", out var b)\n//        //            ? b.GetString()\n//        //            : null;\n\n//        //        if (!value.TryGetProperty(\"metadata\", out var metadata))\n//        //        {\n//        //            logger.LogWarning(\"❌ Inbound payload missing 'metadata' field.\");\n//        //            return;\n//        //        }\n\n//        //        var rawBusinessNumber = metadata.GetProperty(\"display_phone_number\").GetString() ?? \"\";\n//        //        var cleanIncomingBiz = Normalize(rawBusinessNumber);\n\n//        //        logger.LogInformation(\n//        //            \"🔎 Inbound extract: rawContactPhone={RawContact}, normalizedContact={Contact}, rawBusinessNumber={RawBiz}, normalizedBiz={Biz}\",\n//        //            rawContactPhone,\n//        //            contactPhone,\n//        //            rawBusinessNumber,\n//        //            cleanIncomingBiz);\n\n//        //        // 2) Resolve business  ✅ now via WhatsAppPhoneNumbers (NOT WhatsAppSettings)\n//        //        Guid? businessIdHit = null;\n\n//        //        // Pull active numbers (small table; client-side normalization for reliability)\n//        //        var candidates = await db.WhatsAppPhoneNumbers\n//        //            .AsNoTracking()\n//        //            .Where(n => n.IsActive)\n//        //            .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n//        //            .ToListAsync();\n\n//        //        logger.LogDebug(\"📊 Inbound: Loaded {Count} active WhatsAppPhoneNumbers candidates.\", candidates.Count);\n\n//        //        var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);\n//        //        if (numHit != null)\n//        //        {\n//        //            businessIdHit = numHit.BusinessId;\n//        //            logger.LogInformation(\n//        //                \"✅ Inbound: resolved BusinessId={BusinessId} for display_phone_number={RawBiz}\",\n//        //                businessIdHit,\n//        //                rawBusinessNumber);\n//        //        }\n\n//        //        if (businessIdHit == null || businessIdHit == Guid.Empty)\n//        //        {\n//        //            logger.LogWarning(\n//        //                \"❌ Business not found for WhatsApp number: {Number} (normalized={Norm})\",\n//        //                rawBusinessNumber,\n//        //                cleanIncomingBiz);\n//        //            return;\n//        //        }\n\n//        //        var businessId = businessIdHit.Value;\n\n//        //        // 3) Find or create contact\n//        //        logger.LogInformation(\n//        //            \"👤 Inbound: resolving contact for BusinessId={BusinessId}, Phone={Phone}\",\n//        //            businessId,\n//        //            contactPhone);\n\n//        //        var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);\n//        //        if (contact == null)\n//        //        {\n//        //            logger.LogWarning(\"❌ Could not resolve contact for phone: {Phone}\", contactPhone);\n//        //            return;\n//        //        }\n\n//        //        logger.LogInformation(\"✅ Inbound: contact resolved. ContactId={ContactId}\", contact.Id);\n\n//        //        // Extract profile name (contacts[0].profile.name) and upsert into Contacts\n//        //        static string? TryGetProfileName(JsonElement root)\n//        //        {\n//        //            if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n//        //                contactsEl.ValueKind == JsonValueKind.Array &&\n//        //                contactsEl.GetArrayLength() > 0)\n//        //            {\n//        //                var c0 = contactsEl[0];\n//        //                if (c0.TryGetProperty(\"profile\", out var prof) &&\n//        //                    prof.ValueKind == JsonValueKind.Object &&\n//        //                    prof.TryGetProperty(\"name\", out var nm) &&\n//        //                    nm.ValueKind == JsonValueKind.String)\n//        //                {\n//        //                    var n = nm.GetString();\n//        //                    return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n//        //                }\n//        //            }\n//        //            return null;\n//        //        }\n\n//        //        var profileName = TryGetProfileName(value);\n//        //        if (!string.IsNullOrWhiteSpace(profileName))\n//        //        {\n//        //            try\n//        //            {\n//        //                logger.LogInformation(\n//        //                    \"🧾 Inbound: upserting profile name for BusinessId={BusinessId}, Phone={Phone}, Name={Name}\",\n//        //                    businessId,\n//        //                    contactPhone,\n//        //                    profileName);\n\n//        //                await contactProfileService.UpsertProfileNameAsync(\n//        //                    businessId,\n//        //                    contactPhone,\n//        //                    profileName!,\n//        //                    CancellationToken.None);\n//        //            }\n//        //            catch (Exception ex)\n//        //            {\n//        //                logger.LogWarning(ex, \"⚠️ Failed to upsert ProfileName for {Phone}\", contactPhone);\n//        //            }\n//        //        }\n\n//        //        // 4) Check chat mode…\n//        //        var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);\n//        //        var isAgentMode = mode == \"agent\";\n\n//        //        logger.LogInformation(\n//        //            \"💬 Inbound: chat mode for contact {ContactId} is '{Mode}' (isAgentMode={IsAgentMode})\",\n//        //            contact.Id,\n//        //            mode,\n//        //            isAgentMode);\n\n//        //        // 5) Log incoming message\n//        //        var messageLog = new MessageLog\n//        //        {\n//        //            Id = Guid.NewGuid(),\n//        //            BusinessId = businessId,\n//        //            ContactId = contact.Id,\n//        //            RecipientNumber = contactPhone,\n//        //            MessageContent = content,\n//        //            Status = \"received\",\n//        //            CreatedAt = DateTime.UtcNow,\n//        //            SentAt = DateTime.UtcNow,\n//        //            IsIncoming = true\n//        //        };\n\n//        //        db.MessageLogs.Add(messageLog);\n//        //        await db.SaveChangesAsync();\n\n//        //        logger.LogInformation(\n//        //            \"📝 Inbound: MessageLog saved. MessageLogId={MessageLogId}, BusinessId={BusinessId}, ContactId={ContactId}\",\n//        //            messageLog.Id,\n//        //            businessId,\n//        //            contact.Id);\n\n//        //        // 6) Notify Inbox clients via SignalR\n//        //        try\n//        //        {\n//        //            var groupName = $\"business_{businessId}\";\n//        //            logger.LogInformation(\n//        //                \"📡 Inbound: broadcasting ReceiveInboxMessage to SignalR group {GroupName} for ContactId={ContactId}\",\n//        //                groupName,\n//        //                contact.Id);\n\n//        //            await _hub.Clients\n//        //                .Group(groupName)\n//        //                .SendAsync(\"ReceiveInboxMessage\", new\n//        //                {\n//        //                    contactId = contact.Id,\n//        //                    message = messageLog.MessageContent,\n//        //                    isIncoming = true,\n//        //                    senderId = (Guid?)null,\n//        //                    sentAt = messageLog.CreatedAt\n//        //                });\n//        //        }\n//        //        catch (Exception ex)\n//        //        {\n//        //            logger.LogWarning(ex, \"⚠️ Inbound: failed to broadcast ReceiveInboxMessage to SignalR.\");\n//        //        }\n\n//        //        // 7) Try to trigger automation by keyword\n//        //        try\n//        //        {\n//        //            var triggerKeyword = (content ?? string.Empty).Trim().ToLowerInvariant();\n//        //            logger.LogInformation(\n//        //                \"⚙️ Inbound: attempting automation flow match for keyword='{Keyword}'\",\n//        //                triggerKeyword);\n\n//        //            var handled = await automationService.TryRunFlowByKeywordAsync(\n//        //                businessId,\n//        //                triggerKeyword,\n//        //                contact.PhoneNumber,\n//        //                sourceChannel: \"whatsapp\",\n//        //                industryTag: \"default\");\n\n//        //            if (!handled)\n//        //                logger.LogInformation(\"🕵️ No automation flow matched keyword: {Keyword}\", triggerKeyword);\n//        //            else\n//        //                logger.LogInformation(\"✅ Automation flow handled inbound keyword: {Keyword}\", triggerKeyword);\n//        //        }\n//        //        catch (Exception ex)\n//        //        {\n//        //            logger.LogError(ex, \"❌ Automation flow execution failed.\");\n//        //        }\n\n//        //        // 8) Sync to inbox only if agent mode\n//        //        if (isAgentMode)\n//        //        {\n//        //            try\n//        //            {\n//        //                var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n\n//        //                logger.LogInformation(\n//        //                    \"📥 Inbound: syncing message to inbox for BusinessId={BusinessId}, ContactId={ContactId}\",\n//        //                    businessId,\n//        //                    contact.Id);\n\n//        //                await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n//        //                {\n//        //                    BusinessId = businessId,\n//        //                    ContactId = contact.Id,\n//        //                    RecipientPhone = contact.PhoneNumber,\n//        //                    MessageBody = messageLog.MessageContent,\n//        //                    IsIncoming = true,\n//        //                    Status = messageLog.Status,\n//        //                    SentAt = messageLog.CreatedAt\n//        //                });\n\n//        //                logger.LogInformation(\"✅ Message synced to inbox for contact {Phone}\", contactPhone);\n//        //            }\n//        //            catch (Exception ex)\n//        //            {\n//        //                logger.LogError(ex, \"❌ Failed to sync inbound message to inbox.\");\n//        //            }\n//        //        }\n//        //        else\n//        //        {\n//        //            logger.LogInformation(\"🚫 Skipping inbox sync: chat mode is not 'agent'\");\n//        //        }\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        _logger.LogError(ex, \"❌ Failed to process inbound WhatsApp chat.\");\n//        //    }\n//        //}\n\n//        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)\n//        {\n//            _logger.LogInformation(\"💬 InboundMessageProcessor.ProcessInteractiveAsync started.\");\n\n//            using var scope = _serviceScopeFactory.CreateScope();\n//            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n//            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n//            static string Normalize(string? number) =>\n//                string.IsNullOrWhiteSpace(number) ? \"\" : new string(number.Where(char.IsDigit).ToArray());\n\n//            // Safe extract of profile name (Meta Cloud shape)\n//            static string? TryGetProfileName(JsonElement root)\n//            {\n//                if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n//                    contactsEl.ValueKind == JsonValueKind.Array &&\n//                    contactsEl.GetArrayLength() > 0)\n//                {\n//                    var c0 = contactsEl[0];\n//                    if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n//                        profileEl.ValueKind == JsonValueKind.Object &&\n//                        profileEl.TryGetProperty(\"name\", out var nameEl) &&\n//                        nameEl.ValueKind == JsonValueKind.String)\n//                    {\n//                        var n = nameEl.GetString();\n//                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n//                    }\n//                }\n//                return null;\n//            }\n\n//            // messages[0].from is always present for interactive/button\n//            if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n//            {\n//                logger.LogWarning(\"❌ Interactive payload has no 'messages' array or it is empty.\");\n//                return;\n//            }\n\n//            var msg0 = msgs[0];\n//            var fromRaw = msg0.GetProperty(\"from\").GetString() ?? \"\";\n//            var fromE164 = Normalize(fromRaw);\n\n//            logger.LogInformation(\n//                \"🔎 Interactive: fromRaw={FromRaw}, normalized={FromNorm}\",\n//                fromRaw,\n//                fromE164);\n\n//            // Resolve Business via metadata.display_phone_number → WhatsAppPhoneNumbers\n//            if (!value.TryGetProperty(\"metadata\", out var metadata))\n//            {\n//                logger.LogWarning(\"❌ Interactive payload missing 'metadata' field.\");\n//                return;\n//            }\n\n//            var displayNumberRaw = metadata.GetProperty(\"display_phone_number\").GetString() ?? \"\";\n//            var displayNumber = Normalize(displayNumberRaw);\n\n//            logger.LogInformation(\n//                \"🔎 Interactive: display_phone_number raw={Raw}, normalized={Norm}\",\n//                displayNumberRaw,\n//                displayNumber);\n\n//            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers\n//            var candidates = await db.WhatsAppPhoneNumbers\n//                .AsNoTracking()\n//                .Where(n => n.IsActive)\n//                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n//                .ToListAsync(ct);\n\n//            logger.LogDebug(\"📊 Interactive: Loaded {Count} active WhatsAppPhoneNumbers candidates.\", candidates.Count);\n\n//            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);\n//            if (numHit == null)\n//            {\n//                logger.LogWarning(\n//                    \"❌ Business not found for interactive webhook number: {NumRaw} (normalized={Norm})\",\n//                    displayNumberRaw,\n//                    displayNumber);\n//                return;\n//            }\n\n//            var businessId = numHit.BusinessId;\n//            logger.LogInformation(\n//                \"✅ Interactive: resolved BusinessId={BusinessId} for number={NumRaw}\",\n//                businessId,\n//                displayNumberRaw);\n\n//            // Upsert profile name if present\n//            var profileName = TryGetProfileName(value);\n//            if (!string.IsNullOrWhiteSpace(profileName))\n//            {\n//                try\n//                {\n//                    logger.LogInformation(\n//                        \"🧾 Interactive: upserting profile name for BusinessId={BusinessId}, Phone={Phone}, Name={Name}\",\n//                        businessId,\n//                        fromE164,\n//                        profileName);\n\n//                    await contactProfileService.UpsertProfileNameAsync(\n//                        businessId,\n//                        fromE164,\n//                        profileName!,\n//                        ct);\n//                }\n//                catch (Exception ex)\n//                {\n//                    logger.LogWarning(\n//                        ex,\n//                        \"⚠️ Failed to upsert ProfileName on interactive webhook for {Phone}\",\n//                        fromE164);\n//                }\n//            }\n\n//            // … your existing interactive handling continues (routing to next step, etc.)\n//        }\n//    }\n//}\n\n\n////using System;\n////using System.Text.Json;\n////using System.Threading.Tasks;\n////using Microsoft.AspNetCore.SignalR;\n////using Microsoft.EntityFrameworkCore;\n////using Microsoft.Extensions.Logging;\n////using xbytechat.api;\n////using xbytechat.api.Features.Inbox.DTOs;\n////using xbytechat.api.CRM.Models;\n////using xbytechat.api.Features.Inbox.Hubs;\n////using Microsoft.Extensions.DependencyInjection;\n////using xbytechat.api.CRM.Interfaces;\n////using xbytechat.api.Features.AutoReplyBuilder.Services;\n////using xbytechat.api.Features.Inbox.Services;\n////using xbytechat.api.Features.MessagesEngine.DTOs;\n////using xbytechat.api.Features.MessagesEngine.Services;\n////using xbytechat.api.CRM.Services;\n////using xbytechat.api.Features.Automation.Services;\n////using xbytechat.api.Features.Contacts.Services;\n\n\n////namespace xbytechat.api.Features.Webhooks.Services.Processors\n////{\n////    public class InboundMessageProcessor : IInboundMessageProcessor\n////    {\n////        private readonly AppDbContext _context;\n////        private readonly IHubContext<InboxHub> _hubContext;\n////        private readonly ILogger<InboundMessageProcessor> _logger;\n////        private readonly IInboxService _inboxService;\n////        private readonly IServiceScopeFactory _serviceScopeFactory;\n////        private readonly IHubContext<InboxHub> _hub;\n////        private readonly IContactProfileService _contactProfile;\n////        public InboundMessageProcessor(\n////            AppDbContext context,\n////            IHubContext<InboxHub> hubContext,\n////            ILogger<InboundMessageProcessor> logger,\n////            IInboxService inboxService,\n////            IServiceScopeFactory serviceScopeFactory,\n////            IHubContext<InboxHub> hub, IContactProfileService contactProfile)\n////        {\n////            _context = context;\n////            _hubContext = hubContext;\n////            _logger = logger;\n////            _inboxService = inboxService;\n////            _serviceScopeFactory = serviceScopeFactory;\n////            _hub = hub;\n////            _contactProfile = contactProfile;\n////        }\n\n////        public async Task ProcessChatAsync(JsonElement value)\n////        {\n////            try\n////            {\n////                using var scope = _serviceScopeFactory.CreateScope();\n////                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n////                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n////                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n////                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n////                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n////                var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n\n////                // digits-only normalizer (matches how we store/search phones)\n////                static string Normalize(string? s) =>\n////                    string.IsNullOrWhiteSpace(s) ? \"\" : new string(s.Where(char.IsDigit).ToArray());\n\n////                // 1) Extract WA metadata + message (Meta Cloud shape)\n////                var msg = value.GetProperty(\"messages\")[0];\n////                var rawContactPhone = msg.GetProperty(\"from\").GetString() ?? \"\";\n////                var contactPhone = Normalize(rawContactPhone);\n////                var content = msg.TryGetProperty(\"text\", out var t) && t.TryGetProperty(\"body\", out var b) ? b.GetString() : null;\n\n////                var rawBusinessNumber = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString() ?? \"\";\n////                var cleanIncomingBiz = Normalize(rawBusinessNumber);\n\n////                // 2) Resolve business  ✅ now via WhatsAppPhoneNumbers (NOT WhatsAppSettings)\n////                Guid? businessIdHit = null;\n\n////                // Pull active numbers (small table; client-side normalization for reliability)\n////                var candidates = await db.WhatsAppPhoneNumbers\n////                    .AsNoTracking()\n////                    .Where(n => n.IsActive)\n////                    .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n////                    .ToListAsync();\n\n////                var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == cleanIncomingBiz);\n////                if (numHit != null) businessIdHit = numHit.BusinessId;\n\n////                if (businessIdHit == null || businessIdHit == Guid.Empty)\n////                {\n////                    logger.LogWarning(\"❌ Business not found for WhatsApp number: {Number}\", rawBusinessNumber);\n////                    return;\n////                }\n\n////                var businessId = businessIdHit.Value;\n\n////                // 3) Find or create contact\n////                var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);\n////                if (contact == null)\n////                {\n////                    logger.LogWarning(\"❌ Could not resolve contact for phone: {Phone}\", contactPhone);\n////                    return;\n////                }\n\n////                // Extract profile name (contacts[0].profile.name) and upsert into Contacts\n////                static string? TryGetProfileName(JsonElement root)\n////                {\n////                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n////                        contactsEl.ValueKind == JsonValueKind.Array &&\n////                        contactsEl.GetArrayLength() > 0)\n////                    {\n////                        var c0 = contactsEl[0];\n////                        if (c0.TryGetProperty(\"profile\", out var prof) &&\n////                            prof.ValueKind == JsonValueKind.Object &&\n////                            prof.TryGetProperty(\"name\", out var nm) &&\n////                            nm.ValueKind == JsonValueKind.String)\n////                        {\n////                            var n = nm.GetString();\n////                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n////                        }\n////                    }\n////                    return null;\n////                }\n\n////                var profileName = TryGetProfileName(value);\n////                if (!string.IsNullOrWhiteSpace(profileName))\n////                {\n////                    try\n////                    {\n////                        await contactProfileService.UpsertProfileNameAsync(businessId, contactPhone, profileName!, CancellationToken.None);\n////                    }\n////                    catch (Exception ex)\n////                    {\n////                        logger.LogWarning(ex, \"⚠️ Failed to upsert ProfileName for {Phone}\", contactPhone);\n////                    }\n////                }\n\n////                // 4) Check chat mode…\n////                var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);\n////                var isAgentMode = mode == \"agent\";\n\n////                // 5) Log incoming message\n////                var messageLog = new MessageLog\n////                {\n////                    Id = Guid.NewGuid(),\n////                    BusinessId = businessId,\n////                    ContactId = contact.Id,\n////                    RecipientNumber = contactPhone,\n////                    MessageContent = content,\n////                    Status = \"received\",\n////                    CreatedAt = DateTime.UtcNow,\n////                    SentAt = DateTime.UtcNow,\n////                    IsIncoming = true\n////                };\n\n////                db.MessageLogs.Add(messageLog);\n////                await db.SaveChangesAsync();\n\n////                await _hub.Clients\n////                    .Group($\"business_{businessId}\")\n////                    .SendAsync(\"ReceiveInboxMessage\", new\n////                    {\n////                        contactId = contact.Id,\n////                        message = messageLog.MessageContent,\n////                        isIncoming = true,\n////                        senderId = (Guid?)null,\n////                        sentAt = messageLog.CreatedAt\n////                    });\n\n////                // 6) Try to trigger automation by keyword\n////                try\n////                {\n////                    var triggerKeyword = (content ?? string.Empty).Trim().ToLowerInvariant();\n////                    var handled = await automationService.TryRunFlowByKeywordAsync(\n////                        businessId,\n////                        triggerKeyword,\n////                        contact.PhoneNumber,\n////                        sourceChannel: \"whatsapp\",\n////                        industryTag: \"default\");\n\n////                    if (!handled)\n////                        logger.LogInformation(\"🕵️ No automation flow matched keyword: {Keyword}\", triggerKeyword);\n////                }\n////                catch (Exception ex)\n////                {\n////                    logger.LogError(ex, \"❌ Automation flow execution failed.\");\n////                }\n\n////                // 7) Sync to inbox only if agent mode\n////                if (isAgentMode)\n////                {\n////                    var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n////                    await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n////                    {\n////                        BusinessId = businessId,\n////                        ContactId = contact.Id,\n////                        RecipientPhone = contact.PhoneNumber,\n////                        MessageBody = messageLog.MessageContent,\n////                        IsIncoming = true,\n////                        Status = messageLog.Status,\n////                        SentAt = messageLog.CreatedAt\n////                    });\n\n////                    logger.LogInformation(\"📥 Message synced to inbox for contact {Phone}\", contactPhone);\n////                }\n////                else\n////                {\n////                    logger.LogInformation(\"🚫 Skipping inbox sync: chat mode is not 'agent'\");\n////                }\n////            }\n////            catch (Exception ex)\n////            {\n////                _logger.LogError(ex, \"❌ Failed to process inbound WhatsApp chat.\");\n////            }\n////        }\n\n////        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)\n////        {\n////            using var scope = _serviceScopeFactory.CreateScope();\n////            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n////            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n////            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n////            static string Normalize(string? number) =>\n////                string.IsNullOrWhiteSpace(number) ? \"\" : new string(number.Where(char.IsDigit).ToArray());\n\n////            // Safe extract of profile name (Meta Cloud shape)\n////            static string? TryGetProfileName(JsonElement root)\n////            {\n////                if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n////                    contactsEl.ValueKind == JsonValueKind.Array &&\n////                    contactsEl.GetArrayLength() > 0)\n////                {\n////                    var c0 = contactsEl[0];\n////                    if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n////                        profileEl.ValueKind == JsonValueKind.Object &&\n////                        profileEl.TryGetProperty(\"name\", out var nameEl) &&\n////                        nameEl.ValueKind == JsonValueKind.String)\n////                    {\n////                        var n = nameEl.GetString();\n////                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n////                    }\n////                }\n////                return null;\n////            }\n\n////            // messages[0].from is always present for interactive/button\n////            if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n////                return;\n\n////            var msg0 = msgs[0];\n////            var fromRaw = msg0.GetProperty(\"from\").GetString() ?? \"\";\n////            var fromE164 = Normalize(fromRaw);\n\n////            // Resolve Business via metadata.display_phone_number → WhatsAppPhoneNumbers\n////            var displayNumberRaw = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString() ?? \"\";\n////            var displayNumber = Normalize(displayNumberRaw);\n\n////            // Look up the business by matching the normalized number in WhatsAppPhoneNumbers\n////            var candidates = await db.WhatsAppPhoneNumbers\n////                .AsNoTracking()\n////                .Where(n => n.IsActive)\n////                .Select(n => new { n.BusinessId, n.WhatsAppBusinessNumber })\n////                .ToListAsync(ct);\n\n////            var numHit = candidates.FirstOrDefault(n => Normalize(n.WhatsAppBusinessNumber) == displayNumber);\n////            if (numHit == null)\n////            {\n////                logger.LogWarning(\"❌ Business not found for interactive webhook number: {Num}\", displayNumberRaw);\n////                return;\n////            }\n\n////            var businessId = numHit.BusinessId;\n\n////            // Upsert profile name if present\n////            var profileName = TryGetProfileName(value);\n////            if (!string.IsNullOrWhiteSpace(profileName))\n////            {\n////                try\n////                {\n////                    await contactProfileService.UpsertProfileNameAsync(businessId, fromE164, profileName!, ct);\n////                }\n////                catch (Exception ex)\n////                {\n////                    logger.LogWarning(ex, \"⚠️ Failed to upsert ProfileName on interactive webhook for {Phone}\", fromE164);\n////                }\n////            }\n\n////            // … continue your existing interactive handling (routing to next step, etc.)\n////        }\n\n////    }\n////}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IStatusWebhookProcessor.cs",
      "sha256": "4a20eff4b49cd6b4a448445b156c4cab5024becc931566b1cba6d9c5c4e4d89f",
      "language": "csharp",
      "size": 275,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IStatusWebhookProcessor\n    {\n        Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default);\n    }\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ITemplateWebhookProcessor.cs",
      "sha256": "6f04b24d675a88073c59204ed241e4744205e80e8d488dd464550a6105c45b7a",
      "language": "csharp",
      "size": 242,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface ITemplateWebhookProcessor\n    {\n        Task ProcessTemplateUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/StatusWebhookProcessor.cs",
      "sha256": "8dbca3bd505a7a12bd18166688de1e4762c7c6ad5afdc5aa37cfb6789c8018f5",
      "language": "csharp",
      "size": 17950,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\n// 👇 where your AppDbContext lives\nusing xbytechat.api;\n\nusing xbytechat.api.Features.CampaignTracking.Models;   // CampaignSendLog\nusing xbytechat.api.Features.MessageManagement.DTOs;    // MessageLog\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Features.Webhooks.Status;\nusing xbytechat.api.Infrastructure.Observability;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    /// <summary>\n    /// Legacy status processor (back-compat).\n    /// - Extracts statuses from the payload\n    /// - Resolves CampaignSendLog via IMessageIdResolver when possible\n    /// - Updates CampaignSendLog / MessageLog idempotently\n    /// New provider-aware flow should go through the dispatcher -> WhatsAppWebhookService.\n    /// </summary>\n    public class StatusWebhookProcessor : IStatusWebhookProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<StatusWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly IMessageStatusUpdater _updater;\n        public StatusWebhookProcessor(\n            AppDbContext context,\n            ILogger<StatusWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            IMessageStatusUpdater updater)\n        {\n            _context = context;\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _updater = updater;\n        }\n\n        /// <summary>\n        /// Entry point from dispatcher (legacy path).\n        /// Normalizes Meta envelope to a \"value\" object, then processes.\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default)\n        {\n            _logger.LogDebug(\"status_webhook_in (legacy)\\n{Payload}\", payload.ToString());\n\n            // 0) Batch payloads: recurse per item\n            if (payload.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var item in payload.EnumerateArray())\n                    await ProcessStatusUpdateAsync(item, ct);\n                return;\n            }\n\n            // 1) Canonical Meta envelope: { entry:[{ changes:[{ value:{...} }]}] }\n            if (payload.ValueKind == JsonValueKind.Object &&\n                payload.TryGetProperty(\"entry\", out var entry) &&\n                entry.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var e in entry.EnumerateArray())\n                {\n                    if (e.TryGetProperty(\"changes\", out var changes) && changes.ValueKind == JsonValueKind.Array)\n                    {\n                        foreach (var ch in changes.EnumerateArray())\n                        {\n                            if (ch.TryGetProperty(\"value\", out var v))\n                                await ProcessAsync(v.GetRawText(), ct); // <- pass string + ct\n                        }\n                    }\n                }\n                return;\n            }\n\n            // 2) Envelope → value via helper (back-compat)\n            if (TryExtractValue(payload, out var value))\n            {\n                await ProcessAsync(value.GetRawText(), ct);            // <- pass string + ct\n                return;\n            }\n\n            // 3) Already value-like (adapter flattened)\n            if (payload.ValueKind == JsonValueKind.Object &&\n                (payload.TryGetProperty(\"statuses\", out _) || payload.TryGetProperty(\"messages\", out _)))\n            {\n                await ProcessAsync(payload.GetRawText(), ct);          // <- pass string + ct\n                return;\n            }\n\n            // 4) Minimal single-status object (id/status)\n            if (payload.ValueKind == JsonValueKind.Object &&\n                payload.TryGetProperty(\"id\", out _) &&\n                payload.TryGetProperty(\"status\", out _))\n            {\n                await ProcessAsync(payload.GetRawText(), ct);          // <- pass string + ct\n                return;\n            }\n\n            _logger.LogWarning(\"Unrecognized status payload shape (legacy path).\");\n            MetricsRegistry.MessagesFailed.Add(1);\n        }\n\n        /// <summary>\n        /// Extract statuses from a Meta-like \"value\" object and update DB.\n        /// </summary>\n        //public async Task ProcessAsync(JsonElement value)\n        //{\n        //    if (!value.TryGetProperty(\"statuses\", out var statuses) || statuses.ValueKind != JsonValueKind.Array)\n        //    {\n        //        _logger.LogWarning(\"⚠️ 'statuses' array missing in webhook payload (legacy path).\");\n        //        return;\n        //    }\n\n        //    foreach (var status in statuses.EnumerateArray())\n        //    {\n        //        if (status.ValueKind != JsonValueKind.Object) continue;\n\n        //        // message id (WAMID)\n        //        var messageId = status.TryGetProperty(\"id\", out var idEl) && idEl.ValueKind == JsonValueKind.String\n        //            ? idEl.GetString()\n        //            : null;\n\n        //        // status text\n        //        var statusText = status.TryGetProperty(\"status\", out var stEl) && stEl.ValueKind == JsonValueKind.String\n        //            ? stEl.GetString()\n        //            : null;\n\n        //        if (string.IsNullOrWhiteSpace(messageId) || string.IsNullOrWhiteSpace(statusText))\n        //        {\n        //            _logger.LogWarning(\"⚠️ Missing messageId or status in webhook payload (legacy path).\");\n        //            continue;\n        //        }\n\n        //        // timestamp (string or number)\n        //        DateTime? eventTime = null;\n        //        if (status.TryGetProperty(\"timestamp\", out var tsEl))\n        //        {\n        //            if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var epochS))\n        //                eventTime = DateTimeOffset.FromUnixTimeSeconds(epochS).UtcDateTime;\n        //            else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var epochN))\n        //                eventTime = DateTimeOffset.FromUnixTimeSeconds(epochN).UtcDateTime;\n        //        }\n\n        //        _logger.LogDebug(\"🕓 Parsed timestamp: {Time} (raw kind={Kind})\",\n        //            eventTime?.ToString(\"o\") ?? \"n/a\", status.TryGetProperty(\"timestamp\", out var tsDbg) ? tsDbg.ValueKind.ToString() : \"n/a\");\n\n        //        // ✅ First try resolving a CampaignSendLog row via resolver\n        //        Guid? sendLogId = null;\n        //        try\n        //        {\n        //            sendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n        //        }\n        //        catch (Exception ex)\n        //        {\n        //            _logger.LogWarning(ex, \"MessageId resolver failed for {MessageId}\", messageId);\n        //        }\n\n        //        if (sendLogId is Guid sid)\n        //        {\n        //            var log = await _context.Set<CampaignSendLog>()\n        //                                    .FirstOrDefaultAsync(l => l.Id == sid);\n\n        //            if (log != null)\n        //            {\n        //                bool changed = false;\n\n        //                var newStatus = MapMetaStatus(statusText);\n        //                if (!string.IsNullOrEmpty(newStatus) &&\n        //                    !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))\n        //                {\n        //                    log.SendStatus = newStatus;\n        //                    changed = true;\n        //                }\n\n        //                if (statusText == \"sent\" && (log.SentAt == null || log.SentAt == default) && eventTime.HasValue)\n        //                {\n        //                    log.SentAt = eventTime.Value;\n        //                    changed = true;\n        //                }\n        //                if (statusText == \"delivered\" && (log.DeliveredAt == null || log.DeliveredAt == default) && eventTime.HasValue)\n        //                {\n        //                    log.DeliveredAt = eventTime.Value;\n        //                    changed = true;\n        //                }\n        //                if (statusText == \"read\" && (log.ReadAt == null || log.ReadAt == default) && eventTime.HasValue)\n        //                {\n        //                    log.ReadAt = eventTime.Value;\n        //                    changed = true;\n        //                }\n\n        //                if (changed)\n        //                {\n        //                    await _context.SaveChangesAsync();\n        //                    _logger.LogInformation(\"✅ CampaignSendLog updated (legacy) for MessageId: {MessageId} → {Status}\", messageId, newStatus ?? statusText);\n        //                }\n        //                else\n        //                {\n        //                    _logger.LogInformation(\"🔁 Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)\", statusText, messageId);\n        //                }\n\n        //                continue; // done with this status item\n        //            }\n        //        }\n\n        //        // 🔁 Fallback: update MessageLog when there’s no CampaignSendLog\n        //        var msg = await _context.Set<MessageLog>()\n        //                                .FirstOrDefaultAsync(m => m.MessageId == messageId);\n\n        //        if (msg != null)\n        //        {\n        //            bool changed = false;\n\n        //            switch (statusText)\n        //            {\n        //                case \"sent\":\n        //                    if (!EqualsIgnoreCase(msg.Status, \"Sent\"))\n        //                    {\n        //                        msg.Status = \"Sent\";\n        //                        changed = true;\n        //                    }\n        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n        //                    {\n        //                        msg.SentAt = eventTime.Value;\n        //                        changed = true;\n        //                    }\n        //                    break;\n\n        //                case \"delivered\":\n        //                    // no DeliveredAt column on MessageLog; just progression\n        //                    if (!EqualsIgnoreCase(msg.Status, \"Read\") &&\n        //                        !EqualsIgnoreCase(msg.Status, \"Delivered\"))\n        //                    {\n        //                        msg.Status = \"Delivered\";\n        //                        changed = true;\n        //                    }\n        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n        //                    {\n        //                        msg.SentAt = eventTime.Value; // ensure SentAt eventually set\n        //                        changed = true;\n        //                    }\n        //                    break;\n\n        //                case \"read\":\n        //                    if (!EqualsIgnoreCase(msg.Status, \"Read\"))\n        //                    {\n        //                        msg.Status = \"Read\";\n        //                        changed = true;\n        //                    }\n        //                    if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n        //                    {\n        //                        msg.SentAt = eventTime.Value;\n        //                        changed = true;\n        //                    }\n        //                    break;\n\n        //                default:\n        //                    // leave as-is for unknown statuses\n        //                    break;\n        //            }\n\n        //            if (changed)\n        //            {\n        //                await _context.SaveChangesAsync();\n        //                _logger.LogInformation(\"ℹ️ MessageLog updated (legacy) for MessageId: {MessageId} → {Status}\", messageId, msg.Status);\n        //            }\n        //            else\n        //            {\n        //                _logger.LogInformation(\"🔁 Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)\", statusText, messageId);\n        //            }\n        //        }\n        //        else\n        //        {\n        //            // lower severity; common when a send failed before obtaining a message id\n        //            _logger.LogInformation(\"ⓘ No matching CampaignSendLog/MessageLog for MessageId: {MessageId} (legacy)\", messageId);\n        //        }\n        //    }\n        //}\n        public sealed class MetaStatusEnvelope\n        {\n            public Entry[]? entry { get; set; }\n            public sealed class Entry { public Change[]? changes { get; set; } }\n            public sealed class Change { public Value? value { get; set; } }\n            public sealed class Value { public Status[]? statuses { get; set; } }\n            public sealed class Status\n            {\n                public string? id { get; set; }          // WAMID\n                public string? status { get; set; }      // sent|delivered|read|failed\n                public long? timestamp { get; set; }     // epoch seconds\n                public StatusError[]? errors { get; set; }\n            }\n            public sealed class StatusError { public string? message { get; set; } public string? code { get; set; } }\n        }\n\n        // Fallback \"simple\" event for manual tests/tools\n        public sealed class SimpleStatusEvent\n        {\n            public string? MessageId { get; set; }\n            public string? Status { get; set; }\n            public long? Timestamp { get; set; }\n            public string? ErrorMessage { get; set; }\n        }\n\n      \n                // make sure this is injected too\n\n        public async Task<int> ProcessAsync(string rawJson, CancellationToken ct)\n        {\n            // Try Meta-like envelope first\n            try\n            {\n                var env = System.Text.Json.JsonSerializer.Deserialize<MetaStatusEnvelope>(rawJson);\n                if (env?.entry is { Length: > 0 })\n                {\n                    var total = 0;\n                    foreach (var e in env.entry)\n                        foreach (var ch in e.changes ?? Array.Empty<MetaStatusEnvelope.Change>())\n                            foreach (var st in ch.value?.statuses ?? Array.Empty<MetaStatusEnvelope.Status>())\n                            {\n                                var providerMsgId = st.id ?? string.Empty;\n                                var wamid = await _messageIdResolver.ResolveAsync(providerMsgId, ct) ?? providerMsgId; // no-op if already WAMID\n                                var status = (st.status ?? \"\").Trim().ToLowerInvariant();\n                                var ts = st.timestamp.HasValue\n                                    ? DateTimeOffset.FromUnixTimeSeconds(st.timestamp.Value).UtcDateTime\n                                    : DateTime.UtcNow;\n                                var err = st.errors?.FirstOrDefault()?.message;\n\n                                if (!string.IsNullOrWhiteSpace(wamid) && !string.IsNullOrWhiteSpace(status))\n                                {\n                                    total += await _updater.UpdateAsync(wamid, status, ts, err, ct);\n                                }\n                            }\n                    return total;\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogWarning(ex, \"[StatusWebhookProcessor] Meta envelope parse failed; trying simple shape.\");\n            }\n\n            // Fallback: simple shape (handy for cURL testing)\n            try\n            {\n                var ev = System.Text.Json.JsonSerializer.Deserialize<SimpleStatusEvent>(rawJson);\n                if (ev?.MessageId is not null && ev.Status is not null)\n                {\n                    var ts = ev.Timestamp.HasValue\n                        ? DateTimeOffset.FromUnixTimeSeconds(ev.Timestamp.Value).UtcDateTime\n                        : DateTime.UtcNow;\n                    return await _updater.UpdateAsync(ev.MessageId, ev.Status, ts, ev.ErrorMessage, ct);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"[StatusWebhookProcessor] Simple shape parse failed\");\n            }\n\n            _logger.LogWarning(\"[StatusWebhookProcessor] Unsupported payload\");\n            return 0;\n        }\n\n        // ----------------- helpers -----------------\n\n        private static bool TryExtractValue(JsonElement payload, out JsonElement value)\n        {\n            value = default;\n            if (payload.ValueKind != JsonValueKind.Object) return false;\n            if (!payload.TryGetProperty(\"entry\", out var entry) || entry.ValueKind != JsonValueKind.Array || entry.GetArrayLength() == 0) return false;\n\n            var e0 = entry[0];\n            if (!e0.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0) return false;\n\n            var c0 = changes[0];\n            if (!c0.TryGetProperty(\"value\", out var v) || v.ValueKind != JsonValueKind.Object) return false;\n\n            value = v;\n            return true;\n        }\n\n        private static string? MapMetaStatus(string? s) =>\n            (s ?? \"\").ToLowerInvariant() switch\n            {\n                \"sent\" => \"Sent\",\n                \"delivered\" => \"Delivered\",\n                \"read\" => \"Read\",\n                \"failed\" => \"Failed\",\n                \"deleted\" => \"Deleted\",\n                _ => null\n            };\n\n        private static bool EqualsIgnoreCase(string? a, string? b) =>\n            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/TemplateWebhookProcessor.cs",
      "sha256": "0dbe7873fcf7b84d3a4fb9d78bda6689d86cbfd4d9fd50ce1d98029aaaef0558",
      "language": "csharp",
      "size": 1391,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class TemplateWebhookProcessor : ITemplateWebhookProcessor\n    {\n        private readonly ILogger<TemplateWebhookProcessor> _logger;\n\n        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task ProcessTemplateUpdateAsync(JsonElement payload)\n        {\n            try\n            {\n                var entry = payload.GetProperty(\"entry\")[0];\n                var changes = entry.GetProperty(\"changes\")[0];\n                var value = changes.GetProperty(\"value\");\n\n                var eventType = value.GetProperty(\"event\").GetString();\n                var templateId = value.TryGetProperty(\"message_template_id\", out var idProp)\n                                 ? idProp.GetString() : \"(unknown)\";\n\n                _logger.LogInformation($\"🧾 Template Event Received: {eventType} for ID: {templateId}\");\n\n                // 🧠 You can store in DB or show in admin logs in the future\n\n                await Task.CompletedTask;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to process template webhook update.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/IMessageIdResolver.cs",
      "sha256": "b7b826aacb41d60aaa63c0a5c7350a4384eeb07af18d899fb8199afe7e9ef3d9",
      "language": "csharp",
      "size": 463,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public interface IMessageIdResolver\n    {\n        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);\n        Task<Guid?> ResolveMessageLogIdAsync(string messageId);\n        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);\n        Task<string?> ResolveAsync(string providerMessageId, CancellationToken ct = default);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/MessageIdResolver.cs",
      "sha256": "631816c0acf1e2bbc9d610ef2145f4ee80c89efd95d2abf8728ff32be09142e8",
      "language": "csharp",
      "size": 3838,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing Serilog;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public class MessageIdResolver : IMessageIdResolver\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageIdResolver> _logger;\n\n        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n        public async Task<string?> ResolveAsync(string providerMessageId, CancellationToken ct = default)\n        {\n            if (string.IsNullOrWhiteSpace(providerMessageId))\n                return null;\n\n            // 1) Already a WAMID? Return as-is.\n            if (providerMessageId.StartsWith(\"wamid.\", StringComparison.OrdinalIgnoreCase))\n                return providerMessageId;\n\n            // 2) Try MessageLogs mapping (most reliable)\n            //    We pick any field that looks like a WAMID if present; otherwise fall back to MessageId.\n            var mlHit = await _context.MessageLogs.AsNoTracking()\n                .Where(m => m.ProviderMessageId == providerMessageId || m.MessageId == providerMessageId)\n                .OrderByDescending(m => m.CreatedAt)\n                .Select(m =>\n                    m.ProviderMessageId.StartsWith(\"wamid.\", StringComparison.OrdinalIgnoreCase)\n                        ? m.ProviderMessageId\n                        : (m.MessageId ?? m.ProviderMessageId))\n                .FirstOrDefaultAsync(ct);\n\n            if (!string.IsNullOrEmpty(mlHit))\n                return mlHit;\n\n            // 3) Some paths write WAMID straight into CampaignSendLogs.MessageId (no mapping required)\n            var cslHit = await _context.CampaignSendLogs.AsNoTracking()\n                .Where(c => c.MessageId == providerMessageId)\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => c.MessageId)\n                .FirstOrDefaultAsync(ct);\n\n            if (!string.IsNullOrEmpty(cslHit))\n                return cslHit;\n\n            // 4) Fallback: return original (keeps pipeline flowing even if we can’t map)\n            _logger.LogDebug(\"MessageIdResolver: passthrough for provider id {ProviderMessageId}\", providerMessageId);\n            return providerMessageId;\n        }\n\n        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)\n        {\n            var log = await _context.CampaignSendLogs\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"⚠️ CampaignSendLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"⚠️ MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"⚠️ MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.BusinessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WebhookQueueService.cs",
      "sha256": "2d311701b4dcbde69080bf38449fde5e42e9f1aeb9138ba1735af41c8971caee",
      "language": "csharp",
      "size": 3691,
      "content": "using System.Text.Json;\nusing System.Threading.Channels;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WebhookQueueService : IWebhookQueueService\n    {\n        private readonly Channel<JsonElement> _queue;\n        private readonly ILogger<WebhookQueueService> _logger;\n\n        public WebhookQueueService(ILogger<WebhookQueueService> logger)\n        {\n            _logger = logger;\n\n            var options = new BoundedChannelOptions(5000)\n            {\n                FullMode = BoundedChannelFullMode.Wait,\n                SingleReader = true,\n                SingleWriter = false\n            };\n\n            _queue = Channel.CreateBounded<JsonElement>(options);\n\n            _logger.LogInformation(\n                \"✅ WebhookQueueService initialized with capacity {Capacity}, FullMode={FullMode}, SingleReader={SingleReader}, SingleWriter={SingleWriter}.\",\n                5000,\n                options.FullMode,\n                options.SingleReader,\n                options.SingleWriter\n            );\n        }\n\n        public void Enqueue(JsonElement item)\n        {\n            // Optional: log size instead of full content to avoid noisy logs\n            var length = item.ToString()?.Length ?? 0;\n\n            if (!_queue.Writer.TryWrite(item))\n            {\n                _logger.LogError(\n                    \"❌ Failed to enqueue webhook payload: queue is full. CurrentCount={Count}, PayloadLength={PayloadLength}.\",\n                    _queue.Reader.Count,\n                    length\n                );\n                throw new InvalidOperationException(\"⚠️ Webhook queue is full.\");\n            }\n\n            _logger.LogInformation(\n                \"📥 Enqueued webhook payload successfully. CurrentCount={Count}, PayloadLength={PayloadLength}.\",\n                _queue.Reader.Count,\n                length\n            );\n        }\n\n        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n        {\n            var item = await _queue.Reader.ReadAsync(cancellationToken);\n\n            // Again, just log length, not the full JSON, to keep logs readable\n            var length = item.ToString()?.Length ?? 0;\n\n            _logger.LogInformation(\n                \"📤 Dequeued webhook payload for processing. RemainingCount={Count}, PayloadLength={PayloadLength}.\",\n                _queue.Reader.Count,\n                length\n            );\n\n            return item;\n        }\n\n        public int GetQueueLength() => _queue.Reader.Count;\n    }\n}\n\n\n//using System.Text.Json;\n//using System.Threading.Channels;\n\n//namespace xbytechat.api.Features.Webhooks.Services\n//{\n//    public class WebhookQueueService : IWebhookQueueService\n//    {\n//        private readonly Channel<JsonElement> _queue;\n\n//        public WebhookQueueService()\n//        {\n//            var options = new BoundedChannelOptions(5000)\n//            {\n//                FullMode = BoundedChannelFullMode.Wait,\n//                SingleReader = true,\n//                SingleWriter = false\n//            };\n\n//            _queue = Channel.CreateBounded<JsonElement>(options);\n//        }\n\n//        public void Enqueue(JsonElement item)\n//        {\n//            if (!_queue.Writer.TryWrite(item))\n//            {\n//                throw new InvalidOperationException(\"⚠️ Webhook queue is full.\");\n//            }\n//        }\n\n//        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n//        {\n//            return await _queue.Reader.ReadAsync(cancellationToken);\n//        }\n\n//        public int GetQueueLength() => _queue.Reader.Count;\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookDispatcher.cs",
      "sha256": "e6fada25e39b363b0b7136d0997fba40cc2d1fd8347f8fb7a16f779172e7822b",
      "language": "csharp",
      "size": 34800,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Directory;\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n    {\n        // Removed legacy _statusProcessor on purpose\n        private readonly ITemplateWebhookProcessor _templateProcessor;\n        private readonly IClickWebhookProcessor _clickProcessor;\n        private readonly IInboundMessageProcessor _inboundMessageProcessor;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IProviderDirectory _directory;\n        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;\n        private readonly IBillingIngestService _billingIngest;\n\n        public WhatsAppWebhookDispatcher(\n            ITemplateWebhookProcessor templateProcessor,\n            ILogger<WhatsAppWebhookDispatcher> logger,\n            IClickWebhookProcessor clickProcessor,\n            IInboundMessageProcessor inboundMessageProcessor,\n            IWhatsAppWebhookService webhookService,\n            IProviderDirectory directory,\n            IPinnacleToMetaAdapter pinnacleToMetaAdapter,\n            IBillingIngestService billingIngest)\n        {\n            _templateProcessor = templateProcessor;\n            _logger = logger;\n            _clickProcessor = clickProcessor;\n            _inboundMessageProcessor = inboundMessageProcessor;\n            _webhookService = webhookService;\n            _directory = directory;\n            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;\n            _billingIngest = billingIngest;\n        }\n\n        public async Task DispatchAsync(JsonElement payload)\n        {\n            // Keep raw payload at Debug to avoid log spam in prod\n            _logger.LogDebug(\"📦 Dispatcher raw payload:\\n{Payload}\", payload.GetRawText());\n\n            try\n            {\n                // 0) Detect provider & normalize into a Meta-like \"entry[].changes[].value\" envelope\n                var provider = DetectProvider(payload); // \"meta\" | \"pinnacle\" | null\n                _logger.LogInformation(\"🌐 Dispatcher: detected provider={Provider}\", provider ?? \"(auto/meta)\");\n\n                var envelope = provider == \"pinnacle\"\n                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)\n                    : payload;\n\n                if (!envelope.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array)\n                {\n                    _logger.LogWarning(\"⚠️ Dispatcher: No 'entry' array found on envelope; skipping payload.\");\n                    return;\n                }\n\n                // Compute once per envelope (micro-optimization)\n                var isStatus = IsStatusPayload(envelope);\n                _logger.LogInformation(\"🔎 Dispatcher: isStatusPayload={IsStatus}\", isStatus);\n\n                foreach (var entry in entries.EnumerateArray())\n                {\n                    if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array)\n                    {\n                        _logger.LogDebug(\"ℹ️ Dispatcher: 'entry' without 'changes' array; skipping entry.\");\n                        continue;\n                    }\n\n                    foreach (var change in changes.EnumerateArray())\n                    {\n                        if (!change.TryGetProperty(\"value\", out var value) || value.ValueKind != JsonValueKind.Object)\n                        {\n                            _logger.LogDebug(\"ℹ️ Dispatcher: 'change' without object 'value'; skipping change.\");\n                            continue;\n                        }\n\n                        // 1) STATUS UPDATES\n                        if (isStatus)\n                        {\n                            _logger.LogInformation(\"📦 Dispatcher: treating envelope as STATUS payload (provider={Provider}).\", provider ?? \"meta\");\n\n                            // Resolve BusinessId using *envelope* metadata (works for Meta and adapted Pinnacle)\n                            Guid resolvedBiz = Guid.Empty;\n                            try\n                            {\n                                var hints = ExtractNumberHints(envelope, provider);\n                                _logger.LogDebug(\n                                    \"🔢 Dispatcher: Number hints extracted. PhoneNumberId={PhoneNumberId}, DisplayPhone={DisplayPhone}, WabaId={WabaId}, WaId={WaId}\",\n                                    hints.PhoneNumberId,\n                                    hints.DisplayPhoneNumber,\n                                    hints.WabaId,\n                                    hints.WaId);\n\n                                var bid = await _directory.ResolveBusinessIdAsync(\n                                    provider: provider,\n                                    phoneNumberId: hints.PhoneNumberId,\n                                    displayPhoneNumber: hints.DisplayPhoneNumber,\n                                    wabaId: hints.WabaId,\n                                    waId: hints.WaId\n                                );\n                                if (bid.HasValue) resolvedBiz = bid.Value;\n                            }\n                            catch (Exception ex)\n                            {\n                                _logger.LogWarning(ex, \"ProviderDirectory lookup failed; proceeding without BusinessId.\");\n                            }\n\n                            // Canonical provider label for billing\n                            var providerCanonical = string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase)\n                                ? \"PINNACLE\"\n                                : \"META_CLOUD\";\n\n                            // Only call billing ingest when BusinessId was resolved\n                            if (resolvedBiz != Guid.Empty)\n                            {\n                                try\n                                {\n                                    _logger.LogInformation(\n                                        \"💰 Dispatcher: routing status payload to BillingIngest for BusinessId={BusinessId}, Provider={ProviderCanonical}\",\n                                        resolvedBiz,\n                                        providerCanonical);\n\n                                    await _billingIngest.IngestFromWebhookAsync(\n                                        resolvedBiz,\n                                        providerCanonical,\n                                        envelope.GetRawText());\n                                }\n                                catch (Exception ex)\n                                {\n                                    _logger.LogWarning(ex, \"Billing ingest from webhook failed (non-fatal).\");\n                                }\n                            }\n                            else\n                            {\n                                _logger.LogWarning(\n                                    \"⚠️ Dispatcher: status payload had no resolved BusinessId; billing ingest will be skipped.\");\n                            }\n\n                            // Unified status updater (no legacy fallback)\n                            _logger.LogInformation(\n                                \"📦 Dispatcher: routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})\",\n                                provider,\n                                resolvedBiz == Guid.Empty ? \"(unknown)\" : resolvedBiz.ToString());\n\n                            await _webhookService.ProcessStatusUpdateAsync(\n                                resolvedBiz,\n                                provider ?? \"meta\",\n                                envelope);\n\n                            // Note: continue to next change — even if envelope is status-oriented,\n                            // other changes in the same webhook could be non-status in some providers.\n                            continue;\n                        }\n\n                        // 2) TEMPLATE EVENTS\n                        if (value.TryGetProperty(\"event\", out var eventType) &&\n                            eventType.GetString()?.StartsWith(\"template_\", StringComparison.Ordinal) == true)\n                        {\n                            _logger.LogInformation(\"📦 Dispatcher: routing to Template Processor (event={Event})\", eventType.GetString());\n                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope);\n                            continue;\n                        }\n\n                        // 3) MESSAGES (clicks + inbound)\n                        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n                        {\n                            _logger.LogDebug(\"ℹ️ Dispatcher: 'value' has no 'messages' array or it is empty; skipping.\");\n                            continue;\n                        }\n\n                        foreach (var m in msgs.EnumerateArray())\n                        {\n                            if (!m.TryGetProperty(\"type\", out var typeProp))\n                            {\n                                _logger.LogDebug(\"ℹ️ Dispatcher: message without 'type' field; skipping message.\");\n                                continue;\n                            }\n\n                            var type = typeProp.GetString();\n                            _logger.LogDebug(\"🔍 Dispatcher: inspecting message of type '{Type}'.\", type);\n\n                            // (A) Legacy quick-reply button → CLICK\n                            if (type == \"button\")\n                            {\n                                _logger.LogInformation(\"👉 Dispatcher: routing to Click Processor (legacy 'button').\");\n                                await _clickProcessor.ProcessClickAsync(value);\n                                continue;\n                            }\n\n                            // (B) Interactive (button_reply / list_reply) → CLICK\n                            if (type == \"interactive\" && m.TryGetProperty(\"interactive\", out var interactive))\n                            {\n                                if (interactive.TryGetProperty(\"type\", out var interactiveType) &&\n                                    interactiveType.GetString() == \"button_reply\")\n                                {\n                                    _logger.LogInformation(\"👉 Dispatcher: routing to Click Processor (interactive/button_reply).\");\n                                    await _clickProcessor.ProcessClickAsync(value);\n                                    continue;\n                                }\n\n                                if (interactive.TryGetProperty(\"list_reply\", out _))\n                                {\n                                    _logger.LogInformation(\"👉 Dispatcher: routing to Click Processor (interactive/list_reply).\");\n                                    await _clickProcessor.ProcessClickAsync(value);\n                                    continue;\n                                }\n                            }\n\n                            // (C) Inbound plain message types → INBOUND\n                            if (type is \"text\" or \"image\" or \"audio\")\n                            {\n                                _logger.LogInformation(\n                                    \"💬 Dispatcher: routing to InboundMessageProcessor (message type: {Type}, provider={Provider}).\",\n                                    type,\n                                    provider ?? \"meta\");\n\n                                await _inboundMessageProcessor.ProcessChatAsync(value);\n                                continue;\n                            }\n\n                            _logger.LogDebug(\"ℹ️ Dispatcher: message type '{Type}' not handled by dispatcher.\", type);\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Dispatcher failed to process WhatsApp webhook.\");\n            }\n        }\n\n        private static bool IsStatusPayload(JsonElement root)\n        {\n            // Meta-like: entry[].changes[].value.statuses\n            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty(\"statuses\", out _))\n                return true;\n\n            // Some providers mark with \"status\" or event containing \"status\"\n            if (root.TryGetProperty(\"status\", out _)) return true;\n            if (root.TryGetProperty(\"event\", out var ev) &&\n                (ev.GetString()?.Contains(\"status\", StringComparison.OrdinalIgnoreCase) ?? false))\n                return true;\n\n            return false;\n        }\n\n        private static string? DetectProvider(JsonElement root)\n        {\n            // Heuristics by envelope\n            if (root.TryGetProperty(\"object\", out var obj) && obj.GetString() == \"whatsapp_business_account\")\n                return \"meta\";\n            if (root.TryGetProperty(\"entry\", out _))\n                return \"meta\";\n            if (root.TryGetProperty(\"event\", out _))\n                return \"pinnacle\";\n            return null;\n        }\n\n        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n        {\n            res = default;\n            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n                return false;\n\n            var entry = entries[0];\n            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n                return false;\n\n            var change = changes[0];\n            if (!change.TryGetProperty(\"value\", out var value))\n                return false;\n\n            res = (value, change, entry);\n            return true;\n        }\n\n        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)\n        {\n            var hints = new NumberHints();\n\n            // Meta (or unknown → treat as Meta envelope)\n            if (string.Equals(provider, \"meta\", StringComparison.OrdinalIgnoreCase) || provider is null)\n            {\n                if (TryGetMetaValue(root, out var v))\n                {\n                    if (v.Value.TryGetProperty(\"metadata\", out var md))\n                    {\n                        if (md.TryGetProperty(\"phone_number_id\", out var pnid))\n                            hints.PhoneNumberId = pnid.GetString();\n\n                        if (md.TryGetProperty(\"display_phone_number\", out var disp))\n                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());\n\n                        if (md.TryGetProperty(\"waba_id\", out var wabaFromMeta))\n                            hints.WabaId = wabaFromMeta.GetString();\n                    }\n\n                    // Some adapters put waba_id at value-level\n                    if (string.IsNullOrWhiteSpace(hints.WabaId) &&\n                        v.Value.TryGetProperty(\"waba_id\", out var wabaTop))\n                    {\n                        hints.WabaId = wabaTop.GetString();\n                    }\n\n                    // First status often carries recipient_id (WA ID)\n                    if (v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)\n                    {\n                        var s0 = statuses[0];\n                        if (s0.TryGetProperty(\"recipient_id\", out var rid))\n                            hints.WaId = rid.GetString();\n                    }\n                }\n            }\n            // Pinnacle (raw or adapted)\n            else if (string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase))\n            {\n                // If your adapter produced a Meta-like envelope, this will work too:\n                if (TryGetMetaValue(root, out var v2) && v2.Value.TryGetProperty(\"metadata\", out var md2))\n                {\n                    if (md2.TryGetProperty(\"phone_number_id\", out var pnid2))\n                        hints.PhoneNumberId = pnid2.GetString();\n\n                    if (md2.TryGetProperty(\"display_phone_number\", out var disp2))\n                        hints.DisplayPhoneNumber = NormalizePhone(disp2.GetString());\n                }\n\n                // Raw Pinnacle-style fields on the envelope\n                if (string.IsNullOrWhiteSpace(hints.PhoneNumberId) &&\n                    root.TryGetProperty(\"phone_number_id\", out var pn))\n                    hints.PhoneNumberId = pn.GetString();\n\n                if (string.IsNullOrWhiteSpace(hints.DisplayPhoneNumber))\n                {\n                    if (root.TryGetProperty(\"from\", out var from))\n                        hints.DisplayPhoneNumber = NormalizePhone(from.GetString());\n                    else if (root.TryGetProperty(\"msisdn\", out var msisdn))\n                        hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());\n                }\n\n                if (root.TryGetProperty(\"wabaId\", out var waba))\n                    hints.WabaId = waba.GetString();\n            }\n\n            return hints;\n        }\n\n        private static string? NormalizePhone(string? v)\n        {\n            if (string.IsNullOrWhiteSpace(v)) return null;\n            var t = v.Trim();\n            var keepPlus = t.StartsWith(\"+\");\n            var digits = new string(t.Where(char.IsDigit).ToArray());\n            return keepPlus ? \"+\" + digits : digits;\n        }\n\n        private struct NumberHints\n        {\n            public string? PhoneNumberId { get; set; }\n            public string? DisplayPhoneNumber { get; set; }\n            public string? WabaId { get; set; }\n            public string? WaId { get; set; }\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Text.Json;\n//using System.Threading.Tasks;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api.Features.Webhooks.Directory;\n//using xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\n//using xbytechat.api.Features.Webhooks.Services.Processors;\n//using xbytechat_api.Features.Billing.Services;\n\n//namespace xbytechat.api.Features.Webhooks.Services\n//{\n//    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n//    {\n//        // Removed legacy _statusProcessor on purpose\n//        private readonly ITemplateWebhookProcessor _templateProcessor;\n//        private readonly IClickWebhookProcessor _clickProcessor;\n//        private readonly IInboundMessageProcessor _inboundMessageProcessor;\n//        private readonly IWhatsAppWebhookService _webhookService;\n//        private readonly IProviderDirectory _directory;\n//        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n//        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;\n//        private readonly IBillingIngestService _billingIngest;\n\n//        public WhatsAppWebhookDispatcher(\n//            ITemplateWebhookProcessor templateProcessor,\n//            ILogger<WhatsAppWebhookDispatcher> logger,\n//            IClickWebhookProcessor clickProcessor,\n//            IInboundMessageProcessor inboundMessageProcessor,\n//            IWhatsAppWebhookService webhookService,\n//            IProviderDirectory directory,\n//            IPinnacleToMetaAdapter pinnacleToMetaAdapter,\n//            IBillingIngestService billingIngest)\n//        {\n//            _templateProcessor = templateProcessor;\n//            _logger = logger;\n//            _clickProcessor = clickProcessor;\n//            _inboundMessageProcessor = inboundMessageProcessor;\n//            _webhookService = webhookService;\n//            _directory = directory;\n//            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;\n//            _billingIngest = billingIngest;\n//        }\n\n//        public async Task DispatchAsync(JsonElement payload)\n//        {\n//            // Keep raw payload at Debug to avoid log spam in prod\n//            _logger.LogDebug(\"📦 Dispatcher raw payload:\\n{Payload}\", payload.GetRawText());\n\n//            try\n//            {\n//                // 0) Detect provider & normalize into a Meta-like \"entry[].changes[].value\" envelope\n//                var provider = DetectProvider(payload); // \"meta\" | \"pinnacle\" | null\n\n//                var envelope = provider == \"pinnacle\"\n//                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)\n//                    : payload;\n\n//                if (!envelope.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array)\n//                    return;\n\n//                // Compute once per envelope (micro-optimization)\n//                var isStatus = IsStatusPayload(envelope);\n\n//                foreach (var entry in entries.EnumerateArray())\n//                {\n//                    if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array)\n//                        continue;\n\n//                    foreach (var change in changes.EnumerateArray())\n//                    {\n//                        if (!change.TryGetProperty(\"value\", out var value) || value.ValueKind != JsonValueKind.Object)\n//                            continue;\n\n//                        // 1) STATUS UPDATES\n//                        if (isStatus)\n//                        {\n//                            // Resolve BusinessId using *envelope* metadata (works for Meta and adapted Pinnacle)\n//                            Guid resolvedBiz = Guid.Empty;\n//                            try\n//                            {\n//                                var hints = ExtractNumberHints(envelope, provider);\n//                                var bid = await _directory.ResolveBusinessIdAsync(\n//                                    provider: provider,\n//                                    phoneNumberId: hints.PhoneNumberId,\n//                                    displayPhoneNumber: hints.DisplayPhoneNumber,\n//                                    wabaId: hints.WabaId,\n//                                    waId: hints.WaId\n//                                );\n//                                if (bid.HasValue) resolvedBiz = bid.Value;\n//                            }\n//                            catch (Exception ex)\n//                            {\n//                                _logger.LogWarning(ex, \"ProviderDirectory lookup failed; proceeding without BusinessId.\");\n//                            }\n\n//                            // Canonical provider label for billing\n//                            var providerCanonical = string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase)\n//                                ? \"PINNACLE\"\n//                                : \"META_CLOUD\";\n\n//                            // Only call billing ingest when BusinessId was resolved\n//                            if (resolvedBiz != Guid.Empty)\n//                            {\n//                                try\n//                                {\n//                                    await _billingIngest.IngestFromWebhookAsync(\n//                                        resolvedBiz,\n//                                        providerCanonical,\n//                                        envelope.GetRawText());\n//                                }\n//                                catch (Exception ex)\n//                                {\n//                                    _logger.LogWarning(ex, \"Billing ingest from webhook failed (non-fatal).\");\n//                                }\n//                            }\n\n//                            // Unified status updater (no legacy fallback)\n//                            _logger.LogInformation(\n//                                \"📦 Routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})\",\n//                                provider, resolvedBiz == Guid.Empty ? \"(unknown)\" : resolvedBiz.ToString());\n\n//                            await _webhookService.ProcessStatusUpdateAsync(\n//                                resolvedBiz,\n//                                provider ?? \"meta\",\n//                                envelope);\n\n//                            // Note: continue to next change — even if envelope is status-oriented,\n//                            // other changes in the same webhook could be non-status in some providers.\n//                            continue;\n//                        }\n\n//                        // 2) TEMPLATE EVENTS\n//                        if (value.TryGetProperty(\"event\", out var eventType) &&\n//                            eventType.GetString()?.StartsWith(\"template_\", StringComparison.Ordinal) == true)\n//                        {\n//                            _logger.LogInformation(\"📦 Routing to Template Processor\");\n//                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope);\n//                            continue;\n//                        }\n\n//                        // 3) MESSAGES (clicks + inbound)\n//                        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n//                        {\n//                            _logger.LogDebug(\"ℹ️ No 'messages' array present.\");\n//                            continue;\n//                        }\n\n//                        foreach (var m in msgs.EnumerateArray())\n//                        {\n//                            if (!m.TryGetProperty(\"type\", out var typeProp))\n//                            {\n//                                _logger.LogDebug(\"ℹ️ Message without 'type' field.\");\n//                                continue;\n//                            }\n\n//                            var type = typeProp.GetString();\n\n//                            // (A) Legacy quick-reply button → CLICK\n//                            if (type == \"button\")\n//                            {\n//                                _logger.LogInformation(\"👉 Routing to Click Processor (legacy 'button')\");\n//                                await _clickProcessor.ProcessClickAsync(value);\n//                                continue;\n//                            }\n\n//                            // (B) Interactive (button_reply / list_reply) → CLICK\n//                            if (type == \"interactive\" && m.TryGetProperty(\"interactive\", out var interactive))\n//                            {\n//                                if (interactive.TryGetProperty(\"type\", out var interactiveType) &&\n//                                    interactiveType.GetString() == \"button_reply\")\n//                                {\n//                                    _logger.LogInformation(\"👉 Routing to Click Processor (interactive/button_reply)\");\n//                                    await _clickProcessor.ProcessClickAsync(value);\n//                                    continue;\n//                                }\n\n//                                if (interactive.TryGetProperty(\"list_reply\", out _))\n//                                {\n//                                    _logger.LogInformation(\"👉 Routing to Click Processor (interactive/list_reply)\");\n//                                    await _clickProcessor.ProcessClickAsync(value);\n//                                    continue;\n//                                }\n//                            }\n\n//                            // (C) Inbound plain message types → INBOUND\n//                            if (type is \"text\" or \"image\" or \"audio\")\n//                            {\n//                                _logger.LogInformation(\"💬 Routing to InboundMessageProcessor (type: {Type})\", type);\n//                                await _inboundMessageProcessor.ProcessChatAsync(value);\n//                                continue;\n//                            }\n\n//                            _logger.LogDebug(\"ℹ️ Message type '{Type}' not handled by dispatcher.\", type);\n//                        }\n//                    }\n//                }\n//            }\n//            catch (Exception ex)\n//            {\n//                _logger.LogError(ex, \"❌ Dispatcher failed to process WhatsApp webhook.\");\n//            }\n//        }\n\n//        private static bool IsStatusPayload(JsonElement root)\n//        {\n//            // Meta-like: entry[].changes[].value.statuses\n//            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty(\"statuses\", out _))\n//                return true;\n\n//            // Some providers mark with \"status\" or event containing \"status\"\n//            if (root.TryGetProperty(\"status\", out _)) return true;\n//            if (root.TryGetProperty(\"event\", out var ev) &&\n//                (ev.GetString()?.Contains(\"status\", StringComparison.OrdinalIgnoreCase) ?? false))\n//                return true;\n\n//            return false;\n//        }\n\n//        private static string? DetectProvider(JsonElement root)\n//        {\n//            // Heuristics by envelope\n//            if (root.TryGetProperty(\"object\", out var obj) && obj.GetString() == \"whatsapp_business_account\")\n//                return \"meta\";\n//            if (root.TryGetProperty(\"entry\", out _))\n//                return \"meta\";\n//            if (root.TryGetProperty(\"event\", out _))\n//                return \"pinnacle\";\n//            return null;\n//        }\n\n//        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n//        {\n//            res = default;\n//            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n//                return false;\n\n//            var entry = entries[0];\n//            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n//                return false;\n\n//            var change = changes[0];\n//            if (!change.TryGetProperty(\"value\", out var value))\n//                return false;\n\n//            res = (value, change, entry);\n//            return true;\n//        }\n\n//        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)\n//        {\n//            var hints = new NumberHints();\n\n//            // Meta (or unknown → treat as Meta envelope)\n//            if (string.Equals(provider, \"meta\", StringComparison.OrdinalIgnoreCase) || provider is null)\n//            {\n//                if (TryGetMetaValue(root, out var v))\n//                {\n//                    if (v.Value.TryGetProperty(\"metadata\", out var md))\n//                    {\n//                        if (md.TryGetProperty(\"phone_number_id\", out var pnid))\n//                            hints.PhoneNumberId = pnid.GetString();\n\n//                        if (md.TryGetProperty(\"display_phone_number\", out var disp))\n//                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());\n\n//                        if (md.TryGetProperty(\"waba_id\", out var wabaFromMeta))\n//                            hints.WabaId = wabaFromMeta.GetString();\n//                    }\n\n//                    // Some adapters put waba_id at value-level\n//                    if (string.IsNullOrWhiteSpace(hints.WabaId) &&\n//                        v.Value.TryGetProperty(\"waba_id\", out var wabaTop))\n//                    {\n//                        hints.WabaId = wabaTop.GetString();\n//                    }\n\n//                    // First status often carries recipient_id (WA ID)\n//                    if (v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n//                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)\n//                    {\n//                        var s0 = statuses[0];\n//                        if (s0.TryGetProperty(\"recipient_id\", out var rid))\n//                            hints.WaId = rid.GetString();\n//                    }\n//                }\n//            }\n//            // Pinnacle (raw or adapted)\n//            else if (string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase))\n//            {\n//                // If your adapter produced a Meta-like envelope, this will work too:\n//                if (TryGetMetaValue(root, out var v2) && v2.Value.TryGetProperty(\"metadata\", out var md2))\n//                {\n//                    if (md2.TryGetProperty(\"phone_number_id\", out var pnid2))\n//                        hints.PhoneNumberId = pnid2.GetString();\n\n//                    if (md2.TryGetProperty(\"display_phone_number\", out var disp2))\n//                        hints.DisplayPhoneNumber = NormalizePhone(disp2.GetString());\n//                }\n\n//                // Raw Pinnacle-style fields on the envelope\n//                if (string.IsNullOrWhiteSpace(hints.PhoneNumberId) &&\n//                    root.TryGetProperty(\"phone_number_id\", out var pn))\n//                    hints.PhoneNumberId = pn.GetString();\n\n//                if (string.IsNullOrWhiteSpace(hints.DisplayPhoneNumber))\n//                {\n//                    if (root.TryGetProperty(\"from\", out var from))\n//                        hints.DisplayPhoneNumber = NormalizePhone(from.GetString());\n//                    else if (root.TryGetProperty(\"msisdn\", out var msisdn))\n//                        hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());\n//                }\n\n//                if (root.TryGetProperty(\"wabaId\", out var waba))\n//                    hints.WabaId = waba.GetString();\n//            }\n\n//            return hints;\n//        }\n\n//        private static string? NormalizePhone(string? v)\n//        {\n//            if (string.IsNullOrWhiteSpace(v)) return null;\n//            var t = v.Trim();\n//            var keepPlus = t.StartsWith(\"+\");\n//            var digits = new string(t.Where(char.IsDigit).ToArray());\n//            return keepPlus ? \"+\" + digits : digits;\n//        }\n\n//        private struct NumberHints\n//        {\n//            public string? PhoneNumberId { get; set; }\n//            public string? DisplayPhoneNumber { get; set; }\n//            public string? WabaId { get; set; }\n//            public string? WaId { get; set; }\n//        }\n//    }\n//}\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookService.cs",
      "sha256": "28a7cd652990f6303b6c0d8b76fb79b17aa8df36d79774e23c593d21a44df972",
      "language": "csharp",
      "size": 5929,
      "content": "using System.Text.Json;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog (optional if you keep only MessageLogs lookup)\nusing xbytechat.api.Features.MessageManagement.Services; // IMessageStatusUpdater\nusing xbytechat.api.Features.Webhooks.Status;\nusing xbytechat.api.Infrastructure; // your AppDbContext namespace (adjust if different)\nusing xbytechat.api.Infrastructure.Observability; // MetricsRegistry\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    \n\n    public sealed class WhatsAppWebhookService : IWhatsAppWebhookService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<WhatsAppWebhookService> _logger;\n        private readonly IMessageStatusUpdater _updater;\n\n        public WhatsAppWebhookService(\n            AppDbContext context,\n            ILogger<WhatsAppWebhookService> logger,\n            IMessageStatusUpdater updater)\n        {\n            _context = context;\n            _logger = logger;\n            _updater = updater;\n        }\n\n        /// <summary>\n        /// Single modern entrypoint. Assumes payload is Meta-shaped (entry[].changes[].value.statuses[]).\n        /// If you ingest other providers, adapt them to this shape before calling here.\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default)\n        {\n            provider = (provider ?? \"\").Trim().ToLowerInvariant();\n\n            // Normalize status text to what the updater expects\n            static string NormalizeStatus(string? s)\n            {\n                s = (s ?? \"\").Trim().ToLowerInvariant();\n                return s switch\n                {\n                    \"sent\" => \"sent\",\n                    \"delivered\" => \"delivered\",\n                    \"read\" => \"read\",\n                    \"failed\" => \"failed\",\n                    _ => s\n                };\n            }\n\n            // Parse Meta-like envelope: entry[].changes[].value.statuses[]\n            if (!payload.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array)\n            {\n                _logger.LogWarning(\"Status payload missing 'entry' array.\");\n                return;\n            }\n\n            foreach (var entry in entries.EnumerateArray())\n            {\n                if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array)\n                    continue;\n\n                foreach (var change in changes.EnumerateArray())\n                {\n                    if (!change.TryGetProperty(\"value\", out var value) || value.ValueKind != JsonValueKind.Object)\n                        continue;\n\n                    if (!value.TryGetProperty(\"statuses\", out var statuses) || statuses.ValueKind != JsonValueKind.Array)\n                        continue;\n\n                    foreach (var st in statuses.EnumerateArray())\n                    {\n                        // Fields: id (WAMID or provider id), status, timestamp\n                        string? providerOrWaId = st.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                        string? statusText = st.TryGetProperty(\"status\", out var statusProp) ? statusProp.GetString() : null;\n\n                        long unixTs = 0;\n                        if (st.TryGetProperty(\"timestamp\", out var tsProp))\n                        {\n                            if (tsProp.ValueKind == JsonValueKind.String && long.TryParse(tsProp.GetString(), out var parsed))\n                                unixTs = parsed;\n                            else if (tsProp.ValueKind == JsonValueKind.Number)\n                                unixTs = tsProp.GetInt64();\n                        }\n\n                        if (string.IsNullOrWhiteSpace(providerOrWaId) || string.IsNullOrWhiteSpace(statusText))\n                        {\n                            _logger.LogWarning(\"Status item missing id or status: {Item}\", st.GetRawText());\n                            continue;\n                        }\n\n                        // Resolve canonical MessageId (WAMID) from DB; fallback to provider id if not found.\n                        // 1) Try MessageLogs\n                        string? messageId = await _context.MessageLogs.AsNoTracking()\n                            .Where(m => m.ProviderMessageId == providerOrWaId || m.MessageId == providerOrWaId)\n                            .OrderByDescending(m => m.CreatedAt)\n                            .Select(m => m.MessageId ?? m.ProviderMessageId)\n                            .FirstOrDefaultAsync(ct);\n\n                        // 2) Optional: also look in CampaignSendLogs if desired\n                        if (string.IsNullOrWhiteSpace(messageId))\n                        {\n                            messageId = await _context.CampaignSendLogs.AsNoTracking()\n                                .Where(c => c.MessageId == providerOrWaId)\n                                .OrderByDescending(c => c.CreatedAt)\n                                .Select(c => c.MessageId)\n                                .FirstOrDefaultAsync(ct);\n                        }\n\n                        messageId ??= providerOrWaId;\n\n                        var tsUtc = unixTs > 0\n                            ? DateTimeOffset.FromUnixTimeSeconds(unixTs).UtcDateTime\n                            : DateTime.UtcNow;\n\n                        var norm = NormalizeStatus(statusText);\n\n                        // Updater signature: (messageId, status, tsUtc, error, ct)\n                        await _updater.UpdateAsync(messageId, norm, tsUtc, null, ct);\n\n                        _logger.LogInformation(\"Status updated: msg={MessageId} status={Status} ts={Ts}\", messageId, norm, tsUtc);\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/IMessageStatusUpdater.cs",
      "sha256": "38df9b6edc3c2706c404a79c6b9fa66e5065c9a4481e798e7f497e9e56c9c358",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    public interface IMessageStatusUpdater\n    {\n       // Task UpdateAsync(StatusEvent ev, CancellationToken ct = default);\n        Task<int> UpdateAsync(string messageId, string status, DateTime tsUtc, string? error, CancellationToken ct);\n    }\n\n    public sealed class StatusEvent\n    {\n        public Guid BusinessId { get; init; }\n        public string Provider { get; init; } = \"\";          // \"meta\" | \"pinnacle\"\n\n        // Provider message id (Meta \"id\", Pinnacle equivalent) → maps to MessageId in your DB\n        public string ProviderMessageId { get; init; } = \"\";\n\n        // Optional hints (not required in your current lookups)\n        public Guid? CampaignSendLogId { get; init; }\n        public string? RecipientWaId { get; init; }\n\n        public MessageDeliveryState State { get; init; }     // Sent/Delivered/Read/Failed/Deleted\n        public DateTimeOffset OccurredAt { get; init; }      // from provider timestamp when available\n\n        public string? ErrorCode { get; init; }\n        public string? ErrorMessage { get; init; }\n        public string? ConversationId { get; init; }\n    }\n\n    public enum MessageDeliveryState\n    {\n        Sent,\n        Delivered,\n        Read,\n        Failed,\n        Deleted\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusContracts.cs",
      "sha256": "37627bd0faaa1e9e438a5d7379dc5f5773a8f7553fe9e1b476e74ee20a66ce30",
      "language": "csharp",
      "size": 1443,
      "content": "namespace xbytechat.api.Features.Webhooks.Status\n{\n    public class MessageStatusContracts\n    {\n        public enum CanonicalMessageStatus\n        {\n            Unknown = 0,\n            Submitted,   // API accepted (optional)\n            Sent,        // provider accepted / sent\n            Delivered,\n            Read,\n            Failed\n        }\n        public sealed class UpdateMessageStatusRequest\n        {\n            public Guid BusinessId { get; set; }\n            public string Provider { get; set; } = \"\";              // \"meta_cloud\" | \"pinnacle\" | etc.\n            public string MessageId { get; set; } = \"\";             // provider message id (WAMID / id)\n            public string RawStatus { get; set; } = \"\";             // provider-specific (e.g., \"sent\", \"delivered\")\n            public DateTimeOffset? EventTime { get; set; }          // provider timestamp, if any\n\n            public string? RecipientNumber { get; set; }            // optional sanity context\n            public string? ErrorCode { get; set; }                  // optional error info\n            public string? ErrorMessage { get; set; }               // optional error info\n            public string? RawPayloadJson { get; set; }             // optional audit/debug\n        }\n\n        public interface IMessageStatusUpdater\n        {\n            Task<bool> UpdateAsync(UpdateMessageStatusRequest req, CancellationToken ct = default);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusUpdater.cs",
      "sha256": "9bbb3fb92f5443fc392f4ef65a69eef507c7139272044426334fc9d111e6a62c",
      "language": "csharp",
      "size": 25566,
      "content": "using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\n// 👇 make sure this is where your AppDbContext lives\nusing xbytechat.api;\n\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\nusing xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)\nusing xbytechat.api.Features.CRM.Models;                      // Contact (nav)\nusing xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog\n\n// 👇 Billing ingest\nusing xbytechat_api.Features.Billing.Services;        // IBillingIngestService\nusing xbytechat.api.Infrastructure.Observability;\nusing Channel = System.Threading.Channels.Channel;\nusing System.Threading.RateLimiting;\nusing Serilog;\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    /// <summary>\n    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.\n    /// Also forwards raw Meta webhook payloads to Billing ingest for pricing/billing capture.\n    /// </summary>\n    public class MessageStatusUpdater : IMessageStatusUpdater\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<MessageStatusUpdater> _log;\n        private readonly IBillingIngestService _billing;\n\n        public MessageStatusUpdater(AppDbContext db,\n                                    ILogger<MessageStatusUpdater> log,\n                                    IBillingIngestService billing)\n        {\n            _db = db;\n            _log = log;\n            _billing = billing;\n        }\n\n        //public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)\n        //{\n        //    // 🔎 Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably\n        //    if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n        //    {\n        //        _log.LogWarning(\"Status update missing key fields (BusinessId or ProviderMessageId). Skip.\");\n        //        return;\n        //    }\n\n        //    // 1) Pull candidates (scoped to business + WAMID)\n        //    var sendLogQ = _db.Set<CampaignSendLog>()\n        //                      .AsTracking()\n        //                      .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);\n\n        //    // NOTE: some rows set both MessageId and ProviderMessageId to the wamid; be flexible.\n        //    var msgLogQ = _db.Set<MessageLog>()\n        //                     .AsTracking()\n        //                     .Where(m => m.BusinessId == ev.BusinessId &&\n        //                                (m.ProviderMessageId == ev.ProviderMessageId ||\n        //                                 m.MessageId == ev.ProviderMessageId));\n\n        //    // If caller passed a specific CampaignSendLogId, narrow further\n        //    if (ev.CampaignSendLogId is Guid sid)\n        //        sendLogQ = sendLogQ.Where(s => s.Id == sid);\n\n        //    var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);\n        //    var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);\n\n        //    // 2) Apply transition (idempotent)\n        //    var changed = ApplyTransition(sendLog, msgLog, ev);\n\n        //    // 3) Persist only if something actually changed\n        //    if (changed > 0)\n        //        await _db.SaveChangesAsync(ct);\n\n        //    // 4) Always forward Meta status webhook payloads to Billing ingest (for pricing events).\n        //    await TryForwardToBillingAsync(ev, ct);\n        //}\n\n\n        public async Task<int> UpdateAsync(string messageId, string status, DateTime tsUtc, string? error, CancellationToken ct)\n        {\n            if (string.IsNullOrWhiteSpace(messageId)) return 0;\n\n            status = status.Trim().ToLowerInvariant();\n\n            // 1) Update CampaignSendLogs by MessageId (idempotent)\n            var cslQuery = _db.CampaignSendLogs.Where(x => x.MessageId == messageId);\n\n            int affected;\n            if (status == \"delivered\")\n            {\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error)\n                    .SetProperty(x => x.DeliveredAt, tsUtc)\n                    .SetProperty(x => x.SendStatus, \"Delivered\")\n                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"read\")\n            {\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error)\n                    .SetProperty(x => x.ReadAt, tsUtc)\n                    .SetProperty(x => x.SendStatus, \"Read\")\n                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc)\n                    .SetProperty(x => x.DeliveredAt, x => x.DeliveredAt ?? tsUtc), ct);\n            }\n            else if (status == \"failed\")\n            {\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error)\n                    .SetProperty(x => x.SendStatus, \"Failed\")\n                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"sent\")\n            {\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error)\n                    .SetProperty(x => x.SentAt, x => x.SentAt ?? tsUtc)\n                    .SetProperty(x => x.SendStatus, \"Sent\"), ct);\n            }\n            else\n            {\n                // Unknown status: only persist the error text (harmless)\n                affected = await cslQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(x => x.ErrorMessage, error), ct);\n            }\n\n            // 2) Mirror onto MessageLogs (optional but useful for parity)\n            var mlQuery = _db.MessageLogs.Where(m => m.ProviderMessageId == messageId);\n\n            if (status == \"delivered\")\n            {\n                await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Delivered\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"read\")\n            {\n                await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Read\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"failed\")\n            {\n                await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Failed\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n            else if (status == \"sent\")\n            {\n                await mlQuery.ExecuteUpdateAsync(s => s\n                    .SetProperty(m => m.Status, \"Sent\")\n                    .SetProperty(m => m.SentAt, m => m.SentAt ?? tsUtc), ct);\n            }\n            // else: ignore unknown statuses for MessageLogs\n\n            // 3) Side-effects & metrics\n            if (affected == 0)\n            {\n                _log.LogWarning(\"[StatusUpdater] No CampaignSendLog row for messageId={MessageId}\", messageId);\n            }\n            else\n            {\n                if (status == \"failed\") MetricsRegistry.MessagesFailed.Add(1);\n                else if (status == \"sent\") MetricsRegistry.MessagesSent.Add(1);\n                // delivered/read are visible in analytics; counters optional\n            }\n\n            // Optional: billing for delivered/read goes here if required\n\n            return affected;\n        }\n\n        /// <summary>Returns number of entities modified.</summary>\n        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)\n        {\n            int modified = 0;\n\n            // --- CampaignSendLog updates ---\n            if (sendLog != null)\n            {\n                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n                {\n                    sendLog.MessageId = ev.ProviderMessageId;\n                    modified++;\n                }\n\n                switch (ev.State)\n                {\n                    case MessageDeliveryState.Sent:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Sent\"))\n                        {\n                            sendLog.SendStatus = \"Sent\";\n                            modified++;\n                        }\n                        if (sendLog.SentAt == null || sendLog.SentAt == default)\n                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Delivered:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\") &&\n                            !EqualsIgnoreCase(sendLog.SendStatus, \"Delivered\"))\n                        {\n                            sendLog.SendStatus = \"Delivered\";\n                            modified++;\n                        }\n                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)\n                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Read:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\"))\n                        {\n                            sendLog.SendStatus = \"Read\";\n                            modified++;\n                        }\n                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)\n                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Failed:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Failed\"))\n                        {\n                            sendLog.SendStatus = \"Failed\";\n                            modified++;\n                        }\n                        if (sendLog.ErrorMessage != ev.ErrorMessage)\n                        {\n                            sendLog.ErrorMessage = ev.ErrorMessage;\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Deleted:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Deleted\"))\n                        {\n                            sendLog.SendStatus = \"Deleted\";\n                            modified++;\n                        }\n                        break;\n                }\n            }\n\n            // --- MessageLog updates ---\n            if (msgLog != null)\n            {\n                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n                {\n                    msgLog.MessageId = ev.ProviderMessageId;\n                    modified++;\n                }\n\n                switch (ev.State)\n                {\n                    case MessageDeliveryState.Sent:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Sent\"))\n                        {\n                            msgLog.Status = \"Sent\";\n                            modified++;\n                        }\n                        if (msgLog.SentAt == null || msgLog.SentAt == default)\n                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Delivered:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\") &&\n                            !EqualsIgnoreCase(msgLog.Status, \"Delivered\"))\n                        {\n                            msgLog.Status = \"Delivered\";\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Read:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\"))\n                        {\n                            msgLog.Status = \"Read\";\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Failed:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Failed\"))\n                        {\n                            msgLog.Status = \"Failed\";\n                            modified++;\n                        }\n                        if (msgLog.ErrorMessage != ev.ErrorMessage)\n                        {\n                            msgLog.ErrorMessage = ev.ErrorMessage;\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Deleted:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Deleted\"))\n                        {\n                            msgLog.Status = \"Deleted\";\n                            modified++;\n                        }\n                        break;\n                }\n            }\n\n            if (sendLog == null && msgLog == null)\n            {\n                _log.LogWarning(\"No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}\",\n                    ev.BusinessId, ev.ProviderMessageId, ev.State);\n            }\n\n            return modified;\n        }\n\n        private static bool EqualsIgnoreCase(string? a, string? b) =>\n            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n\n        // ---------------- Billing forwarder ----------------\n\n        private async Task TryForwardToBillingAsync(StatusEvent ev, CancellationToken ct)\n        {\n            try\n            {\n                if (ev.BusinessId == Guid.Empty) return;\n\n                // Pull Provider (via reflection to avoid changing your StatusEvent contract)\n                var provider = GetStringProp(ev, \"Provider\")\n                               ?? GetStringProp(ev, \"ChannelProvider\")\n                               ?? GetStringProp(ev, \"SourceProvider\")\n                               ?? GetStringProp(ev, \"ProviderNormalized\");\n\n                // Try to get raw JSON payload from common property names\n                string? rawJson =\n                    GetStringProp(ev, \"RawPayloadJson\") ??\n                    GetStringProp(ev, \"PayloadJson\") ??\n                    TryGetJsonElementText(ev, \"Body\") ??\n                    TryGetJsonElementText(ev, \"RawBody\");\n\n                // If provider missing, use a lightweight sniff (Meta sends \"whatsapp_business_account\")\n                if (string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(rawJson) &&\n                    rawJson.IndexOf(\"\\\"whatsapp_business_account\\\"\", StringComparison.OrdinalIgnoreCase) >= 0)\n                {\n                    provider = \"META_CLOUD\";\n                }\n\n                // Normalize provider for billing\n                var normalized = NormalizeProvider(provider);\n                if (normalized != \"META_CLOUD\") return; // only forward Meta to billing ingest for now\n\n                if (string.IsNullOrWhiteSpace(rawJson))\n                {\n                    _log.LogDebug(\"Billing forward skipped: no raw payload JSON available on StatusEvent.\");\n                    return;\n                }\n\n                await _billing.IngestFromWebhookAsync(ev.BusinessId, normalized, rawJson);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"Billing ingest (status webhook) failed. businessId={BusinessId}\", ev.BusinessId);\n            }\n        }\n\n        private static string NormalizeProvider(string? provider)\n        {\n            if (string.IsNullOrWhiteSpace(provider)) return \"\";\n            var p = provider.Trim();\n            if (p.Equals(\"META_CLOUD\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            if (p.Equals(\"meta\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            if (p.Equals(\"meta_cloud\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            return p; // other providers unchanged\n        }\n\n        private static string? GetStringProp(object obj, string propName)\n        {\n            var pi = obj.GetType().GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            if (pi == null) return null;\n            var val = pi.GetValue(obj);\n            return val as string;\n        }\n\n        private static string? TryGetJsonElementText(object obj, string propName)\n        {\n            var pi = obj.GetType().GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            if (pi == null) return null;\n            var val = pi.GetValue(obj);\n            if (val is JsonElement je) return je.GetRawText();\n            return null;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n\n//// 👇 make sure this is where your AppDbContext lives\n//using xbytechat.api;\n\n//using xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\n//using xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)\n//using xbytechat.api.CRM.Models;                       // Contact (nav)\n//using xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog\n\n//namespace xbytechat.api.Features.Webhooks.Status\n//{\n//    /// <summary>\n//    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.\n//    /// </summary>\n//    public class MessageStatusUpdater : IMessageStatusUpdater\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly ILogger<MessageStatusUpdater> _log;\n\n//        public MessageStatusUpdater(AppDbContext db, ILogger<MessageStatusUpdater> log)\n//        {\n//            _db = db;\n//            _log = log;\n//        }\n\n//        public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)\n//        {\n//            // 🔎 Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably\n//            if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n//            {\n//                _log.LogWarning(\"Status update missing key fields (BusinessId or ProviderMessageId). Skip.\");\n//                return;\n//            }\n\n//            // 1) Pull candidates (scoped to business + WAMID)\n//            var sendLogQ = _db.Set<CampaignSendLog>()\n//                              .AsTracking()\n//                              .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);\n\n//            var msgLogQ = _db.Set<MessageLog>()\n//                             .AsTracking()\n//                             .Where(m => m.BusinessId == ev.BusinessId && m.MessageId == ev.ProviderMessageId);\n\n//            // If caller passed a specific CampaignSendLogId, narrow further\n//            if (ev.CampaignSendLogId is Guid sid)\n//                sendLogQ = sendLogQ.Where(s => s.Id == sid);\n\n//            var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);\n//            var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);\n\n//            // 2) Apply transition (idempotent)\n//            var changed = ApplyTransition(sendLog, msgLog, ev);\n\n//            // 3) Persist only if something actually changed\n//            if (changed > 0)\n//                await _db.SaveChangesAsync(ct);\n//        }\n\n//        /// <summary>Returns number of entities modified.</summary>\n//        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)\n//        {\n//            int modified = 0;\n\n//            // --- CampaignSendLog updates ---\n//            if (sendLog != null)\n//            {\n//                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n//                {\n//                    sendLog.MessageId = ev.ProviderMessageId;\n//                    modified++;\n//                }\n\n//                switch (ev.State)\n//                {\n//                    case MessageDeliveryState.Sent:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Sent\"))\n//                        {\n//                            sendLog.SendStatus = \"Sent\";\n//                            modified++;\n//                        }\n//                        if (sendLog.SentAt == null || sendLog.SentAt == default)\n//                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Delivered:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\") &&\n//                            !EqualsIgnoreCase(sendLog.SendStatus, \"Delivered\"))\n//                        {\n//                            sendLog.SendStatus = \"Delivered\";\n//                            modified++;\n//                        }\n//                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)\n//                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Read:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\"))\n//                        {\n//                            sendLog.SendStatus = \"Read\";\n//                            modified++;\n//                        }\n//                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)\n//                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Failed:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Failed\"))\n//                        {\n//                            sendLog.SendStatus = \"Failed\";\n//                            modified++;\n//                        }\n//                        if (sendLog.ErrorMessage != ev.ErrorMessage)\n//                        {\n//                            sendLog.ErrorMessage = ev.ErrorMessage;\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Deleted:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Deleted\"))\n//                        {\n//                            sendLog.SendStatus = \"Deleted\";\n//                            modified++;\n//                        }\n//                        break;\n//                }\n//            }\n\n//            // --- MessageLog updates ---\n//            if (msgLog != null)\n//            {\n//                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n//                {\n//                    msgLog.MessageId = ev.ProviderMessageId;\n//                    modified++;\n//                }\n\n//                switch (ev.State)\n//                {\n//                    case MessageDeliveryState.Sent:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Sent\"))\n//                        {\n//                            msgLog.Status = \"Sent\";\n//                            modified++;\n//                        }\n//                        if (msgLog.SentAt == null || msgLog.SentAt == default)\n//                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Delivered:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\") &&\n//                            !EqualsIgnoreCase(msgLog.Status, \"Delivered\"))\n//                        {\n//                            msgLog.Status = \"Delivered\";\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Read:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\"))\n//                        {\n//                            msgLog.Status = \"Read\";\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Failed:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Failed\"))\n//                        {\n//                            msgLog.Status = \"Failed\";\n//                            modified++;\n//                        }\n//                        if (msgLog.ErrorMessage != ev.ErrorMessage)\n//                        {\n//                            msgLog.ErrorMessage = ev.ErrorMessage;\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Deleted:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Deleted\"))\n//                        {\n//                            msgLog.Status = \"Deleted\";\n//                            modified++;\n//                        }\n//                        break;\n//                }\n//            }\n\n//            if (sendLog == null && msgLog == null)\n//            {\n//                _log.LogWarning(\"No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}\",\n//                    ev.BusinessId, ev.ProviderMessageId, ev.State);\n//            }\n\n//            return modified;\n//        }\n\n//        private static bool EqualsIgnoreCase(string? a, string? b) =>\n//            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n//    }\n//}\n"
    }
  ]
}
