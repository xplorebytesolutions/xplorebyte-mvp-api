{
  "name": "xbytechat-api/Infrastructure",
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Infrastructure/Flows/FlowClickTokenOptions.cs",
      "sha256": "77072ad81d2853a2fd79e3d9e38138f6adfdf21eea5558d5771531d9dde4eb9d",
      "language": "csharp",
      "size": 421,
      "content": "// üìÑ Infrastructure/Flows/FlowClickTokenOptions.cs\nnamespace xbytechat.api.Infrastructure.Flows\n{\n    public class FlowClickTokenOptions\n    {\n        public string Secret { get; set; } = \"\";   // long random string (256-bit recommended)\n        public string BaseUrl { get; set; } = \"\";  // e.g. https://app.yourdomain.com\n        public int TtlHours { get; set; } = 72;    // token lifetime (default 3 days)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Infrastructure/Flows/FlowClickTokenService.cs",
      "sha256": "a259df299ffe015927cc0dfc8bf0818b0e45222cd93cfb2dfb5879f2658e0dfb",
      "language": "csharp",
      "size": 3570,
      "content": "// üìÑ Infrastructure/Flows/FlowClickTokenService.cs\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Security.Claims;\nusing System.Text;\nusing Microsoft.Extensions.Options;\nusing Microsoft.IdentityModel.Tokens;\n\nnamespace xbytechat.api.Infrastructure.Flows\n{\n    public record FlowClickPayload(\n        Guid biz, Guid fid, int ver, Guid sid, short bi,\n        Guid mlid, string cp, long iat, long exp\n    );\n\n    public interface IFlowClickTokenService\n    {\n        string Create(FlowClickPayload p);\n        FlowClickPayload Validate(string token);\n        string BuildUrl(FlowClickPayload p);\n    }\n\n    public class FlowClickTokenService : IFlowClickTokenService\n    {\n        private readonly FlowClickTokenOptions _opt;\n        private readonly JwtSecurityTokenHandler _handler = new();\n\n        public FlowClickTokenService(IOptions<FlowClickTokenOptions> opt)\n        {\n            _opt = opt.Value;\n        }\n\n        public string Create(FlowClickPayload p)\n        {\n            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_opt.Secret));\n            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n\n            var claims = new[]\n            {\n                new Claim(\"biz\", p.biz.ToString()),\n                new Claim(\"fid\", p.fid.ToString()),\n                new Claim(\"ver\", p.ver.ToString()),\n                new Claim(\"sid\", p.sid.ToString()),\n                new Claim(\"bi\",  p.bi.ToString()),\n                new Claim(\"mlid\",p.mlid.ToString()),\n                new Claim(\"cp\",  p.cp),\n                new Claim(\"iat\", p.iat.ToString()),\n                new Claim(\"exp\", p.exp.ToString())\n            };\n\n            var token = new JwtSecurityToken(claims: claims, signingCredentials: creds);\n            return _handler.WriteToken(token);\n        }\n\n        public FlowClickPayload Validate(string token)\n        {\n            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_opt.Secret));\n\n            var parameters = new TokenValidationParameters\n            {\n                ValidateIssuer = false,\n                ValidateAudience = false,\n                ValidateLifetime = false, // we‚Äôll check manually\n                ValidateIssuerSigningKey = true,\n                IssuerSigningKey = key\n            };\n\n            _handler.ValidateToken(token, parameters, out var validated);\n            var jwt = (JwtSecurityToken)validated;\n\n            long iat = long.Parse(jwt.Claims.First(c => c.Type == \"iat\").Value);\n            long exp = long.Parse(jwt.Claims.First(c => c.Type == \"exp\").Value);\n            var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n            if (now > exp) throw new SecurityTokenExpiredException(\"Token expired\");\n\n            return new FlowClickPayload(\n                biz: Guid.Parse(jwt.Claims.First(c => c.Type == \"biz\").Value),\n                fid: Guid.Parse(jwt.Claims.First(c => c.Type == \"fid\").Value),\n                ver: int.Parse(jwt.Claims.First(c => c.Type == \"ver\").Value),\n                sid: Guid.Parse(jwt.Claims.First(c => c.Type == \"sid\").Value),\n                bi: short.Parse(jwt.Claims.First(c => c.Type == \"bi\").Value),\n                mlid: Guid.Parse(jwt.Claims.First(c => c.Type == \"mlid\").Value),\n                cp: jwt.Claims.First(c => c.Type == \"cp\").Value,\n                iat: iat,\n                exp: exp\n            );\n        }\n\n        public string BuildUrl(FlowClickPayload p)\n        {\n            var token = Create(p);\n            return $\"{_opt.BaseUrl.TrimEnd('/')}/r/flow/{token}\";\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Infrastructure/Json/JsonCtx.cs",
      "sha256": "7f0c06d894ea9cf97b6d1b536ebd48cf3862fab67c3138e0d91e84f9b3539e0d",
      "language": "csharp",
      "size": 779,
      "content": "using System.Text.Json.Serialization;\nusing xbytechat.api.Features.CampaignModule.SendEngine.PayloadModels.Meta;\nusing xbytechat.api.Features.CampaignModule.SendEngine.PayloadModels.Pinnacle;\n\nnamespace xbytechat.api.Infrastructure.Json\n{\n    [JsonSourceGenerationOptions(\n        WriteIndented = false,\n        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]\n    [JsonSerializable(typeof(MetaTemplateMessage))]\n    [JsonSerializable(typeof(PinnacleTemplateMessage))]\n    // Ensure the generator knows about the polymorphic bases\n    [JsonSerializable(typeof(System.Collections.Generic.List<MetaComponentBase>))]\n    [JsonSerializable(typeof(System.Collections.Generic.List<PinnacleComponentBase>))]\n\n    public partial class JsonCtx : JsonSerializerContext { }\n}\n"
    },
    {
      "path": "xbytechat-api/Infrastructure/Observability/MetricsRegistry.cs",
      "sha256": "2cecd0e2963747c522622fa3aa8afe8f9e3afce029eb264c9870aa006ba39612",
      "language": "csharp",
      "size": 2835,
      "content": "using System.Diagnostics.Metrics;\nusing Microsoft.Extensions.Configuration;\n\nnamespace xbytechat.api.Infrastructure.Observability\n{\n    /// <summary>\n    /// Central metrics facade with a hard OFF switch.\n    /// When Observability:Metrics:Enabled=false, all calls no-op.\n    /// </summary>\n    public static class MetricsRegistry\n    {\n        private static bool _enabled;\n        private static Meter? _meter;\n        private static long _queueDepth;\n\n        // Proxies let existing call sites stay unchanged.\n        public static readonly CounterProxy MessagesSent = new();\n        public static readonly CounterProxy MessagesFailed = new();\n        public static readonly CounterProxy RateLimited429s = new();\n        public static readonly HistProxy SendLatencyMs = new();\n\n        /// <summary>Call once at startup from Program.cs.</summary>\n        public static void Configure(IConfiguration cfg)\n        {\n            _enabled = cfg.GetValue<bool>(\"Observability:Metrics:Enabled\", false);\n\n            if (!_enabled)\n            {\n                _meter = null; // proxies remain unbound => no-ops\n                return;\n            }\n\n            _meter = new Meter(\"xbytechat.api\", \"1.0.0\");\n\n            // Bind proxies to actual instruments\n            MessagesSent.Bind(_meter.CreateCounter<long>(\"campaign_messages_sent\", unit: \"msg\",\n                description: \"Accepted by provider\"));\n            MessagesFailed.Bind(_meter.CreateCounter<long>(\"campaign_messages_failed\", unit: \"msg\",\n                description: \"Failed sends\"));\n            RateLimited429s.Bind(_meter.CreateCounter<long>(\"campaign_http_429\", unit: \"hit\",\n                description: \"HTTP 429 responses\"));\n            SendLatencyMs.Bind(_meter.CreateHistogram<double>(\"campaign_send_latency_ms\", unit: \"ms\",\n                description: \"Provider send latency\"));\n\n            _meter.CreateObservableGauge(\"campaign_queue_depth\",\n                () => new Measurement<long>(_queueDepth),\n                unit: \"jobs\",\n                description: \"Outbound campaign jobs waiting in this process\");\n        }\n\n        public static void ReportQueueDepth(long depth)\n        {\n            if (_enabled) _queueDepth = depth;\n        }\n\n        // ---------- Proxies (no-ops when not bound / disabled) ----------\n\n        public sealed class CounterProxy\n        {\n            private Counter<long>? _inner;\n            internal void Bind(Counter<long> inner) => _inner = inner;\n            public void Add(long value) { if (_enabled) _inner?.Add(value); }\n        }\n\n        public sealed class HistProxy\n        {\n            private Histogram<double>? _inner;\n            internal void Bind(Histogram<double> inner) => _inner = inner;\n            public void Record(double value) { if (_enabled) _inner?.Record(value); }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Infrastructure/RateLimiting/PhoneNumberRateLimiter.cs",
      "sha256": "4d1af7bc0ea2e6b6497801cf8749cb1ab4f00fe2a6c85cf8935cb31758552bea",
      "language": "csharp",
      "size": 1851,
      "content": "using System.Collections.Concurrent;\nusing System.Threading.RateLimiting;\n\nnamespace xbytechat.api.Infrastructure.RateLimiting\n{\n    /// <summary>\n    /// Token-bucket limiter per senderKey (Provider|PhoneNumberId).\n    /// Default: 10 req/s with burst 10. You can tune dynamically.\n    /// </summary>\n    public interface IPhoneNumberRateLimiter\n    {\n        ValueTask<RateLimitLease> AcquireAsync(string senderKey, CancellationToken ct);\n        void UpdateLimits(string senderKey, int permitsPerSecond, int burst);\n    }\n\n    public sealed class PhoneNumberRateLimiter : IPhoneNumberRateLimiter\n    {\n        private readonly ConcurrentDictionary<string, TokenBucketRateLimiter> _buckets = new();\n\n        public ValueTask<RateLimitLease> AcquireAsync(string senderKey, CancellationToken ct)\n        {\n            var limiter = _buckets.GetOrAdd(senderKey, _ => Create(permitsPerSecond: 10, burst: 10));\n            return limiter.AcquireAsync(1, ct);\n        }\n\n        public void UpdateLimits(string senderKey, int permitsPerSecond, int burst)\n        {\n            _buckets.AddOrUpdate(senderKey,\n                _ => Create(permitsPerSecond, burst),\n                (_, __) => Create(permitsPerSecond, burst));\n        }\n\n        private static TokenBucketRateLimiter Create(int permitsPerSecond, int burst)\n        {\n            return new TokenBucketRateLimiter(new TokenBucketRateLimiterOptions\n            {\n                TokenLimit = Math.Max(1, burst),\n                TokensPerPeriod = Math.Max(1, permitsPerSecond),\n                ReplenishmentPeriod = TimeSpan.FromSeconds(1),   // ‚Üê correct property name\n                QueueProcessingOrder = QueueProcessingOrder.OldestFirst,\n                QueueLimit = 0                                    // no internal queue; your outbox already queues\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Infrastructure/Schema/SchemaPatchRunner.cs",
      "sha256": "579a0edb4a3292723951ebd710cd840415059aa16baf789ee313a26cb9c3af26",
      "language": "csharp",
      "size": 3388,
      "content": "using System;\nusing System.Data;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Infrastructure.Schema\n{\n    public static class SchemaPatchRunner\n    {\n        /// <summary>\n        /// Ensures a patch is applied exactly once. Creates the tracking table if needed.\n        /// </summary>\n        /// <param name=\"db\">AppDbContext</param>\n        /// <param name=\"patchId\">A unique string, e.g. \"20251003_campaign_cascade\"</param>\n        /// <param name=\"absoluteSqlPath\">Absolute path to the .sql file</param>\n        public static async Task EnsurePatchAsync(DbContext db, string patchId, string absoluteSqlPath)\n        {\n            if (!File.Exists(absoluteSqlPath))\n                throw new FileNotFoundException($\"Schema patch not found: {absoluteSqlPath}\");\n\n            var conn = db.Database.GetDbConnection();\n            await conn.OpenAsync();\n\n            await using var tx = await conn.BeginTransactionAsync();\n\n            try\n            {\n                // 1) Create tracking table if not exists\n                await using (var cmd = conn.CreateCommand())\n                {\n                    cmd.Transaction = tx;\n                    cmd.CommandText = @\"\nCREATE TABLE IF NOT EXISTS __schema_patches (\n    patch_id   text PRIMARY KEY,\n    applied_at timestamp with time zone NOT NULL DEFAULT now()\n);\";\n                    await cmd.ExecuteNonQueryAsync();\n                }\n\n                // 2) Check if already applied\n                bool alreadyApplied;\n                await using (var check = conn.CreateCommand())\n                {\n                    check.Transaction = tx;\n                    check.CommandText = \"SELECT 1 FROM __schema_patches WHERE patch_id = @p LIMIT 1;\";\n                    var p = check.CreateParameter();\n                    p.ParameterName = \"@p\";\n                    p.Value = patchId;\n                    check.Parameters.Add(p);\n\n                    await using var reader = await check.ExecuteReaderAsync();\n                    alreadyApplied = await reader.ReadAsync();\n                }\n\n                if (!alreadyApplied)\n                {\n                    // 3) Run SQL file\n                    var sql = await File.ReadAllTextAsync(absoluteSqlPath);\n\n                    await using (var exec = conn.CreateCommand())\n                    {\n                        exec.Transaction = tx;\n                        exec.CommandText = sql;\n                        await exec.ExecuteNonQueryAsync();\n                    }\n\n                    // 4) Record success\n                    await using (var ins = conn.CreateCommand())\n                    {\n                        ins.Transaction = tx;\n                        ins.CommandText = \"INSERT INTO __schema_patches (patch_id) VALUES (@p);\";\n                        var p = ins.CreateParameter();\n                        p.ParameterName = \"@p\";\n                        p.Value = patchId;\n                        ins.Parameters.Add(p);\n                        await ins.ExecuteNonQueryAsync();\n                    }\n                }\n\n                await tx.CommitAsync();\n            }\n            catch\n            {\n                await tx.RollbackAsync();\n                throw;\n            }\n            finally\n            {\n                await conn.CloseAsync();\n            }\n        }\n    }\n}\n"
    }
  ]
}
