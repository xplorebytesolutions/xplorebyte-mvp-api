{
  "name": "xbytechat-api",
  "part": 1,
  "of": 25,
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/appsettings.json",
      "sha256": "5424b2c610d4974d105ca7e82c352725d7f46ddd9b4488fb7dfff43b8d3efba0",
      "language": "json",
      "size": 1364,
      "content": "{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n\n  \"JwtSettings\": {\n    \"Issuer\": \"xbytechat-api\",\n    \"Audience\": \"xbytechat-client\",\n    \"ExpiryMinutes\": 60,\n    \"SecretKey\": \"CHANGE_ME\"\n  },\n\n  \"WhatsApp\": {\n    \"ApiUrl\": \"https://graph.facebook.com/v23.0/601884673011340/messages\",\n    \"WABA_ID\": \"744548247936621\"\n  },\n\n  \"Cors\": {\n    \"AllowedOrigins\": []\n  },\n\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"\"\n  },\n\n  \"Tracking\": {\n    \"BaseUrl\": \"https://app.xplorebytesolutions.com\",\n    \"Secret\": \"replaceXwithX64+charQrandomhsecret\"\n  },\n\n  \"Debugging\": {\n    \"DebugKey\": \"use-a-long-random-string-here\"\n  },\n  \"FlowClickTokens\": {\n    \"BaseUrl\": \"https://app.xplorebytesolutions.com\",\n    \"Secret\": \"useVaVveryGlongYrandomFstringQhere\",\n    \"TtlHours\": 72\n  },\n  \"Esu\": {\n    \"Facebook\": {\n      \"AppId\": \"1437718797546390\",\n      \"AppSecret\": \"\",\n      \"RedirectUri\": \"https://www.xplorebyte.com/api/esu/facebook/callback\",\n      \"Scopes\": \"whatsapp_business_management,whatsapp_business_messaging\",\n      \"StateTtlMinutes\": 20,\n      \"GraphBaseUrl\": \"https://graph.facebook.com\",\n      \"GraphApiVersion\": \"v22.0\"\n    },\n    \"FlagCache\": {\n      \"TtlSeconds\": 30,\n      \"MissTtlSeconds\": 5\n    }\n  }\n\n}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Controllers/AuthController.cs",
      "sha256": "6453dee724eb4ecf1de4f6f500be89ecbc72fdc75e92ffe5a0f134da8acfb27b",
      "language": "csharp",
      "size": 14863,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security.Claims;\nusing xbytechat.api.AuthModule.DTOs;\nusing xbytechat.api.AuthModule.Services;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Security.Claims;\nusing xbytechat.api.Features.AccessControl.Services;\n\nnamespace xbytechat.api.AuthModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class AuthController : ControllerBase\n    {\n        private readonly IAuthService _authService;\n        private readonly IAccessControlService _accessControlService;\n\n        public AuthController(IAuthService authService, IAccessControlService accessControlService)\n        {\n            _authService = authService;\n            _accessControlService = accessControlService;\n        }\n\n        // ‚úÖ Login ‚Üí return { token } (NO cookies)\n        [AllowAnonymous]\n        [HttpPost(\"login\")]\n        public async Task<IActionResult> Login([FromBody] UserLoginDto dto)\n        {\n            var result = await _authService.LoginAsync(dto);\n            if (!result.Success || string.IsNullOrWhiteSpace(result.Token))\n                return Unauthorized(new { success = false, message = result.Message });\n\n            return Ok(new { token = result.Token });\n        }\n\n        // (Optional) Refresh token endpoint if you still issue refresh tokens.\n        // Returns tokens in body (NO cookies).\n        [AllowAnonymous]\n        [HttpPost(\"refresh-token\")]\n        public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenRequest request)\n        {\n            var result = await _authService.RefreshTokenAsync(request.RefreshToken);\n            if (!result.Success) return Unauthorized(new { success = false, message = result.Message });\n\n            dynamic data = result.Data!;\n            return Ok(new\n            {\n                accessToken = data.accessToken,\n                refreshToken = data.refreshToken\n            });\n        }\n        // ‚úÖ Signup\n        [HttpPost(\"business-user-signup\")]\n        public async Task<IActionResult> Signup([FromBody] SignupBusinessDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                var errors = ModelState.Values\n                    .SelectMany(v => v.Errors)\n                    .Select(e => e.ErrorMessage)\n                    .ToList();\n\n                return BadRequest(new\n                {\n                    success = false,\n                    message = \"‚ùå Validation failed.\",\n                    errors\n                });\n            }\n\n            var result = await _authService.SignupAsync(dto);\n            return result.Success ? Ok(result) : BadRequest(result);\n        }\n\n        // ‚úÖ Logout (stateless JWT): nothing server-side to do\n        [Authorize]\n        [HttpPost(\"logout\")]\n        public IActionResult Logout() => Ok(new { success = true, message = \"Logged out\" });\n\n        // ‚úÖ (Optional) lightweight session echo from claims (works with Bearer)\n        [Authorize]\n        [HttpGet(\"session\")]\n        public IActionResult GetSession()\n        {\n            var user = HttpContext.User;\n            if (user?.Identity is not { IsAuthenticated: true }) return BadRequest(\"Invalid session\");\n\n            var email = user.FindFirst(ClaimTypes.Email)?.Value ?? \"unknown\";\n            var role = user.FindFirst(ClaimTypes.Role)?.Value\n                       ?? user.FindFirst(\"role\")?.Value\n                       ?? \"unknown\";\n            var plan = user.FindFirst(\"plan\")?.Value ?? \"basic\";\n            var biz = user.FindFirst(\"businessId\")?.Value;\n\n            return Ok(new { isAuthenticated = true, role, email, plan, businessId = biz });\n        }\n\n     \n\n        [Authorize]\n        [HttpGet(\"me\")]\n        public IActionResult Me()\n        {\n            var user = HttpContext.User;\n\n            var userId =\n                user.FindFirst(JwtRegisteredClaimNames.Sub)?.Value ??\n                user.FindFirst(ClaimTypes.NameIdentifier)?.Value ??\n                user.FindFirst(\"uid\")?.Value;\n\n            if (string.IsNullOrWhiteSpace(userId))\n            {\n                return Unauthorized(new { ok = false, message = \"Missing user id in token.\" });\n            }\n\n            var email =\n                user.FindFirst(ClaimTypes.Email)?.Value ??\n                user.FindFirst(JwtRegisteredClaimNames.Email)?.Value ??\n                user.FindFirst(\"email\")?.Value;\n\n            var role =\n                user.FindFirst(ClaimTypes.Role)?.Value ??\n                user.FindFirst(\"role\")?.Value ?? \"business\";\n\n            var businessId =\n                user.FindFirst(\"businessId\")?.Value ??\n                user.FindFirst(\"BusinessId\")?.Value ??\n                user.FindFirst(\"business_id\")?.Value;\n\n            return Ok(new\n            {\n                ok = true,\n                user = new\n                {\n                    id = userId,\n                    email,\n                    role\n                },\n                businessId,\n                hasAllAccess = role.Equals(\"admin\", StringComparison.OrdinalIgnoreCase)\n                            || role.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase)\n                            || role.Equals(\"partner\", StringComparison.OrdinalIgnoreCase)\n                            || role.Equals(\"reseller\", StringComparison.OrdinalIgnoreCase)\n            });\n        }\n\n        // -----------------------------------------------------------\n        // ‚úÖ Main auth context: /api/auth/context\n        //    This is what your AuthProvider/refreshAuthContext wants.\n        // -----------------------------------------------------------\n        //[Authorize]\n        //[HttpGet(\"context\")]\n        //public async Task<IActionResult> GetContext()\n        //{\n        //    var principal = HttpContext.User;\n\n        //    // --- User id (mandatory) ---\n        //    var userIdStr =\n        //        principal.FindFirst(JwtRegisteredClaimNames.Sub)?.Value ??\n        //        principal.FindFirst(ClaimTypes.NameIdentifier)?.Value ??\n        //        principal.FindFirst(\"uid\")?.Value;\n\n        //    if (!Guid.TryParse(userIdStr, out var userId))\n        //    {\n        //        return Unauthorized(new\n        //        {\n        //            ok = false,\n        //            isAuthenticated = false,\n        //            message = \"Invalid or missing user id claim.\"\n        //        });\n        //    }\n\n        //    // --- Email ---\n        //    var email =\n        //        principal.FindFirst(ClaimTypes.Email)?.Value ??\n        //        principal.FindFirst(JwtRegisteredClaimNames.Email)?.Value ??\n        //        principal.FindFirst(\"email\")?.Value;\n\n        //    // --- Role ---\n        //    var role =\n        //        principal.FindFirst(ClaimTypes.Role)?.Value ??\n        //        principal.FindFirst(\"role\")?.Value ??\n        //        \"business\";\n\n        //    // --- BusinessId (GUID, optional for some roles) ---\n        //    var businessIdClaim =\n        //        principal.FindFirst(\"businessId\")?.Value ??\n        //        principal.FindFirst(\"BusinessId\")?.Value ??\n        //        principal.FindFirst(\"business_id\")?.Value;\n\n        //    Guid? businessId = null;\n        //    if (Guid.TryParse(businessIdClaim, out var bizGuid))\n        //    {\n        //        businessId = bizGuid;\n        //    }\n\n        //    // --- PlanId (optional) ---\n        //    var planIdClaim =\n        //        principal.FindFirst(\"plan_id\")?.Value ??\n        //        principal.FindFirst(\"planId\")?.Value;\n\n        //    Guid? planId = null;\n        //    if (Guid.TryParse(planIdClaim, out var planGuid))\n        //    {\n        //        planId = planGuid;\n        //    }\n\n        //    // --- Status (active / pending / suspended / etc.) ---\n        //    var status =\n        //        principal.FindFirst(\"status\")?.Value ??\n        //        principal.FindFirst(\"biz_status\")?.Value ??\n        //        principal.FindFirst(\"businessStatus\")?.Value ??\n        //        principal.FindFirst(\"bizStatus\")?.Value ??\n        //        \"active\";\n\n        //    // --- All-access roles (admin, superadmin, partner, reseller, etc.) ---\n        //    var hasAllAccess =\n        //        role.Equals(\"admin\", StringComparison.OrdinalIgnoreCase) ||\n        //        role.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase) ||\n        //        role.Equals(\"partner\", StringComparison.OrdinalIgnoreCase) ||\n        //        role.Equals(\"reseller\", StringComparison.OrdinalIgnoreCase);\n\n        //    // --- Permissions from AccessControl service ---\n        //    var permissions = await _accessControlService.GetPermissionsAsync(userId);\n\n        //    // For now, expose the same codes as \"features\" so the SPA can bootstrap.\n        //    // Entitlements API remains the long-term source of truth.\n        //    var features = permissions;\n\n        //    // --- Build the shape expected by AuthProvider.refreshAuthContext ---\n        //    return Ok(new\n        //    {\n        //        ok = true,\n        //        isAuthenticated = true,\n\n        //        // Used by AuthProvider + ProtectedRoute\n        //        user = new\n        //        {\n        //            id = userId,\n        //            email,\n        //            role\n        //        },\n\n        //        business = businessId.HasValue\n        //            ? new\n        //            {\n        //                id = businessId.Value,\n        //                businessId = businessId.Value,\n        //                planId = planId,\n        //                status\n        //            }\n        //            : null,\n\n        //        businessId = businessId,\n        //        role,\n        //        status,\n        //        hasAllAccess,\n        //        permissions,\n        //        features,\n        //        planId\n        //    });\n        //}\n        [Authorize]\n        [HttpGet(\"context\")]\n        public async Task<IActionResult> GetContext()\n        {\n            var principal = HttpContext.User;\n\n            // --- User id (mandatory) ---\n            var userIdStr =\n                principal.FindFirst(JwtRegisteredClaimNames.Sub)?.Value ??\n                principal.FindFirst(ClaimTypes.NameIdentifier)?.Value ??\n                principal.FindFirst(\"uid\")?.Value ??\n                principal.FindFirst(\"id\")?.Value;\n\n            if (!Guid.TryParse(userIdStr, out var userId))\n            {\n                return Unauthorized(new\n                {\n                    ok = false,\n                    isAuthenticated = false,\n                    message = \"Invalid or missing user id claim.\"\n                });\n            }\n\n            // --- Email ---\n            var email =\n                principal.FindFirst(ClaimTypes.Email)?.Value ??\n                principal.FindFirst(JwtRegisteredClaimNames.Email)?.Value ??\n                principal.FindFirst(\"email\")?.Value;\n\n            // --- User display name ---\n            var userName =\n                principal.FindFirst(\"name\")?.Value ??\n                principal.FindFirst(ClaimTypes.Name)?.Value ??\n                principal.FindFirst(\"fullName\")?.Value ??\n                principal.FindFirst(\"fullname\")?.Value;\n\n            // --- Role ---\n            var role =\n                principal.FindFirst(ClaimTypes.Role)?.Value ??\n                principal.FindFirst(\"role\")?.Value ??\n                \"business\";\n\n            // --- BusinessId (GUID, optional for some roles) ---\n            var businessIdClaim =\n                principal.FindFirst(\"businessId\")?.Value ??\n                principal.FindFirst(\"BusinessId\")?.Value ??\n                principal.FindFirst(\"business_id\")?.Value;\n\n            Guid? businessId = null;\n            if (Guid.TryParse(businessIdClaim, out var bizGuid))\n            {\n                businessId = bizGuid;\n            }\n\n            // --- PlanId (optional) ---\n            var planIdClaim =\n                principal.FindFirst(\"plan_id\")?.Value ??\n                principal.FindFirst(\"planId\")?.Value;\n\n            Guid? planId = null;\n            if (Guid.TryParse(planIdClaim, out var planGuid))\n            {\n                planId = planGuid;\n            }\n\n            // --- Status (active / pending / suspended / etc.) ---\n            var status =\n                principal.FindFirst(\"status\")?.Value ??\n                principal.FindFirst(\"biz_status\")?.Value ??\n                principal.FindFirst(\"businessStatus\")?.Value ??\n                principal.FindFirst(\"bizStatus\")?.Value ??\n                \"active\";\n\n            // --- Business name / company name (for Topbar display) ---\n            var companyName =\n                principal.FindFirst(\"businessName\")?.Value ??\n                principal.FindFirst(\"companyName\")?.Value ??\n                principal.FindFirst(\"bizName\")?.Value;\n\n            // --- All-access roles (admin, superadmin, partner, reseller, etc.) ---\n            var hasAllAccess =\n                role.Equals(\"admin\", StringComparison.OrdinalIgnoreCase) ||\n                role.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase) ||\n                role.Equals(\"partner\", StringComparison.OrdinalIgnoreCase) ||\n                role.Equals(\"reseller\", StringComparison.OrdinalIgnoreCase);\n\n            // --- Permissions from AccessControl service ---\n            var permissions = await _accessControlService.GetPermissionsAsync(userId);\n\n            // For now, expose the same codes as \"features\" so the SPA can bootstrap.\n            // Entitlements API remains the long-term source of truth.\n            var features = permissions;\n\n            // --- Build the shape expected by AuthProvider.refreshAuthContext ---\n            return Ok(new\n            {\n                ok = true,\n                isAuthenticated = true,\n\n                // Used by AuthProvider + ProtectedRoute\n                user = new\n                {\n                    id = userId,\n                    email,\n                    role,\n                    name = userName,\n                    fullName = userName,\n                    displayName = userName\n                },\n\n                business = businessId.HasValue\n                    ? new\n                    {\n                        id = businessId.Value,\n                        businessId = businessId.Value,\n                        businessName = companyName,\n                        companyName = companyName,\n                        planId,\n                        status\n                    }\n                    : null,\n\n                businessId,\n                role,\n                status,\n                hasAllAccess,\n                permissions,\n                features,\n                planId\n            });\n        }\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Controllers/MeController.cs",
      "sha256": "4a1a9ee43f2516879df38fdf87dff87e50f0d932946385c3df1acda490085168",
      "language": "csharp",
      "size": 3184,
      "content": "#nullable enable\nusing System.Security.Claims;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace xbytechat.api.AuthModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/me\")]\n    public sealed class MeController : ControllerBase\n    {\n        [HttpGet]\n        [Authorize]\n        public IActionResult Get()\n        {\n            string? userId =\n                User.FindFirst(\"uid\")?.Value ??\n                User.FindFirst(ClaimTypes.NameIdentifier)?.Value ??\n                User.FindFirst(\"sub\")?.Value;\n\n            string role =\n                User.FindFirst(\"role\")?.Value ??\n                User.FindFirst(ClaimTypes.Role)?.Value ??\n                \"business\";\n\n            string? businessId =\n                User.FindFirst(\"bid\")?.Value ??\n                User.FindFirst(\"BusinessId\")?.Value ??\n                User.FindFirst(\"business_id\")?.Value;\n\n            if (string.IsNullOrWhiteSpace(userId))\n            {\n                return Unauthorized(new { ok = false, message = \"Missing uid/sub claim.\" });\n            }\n\n            // Only enforce BusinessId for non-admins\n            if (!string.Equals(role, \"admin\", StringComparison.OrdinalIgnoreCase) &&\n                string.IsNullOrWhiteSpace(businessId))\n            {\n                return Unauthorized(new { ok = false, message = \"Missing BusinessId claim.\" });\n            }\n\n            var name = User.Identity?.Name ?? \"User\";\n            var permissions = new[] { \"*\" }; // replace later\n\n            return Ok(new\n            {\n                ok = true,\n                user = new { id = userId, name, role },\n                businessId,          // can be null for admin\n                hasAllAccess = string.Equals(role, \"admin\", StringComparison.OrdinalIgnoreCase)\n            });\n        }\n    }\n}\n\n\n//#nullable enable\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api.Shared;\n\n\n\n//namespace xbytechat.api.AuthModule.Controllers\n//{\n\n//    [ApiController]\n//    [Route(\"api/me\")]\n//    public sealed class MeController : ControllerBase\n//    {\n//        [HttpGet]\n//        [Authorize] // requires valid JWT\n//        public IActionResult Get()\n//        {\n//            try\n//            {\n//                var userId = User.GetUserId();        // throws if missing/invalid\n//                var businessId = User.GetBusinessId(); // throws if missing/invalid\n\n//                // Optional: expose a friendly name if you put it in the token\n//                var name = User.Identity?.Name ?? \"User\";\n\n//                // TODO: replace with your real permission source later\n//                var permissions = new[] { \"*\" };\n\n//                return Ok(new\n//                {\n//                    ok = true,\n//                    user = new { id = userId, name },\n//                    businessId,\n//                    permissions\n//                });\n//            }\n//            catch (UnauthorizedAccessException ex)\n//            {\n//                return Unauthorized(new { ok = false, message = ex.Message });\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Controllers/TestJwtController.cs",
      "sha256": "c407c3fdf8977cffcb0cd6131f617087ede160fd75646be61000b68f7a455a22",
      "language": "csharp",
      "size": 2087,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.AuthModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/auth/test\")]\n    public class TestJwtController : ControllerBase\n    {\n        [Authorize]\n        [HttpGet(\"get-logged-in\")]\n        public IActionResult GetLoggedInUserInfo()\n        {\n            var userId = UserContextHelper.GetUserId(User);\n            var businessId = UserContextHelper.GetBusinessId(User);\n            var role = UserContextHelper.GetRole(User);\n            var plan = UserContextHelper.GetPlan(User);\n            var companyName = UserContextHelper.GetCompanyName(User);\n\n            return Ok(new\n            {\n                success = true,\n                message = \"üîê JWT is valid. Here's your decoded info:\",\n                data = new\n                {\n                    userId,\n                    businessId,\n                    role,\n                    plan,\n                    companyName\n                }\n            });\n        }\n\n        [HttpGet(\"get-current-user\")]\n        public IActionResult GetCurrentUser()\n        {\n            if (User?.Identity?.IsAuthenticated != true)\n            {\n                return Unauthorized(new { success = false, message = \"‚ùå Not authenticated\" });\n            }\n\n            var userId = User.FindFirst(\"sub\")?.Value;\n            var email = User.FindFirst(\"email\")?.Value;\n            var role = User.FindFirst(\"role\")?.Value;\n            var businessId = User.FindFirst(\"businessId\")?.Value;\n            var plan = User.FindFirst(\"plan\")?.Value;\n            var permissions = User.FindFirst(\"permissions\")?.Value;\n\n            return Ok(new\n            {\n                success = true,\n                message = \"‚úÖ Token is valid\",\n                user = new\n                {\n                    userId,\n                    email,\n                    role,\n                    businessId,\n                    plan,\n                    permissions\n                }\n            });\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/AuthModule/DTOs/RefreshTokenRequest.cs",
      "sha256": "5f68342bebd5c2664561285523bcabe509a7ffe5fe9c995eeeaf821aba238e2d",
      "language": "csharp",
      "size": 142,
      "content": "namespace xbytechat.api.AuthModule.DTOs\n{\n    public class RefreshTokenRequest\n    {\n        public string RefreshToken { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/DTOs/ResendConfirmationDto.cs",
      "sha256": "c390da7f0aa2324928025edc1a4ce1c65e079357cb2219fade8cdc4153734982",
      "language": "csharp",
      "size": 226,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.AuthModule.DTOs\n{\n    public class ResendConfirmationDto\n    {\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/AuthModule/DTOs/ResetPasswordDto.cs",
      "sha256": "33b22ea5acec9376aef19d7c09ff580b689f7a6bc04ea1d6f214dd9b203de0c4",
      "language": "csharp",
      "size": 374,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.AuthModule.DTOs\n{\n    public class ResetPasswordDto\n    {\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; }\n\n        [Required]\n        [MinLength(6, ErrorMessage = \"Password must be at least 6 characters long.\")]\n        public string NewPassword { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/DTOs/UserDto.cs",
      "sha256": "47384e5d11fcdfb564f639c3937db6f3aa97f5963366ecb7af4dc37e6a311ff1",
      "language": "csharp",
      "size": 587,
      "content": "namespace xbytechat.api.AuthModule.DTOs\n{\n    public class UserDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; }\n        public string Email { get; set; }\n        public string Role { get; set; }\n        public string Status { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n        // ‚úÖ Extra fields\n        public Guid BusinessId { get; set; }\n        public string CompanyName { get; set; }\n        public string Plan { get; set; }\n        public string AccessToken { get; set; }\n\n        public Guid? PlanId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/DTOs/UserLoginDto.cs",
      "sha256": "d0b1140af88b221c2cb7dbd58223d5803643620b16d27f016aba26ed9b816482",
      "language": "csharp",
      "size": 281,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.AuthModule.DTOs\n{\n    public class UserLoginDto\n    {\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; }\n\n        [Required]\n        public string Password { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Models/User.cs",
      "sha256": "25f82a426c60ebda55385071a527cb10389e2f164415031be0a718cc4dc8f768",
      "language": "csharp",
      "size": 1761,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models; // üÜï Required for navigation\n\nnamespace xbytechat.api.AuthModule.Models\n{\n    public class User\n    {\n        public Guid Id { get; set; }\n\n        // üîó FK to Business\n        public Guid? BusinessId { get; set; }\n        public Business Business { get; set; }\n\n        // üë§ User Info\n        [Required]\n        public string Name { get; set; }\n\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; }\n\n        [Required]\n        public string PasswordHash { get; set; }\n\n        // üõ°Ô∏è Role System\n        // üõ°Ô∏è Role System (FK + Navigation)\n        public Guid? RoleId { get; set; }\n        public Role Role { get; set; }// admin / business / agent / staff\n\n        // ‚úÖ Status Management\n        public string Status { get; set; } = \"Pending\"; // Active / Hold / Rejected / Pending\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // üóëÔ∏è Soft Delete Role \n        public bool IsDeleted { get; set; } = false;\n        public DateTime? DeletedAt { get; set; }\n\n        public List<CampaignSendLog> SendLogs { get; set; }\n        public ICollection<MessageStatusLog> MessageStatusLogs { get; set; }\n\n        // üÜï Permission Navigation\n        public ICollection<UserPermission> UserPermissions { get; set; } // üí° Enables .WithMany(u => u.UserPermissions)\n        public string? RefreshToken { get; set; }\n        public DateTime? RefreshTokenExpiry { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Models/WhatsAppTemplate.cs",
      "sha256": "f6d549b8bc59ee42cba54fb40b14be15a99861230b581b6224dd95b14f29fd22",
      "language": "csharp",
      "size": 5144,
      "content": "using System.ComponentModel.DataAnnotations;\n\nusing Microsoft.EntityFrameworkCore;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.AuthModule.Models\n{\n    // All enum usages removed. We store canonical strings instead.\n\n    //[Index(nameof(BusinessId), nameof(Provider))]\n    //[Index(nameof(BusinessId), nameof(Name))]\n    //[Index(nameof(BusinessId), nameof(Name), nameof(LanguageCode), nameof(Provider), IsUnique = true)]\n    public sealed class WhatsAppTemplate\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n\n        // Provider is stored as UPPERCASE per your decision: e.g., \"META_CLOUD\", \"PINNACLE\", \"OTHER\"\n        [MaxLength(40)]\n        public string Provider { get; set; } = \"META_CLOUD\";\n\n        public string? TemplateId { get; set; }\n\n        [MaxLength(160)]\n        public string Name { get; set; } = string.Empty;\n\n        [MaxLength(16)]\n        public string LanguageCode { get; set; } = \"en_US\";\n\n        // Former TemplateStatus enum ‚Üí string (canonical UPPERCASE: APPROVED/REJECTED/PENDING/PAUSED/UNKNOWN)\n        [MaxLength(24)]\n        public string Status { get; set; } = \"APPROVED\";\n\n        public string? Category { get; set; }\n        public string? SubCategory { get; set; }\n\n        // Full provider JSON\n        public string RawJson { get; set; } = \"{}\";\n\n        // Former ParameterFormat enum ‚Üí string (canonical UPPERCASE: POSITIONAL/NAMED/UNKNOWN)\n        [MaxLength(24)]\n        public string ParameterFormat { get; set; } = \"UNKNOWN\";\n\n        // Former HeaderKind enum ‚Üí string (canonical lowercase: none/text/image/video/document/location)\n        [MaxLength(16)]\n        public string HeaderKind { get; set; } = \"none\";\n\n        public string? HeaderText { get; set; }\n        public string? Body { get; set; }\n        public string? BodyPreview { get; set; }\n\n        public bool RequiresMediaHeader { get; set; }\n\n        // Counts (kept as ints)\n        public int BodyVarCount { get; set; }\n        public int HeaderTextVarCount { get; set; }\n        public int TotalTextParamCount { get; set; }\n\n        // JSON blobs\n        public string? UrlButtons { get; set; }      // jsonb\n        public int QuickReplyCount { get; set; }\n        public bool HasPhoneButton { get; set; }\n        public string? NamedParamKeys { get; set; }  // jsonb\n        public string? PlaceholderMap { get; set; }  // jsonb\n\n        public bool IsActive { get; set; } = true;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime LastSyncedAt { get; set; } = DateTime.UtcNow;\n\n        // Concurrency\n        public byte[]? RowVersion { get; set; }\n    }\n}\n\n\n//using Microsoft.EntityFrameworkCore;\n//using System.ComponentModel.DataAnnotations;\n\n//namespace xbytechat.api.AuthModule.Models\n//{\n//    [Index(nameof(BusinessId), nameof(Provider))]\n//    [Index(nameof(BusinessId), nameof(Name))]\n//    [Index(nameof(BusinessId), nameof(Name), nameof(Language), nameof(Provider), IsUnique = true)]\n//    // xbytechat_api/WhatsAppSettings/Models/WhatsAppTemplate.cs\n//    public sealed class WhatsAppTemplate\n//    {\n//        public Guid Id { get; set; }\n//        public Guid BusinessId { get; set; }\n//        public string Provider { get; set; } = \"META_CLOUD\";\n//        public string? ExternalId { get; set; }\n//        public string Name { get; set; } = \"\";\n//        public string? Language { get; set; }\n//        public string Status { get; set; } = \"APPROVED\";\n//        public string? Category { get; set; }\n\n//        // Already present in your code:\n//        public string? HeaderKind { get; set; }           // \"text\", \"image\", \"video\", \"document\", \"none\"\n//        public string? Body { get; set; }                 // we keep this as the COMBINED PREVIEW (headerText + bodyText)\n//        public int PlaceholderCount { get; set; }\n//        public string? ButtonsJson { get; set; }\n//        public string? RawJson { get; set; }\n\n//        // ‚úÖ NEW: cached, de-normalized fields for debug + send-time mapping\n//        public string? ParameterFormat { get; set; }      // \"POSITIONAL\" | \"NAMED\" | \"MIXED\" | \"UNKNOWN\"\n//        public string? HeaderText { get; set; }           // only for text headers; null for media headers\n//        public string? BodyText { get; set; }             // body block text as-is (no header included)\n\n//        // token metadata (JSON for flexibility)\n//        public string? HeaderParamIndicesJson { get; set; }   // e.g. \"[1,2]\"\n//        public string? BodyParamIndicesJson { get; set; }     // e.g. \"[1,3]\"\n//        public string? ButtonParamTemplatesJson { get; set; } // e.g. \"[{ order:1, type:'URL', text:'..', paramTemplate:'..', paramIndices:[1]}]\"\n//        public string? PlaceholderOccurrencesJson { get; set; } // full `Placeholders` array from helper (optional)\n\n//        public bool IsActive { get; set; } = true;\n//        public DateTime CreatedAt { get; set; }\n//        public DateTime UpdatedAt { get; set; }\n//        public DateTime LastSyncedAt { get; set; }\n//    }\n\n//}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Roles/UserRoles.cs",
      "sha256": "5a91bb09b9b5fc0f5fe14cf1b9727c0c8a8de225c71455452a14d491125209c5",
      "language": "csharp",
      "size": 507,
      "content": "namespace xbytechat.api.AuthModule.Roles\n{\n    public static class UserRoles\n    {\n        public const string Admin = \"admin\";         // xByte Admin\n        public const string Business = \"business\";   // Tenant Admin\n        public const string Staff = \"staff\";         // CRM Staff (future)\n        public const string Agent = \"agent\";         // WhatsApp/chat agent\n        public const string CRM = \"crm\";             // CRM-only user (future)\n        public const string Partner = \"partner\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Services/AuthService.cs",
      "sha256": "379e7afa5ee08acb8f22afa45cddb3307f1da5fb9e98559056e7c8fa59a69f57",
      "language": "csharp",
      "size": 28698,
      "content": "using System.Security.Cryptography;\nusing System.Text;\nusing xbytechat.api.AuthModule.DTOs;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Repositories.Interfaces;\nusing xbytechat.api.Features.AccessControl.Services;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.AspNetCore.Http;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.BusinessModule.Services;\n\nusing System.Security.Claims;\nusing System.IdentityModel.Tokens.Jwt;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.AuthModule.Services\n{\n    public class AuthService : IAuthService\n    {\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IBusinessService _businessService;\n        private readonly IJwtTokenService _jwtTokenService;\n        private readonly IAccessControlService _accessControlService;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        private readonly ILogger<AuthService> _logger;\n        private readonly AppDbContext _dbContext;\n        public AuthService(\n            IGenericRepository<User> userRepo,\n            IBusinessService businessService,\n            IJwtTokenService jwtTokenService,\n            IAccessControlService accessControlService,\n            IHttpContextAccessor httpContextAccessor,\n            ILogger<AuthService> logger,\n            AppDbContext dbContext)\n        {\n            _userRepo = userRepo;\n            _businessService = businessService;\n            _jwtTokenService = jwtTokenService;\n            _accessControlService = accessControlService;\n            _httpContextAccessor = httpContextAccessor;\n            _logger = logger;\n            _dbContext = dbContext;\n        }\n\n        //        public async Task<ResponseResult> LoginAsync(UserLoginDto dto)\n        //        {\n        //            _logger.LogInformation(\"üîë Login attempt for email: {Email}\", dto.Email);\n        //            var hashedPassword = HashPassword(dto.Password);\n\n        //            var user = await _userRepo\n        //                .AsQueryable()\n        //                .Where(u => u.Email == dto.Email && u.PasswordHash == hashedPassword && !u.IsDeleted)\n        //                .Include(u => u.Role)\n        //                .FirstOrDefaultAsync();\n\n        //            if (user == null)\n        //            {\n        //                _logger.LogWarning(\"‚ùå Login failed: Invalid email or password for {Email}\", dto.Email);\n        //                return ResponseResult.ErrorInfo(\"‚ùå Invalid email or password\");\n        //            }\n\n        //            var roleName = user.Role?.Name?.Trim().ToLower() ?? \"unknown\";\n        //            var isAdminType = roleName is \"admin\" or \"superadmin\" or \"partner\" or \"reseller\";\n\n        //            if (user.BusinessId == null && !isAdminType)\n        //            {\n        //                _logger.LogWarning(\"‚ùå Login denied for {Email}: No BusinessId and not admin\", dto.Email);\n        //                return ResponseResult.ErrorInfo(\"‚ùå Your account approval is pending. Please contact your administrator or support.\");\n        //            }\n\n        //            Business? business = null;\n        //            Guid? planId = null;\n        //            string companyName = string.Empty;\n        //            string businessId = user.BusinessId?.ToString() ?? string.Empty;\n\n        //            if (user.BusinessId != null)\n        //            {\n        //                business = await _businessService.Query()\n        //                    .Include(b => b.Plan)\n        //                    .FirstOrDefaultAsync(b => b.Id == user.BusinessId.Value);\n\n        //                if (business == null)\n        //                    return ResponseResult.ErrorInfo(\"‚ùå Associated business not found.\");\n\n        //                if (business.Status == Business.StatusType.Pending)\n        //                    return ResponseResult.ErrorInfo(\"‚è≥ Your business is under review. Please wait for approval.\");\n\n        //                //if (!business.PlanId.HasValue)\n        //                //    return ResponseResult.ErrorInfo(\"‚ùå No plan assigned to this business.\");\n\n        //                planId = business.PlanId;\n        //                companyName = business.CompanyName ?? string.Empty;\n\n        //                _logger.LogInformation(\"Business {BusinessId} login. Status: {Status}, PlanId: {PlanId}\", business.Id, business.Status, planId\n        //);\n        //            }\n\n        //            if (isAdminType)\n        //            {\n        //                // Admins don‚Äôt get plan restrictions\n        //                companyName = \"xByte Admin\";\n        //                businessId = string.Empty;\n        //                planId = null;\n        //            }\n\n        //            // üî• Compute EFFECTIVE permissions (plan ‚à© role) and derive features\n        //            var (permCodes, featureKeys) = isAdminType\n        //                ? (await GetAllActivePermissions(), new List<string> { \"Dashboard\", \"Messaging\", \"CRM\", \"Campaigns\", \"Catalog\", \"AdminPanel\" })\n        //                : await GetEffectivePermissionsAndFeaturesAsync(user.Id);\n\n        //            // üé´ Generate JWT (now includes permissions, features, plan_id)\n        //            var token = _jwtTokenService.GenerateToken(\n        //                userId: user.Id.ToString(),\n        //                role: roleName,\n        //                userName: user.Name ?? string.Empty,\n        //                email: user.Email ?? string.Empty,\n        //                status: user.Status ?? \"unknown\",\n        //                businessId: businessId,\n        //                companyName: companyName,\n        //                permissions: permCodes ?? new List<string>(),\n        //                planId: planId?.ToString() ?? string.Empty,\n        //                features: featureKeys,\n        //                hasAllAccess: isAdminType\n        //            );\n        //            try\n        //            {\n        //                var jwt = new JwtSecurityTokenHandler().ReadJwtToken(token);\n        //                var pid = jwt.Claims.FirstOrDefault(c => c.Type == \"plan_id\")?.Value;\n        //                _logger.LogInformation(\"üîé JWT includes plan_id: {PlanId}\", pid ?? \"<null>\");\n        //            }\n        //            catch { /* ignore */ }\n        //            var userDto = new UserDto\n        //            {\n        //                Id = user.Id,\n        //                Name = user.Name,\n        //                Email = user.Email,\n        //                Role = roleName,\n        //                Status = user.Status,\n        //                CreatedAt = user.CreatedAt,\n        //                BusinessId = string.IsNullOrEmpty(businessId) ? Guid.Empty : Guid.Parse(businessId),\n        //                CompanyName = companyName,\n        //                PlanId = planId,\n        //                AccessToken = null\n        //            };\n\n        //            _logger.LogInformation(\n        //                \"‚úÖ Login successful for {Email}, Role: {Role}, PlanId: {PlanId}\",\n        //                dto.Email, roleName, planId\n        //            );\n\n        //            return new ResponseResult\n        //            {\n        //                Success = true,\n        //                Message = \"‚úÖ Login successful\",\n        //                Data = userDto,\n        //                Token = token\n        //            };\n        //        }\n\n        public async Task<ResponseResult> LoginAsync(UserLoginDto dto)\n        {\n            _logger.LogInformation(\"üîë Login attempt for email: {Email}\", dto.Email);\n            var hashedPassword = HashPassword(dto.Password);\n\n            var user = await _userRepo\n                .AsQueryable()\n                .Where(u => u.Email == dto.Email && u.PasswordHash == hashedPassword && !u.IsDeleted)\n                .Include(u => u.Role)\n                .FirstOrDefaultAsync();\n\n            if (user == null)\n            {\n                _logger.LogWarning(\"‚ùå Login failed: Invalid email or password for {Email}\", dto.Email);\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid email or password\");\n            }\n\n            var roleName = user.Role?.Name?.Trim().ToLower() ?? \"unknown\";\n            var isAdminType = roleName is \"admin\" or \"superadmin\" or \"partner\" or \"reseller\";\n\n            if (user.BusinessId == null && !isAdminType)\n            {\n                _logger.LogWarning(\"‚ùå Login denied for {Email}: No BusinessId and not admin\", dto.Email);\n                return ResponseResult.ErrorInfo(\"‚ùå Your account approval is pending. Please contact your administrator or support.\");\n            }\n\n            Business? business = null;\n\n            // This is the REAL plan id from DB (can be internal)\n            Guid? planId = null;\n\n            // This is what we expose to the FRONTEND (hide internal plans)\n            Guid? exposedPlanId = null;\n\n            string companyName = string.Empty;\n            string businessId = user.BusinessId?.ToString() ?? string.Empty;\n\n            if (user.BusinessId != null)\n            {\n                business = await _businessService.Query()\n                    .Include(b => b.Plan) // ensure Plan loaded so we can check IsInternal\n                    .FirstOrDefaultAsync(b => b.Id == user.BusinessId.Value);\n\n                if (business == null)\n                    return ResponseResult.ErrorInfo(\"‚ùå Associated business not found.\");\n\n                if (business.Status == Business.StatusType.Pending)\n                    return ResponseResult.ErrorInfo(\"‚è≥ Your business is under review. Please wait for approval.\");\n\n                planId = business.PlanId;\n                companyName = business.CompanyName ?? string.Empty;\n\n                // üß† Decide whether to expose plan to frontend\n                var isInternalPlan = business.Plan?.IsInternal == true;\n                exposedPlanId = isInternalPlan ? null : planId;\n\n                _logger.LogInformation(\n                    \"Business {BusinessId} login. Status: {Status}, DbPlanId: {DbPlanId}, ExposedPlanId: {ExposedPlanId}, IsInternal: {IsInternal}\",\n                    business.Id, business.Status, planId, exposedPlanId, isInternalPlan\n                );\n            }\n\n            if (isAdminType)\n            {\n                // Admins don‚Äôt get plan restrictions and shouldn't show a plan in UI\n                companyName = \"xByte Admin\";\n                businessId = string.Empty;\n                planId = null;\n                exposedPlanId = null;\n            }\n\n            // üî• Compute EFFECTIVE permissions (plan ‚à© role) and derive features\n            var (permCodes, featureKeys) = isAdminType\n                ? (await GetAllActivePermissions(), new List<string> { \"Dashboard\", \"Messaging\", \"CRM\", \"Campaigns\", \"Catalog\", \"AdminPanel\" })\n                : await GetEffectivePermissionsAndFeaturesAsync(user.Id);\n\n            // üé´ Generate JWT ‚Üí use EXPOSED plan id (hide internal/system plans)\n            var token = _jwtTokenService.GenerateToken(\n                userId: user.Id.ToString(),\n                role: roleName,\n                userName: user.Name ?? string.Empty,\n                email: user.Email ?? string.Empty,\n                status: user.Status ?? \"unknown\",\n                businessId: businessId,\n                companyName: companyName,\n                permissions: permCodes ?? new List<string>(),\n                planId: exposedPlanId?.ToString() ?? string.Empty,\n                features: featureKeys,\n                hasAllAccess: isAdminType\n            );\n\n            try\n            {\n                var jwt = new JwtSecurityTokenHandler().ReadJwtToken(token);\n                var pid = jwt.Claims.FirstOrDefault(c => c.Type == \"plan_id\")?.Value;\n                _logger.LogInformation(\"üîé JWT includes plan_id (exposed): {PlanId}\", pid ?? \"<null>\");\n            }\n            catch\n            {\n                // ignore\n            }\n\n            var userDto = new UserDto\n            {\n                Id = user.Id,\n                Name = user.Name,\n                Email = user.Email,\n                Role = roleName,\n                Status = user.Status,\n                CreatedAt = user.CreatedAt,\n                BusinessId = string.IsNullOrEmpty(businessId) ? Guid.Empty : Guid.Parse(businessId),\n                CompanyName = companyName,\n\n                // üëá important: return ONLY the exposed plan id to the frontend\n                PlanId = exposedPlanId,\n\n                AccessToken = null\n            };\n\n            _logger.LogInformation(\n                \"‚úÖ Login successful for {Email}, Role: {Role}, DbPlanId: {DbPlanId}, ExposedPlanId: {ExposedPlanId}\",\n                dto.Email, roleName, planId, exposedPlanId\n            );\n\n            return new ResponseResult\n            {\n                Success = true,\n                Message = \"‚úÖ Login successful\",\n                Data = userDto,\n                Token = token\n            };\n        }\n\n        public async Task<ResponseResult> SignupAsync(SignupBusinessDto dto)\n        {\n            _logger.LogInformation(\"üü¢ Signup attempt: {Email}\", dto.Email);\n            var result = await _businessService.SignupBusinessAsync(dto);\n\n            if (!result.Success)\n            {\n                _logger.LogWarning(\"‚ùå Signup failed for {Email}: {Msg}\", dto.Email, result.Message);\n                return ResponseResult.ErrorInfo(result.Message);\n            }\n\n            var business = await _businessService.GetBusinessByEmailAsync(dto.Email);\n\n            if (business == null)\n            {\n                _logger.LogError(\"‚ùå Signup succeeded but business retrieval failed for {Email}\", dto.Email);\n                return ResponseResult.ErrorInfo(\"‚ùå Signup succeeded but business retrieval failed.\");\n            }\n\n            // No extra UpdateBusinessAsync call here.\n            // CreatedByPartnerId is set inside SignupBusinessAsync.\n\n            _logger.LogInformation(\"‚úÖ Signup successful for {Email} (BusinessId: {BusinessId})\", dto.Email, business.Id);\n            return ResponseResult.SuccessInfo(\"‚úÖ Signup successful. Pending approval.\", new { BusinessId = business.Id });\n        }\n\n\n        // üîÑ Refresh JWT Token (and Rotate)\n        //public async Task<ResponseResult> RefreshTokenAsync(string refreshToken)\n        //{\n        //    _logger.LogInformation(\"üîÑ RefreshToken attempt\");\n\n        //    var user = await _userRepo\n        //        .AsQueryable()\n        //        .Include(u => u.Role)\n        //        .Include(u => u.Business)\n        //            .ThenInclude(b => b.BusinessPlanInfo)\n        //        .FirstOrDefaultAsync(u => u.RefreshToken == refreshToken && u.RefreshTokenExpiry > DateTime.UtcNow);\n\n        //    if (user == null)\n        //    {\n        //        _logger.LogWarning(\"‚ùå Invalid or expired refresh token.\");\n        //        return ResponseResult.ErrorInfo(\"‚ùå Invalid or expired refresh token.\");\n        //    }\n\n        //    var roleName = user.Role?.Name?.Trim().ToLower() ?? \"unknown\";\n        //    var isAdminType = roleName is \"admin\" or \"superadmin\" or \"partner\" or \"reseller\";\n\n        //    string planId = user.Business?.PlanId?.ToString() ?? string.Empty;\n        //    string companyName = isAdminType ? \"xByte Admin\" : (user.Business?.CompanyName ?? string.Empty);\n        //    string businessId = isAdminType ? string.Empty : (user.BusinessId?.ToString() ?? string.Empty);\n\n        //    var (permCodes, featureKeys) = isAdminType\n        //        ? (await GetAllActivePermissions(), new List<string> { \"Dashboard\", \"Messaging\", \"CRM\", \"Campaigns\", \"Catalog\", \"AdminPanel\" })\n        //        : await GetEffectivePermissionsAndFeaturesAsync(user.Id);\n\n        //    var claims = new List<Claim>\n        //{\n        //    new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),\n        //    new Claim(\"id\", user.Id.ToString()),\n        //    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),\n        //    new Claim(\"email\", user.Email ?? \"\"),\n        //    new Claim(\"name\", user.Name ?? \"\"),\n        //    new Claim(\"status\", user.Status ?? \"unknown\"),\n        //    new Claim(\"businessId\", businessId),\n        //    new Claim(\"companyName\", companyName),\n        //    new Claim(\"permissions\", string.Join(\",\", permCodes ?? new List<string>())),\n        //    new Claim(\"features\", string.Join(\",\", featureKeys ?? new List<string>())),\n        //    new Claim(\"hasAllAccess\", isAdminType ? \"true\" : \"false\"),\n        //    new Claim(\"role\", roleName),\n        //    new Claim(ClaimTypes.Role, roleName),\n        //    new Claim(\"plan_id\", planId ?? string.Empty)\n        //};\n\n        //    var token = _jwtTokenService.GenerateToken(claims);\n\n        //    // üîÅ Rotate refresh token\n        //    var newRefreshToken = Guid.NewGuid().ToString(\"N\");\n        //    user.RefreshToken = newRefreshToken;\n        //    user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(30);\n        //    _userRepo.Update(user);\n\n        //    _logger.LogInformation(\"üîÑ Token refreshed for user {UserId}, role {Role}\", user.Id, roleName);\n\n        //    return ResponseResult.SuccessInfo(\"üîÑ Token refreshed\", new\n        //    {\n        //        accessToken = token,\n        //        refreshToken = newRefreshToken\n        //    });\n        //}\n        public async Task<ResponseResult> RefreshTokenAsync(string refreshToken)\n        {\n            _logger.LogInformation(\"üîÑ RefreshToken attempt\");\n\n            var user = await _userRepo\n                .AsQueryable()\n                .Include(u => u.Role)\n                .Include(u => u.Business)\n                    .ThenInclude(b => b.BusinessPlanInfo)\n                .Include(u => u.Business)\n                    .ThenInclude(b => b.Plan) // üëà ensure Plan is loaded\n                .FirstOrDefaultAsync(u =>\n                    u.RefreshToken == refreshToken &&\n                    u.RefreshTokenExpiry > DateTime.UtcNow\n                );\n\n            if (user == null)\n            {\n                _logger.LogWarning(\"‚ùå Invalid or expired refresh token.\");\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid or expired refresh token.\");\n            }\n\n            var roleName = user.Role?.Name?.Trim().ToLower() ?? \"unknown\";\n            var isAdminType = roleName is \"admin\" or \"superadmin\" or \"partner\" or \"reseller\";\n\n            string companyName;\n            string businessId;\n\n            // REAL plan from DB\n            Guid? dbPlanId = user.Business?.PlanId;\n\n            // What we expose to frontend (null for internal plans)\n            string? exposedPlanIdForClaim = null;\n\n            if (isAdminType)\n            {\n                companyName = \"xByte Admin\";\n                businessId = string.Empty;\n                dbPlanId = null;\n                exposedPlanIdForClaim = null;\n            }\n            else\n            {\n                companyName = user.Business?.CompanyName ?? string.Empty;\n                businessId = user.BusinessId?.ToString() ?? string.Empty;\n\n                if (dbPlanId.HasValue)\n                {\n                    var isInternalPlan = user.Business?.Plan?.IsInternal == true;\n                    if (!isInternalPlan)\n                    {\n                        exposedPlanIdForClaim = dbPlanId.Value.ToString();\n                    }\n\n                    _logger.LogInformation(\n                        \"üîÑ RefreshToken: Business {BusinessId}, DbPlanId: {DbPlanId}, ExposedPlanId: {ExposedPlanId}, IsInternal: {IsInternal}\",\n                        businessId, dbPlanId, exposedPlanIdForClaim, isInternalPlan\n                    );\n                }\n            }\n\n            var (permCodes, featureKeys) = isAdminType\n                ? (await GetAllActivePermissions(), new List<string> { \"Dashboard\", \"Messaging\", \"CRM\", \"Campaigns\", \"Catalog\", \"AdminPanel\" })\n                : await GetEffectivePermissionsAndFeaturesAsync(user.Id);\n\n            var claims = new List<Claim>\n    {\n        new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),\n        new Claim(\"id\", user.Id.ToString()),\n        new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),\n        new Claim(\"email\", user.Email ?? \"\"),\n        new Claim(\"name\", user.Name ?? \"\"),\n        new Claim(\"status\", user.Status ?? \"unknown\"),\n        new Claim(\"businessId\", businessId),\n        new Claim(\"companyName\", companyName),\n        new Claim(\"permissions\", string.Join(\",\", permCodes ?? new List<string>())),\n        new Claim(\"features\", string.Join(\",\", featureKeys ?? new List<string>())),\n        new Claim(\"hasAllAccess\", isAdminType ? \"true\" : \"false\"),\n        new Claim(\"role\", roleName),\n        new Claim(ClaimTypes.Role, roleName)\n    };\n\n            // üëâ Only add plan_id claim if we want the frontend to see it\n            if (!string.IsNullOrWhiteSpace(exposedPlanIdForClaim))\n            {\n                claims.Add(new Claim(\"plan_id\", exposedPlanIdForClaim));\n            }\n\n            var token = _jwtTokenService.GenerateToken(claims);\n\n            // üîÅ Rotate refresh token\n            var newRefreshToken = Guid.NewGuid().ToString(\"N\");\n            user.RefreshToken = newRefreshToken;\n            user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(30);\n            _userRepo.Update(user);\n\n            _logger.LogInformation(\n                \"üîÑ Token refreshed for user {UserId}, role {Role}, DbPlanId: {DbPlanId}, ExposedPlanId: {ExposedPlanId}\",\n                user.Id, roleName, dbPlanId, exposedPlanIdForClaim\n            );\n\n            return ResponseResult.SuccessInfo(\"üîÑ Token refreshed\", new\n            {\n                accessToken = token,\n                refreshToken = newRefreshToken\n            });\n        }\n\n\n\n\n        public async Task<ResponseResult> ResendConfirmationAsync(ResendConfirmationDto dto)\n        {\n            _logger.LogInformation(\"üîÅ Resend confirmation attempt for {Email}\", dto.Email);\n            var business = await _businessService.GetBusinessByEmailAsync(dto.Email);\n            if (business == null)\n            {\n                _logger.LogWarning(\"‚ùå Resend confirmation failed: No business for {Email}\", dto.Email);\n                return ResponseResult.ErrorInfo(\"‚ùå No business registered with this email\");\n            }\n\n            _logger.LogInformation(\"‚úÖ Resend confirmation request processed for {Email}\", dto.Email);\n            return ResponseResult.SuccessInfo(\"üì® Confirmation request resent.\");\n        }\n\n        // üîí Reset password\n        public async Task<ResponseResult> ResetPasswordAsync(ResetPasswordDto dto)\n        {\n            _logger.LogInformation(\"üîí Reset password attempt for {Email}\", dto.Email);\n            var user = await _userRepo.FirstOrDefaultAsync(u => u.Email == dto.Email);\n            if (user == null)\n            {\n                _logger.LogWarning(\"‚ùå Reset password failed: No user for {Email}\", dto.Email);\n                return ResponseResult.ErrorInfo(\"‚ùå No user found with this email\");\n            }\n\n            user.PasswordHash = HashPassword(dto.NewPassword);\n            _userRepo.Update(user);\n\n            _logger.LogInformation(\"‚úÖ Password reset successfully for {Email}\", dto.Email);\n            return ResponseResult.SuccessInfo(\"‚úÖ Password reset successfully\");\n        }\n\n        // Utility: Hash password using SHA256\n        //private string HashPassword(string password)\n        //{\n        //    using var sha = SHA256.Create();\n        //    var bytes = Encoding.UTF8.GetBytes(password);\n        //    var hash = sha.ComputeHash(bytes);\n        //    return Convert.ToBase64String(hash);\n        //}\n        // INTERSECTION: Role ‚à© Plan for the user, then map groups -> feature keys\n        //private async Task<(List<string> Perms, List<string> Features)> GetEffectivePermissionsAndFeaturesAsync(Guid userId)\n        //{\n        //    var userAndPermissions = _dbContext.Users\n        //        .Where(u => u.Id == userId)\n        //        .Join(_dbContext.Businesses,\n        //            u => u.BusinessId,\n        //            b => b.Id,\n        //            (u, b) => new { u, b })\n        //        .Join(_dbContext.PlanPermissions.Where(pp => pp.IsActive),\n        //            ub => ub.b.PlanId,\n        //            pp => pp.PlanId,\n        //            (ub, pp) => new { ub.u, pp })\n        //        .Join(_dbContext.Permissions.Where(p => p.IsActive),\n        //            ubpp => ubpp.pp.PermissionId,\n        //            p => p.Id,\n        //            (ubpp, p) => new { ubpp.u, p }); // This gives you a sequence of {user, permission} pairs\n\n        //    // Replace the final problematic Join with this Where clause\n        //    var rows = await userAndPermissions\n        //        .Where(up => _dbContext.RolePermissions\n        //            .Where(rp => rp.IsActive && !rp.IsRevoked)\n        //            .Any(rp => rp.RoleId == up.u.RoleId && rp.PermissionId == up.p.Id))\n        //        .Select(up => up.p) // Select the final permission object\n        //        .Select(p => new { p.Code, p.Group })\n        //        .Distinct()\n        //        .ToListAsync();\n\n        //    var perms = rows.Select(r => r.Code).ToList();\n\n        //    var features = rows.Select(r => r.Group)\n        //        .Where(g => !string.IsNullOrWhiteSpace(g))\n        //        .Select(GroupToFeature)\n        //        .Where(f => f != null)\n        //        .Select(f => f!)\n        //        .Distinct(StringComparer.OrdinalIgnoreCase)\n        //        .ToList();\n\n        //    return (perms, features);\n        //}\n        //// If you ever need ‚Äúall perms‚Äù (e.g., for superadmins)\n        /// <summary>\n        /// \n        /// </summary>\n        /// <returns></returns>\n        /// \n        private async Task<(List<string> Perms, List<string> Features)> GetEffectivePermissionsAndFeaturesAsync(Guid userId)\n        {\n            var rows = await _dbContext.Users\n                .AsNoTracking()\n                .Where(u => u.Id == userId)\n                .Join(_dbContext.Businesses.AsNoTracking(),\n                      u => u.BusinessId,\n                      b => b.Id,\n                      (u, b) => new { u, b })\n                .Join(_dbContext.PlanPermissions.AsNoTracking().Where(pp => pp.IsActive),\n                      ub => ub.b.PlanId,\n                      pp => pp.PlanId,\n                      (ub, pp) => new { ub.u, pp })\n                .Join(_dbContext.Permissions.AsNoTracking().Where(p => p.IsActive),\n                      ubpp => ubpp.pp.PermissionId,\n                      p => p.Id,\n                      (ubpp, p) => new { ubpp.u, p })\n                // Intersect with RolePermissions via EXISTS\n                .Where(up => _dbContext.RolePermissions\n                    .AsNoTracking()\n                    .Where(rp => rp.IsActive && !rp.IsRevoked)\n                    .Any(rp => rp.RoleId == up.u.RoleId && rp.PermissionId == up.p.Id))\n                .Select(up => new { up.p.Code, up.p.Group })\n                .Distinct()\n                .ToListAsync();\n\n            var perms = rows.Select(r => r.Code).ToList();\n\n            var features = rows.Select(r => r.Group)\n                .Where(g => !string.IsNullOrWhiteSpace(g))\n                .Select(GroupToFeature)\n                .Where(f => f != null)\n                .Select(f => f!)\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            return (perms, features);\n        }\n\n        private async Task<List<string>> GetAllActivePermissions() =>\n            await _dbContext.Permissions\n                .Where(p => p.IsActive)\n                .Select(p => p.Code)\n                .OrderBy(c => c)\n                .ToListAsync();\n\n        private static string? GroupToFeature(string? g) => g switch\n        {\n            \"Messaging\" => \"Messaging\",\n            \"Contacts\" => \"CRM\",\n            \"Campaign\" => \"Campaigns\",\n            \"Product\" => \"Catalog\",\n            \"Dashboard\" => \"Dashboard\",\n            \"Admin\" => \"AdminPanel\",\n            _ => null\n        };\n\n        private string HashPassword(string password)\n        {\n            using var sha = SHA256.Create();\n            var bytes = Encoding.UTF8.GetBytes(password);\n            var hash = sha.ComputeHash(bytes);\n            return Convert.ToBase64String(hash);\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Services/IAuthService.cs",
      "sha256": "0ba16acc52a94c3f3a942c3bf05a595aa307b6f399515662cd0c053dd69fb632",
      "language": "csharp",
      "size": 667,
      "content": "using System.Security.Claims;\nusing xbytechat.api.AuthModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.AuthModule.Services\n{\n    public interface IAuthService\n    {\n        Task<ResponseResult> LoginAsync(UserLoginDto dto);\n        Task<ResponseResult> SignupAsync(SignupBusinessDto dto);                  // ‚úÖ Add this\n        Task<ResponseResult> ResetPasswordAsync(ResetPasswordDto dto);           // ‚úÖ Add this\n        Task<ResponseResult> ResendConfirmationAsync(ResendConfirmationDto dto); // ‚úÖ Add this\n        Task<ResponseResult> RefreshTokenAsync(string refreshToken);\n    \n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Services/IJwtTokenService.cs",
      "sha256": "6d4a732e224fe37de1184e7c79c9a3413bab6ea6cda0d29a1c3fb5a70cf9b6e7",
      "language": "csharp",
      "size": 750,
      "content": "using Microsoft.IdentityModel.Tokens;\nusing System.Collections.Generic;\nusing System.Security.Claims;\n\nnamespace xbytechat.api.AuthModule.Services\n{\n    public interface IJwtTokenService\n    {\n        string GenerateToken(\n            string userId,\n            string role,\n            string userName,\n            string email,\n            string status,\n            string businessId,\n            string companyName,\n                       List<string> permissions,\n            string planId,\n              List<string>? features = null,\n            bool hasAllAccess = false\n        );\n        string GenerateToken(IEnumerable<Claim> claims);\n        TokenValidationParameters GetValidationParameters(); // ‚úÖ For Middleware validation\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/AuthModule/Services/JwtTokenService.cs",
      "sha256": "54b0235003a02ee3bff4006db2d37974e88962409ec7f015cbad4ad2a264491f",
      "language": "csharp",
      "size": 12625,
      "content": "using Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.IdentityModel.Tokens;\nusing System;\nusing System.Collections.Generic;\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Text;\n\nnamespace xbytechat.api.AuthModule.Services\n{\n    public class JwtTokenService : IJwtTokenService\n    {\n        private readonly IConfiguration _config;\n        private readonly ILogger<JwtTokenService> _logger;\n\n        public JwtTokenService(IConfiguration config, ILogger<JwtTokenService> logger)\n        {\n            _config = config;\n            _logger = logger;\n        }\n\n        public string GenerateToken(\n            string userId,\n            string role,\n            string userName,\n            string email,\n            string status,\n            string businessId,\n            string companyName,\n            List<string> permissions,\n            string planId,\n            List<string>? features = null,\n            bool hasAllAccess = false)\n        {\n            try\n            {\n                var permissionString = string.Join(\",\", permissions ?? new List<string>());\n                var featuresString = string.Join(\",\", features ?? new List<string>());\n\n                var claims = new List<Claim>\n{\n    new Claim(JwtRegisteredClaimNames.Sub, userId),\n    new Claim(\"id\", userId),\n    new Claim(ClaimTypes.NameIdentifier, userId),\n\n    new Claim(\"email\", email ?? \"\"),\n    new Claim(\"name\", userName ?? \"\"),\n    new Claim(\"status\", status ?? \"unknown\"),\n\n    // üîê Business id: add BOTH for compatibility\n    new Claim(\"BusinessId\", businessId ?? \"\"), // <-- used by our helpers/controllers\n    new Claim(\"businessId\", businessId ?? \"\"), // <-- keep for existing clients\n\n    new Claim(\"companyName\", companyName ?? \"\"),\n\n    // üîñ Role (API + UI)\n    new Claim(\"role\", role?.ToLowerInvariant() ?? \"unknown\"),\n    new Claim(ClaimTypes.Role, role?.ToLowerInvariant() ?? \"unknown\"),\n\n    // üß© Plan & access\n    new Claim(\"plan_id\", planId ?? string.Empty),\n    new Claim(\"permissions\", string.Join(\",\", permissions ?? new List<string>())),\n    new Claim(\"features\", string.Join(\",\", features ?? new List<string>())),\n    new Claim(\"hasAllAccess\", hasAllAccess ? \"true\" : \"false\"),\n};\n\n\n                return GenerateToken(claims);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Error generating token for userId: {UserId}\", userId);\n                throw;\n            }\n        }\n\n        public string GenerateToken(IEnumerable<Claim> claims)\n        {\n            try\n            {\n                var jwtSettings = _config.GetSection(\"JwtSettings\");\n\n                var secret = jwtSettings[\"SecretKey\"];\n                if (string.IsNullOrEmpty(secret))\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è JWT SecretKey is missing from configuration.\");\n                    throw new Exception(\"JWT SecretKey is not configured.\");\n                }\n\n                var expiry = jwtSettings[\"ExpiryMinutes\"];\n                if (!int.TryParse(expiry, out var expiryMinutes))\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è JWT ExpiryMinutes is invalid or missing. Defaulting to 60 minutes.\");\n                    expiryMinutes = 60;\n                }\n\n                var secretKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret));\n                var creds = new SigningCredentials(secretKey, SecurityAlgorithms.HmacSha256);\n\n                var expires = DateTime.UtcNow.AddMinutes(expiryMinutes);\n                var unixExp = new DateTimeOffset(expires).ToUnixTimeSeconds();\n\n                var finalClaims = claims.ToList();\n                finalClaims.Add(new Claim(JwtRegisteredClaimNames.Exp, unixExp.ToString()));\n\n                var token = new JwtSecurityToken(\n                    issuer: jwtSettings[\"Issuer\"],\n                    audience: jwtSettings[\"Audience\"],\n                    claims: finalClaims,\n                    expires: expires,\n                    signingCredentials: creds\n                );\n\n                _logger.LogInformation(\"‚úÖ Token generated for: {Email}\", finalClaims.FirstOrDefault(c => c.Type == \"email\")?.Value);\n\n                return new JwtSecurityTokenHandler().WriteToken(token);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Error generating JWT from claims.\");\n                throw;\n            }\n        }\n\n        public TokenValidationParameters GetValidationParameters()\n        {\n            var jwtSettings = _config.GetSection(\"JwtSettings\");\n\n            return new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidateAudience = true,\n                ValidateIssuerSigningKey = true,\n                ValidateLifetime = true,\n                RequireSignedTokens = true,\n                RequireExpirationTime = true,\n                ValidIssuer = jwtSettings[\"Issuer\"],\n                ValidAudience = jwtSettings[\"Audience\"],\n                IssuerSigningKey = new SymmetricSecurityKey(\n                    Encoding.UTF8.GetBytes(jwtSettings[\"SecretKey\"])\n                ),\n                ClockSkew = TimeSpan.Zero,\n                RoleClaimType = \"role\",\n                NameClaimType = \"name\"\n            };\n        }\n    }\n}\n\n\n//using Microsoft.Extensions.Configuration;\n//using Microsoft.Extensions.Logging;\n//using Microsoft.IdentityModel.Tokens;\n//using System;\n//using System.Collections.Generic;\n//using System.IdentityModel.Tokens.Jwt;\n//using System.Linq;\n//using System.Security.Claims;\n//using System.Text;\n\n//namespace xbytechat.api.AuthModule.Services\n//{\n//    public class JwtTokenService : IJwtTokenService\n//    {\n//        private readonly IConfiguration _config;\n//        private readonly ILogger<JwtTokenService> _logger;\n\n//        public JwtTokenService(IConfiguration config, ILogger<JwtTokenService> logger)\n//        {\n//            _config = config;\n//            _logger = logger;\n//        }\n\n//        //public string GenerateToken(\n//        //    string userId,\n//        //    string role,\n//        //    string userName,\n//        //    string email,\n//        //    string status,\n//        //    string businessId,\n//        //    string companyName,\n//        //    string plan,\n//        //    List<string> permissions)\n//        //{\n//        //    try\n//        //    {\n//        //        var permissionString = string.Join(\",\", permissions ?? new List<string>());\n\n//        //        var claims = new List<Claim>\n//        //        {\n//        //            new Claim(JwtRegisteredClaimNames.Sub, userId),\n//        //            new Claim(\"id\", userId),\n//        //            new Claim(ClaimTypes.NameIdentifier, userId),\n//        //            new Claim(\"email\", email ?? \"\"),\n//        //            new Claim(\"role\", role?.ToLowerInvariant() ?? \"unknown\"),    // lowercased!\n//        //            new Claim(\"name\", userName ?? \"\"),\n//        //            new Claim(\"status\", status ?? \"unknown\"),\n//        //            new Claim(\"businessId\", businessId ?? \"\"),                   // lowercased!\n//        //            new Claim(\"companyName\", companyName ?? \"\"),\n//        //            new Claim(\"plan\", plan?.ToLowerInvariant() ?? \"basic\"),      // lowercased!\n//        //            new Claim(\"permissions\", permissionString)\n//        //        };\n\n//        //        return GenerateToken(claims);\n//        //    }\n//        //    catch (Exception ex)\n//        //    {\n//        //        _logger.LogError(ex, \"‚ùå Error generating token for userId: {UserId}\", userId);\n//        //        throw;\n//        //    }\n//        //}\n//        public string GenerateToken(string userId, string role,string userName,\n//                                    string email,\n//                                    string status,\n//                                    string businessId,\n//                                    string companyName,\n//                                    //string plan,\n//                                    List<string> permissions,\n//                                    string planId)\n//        {\n//            try\n//            {\n//                var permissionString = string.Join(\",\", permissions ?? new List<string>());\n\n//                var claims = new List<Claim>\n//        {\n//            new Claim(JwtRegisteredClaimNames.Sub, userId),\n//            new Claim(\"id\", userId),\n//            new Claim(ClaimTypes.NameIdentifier, userId),\n//            new Claim(\"email\", email ?? \"\"),\n//            new Claim(\"name\", userName ?? \"\"),\n//            new Claim(\"status\", status ?? \"unknown\"),\n//            new Claim(\"businessId\", businessId ?? \"\"),\n//            new Claim(\"companyName\", companyName ?? \"\"),\n//           // new Claim(\"plan\", plan?.ToLowerInvariant() ?? \"basic\"),\n//            new Claim(\"permissions\", permissionString),\n\n//            // ‚úÖ Proper role mapping for both ASP.NET and frontend\n//            new Claim(\"role\", role?.ToLowerInvariant() ?? \"unknown\"),           // for React\n//            new Claim(ClaimTypes.Role, role?.ToLowerInvariant() ?? \"unknown\") ,  // for ASP.NET\n//            new Claim(\"plan_id\", planId ?? string.Empty)\n\n//        };\n\n//                return GenerateToken(claims);\n//            }\n//            catch (Exception ex)\n//            {\n//                _logger.LogError(ex, \"‚ùå Error generating token for userId: {UserId}\", userId);\n//                throw;\n//            }\n//        }\n\n//        public string GenerateToken(IEnumerable<Claim> claims)\n//        {\n//            try\n//            {\n//                var jwtSettings = _config.GetSection(\"JwtSettings\");\n\n//                var secret = jwtSettings[\"SecretKey\"];\n//                if (string.IsNullOrEmpty(secret))\n//                {\n//                    _logger.LogWarning(\"‚ö†Ô∏è JWT SecretKey is missing from configuration.\");\n//                    throw new Exception(\"JWT SecretKey is not configured.\");\n//                }\n\n//                var expiry = jwtSettings[\"ExpiryMinutes\"];\n//                if (!int.TryParse(expiry, out var expiryMinutes))\n//                {\n//                    _logger.LogWarning(\"‚ö†Ô∏è JWT ExpiryMinutes is invalid or missing. Defaulting to 60 minutes.\");\n//                    expiryMinutes = 60;\n//                }\n\n//                var secretKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret));\n//                var creds = new SigningCredentials(secretKey, SecurityAlgorithms.HmacSha256);\n\n//                var expires = DateTime.UtcNow.AddMinutes(expiryMinutes);\n//                var unixExp = new DateTimeOffset(expires).ToUnixTimeSeconds();\n\n//                var finalClaims = claims.ToList();\n//                finalClaims.Add(new Claim(JwtRegisteredClaimNames.Exp, unixExp.ToString()));\n\n//                var token = new JwtSecurityToken(\n//                    issuer: jwtSettings[\"Issuer\"],\n//                    audience: jwtSettings[\"Audience\"],\n//                    claims: finalClaims,\n//                    expires: expires,\n//                    signingCredentials: creds\n//                );\n\n//                _logger.LogInformation(\"‚úÖ Token generated for: {Email}\", finalClaims.FirstOrDefault(c => c.Type == \"email\")?.Value);\n\n//                return new JwtSecurityTokenHandler().WriteToken(token);\n//            }\n//            catch (Exception ex)\n//            {\n//                _logger.LogError(ex, \"‚ùå Error generating JWT from claims.\");\n//                throw;\n//            }\n//        }\n\n//        public TokenValidationParameters GetValidationParameters()\n//        {\n//            var jwtSettings = _config.GetSection(\"JwtSettings\");\n\n//            return new TokenValidationParameters\n//            {\n//                ValidateIssuer = true,\n//                ValidateAudience = true,\n//                ValidateIssuerSigningKey = true,\n//                ValidateLifetime = true,\n//                RequireSignedTokens = true,\n//                RequireExpirationTime = true,\n//                ValidIssuer = jwtSettings[\"Issuer\"],\n//                ValidAudience = jwtSettings[\"Audience\"],\n//                IssuerSigningKey = new SymmetricSecurityKey(\n//                    Encoding.UTF8.GetBytes(jwtSettings[\"SecretKey\"])\n//                ),\n//                ClockSkew = TimeSpan.Zero,\n//                RoleClaimType = \"role\",   // standardized!\n//                NameClaimType = \"name\"\n//            };\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Configuration/JwtSettings.cs",
      "sha256": "4109fe340feebbd3a5c6b5092cefe36791eb45d9b52faaa2bfde8080d93c4740",
      "language": "csharp",
      "size": 325,
      "content": "namespace xbytechat.api.Configuration\n{\n    public sealed class JwtSettings\n    {\n        public string Issuer { get; set; } = string.Empty;\n        public string Audience { get; set; } = string.Empty;\n        public string SecretKey { get; set; } = string.Empty;\n        public int ExpiryMinutes { get; set; } = 60;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Controllers/BusinessLoginController.cs",
      "sha256": "7eda997e4bb632f6a487b52c57910c7c83ca50c17597d2a02e818cb3ed2459be",
      "language": "csharp",
      "size": 1158,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.DTOs;\nusing xbytechat.api.DTOs.Tenants;\nusing xbytechat.api.Services.Interfaces;\n\nnamespace xbytechat.api.Controllers\n{\n    [ApiController]\n    [Route(\"api/tenants\")]\n    public class BusinessLoginController : ControllerBase\n    {\n        private readonly IBusinessService _tenantService;\n\n        public BusinessLoginController(IBusinessService tenantService)\n        {\n            _tenantService = tenantService;\n        }\n\n        [HttpPost(\"login\")]\n        public async Task<IActionResult> Login([FromBody] BusinessLoginRequest request)\n        {\n            try\n            {\n                var tenant = await _tenantService.LoginAsync(request);\n\n                return Ok(new\n                {\n                    tenant.Id,\n                    tenant.Email,\n                    tenant.CompanyName,\n                    //tenant.Role,\n                    //tenant.Plan,\n                    Message = \"Login successful\"\n                });\n            }\n            catch (Exception ex)\n            {\n                return Unauthorized(new { Message = ex.Message });\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Controllers/DevSeedController.cs",
      "sha256": "e42997ea8140347d4c505532f1a7a654901109f62e13ac56dc8622ae0a20b3d8",
      "language": "csharp",
      "size": 2166,
      "content": "#if DEBUG\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Linq;\nusing System.Threading.Tasks;\n\n[ApiController]\n[Route(\"api/dev-seed\")]\n[ApiExplorerSettings(IgnoreApi = true)]\npublic class DevSeedController : ControllerBase\n{\n    private readonly UserManager<IdentityUser> _users;\n    private readonly RoleManager<IdentityRole> _roles;\n    private readonly IWebHostEnvironment _env;\n\n    public DevSeedController(\n        UserManager<IdentityUser> users,\n        RoleManager<IdentityRole> roles,\n        IWebHostEnvironment env)\n    {\n        _users = users;\n        _roles = roles;\n        _env = env;\n    }\n\n    [AllowAnonymous]\n    [HttpPost(\"e2e-user\")]\n    public async Task<IActionResult> SeedE2E([FromBody] SeedReq req)\n    {\n        // Only allow in Development\n        if (!_env.IsDevelopment())\n            return Forbid();\n\n        var email = (req.Email ?? \"\").Trim();\n        if (string.IsNullOrWhiteSpace(email) || string.IsNullOrWhiteSpace(req.Password))\n            return BadRequest(new { message = \"email/password required\" });\n\n        // Idempotent create/update\n        var user = await _users.FindByEmailAsync(email);\n        if (user == null)\n        {\n            user = new IdentityUser { UserName = email, Email = email, EmailConfirmed = true };\n            var create = await _users.CreateAsync(user, req.Password);\n            if (!create.Succeeded)\n                return BadRequest(new { message = \"create failed\", errors = create.Errors.Select(e => e.Description) });\n        }\n\n        // Ensure role (use \"superadmin\" or a minimal CRM role your app understands)\n        var role = string.IsNullOrWhiteSpace(req.Role) ? \"superadmin\" : req.Role.Trim();\n        if (!await _roles.RoleExistsAsync(role))\n            await _roles.CreateAsync(new IdentityRole(role));\n        if (!await _users.IsInRoleAsync(user, role))\n            await _users.AddToRoleAsync(user, role);\n\n        return Ok(new { ok = true, email, role });\n    }\n\n    public record SeedReq(string Email, string Password, string Role = \"superadmin\");\n}\n#endif\n"
    },
    {
      "path": "xbytechat-api/Controllers/HealthCheckController.cs",
      "sha256": "52d69ec41e8cd4fc50bc1281507a30e39bc629677df7bbd0e1cfb876e2623086",
      "language": "csharp",
      "size": 799,
      "content": "// xbytechat-api/Controllers/HealthCheckController.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Reflection;\n\nnamespace xbytechat.api.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class HealthCheckController : ControllerBase\n    {\n        [HttpGet]\n        public IActionResult Get() => Ok(\"‚úÖ xByteChat backend is running üöÄ\");\n\n        [AllowAnonymous]\n        [HttpGet(\"ping\")]\n        public IActionResult Ping()\n        {\n            var version = Assembly.GetExecutingAssembly()?.GetName()?.Version?.ToString() ?? \"0.0.0\";\n            return Ok(new\n            {\n                status = \"ok\",\n                version,\n                serverTimeUtc = DateTime.UtcNow.ToString(\"o\")\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Controllers/MessageLogsController.cs",
      "sha256": "2014da3730fd92be67ab8a9461210d16c3deb068b4bb2861725c43bdfce2323b",
      "language": "csharp",
      "size": 799,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // TODO: restrict further with RequirePermission(\"MESSAGING.REPORT.VIEW\") and tenant scoping\n    public class MessageLogsController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public MessageLogsController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> Get()\n        {\n            var logs = await _db.MessageLogs\n                .OrderByDescending(log => log.CreatedAt)\n                .ToListAsync();\n\n            return Ok(logs);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Controllers/MessagesController.cs",
      "sha256": "26143a83f2654afeedbc193ee1491cd078982e7b8f06365f5ecbecd9fa78d291",
      "language": "csharp",
      "size": 7066,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Services.Messages.Interfaces;\n\nnamespace xbytechat.api.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // TODO: refine with permission/quota checks (e.g., MESSAGING.SEND)\n    public class MessagesController : ControllerBase\n    {\n        private readonly IMessageService _messageService;\n\n        public MessagesController(IMessageService messageService)\n        {\n            _messageService = messageService;\n        }\n\n        /// ‚úÖ SEND TEXT MESSAGE\n        [HttpPost(\"send-text\")]\n        public async Task<IActionResult> SendTextMessage([FromBody] TextMessageDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new\n                {\n                    success = false,\n                    message = \"‚ùå Validation failed\",\n                    errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage)\n                });\n            }\n\n            var result = await _messageService.SendMessageAsync(dto);\n\n            return result.Success\n                ? Ok(new { success = true, message = result.Message, response = result.Data })\n                : StatusCode(500, new { success = false, message = result.Message, error = result.ErrorMessage });\n        }\n\n        /// ‚úÖ SEND IMAGE MESSAGE\n        [HttpPost(\"send-image\")]\n        public async Task<IActionResult> SendImageMessage([FromBody] ImageMessageDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new\n                {\n                    success = false,\n                    message = \"‚ùå Validation failed\",\n                    errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage)\n                });\n            }\n\n            var result = await _messageService.SendMessageAsync(dto);\n\n            return result.Success\n                ? Ok(new { success = true, message = result.Message, response = result.Data })\n                : StatusCode(500, new { success = false, message = result.Message, error = result.ErrorMessage });\n        }\n\n        /// ‚úÖ SEND TEMPLATE MESSAGE\n        [HttpPost(\"send-template\")]\n        public async Task<IActionResult> SendTemplateMessage([FromBody] TemplateMessageDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(new\n                {\n                    success = false,\n                    message = \"‚ùå Validation failed\",\n                    errors = ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage)\n                });\n            }\n\n            var result = await _messageService.SendMessageAsync(dto);\n\n            return result.Success\n                ? Ok(new { success = true, message = result.Message, response = result.Data })\n                : StatusCode(500, new { success = false, message = result.Message, error = result.ErrorMessage });\n        }\n\n        /// ‚úÖ SEND CTA BUTTON MESSAGE (Free-form Interactive)\n        [HttpPost(\"send-cta\")]\n        public async Task<IActionResult> SendCtaMessage([FromBody] CtaMessageDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.RecipientPhone) || string.IsNullOrWhiteSpace(dto.BodyText) || dto.Buttons == null || dto.Buttons.Count == 0)\n            {\n                return BadRequest(new\n                {\n                    success = false,\n                    message = \"‚ùå Invalid request ‚Äî phone, body text and buttons are required\"\n                });\n            }\n\n            // Optional tracking\n            var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n            var userAgent = Request.Headers[\"User-Agent\"].ToString() ?? \"unknown\";\n\n            var result = await _messageService.SendInteractiveMessageAsync(dto.RecipientPhone, dto.BodyText, dto.Buttons);\n\n            return result.Success\n                ? Ok(new\n                {\n                    success = true,\n                    message = result.Message,\n                    messageId = result.MessageId,\n                    logId = result.MessageLogId,\n                    raw = result.RawResponse\n                })\n                : StatusCode(500, new\n                {\n                    success = false,\n                    message = result.Message,\n                    error = result.ErrorMessage\n                });\n        }\n\n        /// ‚úÖ SEND BULK MESSAGES\n        //[HttpPost(\"send-bulk\")]\n        //public async Task<SendResultExtended> SendBulkMessagesAsync(BulkMessageDto dto)\n        //{\n        //    var result = new SendResultExtended\n        //    {\n        //        Success = true,\n        //        Message = \"‚úÖ All messages processed.\",\n        //        LogId = null,\n        //        MessageId = null\n        //    };\n\n        //    try\n        //    {\n        //        foreach (var contactId in dto.ContactIds)\n        //        {\n        //            var contact = await _dbContext.Contacts\n        //                .Include(c => c.Business)\n        //                .FirstOrDefaultAsync(c => c.Id == contactId);\n\n        //            if (contact == null || string.IsNullOrWhiteSpace(contact.PhoneNumber))\n        //                continue;\n\n        //            BaseMessageDto message;\n\n        //            if (dto.MessageType.ToLower() == \"template\")\n        //            {\n        //                message = new TemplateMessageDto\n        //                {\n        //                    RecipientNumber = contact.PhoneNumber,\n        //                    MessageContent = dto.MessageTemplate,\n        //                    MessageType = \"template\",\n        //                    TemplateName = dto.TemplateName!,\n        //                    TemplateParameters = dto.TemplateParams ?? new List<string>(),\n        //                    BusinessId = contact.BusinessId\n        //                };\n        //            }\n        //            else\n        //            {\n        //                message = new TextMessageDto\n        //                {\n        //                    RecipientNumber = contact.PhoneNumber,\n        //                    MessageContent = dto.MessageTemplate,\n        //                    MessageType = \"text\",\n        //                    BusinessId = contact.BusinessId\n        //                };\n        //            }\n\n        //            await SendMessageAsync(message); // already returns SendResultExtended\n        //        }\n\n        //        return result;\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        return new SendResultExtended\n        //        {\n        //            Success = false,\n        //            Message = \"‚ùå Bulk send failed.\",\n        //            ErrorMessage = ex.Message\n        //        };\n        //    }\n        //}\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Controllers/SendMessageController.cs",
      "sha256": "99cba388c6d8f53e4bc42c8b62f81056b517ca83a5c3a3ca6dae203b2ba80a63",
      "language": "csharp",
      "size": 2090,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Services;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // TODO: add RequirePermission(\"MESSAGING.SEND\") and quota enforcement\n    public class WhatsAppController : ControllerBase\n    {\n        private readonly WhatsAppService _whatsAppService;\n\n        public WhatsAppController(WhatsAppService whatsAppService)\n        {\n            _whatsAppService = whatsAppService;\n        }\n\n        /// <summary>\n        /// Endpoint to send a WhatsApp message.\n        /// </summary>\n        /// <param name=\"recipientPhone\">Recipient's phone number (including country code).</param>\n        /// <param name=\"messageText\">Text message to send.</param>\n        /// <returns>Response with the result of the send operation.</returns>\n        [HttpPost(\"send\")]\n        //[RequirePermission(\"MESSAGING.SEND\")] // TODO: enable after mapping codes\n        public async Task<IActionResult> SendMessage([FromQuery] string recipientPhone, [FromQuery] string messageText)\n        {\n            if (string.IsNullOrEmpty(recipientPhone) || string.IsNullOrEmpty(messageText))\n            {\n                return BadRequest(new { success = false, message = \"Phone number and message text are required.\" });\n            }\n\n            // Call WhatsApp service to send the message\n            var result = await _whatsAppService.SendMessageAsync(recipientPhone, messageText);\n\n            if (result.Success)\n            {\n                return Ok(new\n                {\n                    success = true,\n                    message = \"‚úÖ Message sent successfully.\",\n                    response = result.RawResponse\n                });\n            }\n            else\n            {\n                return StatusCode(500, new\n                {\n                    success = false,\n                    message = result.ErrorMessage ?? \"‚ùå Failed to send message.\",\n                    response = result.RawResponse\n                });\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Data/AppDbContext.cs",
      "sha256": "ec8e3aa26efdb1cf3d154b9cd229ac5d67f3c36bb286bb8fb3024cbdf7ba1f7b",
      "language": "csharp",
      "size": 58317,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System.Globalization;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.AccessControl.Seeder;\nusing xbytechat.api.Features.AuditTrail.Models;\nusing xbytechat_api.WhatsAppSettings.Models;\nusing xbytechat.api.Features.CTAManagement.Models;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.Automation.Models;\nusing xbytechat.api.Features.CampaignTracking.Worker;\nusing xbytechat.api.Features.WhatsAppSettings.Models;\nusing Microsoft.AspNetCore.Http.HttpResults;\nusing xbytechat_api.Features.Billing.Models;\nusing xbytechat.api.Features.CustomeApi.Models;\nusing xbytechat.api.Features.CampaignTracking.EntityTypeConfigs;\nusing xbytechat.api.Features.TemplateModule.Models;\nusing xbytechat.api.Features.ESU.Shared;\nusing xbytechat.api.Features.ESU.Facebook.Models;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.Payment.Models;\nusing xbytechat.api.Features.Entitlements.Models;\nusing Microsoft.EntityFrameworkCore.Storage.ValueConversion;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\n\nnamespace xbytechat.api\n{\n    public class AppDbContext : DbContext\n    {\n        public AppDbContext(DbContextOptions<AppDbContext> options)\n            : base(options) { }\n\n        public DbSet<Business> Businesses { get; set; }\n        public DbSet<User> Users { get; set; }\n        public DbSet<MessageLog> MessageLogs { get; set; }\n        public DbSet<Product> Products { get; set; }\n        public DbSet<CatalogClickLog> CatalogClickLogs { get; set; }\n        public DbSet<Contact> Contacts { get; set; }\n        public DbSet<Tag> Tags { get; set; }\n        public DbSet<Reminder> Reminders { get; set; }\n        public DbSet<Note> Notes { get; set; }\n        public DbSet<LeadTimeline> LeadTimelines { get; set; }\n        public DbSet<ContactTag> ContactTags { get; set; }\n        public DbSet<Campaign> Campaigns { get; set; }\n        public DbSet<CampaignRecipient> CampaignRecipients { get; set; }\n        public DbSet<CampaignSendLog> CampaignSendLogs { get; set; }\n        public DbSet<MessageStatusLog> MessageStatusLogs { get; set; }\n\n        // üß© Access Control\n        public DbSet<Role> Roles { get; set; }\n        public DbSet<Permission> Permissions { get; set; }\n        public DbSet<RolePermission> RolePermissions { get; set; }\n        public DbSet<UserPermission> UserPermissions { get; set; }\n        public DbSet<AuditLog> AuditLogs { get; set; }\n        public DbSet<WhatsAppSettingEntity> WhatsAppSettings { get; set; }\n        public DbSet<BusinessPlanInfo> BusinessPlanInfos { get; set; }\n        public DbSet<TrackingLog> TrackingLogs { get; set; }\n        public DbSet<CTADefinition> CTADefinitions { get; set; }\n        public DbSet<CampaignButton> CampaignButtons { get; set; }\n        public DbSet<FailedWebhookLog> FailedWebhookLogs { get; set; }\n        public DbSet<WebhookSettings> WebhookSettings { get; set; }\n        public DbSet<CTAFlowConfig> CTAFlowConfigs { get; set; }\n        public DbSet<CTAFlowStep> CTAFlowSteps { get; set; }\n        public DbSet<FlowButtonLink> FlowButtonLinks { get; set; }\n\n        public DbSet<CampaignFlowOverride> CampaignFlowOverrides { get; set; }\n        public DbSet<FlowExecutionLog> FlowExecutionLogs { get; set; }\n        public DbSet<ContactRead> ContactReads { get; set; }\n       \n        public DbSet<AutoReplyFlow> AutoReplyFlows { get; set; } = null!;\n        public DbSet<AutoReplyFlowNode> AutoReplyNodes { get; set; } = null!;\n        // Back-compat alias until older code is removed\n        public DbSet<AutoReplyFlowNode> AutoReplyFlowNodes { get; set; } = null!;\n        public DbSet<AutoReplyFlowEdge> AutoReplyFlowEdges { get; set; }\n        public DbSet<AutoReplyLog> AutoReplyLogs { get; set; }\n        public DbSet<ChatSessionState> ChatSessionStates { get; set; }\n        public DbSet<Plan> Plans { get; set; }\n        public DbSet<PlanPermission> PlanPermissions { get; set; }\n\n        public DbSet<PlanFeatureMatrix> PlanFeatureMatrix { get; set; }\n\n\n        public DbSet<AutomationFlow> AutomationFlows { get; set; }\n        public DbSet<WhatsAppTemplate> WhatsAppTemplates { get; set; }\n        public DbSet<CampaignClickLog> CampaignClickLogs => Set<CampaignClickLog>();\n        public DbSet<CampaignClickDailyAgg> CampaignClickDailyAgg => Set<CampaignClickDailyAgg>();\n        public DbSet<QuickReply> QuickReplies { get; set; } = null!;\n        public DbSet<WhatsAppPhoneNumber> WhatsAppPhoneNumbers { get; set; }\n        public DbSet<Audience> Audiences { get; set; }\n        public DbSet<AudienceMember> AudienceMembers { get; set; }\n        public DbSet<CsvBatch> CsvBatches { get; set; }\n        public DbSet<CsvRow> CsvRows { get; set; }\n        public DbSet<CampaignVariableMap> CampaignVariableMaps { get; set; }\n        public DbSet<ProviderBillingEvent> ProviderBillingEvents { get; set; } = default!;\n        public DbSet<OutboundCampaignJob> OutboundCampaignJobs { get; set; }\n        public DbSet<ApiKey> ApiKeys { get; set; } = null!;\n        public DbSet<CustomerWebhookConfig> CustomerWebhookConfigs { get; set; }\n        public DbSet<ContactJourneyState> ContactJourneyStates { get; set; }\n        public DbSet<OutboundMessageJob> OutboundMessageJobs { get; set; }\n\n        // Template Creation\n        public DbSet<TemplateDraft> TemplateDrafts { get; set; } = default!;\n        public DbSet<TemplateDraftVariant> TemplateDraftVariants { get; set; } = default!;\n        public DbSet<TemplateLibraryItem> TemplateLibraryItems { get; set; } = default!;\n        public DbSet<TemplateLibraryVariant> TemplateLibraryVariants { get; set; } = default!;\n\n        // ESU\n        public DbSet<IntegrationFlags> IntegrationFlags { get; set; } = null!;\n        public DbSet<EsuToken> EsuTokens { get; set; }\n\n        public DbSet<AccountInsightsAction> AccountInsightsActions { get; set; }\n\n\n\n        // Payment module\n        public DbSet<Subscription> Subscriptions { get; set; }\n        public DbSet<PaymentTransaction> PaymentTransactions { get; set; }\n        public DbSet<Invoice> Invoices { get; set; }\n        public DbSet<InvoiceLineItem> InvoiceLineItems { get; set; }\n        public DbSet<Coupon> Coupons { get; set; }\n\n        // Quota\n        public DbSet<PlanQuota> PlanQuotas => Set<PlanQuota>();\n        public DbSet<BusinessQuotaOverride> BusinessQuotaOverrides => Set<BusinessQuotaOverride>();\n        public DbSet<BusinessUsageCounter> BusinessUsageCounters => Set<BusinessUsageCounter>();\n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        {\n            base.OnModelCreating(modelBuilder);\n\n            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DETERMINISTIC SEED TIMESTAMPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n            var seedCreatedAt = new DateTime(2025, 1, 1, 0, 0, 0, DateTimeKind.Utc);\n            var planCreatedAt = new DateTime(2025, 1, 1, 0, 0, 0, DateTimeKind.Utc);\n            var created = new DateTime(2025, 9, 13, 0, 0, 0, DateTimeKind.Utc);\n\n            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SEEDS (unchanged GUIDs) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n            var superadminRoleId = Guid.Parse(\"00000000-0000-0000-0000-000000000001\");\n            var partnerRoleId = Guid.Parse(\"00000000-0000-0000-0000-000000000002\");\n            var resellerRoleId = Guid.Parse(\"00000000-0000-0000-0000-000000000003\");\n            var businessRoleId = Guid.Parse(\"00000000-0000-0000-0000-000000000004\");\n            var agentRoleId = Guid.Parse(\"00000000-0000-0000-0000-000000000005\");\n\n            modelBuilder.Entity<Role>().HasData(\n                new Role { Id = superadminRoleId, Name = \"admin\", Description = \"Super Admin\", CreatedAt = seedCreatedAt },\n                new Role { Id = partnerRoleId, Name = \"partner\", Description = \"Business Partner\", CreatedAt = seedCreatedAt },\n                new Role { Id = resellerRoleId, Name = \"reseller\", Description = \"Reseller Partner\", CreatedAt = seedCreatedAt },\n                new Role { Id = businessRoleId, Name = \"business\", Description = \"Business Owner\", CreatedAt = seedCreatedAt },\n                new Role { Id = agentRoleId, Name = \"staff\", Description = \"Staff\", CreatedAt = seedCreatedAt }\n            );\n\n            var superAdminUserId = Guid.Parse(\"62858aa2-3a54-4fd5-8696-c343d9af7634\");\n            modelBuilder.Entity<User>().HasData(new User\n            {\n                Id = superAdminUserId,\n                Name = \"Super Admin\",\n                Email = \"admin@xbytechat.com\",\n                RoleId = superadminRoleId,\n                Status = \"active\",\n                CreatedAt = seedCreatedAt,\n                DeletedAt = null,\n                IsDeleted = false,\n                BusinessId = null,\n                PasswordHash = \"JAvlGPq9JyTdtvBO6x2llnRI1+gxwIyPqCKAn3THIKk=\",\n                RefreshToken = null,\n                RefreshTokenExpiry = null\n            });\n\n            var basicPlanId = Guid.Parse(\"5f9f5de1-a0b2-48ba-b03d-77b27345613f\");\n            \n            modelBuilder.Entity<Plan>().HasData(new Plan\n            {\n                Id = basicPlanId,\n                Code = \"SYSTEM_DEFAULT\",\n                Name = \"System Default\",\n                Description = \"Default free plan\",\n                IsActive = true,\n                IsInternal = true,\n                CreatedAt = planCreatedAt\n            });\n\n            modelBuilder.Entity<Permission>().HasData(\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000000\"), Code = \"dashboard.view\", Name = \"dashboard.view\", Group = \"Dashboard\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000001\"), Code = \"campaign.view\", Name = \"campaign.view\", Group = \"Campaign\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000002\"), Code = \"campaign.create\", Name = \"campaign.create\", Group = \"Campaign\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000003\"), Code = \"campaign.delete\", Name = \"campaign.delete\", Group = \"Campaign\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000004\"), Code = \"product.view\", Name = \"product.view\", Group = \"Catalog\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000005\"), Code = \"product.create\", Name = \"product.create\", Group = \"Catalog\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000006\"), Code = \"product.delete\", Name = \"product.delete\", Group = \"Catalog\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000007\"), Code = \"contacts.view\", Name = \"contacts.view\", Group = \"CRM\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000008\"), Code = \"tags.edit\", Name = \"tags.edit\", Group = null, IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000009\"), Code = \"admin.business.approve\", Name = \"admin.business.approve\", Group = \"Admin\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000010\"), Code = \"admin.logs.view\", Name = \"admin.logs.view\", Group = null, IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000011\"), Code = \"admin.plans.view\", Name = \"admin.plans.view\", Group = \"Admin\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000012\"), Code = \"admin.plans.create\", Name = \"admin.plans.create\", Group = \"Admin\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000013\"), Code = \"admin.plans.update\", Name = \"admin.plans.update\", Group = \"Admin\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"30000000-0000-0000-0000-000000000014\"), Code = \"admin.plans.delete\", Name = \"admin.plans.delete\", Group = \"Admin\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"74c8034f-d9cb-4a17-8578-a9f765bd845c\"), Code = \"messaging.report.view\", Name = \"messaging.report.view\", Group = \"Messaging\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"c819f1bd-422d-4609-916c-cc185fe44ab0\"), Code = \"messaging.status.view\", Name = \"messaging.status.view\", Group = \"Messaging\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"eecd0fac-223c-4dba-9fa1-2a6e973d61d1\"), Code = \"messaging.inbox.view\", Name = \"messaging.inbox.view\", Group = \"Messaging\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"974af1f9-3caa-4857-a1a7-48462c389332\"), Code = \"messaging.send.text\", Name = \"messaging.send.text\", Group = \"Messaging\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"0485154c-dde5-4732-a7aa-a379c77a5b27\"), Code = \"messaging.send.template\", Name = \"messaging.send.template\", Group = \"Messaging\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"29461562-ef9c-48c0-a606-482ff57b8f95\"), Code = \"messaging.send\", Name = \"messaging.send\", Group = \"Messaging\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"bbc5202a-eac9-40bb-aa78-176c677dbf5b\"), Code = \"messaging.whatsappsettings.view\", Name = \"messaging.whatsappsettings.view\", Group = \"Messaging\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"205b87c7-b008-4e51-9fea-798c2dc4f9c2\"), Code = \"admin.whatsappsettings.view\", Name = \"admin.whatsappsettings.view\", Group = \"Admin\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"6e4d3a86-7cf9-4ac2-b8a7-ed10c9f0173d\"), Code = \"settings.whatsapp.view\", Name = \"Settings - WhatsApp View\", Group = \"Settings\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"ad36cdb7-5221-448b-a6a6-c35c9f88d021\"), Code = \"inbox.view\", Name = \"inbox.view\", Group = \"Inbox\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"74828fc0-e358-4cfc-b924-13719a0d9f50\"), Code = \"inbox.menu\", Name = \"inbox.menu\", Group = \"Inbox\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"98572fe7-d142-475a-b990-f248641809e2\"), Code = \"settings.profile.view\", Name = \"settings.profile.view\", Group = \"Settings\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"821480c6-1464-415e-bba8-066fcb4e7e63\"), Code = \"automation.menu\", Name = \"automation.menu\", Group = \"Automation\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"918a61d0-5ab6-46af-a3d3-41e37b7710f9\"), Code = \"automation.Create.Template.Flow\", Name = \"automation.Create.Template.Flow\", Group = \"Automation\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"9ae90cfe-3fea-4307-b024-3083c2728148\"), Code = \"automation.View.Template.Flow\", Name = \"automation.View.Template.Flow\", Group = \"Automation\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"93c5d5a7-f8dd-460a-8c7b-e3788440ba3a\"), Code = \"automation.Create.TemplatePlusFreetext.Flow\", Name = \"automation.Create.TemplatePlusFreetext.Flow\", Group = \"Automation\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"7d7cbceb-4ce7-4835-85cd-59562487298d\"), Code = \"automation.View.TemplatePlusFreetext.Flow\", Name = \"automation.View.TemplatePlusFreetext.Flow\", Group = \"Automation\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"636b17f2-1c54-4e26-a8cd-dbf561dcb522\"), Code = \"automation.View.Template.Flow_analytics\", Name = \"automation.View.Template.Flow_analytics\", Group = \"Automation\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"adfa8490-9705-4a36-a86e-d5bff7ddc220\"), Code = \"automation.View.TemplatePlusFreeText.Flow_analytics\", Name = \"automation.View.TemplatePlusFreeText.Flow_analytics\", Group = \"Automation\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"0dedac5b-81c8-44c3-8cfe-76c58e29c6db\"), Code = \"automation_trigger_test\", Name = \"automation_trigger_test\", Group = \"Automation\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"14ef7f9d-0975-4ab4-b6f1-7d1af8b594ca\"), Code = \"template.builder.view\", Name = \"View Template Builder\", Group = \"TemplateBuilder\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"03eabd97-b196-4603-bbdd-1b2cdd595ead\"), Code = \"template.builder.create.draft\", Name = \"Draft Creation\", Group = \"TemplateBuilder\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"d272be50-ff26-45cf-bd7a-e9db74813699\"), Code = \"template.builder.approved.templates.view\", Name = \"View Approved Template\", Group = \"TemplateBuilder\", IsActive = true, CreatedAt = created },\n                new Permission { Id = Guid.Parse(\"3602f49d-dc10-4faa-9a44-4185a669ea0a\"), Code = \"template.builder.library.browse\", Name = \"View Template Library\", Group = \"TemplateBuilder\", IsActive = true, CreatedAt = created }\n                );\n\n            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Relationships (clean and deduped) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n            // Access-control\n            modelBuilder.Entity<RolePermission>()\n                .HasOne(rp => rp.Role).WithMany(r => r.RolePermissions)\n                .HasForeignKey(rp => rp.RoleId).OnDelete(DeleteBehavior.Cascade);\n\n            modelBuilder.Entity<RolePermission>()\n                .HasOne(rp => rp.Permission).WithMany(p => p.RolePermissions)\n                .HasForeignKey(rp => rp.PermissionId).OnDelete(DeleteBehavior.Cascade);\n\n            modelBuilder.Entity<UserPermission>()\n                .HasOne(up => up.User).WithMany(u => u.UserPermissions)\n                .HasForeignKey(up => up.UserId).OnDelete(DeleteBehavior.Cascade);\n\n            modelBuilder.Entity<UserPermission>()\n                .HasOne(up => up.Permission).WithMany(p => p.UserPermissions)\n                .HasForeignKey(up => up.PermissionId).OnDelete(DeleteBehavior.Cascade);\n\n            // üîí Join-table uniqueness (prevents duplicates)\n            modelBuilder.Entity<RolePermission>()\n                .HasIndex(x => new { x.RoleId, x.PermissionId })\n                .IsUnique()\n                .HasDatabaseName(\"UX_RolePermissions_Role_Permission\");\n\n            modelBuilder.Entity<PlanPermission>()\n                .HasIndex(x => new { x.PlanId, x.PermissionId })\n                .IsUnique()\n                .HasDatabaseName(\"UX_PlanPermissions_Plan_Permission\");\n\n            modelBuilder.Entity<PlanPermission>(e =>\n            {\n                // Fast lookups\n                e.HasIndex(x => x.PlanId);\n                e.HasIndex(x => x.PermissionId);\n\n                // One row per (Plan, Permission)\n                e.HasIndex(x => new { x.PlanId, x.PermissionId }).IsUnique();\n            });\n            // Campaign core\n            modelBuilder.Entity<Campaign>()\n                .HasOne(c => c.Business).WithMany(b => b.Campaigns)\n                .HasForeignKey(c => c.BusinessId).IsRequired();\n\n            modelBuilder.Entity<Campaign>()\n                .HasMany(c => c.MultiButtons).WithOne(b => b.Campaign)\n                .HasForeignKey(b => b.CampaignId).OnDelete(DeleteBehavior.Cascade);\n\n            modelBuilder.Entity<Campaign>(e =>\n            {\n                e.Property(x => x.TemplateSchemaSnapshot).HasColumnType(\"jsonb\");\n\n                // üîÅ MATCHES PATCH: Campaign ‚Üí Audiences CASCADE\n                e.HasMany(c => c.Audiences).WithOne(a => a.Campaign)\n                 .HasForeignKey(a => a.CampaignId).OnDelete(DeleteBehavior.Cascade);\n\n                // already cascade\n                e.HasMany(c => c.SendLogs).WithOne(s => s.Campaign)\n                 .HasForeignKey(s => s.CampaignId).OnDelete(DeleteBehavior.Cascade);\n\n                // üîÅ MATCHES PATCH: Campaign ‚Üí MessageLogs CASCADE\n                e.HasMany(c => c.MessageLogs).WithOne(m => m.SourceCampaign)\n                 .HasForeignKey(m => m.CampaignId).OnDelete(DeleteBehavior.Cascade);\n            });\n\n\n            // Audience / CSV\n            modelBuilder.Entity<CsvBatch>(e =>\n            {\n                e.ToTable(\"CsvBatches\");\n                e.HasKey(x => x.Id);\n                e.Property(x => x.HeadersJson).HasColumnType(\"jsonb\");\n                e.HasIndex(x => x.Checksum).HasDatabaseName(\"ix_csvbatch_checksum\");\n                e.HasIndex(x => new { x.BusinessId, x.CreatedAt }).HasDatabaseName(\"ix_csvbatch_biz_created\");\n                e.HasIndex(x => new { x.BusinessId, x.AudienceId });\n                e.HasOne<Audience>().WithMany()\n                 .HasForeignKey(x => x.AudienceId).OnDelete(DeleteBehavior.SetNull);\n            });\n\n            modelBuilder.Entity<CsvRow>(e =>\n            {\n                e.ToTable(\"CsvRows\");\n                e.HasKey(x => x.Id);\n                e.Property(x => x.RowJson).HasColumnType(\"jsonb\");\n                e.HasIndex(x => new { x.BatchId, x.RowIndex }).IsUnique().HasDatabaseName(\"ux_csvrow_batch_rowidx\");\n                e.HasIndex(x => x.PhoneE164).HasDatabaseName(\"ix_csvrow_phone\");\n                e.HasIndex(x => new { x.BusinessId, x.BatchId });\n                e.HasOne(x => x.Batch).WithMany().HasForeignKey(x => x.BatchId).OnDelete(DeleteBehavior.Cascade);\n            });\n\n            modelBuilder.Entity<Audience>(e =>\n            {\n                e.ToTable(\"Audiences\");\n                e.HasKey(x => x.Id);\n                e.HasIndex(x => new { x.BusinessId, x.IsDeleted }).HasDatabaseName(\"ix_audiences_biz_deleted\");\n                e.HasIndex(x => new { x.BusinessId, x.CampaignId });\n                e.HasIndex(x => new { x.BusinessId, x.CsvBatchId });\n                e.HasOne(x => x.CsvBatch).WithMany().HasForeignKey(x => x.CsvBatchId).OnDelete(DeleteBehavior.SetNull);\n            });\n\n            modelBuilder.Entity<AudienceMember>(e =>\n            {\n                e.ToTable(\"AudienceMembers\");\n                e.HasKey(x => x.Id);\n                e.Property(x => x.AttributesJson).HasColumnType(\"jsonb\");\n                e.HasIndex(x => new { x.AudienceId, x.PhoneE164 }).IsUnique().HasDatabaseName(\"ux_audmember_audience_phone\");\n                e.HasIndex(x => x.ContactId).HasDatabaseName(\"ix_audmember_contact\");\n                e.HasOne(x => x.Audience).WithMany(a => a.Members)\n                 .HasForeignKey(x => x.AudienceId).OnDelete(DeleteBehavior.Cascade);\n            });\n\n            // Recipients ‚Äî OPTIONAL AudienceMember, OPTIONAL Contact\n            modelBuilder.Entity<CampaignRecipient>(e =>\n            {\n                e.ToTable(\"CampaignRecipients\");\n                e.HasKey(x => x.Id);\n\n                e.Property(x => x.ResolvedParametersJson).HasColumnType(\"jsonb\");\n                e.Property(x => x.ResolvedButtonUrlsJson).HasColumnType(\"jsonb\");\n                e.HasIndex(x => x.IdempotencyKey).HasDatabaseName(\"ix_campaignrecipients_idempotency\");\n                e.HasIndex(x => new { x.CampaignId, x.ContactId }).HasDatabaseName(\"ix_recipients_campaign_contact\");\n\n                e.HasOne(r => r.AudienceMember)\n                 .WithMany()\n                 .HasForeignKey(r => r.AudienceMemberId)\n                 .IsRequired(false)\n                 .OnDelete(DeleteBehavior.SetNull);\n\n                e.HasOne(r => r.Contact)\n                 .WithMany()\n                 .HasForeignKey(r => r.ContactId)\n                 .IsRequired(false)\n                 .OnDelete(DeleteBehavior.SetNull);\n\n                e.HasOne(r => r.Campaign)\n                 .WithMany(c => c.Recipients)\n                 .HasForeignKey(r => r.CampaignId)\n                 .OnDelete(DeleteBehavior.Cascade);\n\n                e.HasOne(r => r.Business)\n                 .WithMany()\n                 .HasForeignKey(r => r.BusinessId)\n                 .OnDelete(DeleteBehavior.Restrict);\n            });\n\n            // Send logs ‚Äî OPTIONAL Contact, REQUIRED Campaign\n            modelBuilder.Entity<CampaignSendLog>(e =>\n            {\n                e.ToTable(\"CampaignSendLogs\");\n                e.HasKey(x => x.Id);\n\n                e.Property(x => x.BusinessId).IsRequired();\n                e.HasIndex(x => x.MessageId);\n                e.HasIndex(x => x.RunId);\n                e.HasIndex(x => new { x.BusinessId, x.MessageId }).HasDatabaseName(\"IX_CampaignSendLogs_Business_MessageId\");\n\n                e.HasOne(s => s.Recipient).WithMany(r => r.SendLogs)\n                 .HasForeignKey(s => s.RecipientId);\n\n                // ‚úÖ allow null ContactId (fixes 23502 once column is nullable)\n                e.HasOne(s => s.Contact).WithMany()\n                 .HasForeignKey(s => s.ContactId)\n                 .IsRequired(false)\n                 .OnDelete(DeleteBehavior.SetNull);\n\n                e.HasOne(s => s.Campaign).WithMany(c => c.SendLogs)\n                 .HasForeignKey(s => s.CampaignId)\n                 .IsRequired()\n                 .OnDelete(DeleteBehavior.Cascade);\n\n                e.HasOne(s => s.MessageLog).WithMany()\n                 .HasForeignKey(s => s.MessageLogId)\n                 .OnDelete(DeleteBehavior.Restrict);\n            });\n\n            // Message logs ‚Äî helpful indexes + computed column\n            modelBuilder.Entity<MessageLog>(b =>\n            {\n                b.HasIndex(x => x.MessageId);\n                b.HasIndex(x => x.RunId);\n                b.HasIndex(x => new { x.BusinessId, x.MessageId }).HasDatabaseName(\"IX_MessageLogs_Business_MessageId\");\n                b.HasIndex(x => new { x.BusinessId, x.RecipientNumber }).HasDatabaseName(\"IX_MessageLogs_Business_Recipient\");\n                b.Property<DateTime?>(\"MessageTime\").HasComputedColumnSql(\"COALESCE(\\\"SentAt\\\", \\\"CreatedAt\\\")\", stored: true);\n                b.HasIndex(\"BusinessId\", \"IsIncoming\", \"ContactId\", \"MessageTime\").HasDatabaseName(\"ix_msglogs_biz_in_contact_msgtime\");\n            });\n\n            // QuickReplies\n            modelBuilder.Entity<QuickReply>(e =>\n            {\n                e.HasIndex(x => new { x.BusinessId, x.Scope, x.IsActive });\n                e.HasIndex(x => new { x.BusinessId, x.OwnerUserId, x.IsActive });\n                e.HasIndex(x => x.UpdatedAt);\n                e.Property(x => x.Title).HasMaxLength(120).IsRequired();\n                e.Property(x => x.Language).HasMaxLength(8);\n                e.Property(q => q.UpdatedAt).HasDefaultValueSql(\"NOW()\");\n            });\n\n            // Contacts ‚Äî uniqueness\n            modelBuilder.Entity<Contact>()\n                .HasIndex(c => new { c.BusinessId, c.PhoneNumber }).IsUnique();\n\n            modelBuilder.Entity<ContactRead>()\n                .HasIndex(cr => new { cr.ContactId, cr.UserId }).IsUnique();\n\n            modelBuilder.Entity<ContactRead>()\n                .HasIndex(cr => new { cr.BusinessId, cr.UserId, cr.ContactId })\n                .IsUnique().HasDatabaseName(\"ux_contactreads_biz_user_contact\");\n\n            // WhatsApp settings (principal with composite AK)\n            modelBuilder.Entity<WhatsAppSettingEntity>(b =>\n            {\n                b.ToTable(\"WhatsAppSettings\");\n                b.HasAlternateKey(s => new { s.BusinessId, s.Provider })\n                 .HasName(\"AK_WhatsAppSettings_BusinessId_Provider\");\n\n                b.HasIndex(x => new { x.Provider, x.WabaId }).HasDatabaseName(\"IX_WhatsAppSettings_Provider_WabaId\");\n                b.HasIndex(x => new { x.BusinessId, x.Provider, x.IsActive }).HasDatabaseName(\"IX_WhatsAppSettings_Business_Provider_IsActive\");\n                b.HasIndex(x => new { x.Provider, x.WebhookCallbackUrl }).HasDatabaseName(\"IX_WhatsAppSettings_Provider_CallbackUrl\");\n            });\n\n            modelBuilder.Entity<Business>()\n                .HasMany(b => b.WhatsAppSettings).WithOne()\n                .HasForeignKey(s => s.BusinessId).OnDelete(DeleteBehavior.Cascade);\n\n            modelBuilder.Entity<WhatsAppPhoneNumber>(e =>\n            {\n                e.ToTable(\"WhatsAppPhoneNumbers\");\n                e.HasKey(x => x.Id);\n                e.Property(x => x.Provider).IsRequired();\n                e.Property(x => x.PhoneNumberId).IsRequired();\n\n                e.HasOne<WhatsAppSettingEntity>()\n                 .WithMany(s => s.WhatsAppBusinessNumbers)\n                 .HasForeignKey(x => new { x.BusinessId, x.Provider })\n                 .HasPrincipalKey(s => new { s.BusinessId, s.Provider })\n                 .OnDelete(DeleteBehavior.Cascade);\n\n                // ‚úÖ keep this UNIQUE index\n                e.HasIndex(x => new { x.BusinessId, x.Provider, x.PhoneNumberId })\n                 .IsUnique()\n                 .HasDatabaseName(\"UX_WhatsappPhoneNumbers_Bus_Prov_PhoneId\");\n            });\n\n            // CTA / Tracking misc\n            modelBuilder.Entity<CampaignClickLog>(e =>\n            {\n                e.HasIndex(x => new { x.CampaignId, x.ClickType, x.ClickedAt });\n                e.HasIndex(x => new { x.CampaignId, x.ButtonIndex });\n                e.HasIndex(x => new { x.CampaignId, x.ContactId });\n            });\n\n            modelBuilder.Entity<CampaignClickDailyAgg>(e =>\n            {\n                e.HasIndex(x => new { x.CampaignId, x.Day, x.ButtonIndex }).IsUnique();\n                e.Property(x => x.Day).HasColumnType(\"date\");\n            });\n\n            // Flow graph bits\n            modelBuilder.Entity<FlowButtonLink>().HasKey(b => b.Id);\n\n            // Auto-reply flows & nodes (CRUD storage for builder)\n            modelBuilder.Entity<AutoReplyFlow>(entity =>\n            {\n                entity.HasKey(f => f.Id);\n                entity.HasIndex(f => new { f.BusinessId, f.Name });\n\n                entity.HasMany<AutoReplyFlowNode>()\n                      .WithOne(n => n.Flow)\n                      .HasForeignKey(n => n.FlowId)\n                      .OnDelete(DeleteBehavior.Cascade);\n            });\n\n            modelBuilder.Entity<AutoReplyFlowNode>(entity =>\n            {\n                entity.HasKey(n => n.Id);\n                entity.HasIndex(n => new { n.FlowId, n.NodeName });\n\n                // keep coordinates as an owned type\n                entity.OwnsOne(n => n.Position);\n            });\n\n            // Features/Plans\n      \n            // Outbound worker\n            modelBuilder.Entity<OutboundCampaignJob>(e =>\n            {\n                e.ToTable(\"OutboundCampaignJobs\");\n                e.HasIndex(x => new { x.Status, x.NextAttemptAt });\n                e.HasIndex(x => x.CampaignId);\n                e.Property(x => x.Status).HasMaxLength(32);\n                e.Property(x => x.LastError).HasMaxLength(4000);\n            });\n\n            modelBuilder.Entity<Campaign>()\n                 .HasOne(c => c.CTAFlowConfig)      // ‚úÖ use the nav that exists on Campaign\n                 .WithMany()\n                 .HasForeignKey(c => c.CTAFlowConfigId)\n                 .OnDelete(DeleteBehavior.Restrict);\n\n            modelBuilder.Entity<CTAFlowConfig>(e =>\n            {\n                e.HasMany(f => f.Steps)\n                 .WithOne(s => s.Flow)\n                 .HasForeignKey(s => s.CTAFlowConfigId)\n                 .OnDelete(DeleteBehavior.Cascade);\n            });\n\n            // keep only this one:\n            modelBuilder.Entity<CTAFlowConfig>()\n                .HasIndex(f => new { f.BusinessId, f.FlowName, f.IsActive })\n                .IsUnique();\n\n            modelBuilder.Entity<CTAFlowStep>(e =>\n            {\n                e.HasMany(s => s.ButtonLinks)\n                 .WithOne(b => b.Step)                 // only if FlowButtonLink has a 'Step' nav\n                 .HasForeignKey(b => b.CTAFlowStepId)  // ‚úÖ use existing FK name\n                 .OnDelete(DeleteBehavior.Cascade);\n            });\n\n            // Flow execution logs ‚Üí delete with their Flow\n            //modelBuilder.Entity<FlowExecutionLog>(e =>\n            //{\n            //    e.ToTable(\"FlowExecutionLogs\");\n            //    e.HasKey(x => x.Id);\n            //    e.HasIndex(x => x.FlowId).HasDatabaseName(\"IX_FlowExecutionLogs_FlowId\");\n\n            //    // Critical: tie logs to Flow and cascade on delete\n            //    e.HasOne<CTAFlowConfig>()\n            //     .WithMany()                            // no collection needed\n            //     .HasForeignKey(x => x.FlowId)\n            //     .OnDelete(DeleteBehavior.Cascade);\n\n            //});\n            // Flow execution logs ‚Üí delete with their Flow\n            modelBuilder.Entity<FlowExecutionLog>(e =>\n            {\n                e.ToTable(\"FlowExecutionLogs\");\n                e.HasKey(x => x.Id);\n\n                // existing / kept index\n                e.HasIndex(x => x.FlowId)\n                 .HasDatabaseName(\"IX_FlowExecutionLogs_FlowId\");\n\n                // üîç time-based analytics per business\n                e.HasIndex(x => new { x.BusinessId, x.ExecutedAt })\n                 .HasDatabaseName(\"ix_flowexec_biz_executedat\");\n\n                // üîç campaign-origin segmentation\n                e.HasIndex(x => new { x.BusinessId, x.Origin, x.CampaignId })\n                 .HasDatabaseName(\"ix_flowexec_biz_origin_campaign\");\n\n                // üîç autoreply-origin segmentation\n                e.HasIndex(x => new { x.BusinessId, x.Origin, x.AutoReplyFlowId })\n                 .HasDatabaseName(\"ix_flowexec_biz_origin_autoreply\");\n\n                // tie logs to Flow and cascade on delete\n                e.HasOne<CTAFlowConfig>()\n                 .WithMany()\n                 .HasForeignKey(x => x.FlowId)\n                 .OnDelete(DeleteBehavior.Cascade);\n            });\n\n            // ----- ProviderBillingEvents (core for billing dedupe + reads) -----\n            modelBuilder.Entity<ProviderBillingEvent>(e =>\n            {\n                // Hard dedupe (webhook replays, same message/event). Filter keeps NULLs out of the unique constraint.\n                e.HasIndex(x => new { x.BusinessId, x.Provider, x.ProviderMessageId, x.EventType })\n                 .HasDatabaseName(\"UX_ProviderBillingEvents_UniqueEvent\")\n                 .IsUnique()\n                 .HasFilter(\"\\\"ProviderMessageId\\\" IS NOT NULL\");\n\n                // Time-range scans by event type (used by snapshot)\n                e.HasIndex(x => new { x.BusinessId, x.EventType, x.OccurredAt })\n                 .HasDatabaseName(\"IX_Billing_BizEventTime\");\n\n                // Group/lookup by conversation window\n                e.HasIndex(x => new { x.BusinessId, x.ConversationId })\n                 .HasDatabaseName(\"IX_Billing_BizConversation\")\n                 .HasFilter(\"\\\"ConversationId\\\" IS NOT NULL\");\n\n                // Direct lookups by provider message id\n                e.HasIndex(x => new { x.BusinessId, x.ProviderMessageId })\n                 .HasDatabaseName(\"IX_Billing_BizProviderMessage\")\n                 .HasFilter(\"\\\"ProviderMessageId\\\" IS NOT NULL\");\n            });\n\n            // ----- MessageLogs (snapshot volume + joins from billing) -----\n            modelBuilder.Entity<MessageLog>(e =>\n            {\n                // Period queries\n                e.HasIndex(x => new { x.BusinessId, x.CreatedAt })\n                 .HasDatabaseName(\"IX_MessageLogs_BizCreatedAt\");\n\n                // Join from billing by provider message id\n                e.HasIndex(x => new { x.BusinessId, x.ProviderMessageId })\n                 .HasDatabaseName(\"IX_MessageLogs_BizProviderMessage\")\n                 .HasFilter(\"\\\"ProviderMessageId\\\" IS NOT NULL\");\n\n                // Conversation aggregation / backfills\n                e.HasIndex(x => new { x.BusinessId, x.ConversationId })\n                 .HasDatabaseName(\"IX_MessageLogs_BizConversation\")\n                 .HasFilter(\"\\\"ConversationId\\\" IS NOT NULL\");\n            });\n\n            // ----- CampaignSendLogs (status updater lookups) -----\n            modelBuilder.Entity<CampaignSendLog>(e =>\n            {\n                e.HasIndex(x => new { x.BusinessId, x.SendStatus, x.SentAt })\n                 .HasDatabaseName(\"IX_CampaignSendLogs_StatusTime\");\n            });\n\n            // ----- Optional: provider config lookups used during send/status -----\n\n            modelBuilder.Entity<xbytechat.api.Features.CustomeApi.Models.ApiKey>(e =>\n            {\n                e.HasKey(x => x.Id);\n                e.HasIndex(x => x.Prefix).IsUnique();\n                e.Property(x => x.SecretHash).IsRequired();\n                e.Property(x => x.Scopes).HasMaxLength(512);\n            });\n\n            //modelBuilder.Entity<MessageStatusLog>()\n            //    .HasOne<Campaign>()                       // (no nav on MessageStatusLog needed)\n            //    .WithMany(c => c.MessageStatusLogs)       // uses Campaign.MessageStatusLogs collection\n            //    .HasForeignKey(ms => ms.CampaignId)\n            //    .OnDelete(DeleteBehavior.Cascade);\n            modelBuilder.Entity<MessageStatusLog>(e =>\n            {\n                e.HasKey(x => x.Id);\n\n                e.HasOne(ms => ms.Campaign)          // ‚úÖ use nav\n                 .WithMany(c => c.MessageStatusLogs) // or .WithMany() if Campaign doesn't expose the collection\n                 .HasForeignKey(ms => ms.CampaignId)\n                 .OnDelete(DeleteBehavior.Cascade);\n            });\n            // FK indexes used by hard delete / reads\n            modelBuilder.Entity<CampaignSendLog>()\n                .HasIndex(x => x.CampaignId)\n                .HasDatabaseName(\"IX_CampaignSendLogs_Campaign\");\n\n            modelBuilder.Entity<MessageLog>()\n                .HasIndex(x => x.CampaignId)\n                .HasDatabaseName(\"IX_MessageLogs_Campaign\");\n\n            modelBuilder.Entity<MessageLog>()\n                .HasIndex(x => x.ProviderMessageId)\n                .HasDatabaseName(\"IX_MessageLogs_ProviderMessageId\")\n                .HasFilter(\"\\\"ProviderMessageId\\\" IS NOT NULL\");\n\n            modelBuilder.Entity<TrackingLog>(e =>\n            {\n                e.HasKey(x => x.Id);\n\n                // indexes (keep)\n                e.HasIndex(x => x.CampaignId).HasDatabaseName(\"IX_TrackingLogs_Campaign\");\n                e.HasIndex(x => x.MessageLogId).HasDatabaseName(\"IX_TrackingLogs_MessageLog\");\n                e.HasIndex(x => x.CampaignSendLogId).HasDatabaseName(\"IX_TrackingLogs_SendLog\");\n\n                // ‚úÖ use navs defined on the POCO\n                e.HasOne(t => t.Campaign)\n                 .WithMany()\n                 .HasForeignKey(t => t.CampaignId)\n                 .IsRequired(false)\n                 .OnDelete(DeleteBehavior.Restrict);\n\n                e.HasOne(t => t.MessageLog)\n                 .WithMany()\n                 .HasForeignKey(t => t.MessageLogId)\n                 .IsRequired(false)\n                 .OnDelete(DeleteBehavior.Restrict);\n\n                e.HasOne(t => t.CampaignSendLog)\n                 .WithMany()\n                 .HasForeignKey(t => t.CampaignSendLogId)\n                 .IsRequired(false)\n                 .OnDelete(DeleteBehavior.Restrict);\n            });\n\n            modelBuilder.Entity<OutboundMessageJob>(e =>\n            {\n                e.ToTable(\"OutboundMessageJobs\");\n\n                // Columns\n                e.Property(x => x.Status).HasMaxLength(24);\n                e.Property(x => x.LastError).HasMaxLength(4000);\n                e.Property(x => x.IdempotencyKey).HasMaxLength(1000)\n                .IsRequired(false);\n\n                // Helpful indexes\n                e.HasIndex(x => x.CampaignId);\n\n                e.HasIndex(x => new { x.BusinessId, x.IdempotencyKey })\n                 .IsUnique()\n                 .HasFilter(\"\\\"IdempotencyKey\\\" IS NOT NULL AND \\\"IdempotencyKey\\\" <> ''\")\n                 .HasDatabaseName(\"UX_Outbox_Biz_IdemKey\");\n\n                // üî• Hot-path for producer & reaper (keep this one; remove the 2-col variant)\n                e.HasIndex(x => new { x.Status, x.NextAttemptAt, x.CreatedAt })\n                 .HasDatabaseName(\"IX_Outbox_StatusDueCreated\");\n            });\n\n            modelBuilder.Entity<WhatsAppTemplate>(e =>\n            {\n                e.ToTable(\"WhatsAppTemplates\");\n\n                // ‚îÄ‚îÄ üîê HARD DEDUPE: pick one of these keys (both are safe together) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // Prefer external TemplateId when present (provider's primary key)\n                e.HasIndex(x => new { x.BusinessId, x.Provider, x.TemplateId })\n                 .IsUnique()\n                 .HasFilter(@\"\"\"TemplateId\"\" IS NOT NULL\")\n                 .HasDatabaseName(\"UX_WAT_BizProvTemplateId\");\n\n                // Fallback uniqueness: Name + LanguageCode per provider per business\n                e.HasIndex(x => new { x.BusinessId, x.Provider, x.Name, x.LanguageCode })\n                 .IsUnique()\n                 .HasDatabaseName(\"UX_WAT_BizProvNameLang\");\n\n                // ‚îÄ‚îÄ üîé Your existing read-path indexes (kept) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n                // Core ‚Äúlist for a business‚Äù scans (Used by List endpoint + internal dashboards)\n                // Filters: BusinessId, Provider?, IsActive; sort by UpdatedAt/LastSyncedAt\n                e.HasIndex(x => new { x.BusinessId, x.Provider, x.IsActive, x.UpdatedAt, x.LastSyncedAt })\n                 .HasDatabaseName(\"IX_WAT_Business_Provider_IsActive_Sort\")\n#if NET7_0_OR_GREATER\n                 .IsDescending(false, false, false, true, true) // DESC on UpdatedAt/LastSyncedAt where supported\n#endif\n                 ;\n\n                // When provider filter isn‚Äôt present ‚Äî still useful for a business-wide ‚Äúactive‚Äù list\n                e.HasIndex(x => new { x.BusinessId, x.IsActive })\n                 .HasDatabaseName(\"IX_WAT_Business_IsActive\");\n\n                // Exact fetch by external TemplateId (preferred lookup when present)\n                e.HasIndex(x => new { x.BusinessId, x.Provider, x.TemplateId })\n                 .HasDatabaseName(\"IX_WAT_Business_Provider_TemplateId\")\n                 .HasFilter(@\"\"\"TemplateId\"\" IS NOT NULL\");\n\n                // Fallback fetch used by sync/GetOne: Name + LanguageCode for a given provider\n                e.HasIndex(x => new { x.BusinessId, x.Provider, x.Name, x.LanguageCode })\n                 .HasDatabaseName(\"IX_WAT_Business_Provider_Name_Lang\");\n\n                // List filters: Status + Language on active rows\n                e.HasIndex(x => new { x.BusinessId, x.Provider, x.Status, x.LanguageCode })\n                 .HasDatabaseName(\"IX_WAT_Business_Provider_Status_Lang_Active\")\n                 .HasFilter(@\"\"\"IsActive\"\" = TRUE\");\n\n                // TTL check in sync: ORDER BY LastSyncedAt DESC LIMIT 1 per business\n                e.HasIndex(x => new { x.BusinessId, x.LastSyncedAt })\n                 .HasDatabaseName(\"IX_WAT_Business_LastSyncedAt\")\n#if NET7_0_OR_GREATER\n                 .IsDescending(false, true) // DESC LastSyncedAt where supported\n#endif\n                 ;\n\n                // Helpful single-column lookups/sorts you do frequently\n                e.HasIndex(x => x.UpdatedAt).HasDatabaseName(\"IX_WAT_UpdatedAt\");\n                e.HasIndex(x => x.LastSyncedAt).HasDatabaseName(\"IX_WAT_LastSyncedAt\");\n\n                // NOTE: for q= search on Name/Body with Contains/ILIKE, add pg_trgm GIN via migration:\n                //   CREATE EXTENSION IF NOT EXISTS pg_trgm;\n                //   CREATE INDEX IX_WAT_trgm_lower_name ON \"WhatsAppTemplates\" USING GIN (lower(\"Name\") gin_trgm_ops);\n                //   CREATE INDEX IX_WAT_trgm_body        ON \"WhatsAppTemplates\" USING GIN (\"Body\" gin_trgm_ops);\n                // (done with migrationBuilder.Sql(...))\n            });\n            //TemplateDrafts\n            modelBuilder.Entity<TemplateDraft>(e =>\n            {\n                // üîê One logical draft key per business\n                e.HasIndex(x => new { x.BusinessId, x.Key })\n                 .IsUnique()\n                 .HasDatabaseName(\"UX_TemplateDrafts_Biz_Key\");\n\n                // üîé Common scans\n                e.HasIndex(x => new { x.BusinessId, x.UpdatedAt })\n                 .HasDatabaseName(\"IX_TemplateDrafts_Biz_UpdatedAt\");\n\n                e.HasIndex(x => x.CreatedAt)\n                 .HasDatabaseName(\"IX_TemplateDrafts_CreatedAt\");\n            });\n            //TemplateDraftVariants\n\n            modelBuilder.Entity<TemplateDraftVariant>(e =>\n            {\n                // üîê One language variant per draft\n                e.HasIndex(x => new { x.TemplateDraftId, x.Language })\n                 .IsUnique()\n                 .HasDatabaseName(\"UX_TDraftVariants_Draft_Language\");\n\n                // üîé Ready-for-submission filters\n                e.HasIndex(x => new { x.TemplateDraftId, x.IsReadyForSubmission })\n                 .HasDatabaseName(\"IX_TDraftVariants_Draft_Ready\");\n\n                // üîé Language lookups\n                e.HasIndex(x => x.Language)\n                 .HasDatabaseName(\"IX_TDraftVariants_Language\");\n            });\n\n            //TemplateLibraryItems\n            modelBuilder.Entity<TemplateLibraryItem>(e =>\n            {\n                // üîê Unique per industry\n                e.HasIndex(x => new { x.Industry, x.Key })\n                 .IsUnique()\n                 .HasDatabaseName(\"UX_TLibrary_Industry_Key\");\n\n                // üîé Featured filters per industry\n                e.HasIndex(x => new { x.Industry, x.IsFeatured })\n                 .HasDatabaseName(\"IX_TLibrary_Industry_Featured\");\n\n                // üîé Browse by category\n                e.HasIndex(x => x.Category)\n                 .HasDatabaseName(\"IX_TLibrary_Category\");\n            });\n\n            //TemplateLibraryVariants\n            modelBuilder.Entity<TemplateLibraryVariant>(e =>\n            {\n                // üîê One language per library item\n                e.HasIndex(x => new { x.LibraryItemId, x.Language })\n                 .IsUnique()\n                 .HasDatabaseName(\"UX_TLibraryVariants_Item_Lang\");\n\n                // üîé Language browsing\n                e.HasIndex(x => x.Language)\n                 .HasDatabaseName(\"IX_TLibraryVariants_Language\");\n            });\n            // ESU / Facebook: single-row flags per Business\n            modelBuilder.Entity<IntegrationFlags>(b =>\n            {\n                b.ToTable(\"IntegrationFlags\");\n                b.HasKey(x => x.BusinessId);\n\n                b.Property(x => x.BusinessId).ValueGeneratedNever();\n\n                b.Property(x => x.FacebookEsuCompleted)\n                 .IsRequired()\n                 .HasDefaultValue(false);\n\n\n\n                b.Property(x => x.CreatedAtUtc)\n                 .HasDefaultValueSql(\"timezone('utc', now())\")\n                 .ValueGeneratedOnAdd();\n\n                b.Property(x => x.UpdatedAtUtc)\n                 .HasDefaultValueSql(\"timezone('utc', now())\")\n                 .ValueGeneratedOnAdd();\n            });\n\n            modelBuilder.Entity<EsuToken>(b =>\n            {\n                b.ToTable(\"EsuTokens\");\n                b.HasIndex(x => new { x.BusinessId, x.Provider }).IsUnique();\n            });\n\n            modelBuilder.Entity<AccountInsightsAction>(cfg =>\n            {\n                cfg.ToTable(\"AccountInsightsActions\");\n\n                cfg.HasKey(x => x.Id);\n\n                cfg.Property(x => x.BusinessId)\n                    .IsRequired();\n\n                cfg.Property(x => x.ActionType)\n                    .HasMaxLength(64)\n                    .IsRequired();\n\n                cfg.Property(x => x.Label)\n                    .HasMaxLength(256);\n\n                cfg.Property(x => x.Actor)\n                    .HasMaxLength(256);\n\n                cfg.Property(x => x.MetaJson)\n                    .HasColumnType(\"text\");\n\n                cfg.Property(x => x.CreatedAtUtc)\n                    .IsRequired();\n\n                cfg.HasIndex(x => new { x.BusinessId, x.CreatedAtUtc });\n            });\n\n            // ----- Payment: Subscription -----\n            modelBuilder.Entity<Subscription>(b =>\n            {\n                b.ToTable(\"Subscriptions\");\n                b.HasKey(x => x.Id);\n\n                b.HasOne(x => x.Business)\n                    .WithMany() // later you can expose Business.Subscriptions if needed\n                    .HasForeignKey(x => x.BusinessId)\n                    .OnDelete(DeleteBehavior.Cascade);\n\n                b.HasOne(x => x.Plan)\n                    .WithMany()\n                    .HasForeignKey(x => x.PlanId)\n                    .OnDelete(DeleteBehavior.Restrict);\n\n                // Store enums as ints for simplicity\n                b.Property(x => x.Status)\n                    .HasConversion<int>()\n                    .IsRequired();\n\n                b.Property(x => x.BillingCycle)\n                    .HasConversion<int>()\n                    .IsRequired();\n\n                b.Property(x => x.CurrentPeriodStartUtc).IsRequired();\n                b.Property(x => x.CurrentPeriodEndUtc).IsRequired();\n\n                b.Property(x => x.GatewayCustomerId).HasMaxLength(200);\n                b.Property(x => x.GatewaySubscriptionId).HasMaxLength(200);\n            });\n\n            // ----- Payment: PaymentTransaction -----\n            modelBuilder.Entity<PaymentTransaction>(b =>\n            {\n                b.ToTable(\"PaymentTransactions\");\n                b.HasKey(x => x.Id);\n\n                b.HasOne(x => x.Business)\n                    .WithMany()\n                    .HasForeignKey(x => x.BusinessId)\n                    .OnDelete(DeleteBehavior.Cascade);\n\n                b.HasOne(x => x.Subscription)\n                    .WithMany(s => s.Payments)\n                    .HasForeignKey(x => x.SubscriptionId)\n                    .OnDelete(DeleteBehavior.SetNull);\n\n                b.HasOne(x => x.Invoice)\n                    .WithMany(i => i.Payments)\n                    .HasForeignKey(x => x.InvoiceId)\n                    .OnDelete(DeleteBehavior.SetNull);\n\n                b.Property(x => x.Status)\n                    .HasConversion<int>()\n                    .IsRequired();\n\n                b.Property(x => x.Amount)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n\n                b.Property(x => x.Currency)\n                    .HasMaxLength(10)\n                    .IsRequired();\n\n                b.Property(x => x.Gateway)\n                    .HasMaxLength(50)\n                    .IsRequired();\n\n                b.Property(x => x.GatewayPaymentId).HasMaxLength(200);\n                b.Property(x => x.GatewayOrderId).HasMaxLength(200);\n                b.Property(x => x.GatewaySignature).HasMaxLength(500);\n\n                b.Property(x => x.CreatedAtUtc).IsRequired();\n            });\n            // ----- Payment: Invoice -----\n            modelBuilder.Entity<Invoice>(b =>\n            {\n                b.ToTable(\"Invoices\");\n                b.HasKey(x => x.Id);\n\n                b.HasOne(x => x.Business)\n                    .WithMany()\n                    .HasForeignKey(x => x.BusinessId)\n                    .OnDelete(DeleteBehavior.Cascade);\n\n                b.HasOne(x => x.Subscription)\n                    .WithMany(s => s.Invoices)\n                    .HasForeignKey(x => x.SubscriptionId)\n                    .OnDelete(DeleteBehavior.SetNull);\n\n                b.Property(x => x.InvoiceNumber)\n                    .HasMaxLength(100)\n                    .IsRequired();\n\n                b.HasIndex(x => x.InvoiceNumber)\n                    .IsUnique();\n\n                b.Property(x => x.Status)\n                    .HasConversion<int>()\n                    .IsRequired();\n\n                b.Property(x => x.SubtotalAmount)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n\n                b.Property(x => x.TaxAmount)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n\n                b.Property(x => x.DiscountAmount)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n\n                b.Property(x => x.TotalAmount)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n\n                b.Property(x => x.Currency)\n                    .HasMaxLength(10)\n                    .IsRequired();\n\n                b.Property(x => x.AppliedCouponCode)\n                    .HasMaxLength(100);\n\n                b.Property(x => x.TaxBreakdownJson)\n                    .HasColumnType(\"text\");\n\n                b.Property(x => x.IssuedAtUtc)\n                    .IsRequired();\n\n\n                b.HasOne(x => x.Plan)\n                   .WithMany()\n                   .HasForeignKey(x => x.PlanId)\n                   .OnDelete(DeleteBehavior.SetNull);\n\n                b.Property(x => x.BillingCycle)\n                    .HasConversion<int?>();\n\n                b.Property(x => x.InvoiceNumber)\n                    .HasMaxLength(100)\n                    .IsRequired();\n\n                b.HasIndex(x => x.InvoiceNumber).IsUnique();\n            });\n            // ----- Payment: InvoiceLineItem -----\n            modelBuilder.Entity<InvoiceLineItem>(b =>\n            {\n                b.ToTable(\"InvoiceLineItems\");\n                b.HasKey(x => x.Id);\n\n                b.HasOne(x => x.Invoice)\n                    .WithMany(i => i.LineItems)\n                    .HasForeignKey(x => x.InvoiceId)\n                    .OnDelete(DeleteBehavior.Cascade);\n\n                b.Property(x => x.Description)\n                    .HasMaxLength(500)\n                    .IsRequired();\n\n                b.Property(x => x.Quantity)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n\n                b.Property(x => x.UnitPrice)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n\n                b.Property(x => x.LineTotal)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n            });\n            // ----- Payment: Coupon -----\n            modelBuilder.Entity<Coupon>(b =>\n            {\n                b.ToTable(\"Coupons\");\n                b.HasKey(x => x.Id);\n\n                b.Property(x => x.Code)\n                    .HasMaxLength(100)\n                    .IsRequired();\n\n                b.HasIndex(x => x.Code)\n                    .IsUnique();\n\n                b.Property(x => x.DiscountType)\n                    .HasConversion<int>()\n                    .IsRequired();\n\n                b.Property(x => x.DiscountValue)\n                    .HasColumnType(\"numeric(18,2)\")\n                    .IsRequired();\n\n                b.Property(x => x.IsActive)\n                    .IsRequired();\n\n                // Optional plan scope\n                b.HasOne<Plan>()\n                    .WithMany()\n                    .HasForeignKey(x => x.PlanId)\n                    .OnDelete(DeleteBehavior.SetNull);\n            });\n            var toUpper = new ValueConverter<string, string>(\n                    v => v == null ? null : v.ToUpperInvariant(),\n                    v => v\n                );\n\n            // --- PlanQuota ---\n            modelBuilder.Entity<PlanQuota>(e =>\n            {\n                e.Property(p => p.QuotaKey)\n                    .HasMaxLength(128)\n                    .HasConversion(toUpper); // normalize\n\n                // Unique per Plan + QuotaKey\n                e.HasIndex(p => new { p.PlanId, p.QuotaKey }).IsUnique();\n            });\n\n            // --- BusinessQuotaOverride ---\n            modelBuilder.Entity<BusinessQuotaOverride>(e =>\n            {\n                e.Property(p => p.QuotaKey)\n                    .HasMaxLength(128)\n                    .HasConversion(toUpper); // normalize\n\n                // Unique per Business + QuotaKey\n                e.HasIndex(p => new { p.BusinessId, p.QuotaKey }).IsUnique();\n            });\n\n            // --- BusinessUsageCounter ---\n            modelBuilder.Entity<BusinessUsageCounter>(e =>\n            {\n                e.Property(p => p.QuotaKey)\n                    .HasMaxLength(128)\n                    .HasConversion(toUpper); // normalize\n\n                // One active window per Business + QuotaKey + Period + WindowStart\n                e.HasIndex(u => new { u.BusinessId, u.QuotaKey, u.Period, u.WindowStartUtc }).IsUnique();\n            });\n\n            // --- Permission ---\n            modelBuilder.Entity<Permission>(e =>\n            {\n                e.Property(p => p.Code)\n                    .IsRequired()\n                    .HasMaxLength(120)\n                    .HasConversion(toUpper); // normalize\n\n                e.HasIndex(p => p.Code).IsUnique(); // enforce uniqueness\n            });\n\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/DTOs/Messages/BaseMessageDto.cs",
      "sha256": "9af6b10a0f81ca1fef4fa6f55228cf022cf8f574e7dc66dcee263cde3074a20d",
      "language": "csharp",
      "size": 440,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.DTOs.Messages\n{\n    public abstract class BaseMessageDto\n    {\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [Phone]\n        public string RecipientNumber { get; set; }\n\n        public abstract string MessageContent { get; set; }\n\n        //[Required]\n        //public string MessageType { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/DTOs/Messages/BulkMessageDto.cs",
      "sha256": "c9cf233e8ad3bf868c53de4f40343b326e34c668d015097e2aa6a1221696b9c4",
      "language": "csharp",
      "size": 647,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.DTOs.Messages\n{\n    public class BulkMessageDto\n    {\n        [Required]\n        public List<Guid> ContactIds { get; set; } = new();\n\n        [Required]\n        public string MessageType { get; set; } = string.Empty; // \"text\" or \"template\"\n\n        [Required]\n        public string MessageTemplate { get; set; } = string.Empty;\n\n        public string? TemplateName { get; set; }\n\n        public List<string>? TemplateParams { get; set; }\n\n        public DateTime? ScheduledAt { get; set; } // Optional future scheduling\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/DTOs/Messages/CtaMessageDto.cs",
      "sha256": "80af1338096deb56a727a9ac543829c364442d6f67637455296e227a56abbd7b",
      "language": "csharp",
      "size": 1326,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.DTOs.Messages\n{\n    public class CtaMessageDto\n    {\n        // üéØ Required Fields\n        public string RecipientPhone { get; set; } = string.Empty;\n        public string BodyText { get; set; } = string.Empty;\n        public List<string> Buttons { get; set; } = new();\n\n        // üîó Optional Source Info\n        public Guid? BusinessId { get; set; }          // Optional: Track for MessageLog\n        public Guid? CampaignId { get; set; }          // Optional: If triggered via Campaign\n        public string? SourceModule { get; set; }      // e.g., \"Catalog\", \"CRM\", \"Timeline\"\n\n        // üë§ Customer Context (Optional Enrichment)\n        public string? CustomerId { get; set; }\n        public string? CustomerName { get; set; }\n        public string? CustomerPhone { get; set; }\n\n        // üì¶ Advanced (Optional but useful)\n        public string? BotId { get; set; }             // Bot which served this (optional)\n        public string? RefMessageId { get; set; }      // Link to previous message (thread)\n        public string? CTATriggeredFrom { get; set; }  // e.g., ‚ÄúBuy Now‚Äù, ‚ÄúKnow More‚Äù\n\n        // ‚è±Ô∏è Timestamps / Meta\n        public DateTime? ScheduledAt { get; set; }     // For future automation (optional)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/DTOs/Messages/ImageMessageDto.cs",
      "sha256": "f5c8436e0d3055ef94a5fd88067f1497534a889f1296174babd92385a36494cf",
      "language": "csharp",
      "size": 340,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.DTOs.Messages\n{\n    public class ImageMessageDto : BaseMessageDto\n    {\n        [Required]\n        public override string MessageContent { get; set; } = string.Empty;\n\n        [Required]\n        [Url]\n        public string MediaUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/DTOs/Messages/RawMessageWrapper.cs",
      "sha256": "d7ac355237d8f59f61eeeee123e9450f669ff9eb387359212b8c2c2456ac4353",
      "language": "csharp",
      "size": 220,
      "content": "// DTOs/Messages/RawMessageWrapper.cs\nusing Newtonsoft.Json.Linq;\n\npublic class RawMessageWrapper\n{\n    public string MessageType { get; set; } = string.Empty;\n    public JObject Payload { get; set; } = new JObject();\n}\n"
    },
    {
      "path": "xbytechat-api/DTOs/Messages/TemplateMessageDto.cs",
      "sha256": "06b028cea23f4720af49039d87a58cf7134087ad5744eae187c7900c0a2daa35",
      "language": "csharp",
      "size": 1033,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.DTOs.Messages\n{\n    /// <summary>\n    /// DTO for sending WhatsApp template-based messages.\n    /// </summary>\n    public class TemplateMessageDto : BaseMessageDto\n    {\n        [Required]\n        public string TemplateName { get; set; } = string.Empty;\n\n        [Required]\n        public string LanguageCode { get; set; } = \"en_US\";\n\n        public Dictionary<string, string> TemplateParameters { get; set; }\n\n        public List<ButtonPayloadDto>? ButtonParams { get; set; } // ‚úÖ NEW\n\n        public override string MessageContent { get; set; } = \"[Template]\";\n    }\n\n    /// <summary>\n    /// DTO for each button in a WhatsApp template.\n    /// </summary>\n    public class ButtonPayloadDto\n    {\n        public string SubType { get; set; } = \"url\"; // or \"phone_number\"\n        public string Index { get; set; } = \"0\";      // 0-based index as string\n        public string Param { get; set; } = string.Empty; // dynamic value for URL or phone number\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/DTOs/Messages/TextMessageDto.cs",
      "sha256": "a899c48829d76e7fdf88be5bdafe15ab5307342c557b6431ba43c60f51a8ee11",
      "language": "csharp",
      "size": 244,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.DTOs.Messages\n{\n    public class TextMessageDto : BaseMessageDto\n    {\n        [Required]\n        public override string MessageContent { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Attributes/HasPermissionAttribute.cs",
      "sha256": "4c0b87bd0b181823afbcc065a45376dc4c185ec94ae738d09d28afeee757d71d",
      "language": "csharp",
      "size": 3182,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Services;\n\nnamespace xbytechat.api.Features.AccessControl.Attributes\n{\n    public class HasPermissionAttribute : Attribute, IAsyncAuthorizationFilter\n    {\n        private readonly string _permissionCode;\n\n        public HasPermissionAttribute(string permissionCode) => _permissionCode = permissionCode;\n\n        public async Task OnAuthorizationAsync(AuthorizationFilterContext context)\n        {\n            var user = context.HttpContext.User;\n            var planIdClaim = user.FindFirst(\"plan_id\")?.Value;\n\n            if (string.IsNullOrWhiteSpace(planIdClaim) || !Guid.TryParse(planIdClaim, out var planId))\n            {\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            var permissionService = context.HttpContext.RequestServices\n                .GetRequiredService<IPermissionCacheService>();\n\n            var permissions = await permissionService.GetPlanPermissionsAsync(planId);\n\n            var hasPermission = permissions.Any(p =>\n                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));\n\n            if (!hasPermission)\n                context.Result = new ForbidResult();\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.AspNetCore.Mvc.Filters;\n//using Microsoft.Extensions.DependencyInjection;\n//using System;\n//using System.Linq;\n//using xbytechat.api.Features.AccessControl.Services;\n\n//namespace xbytechat.api.Features.AccessControl.Attributes\n//{\n//    public class HasPermissionAttribute : Attribute, IAuthorizationFilter\n//    {\n//        private readonly string _permissionCode;\n\n//        public HasPermissionAttribute(string permissionCode)\n//        {\n//            _permissionCode = permissionCode;\n//        }\n\n//        public void OnAuthorization(AuthorizationFilterContext context)\n//        {\n//            var user = context.HttpContext.User;\n//            var planIdClaim = user.FindFirst(\"plan_id\")?.Value;\n\n//            if (string.IsNullOrEmpty(planIdClaim))\n//            {\n//                context.Result = new ForbidResult();\n//                return;\n//            }\n\n//            if (!Guid.TryParse(planIdClaim, out var planId))\n//            {\n//                context.Result = new ForbidResult();\n//                return;\n//            }\n\n//            var permissionService = context.HttpContext.RequestServices\n//                .GetRequiredService<IPermissionCacheService>();\n\n//            // Get permissions for this plan from cache\n//            var permissions = permissionService.GetPlanPermissionsAsync(planId).Result;\n\n//            // Check if any permission matches the requested code\n//            bool hasPermission = permissions.Any(p =>\n//                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));\n\n//            if (!hasPermission)\n//            {\n//                context.Result = new ForbidResult();\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PermissionController.cs",
      "sha256": "f3ef162fea0e7bd86c0bf3b538aad49c8e9e7af7213b4b00adac8b994e3e103f",
      "language": "csharp",
      "size": 3705,
      "content": "// üìÑ Features/AccessControl/Controllers/PermissionController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [ApiController]\n    [Route(\"api/permission\")]\n    [Authorize]\n    public class PermissionController : ControllerBase\n    {\n        private readonly IPermissionService _permissionService;\n\n        public PermissionController(IPermissionService permissionService)\n        {\n            _permissionService = permissionService;\n        }\n\n        // --- Existing grouped endpoint (kept for compatibility) ---\n        // GET /api/permission/grouped\n        [HttpGet(\"grouped\")]\n        public async Task<IActionResult> GetGroupedPermissions(CancellationToken ct)\n        {\n            var grouped = await _permissionService.GetGroupedPermissionsAsync();\n            return Ok(ResponseResult.SuccessInfo(\"Permissions grouped by category\", grouped));\n        }\n\n        // --- New CRUD endpoints used by PermissionsPage ---\n\n        // GET /api/permission\n        [HttpGet]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<IEnumerable<PermissionSummaryDto>>> GetAll(\n            CancellationToken ct)\n        {\n            var list = await _permissionService.GetAllAsync(ct);\n            return Ok(list); // React expects a plain array\n        }\n\n        // POST /api/permission\n        [HttpPost]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<PermissionSummaryDto>> Create(\n            [FromBody] PermissionUpsertDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var created = await _permissionService.CreateAsync(dto, ct);\n                return Ok(created);\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n        }\n\n        // PUT /api/permission/{id}\n        [HttpPut(\"{id:guid}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<ActionResult<PermissionSummaryDto>> Update(\n            Guid id,\n            [FromBody] PermissionUpsertDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return BadRequest(ModelState);\n            }\n\n            try\n            {\n                var updated = await _permissionService.UpdateAsync(id, dto, ct);\n                return Ok(updated);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n            catch (InvalidOperationException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n        }\n\n        // DELETE /api/permission/{id}  (soft delete)\n        [HttpDelete(\"{id:guid}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> Deactivate(\n            Guid id,\n            CancellationToken ct)\n        {\n            try\n            {\n                await _permissionService.DeactivateAsync(id, ct);\n                return NoContent();\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PlanController.cs",
      "sha256": "44b6dcfde1ac688e832cff42dabd6d3c41711e52f5e0e78cedefbd3dc43ac06a",
      "language": "csharp",
      "size": 7262,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers; // ‚úÖ For ResponseResult\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    [Authorize]\n    public class PlanController : ControllerBase\n    {\n        private readonly IPlanService _planService;\n        private readonly IPermissionCacheService _permissionCacheService;\n        private readonly ILogger<PlanController> _logger;\n        public PlanController(IPlanService planService, IPermissionCacheService permissionCacheService, ILogger<PlanController> logger)\n        {\n            _planService = planService;\n            _permissionCacheService = permissionCacheService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetPlans()\n        {\n            try\n            {\n                var plans = await _planService.GetAllPlansAsync();\n                return Ok(plans); // Return plain array\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load plans\");\n                return BadRequest(new { message = \"Failed to load plans\", error = ex.Message });\n            }\n        }\n\n        [HttpGet(\"{planId}/permissions\")]\n        public async Task<IActionResult> GetPlanPermissions(Guid planId)\n        {\n            try\n            {\n               // var permissions = await _planService.GetPermissionsForPlanAsync(planId);\n                var permissions = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n\n                return Ok(permissions);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load permissions for plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to load permissions\", error = ex.Message });\n            }\n        }\n\n     \n        [HttpPost(\"Create\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> CreatePlan([FromBody] CreatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var newPlanId = await _planService.CreatePlanAsync(dto);\n                return Ok(new { id = newPlanId, message = \"Plan created successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to create plan {PlanName}\", dto.Name);\n                return BadRequest(new { message = \"Failed to create plan\", error = ex.Message });\n            }\n        }\n\n        [HttpPut(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlan(Guid planId, [FromBody] UpdatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var updated = await _planService.UpdatePlanAsync(planId, dto);\n                if (!updated)\n                    return NotFound(new { message = \"Plan not found\" });\n\n                return Ok(new { message = \"Plan updated successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to update plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to update plan\", error = ex.Message });\n            }\n        }\n\n        [HttpDelete(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> DeletePlan(Guid planId)\n        {\n            try\n            {\n                var deleted = await _planService.DeletePlanAsync(planId);\n                if (!deleted)\n                    return NotFound(new { message = \"Plan not found or already inactive\" });\n                // ‚úÖ Clear cache when plan is deleted\n                _permissionCacheService.ClearPlanPermissionsCache(planId);\n                return Ok(new { message = \"Plan deleted successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to delete plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to delete plan\", error = ex.Message });\n            }\n        }\n      \n        [HttpGet(\"me/permissions\")]\n        public async Task<IActionResult> GetMyPlanPermissions(CancellationToken ct)\n        {\n            var role = User.FindFirst(\"role\")?.Value ?? string.Empty;\n\n            // Admin-like roles don't need a plan\n            if (role is \"superadmin\" or \"admin\" or \"partner\" or \"reseller\")\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = new[] { \"*\" }\n                });\n\n            var planIdStr = User.FindFirst(\"plan_id\")?.Value;\n            if (!Guid.TryParse(planIdStr, out var planId))\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = Array.Empty<string>()\n                });\n\n            // permissions (cached)\n            var permissionEntities = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n            var codes = permissionEntities\n                .Where(p => p.IsActive)\n                .Select(p => p.Code)\n                .Distinct()\n                .ToList();\n\n            // ‚úÖ Fetch the plan once and return it as PlanDto\n            var planDto = await _planService.GetByIdAsync(planId, ct);\n\n            return Ok(new\n            {\n                planId,\n                plan = planDto,     // PlanDto or null\n                permissions = codes\n            });\n        }\n\n        // üìÑ Features/AccessControl/Controllers/PlanController.cs\n        [HttpPut(\"{planId:guid}/permissions\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlanPermissions(\n            Guid planId,\n            [FromBody] UpdatePlanPermissionsRequest body,\n            CancellationToken ct)\n        {\n            var actor = User?.Identity?.Name ?? \"system\";\n            await _planService.UpdatePlanPermissionsAsync(\n                planId,\n                body.PermissionIds,     // must be named PermissionIds\n                body.ReplaceAll,        // default true\n                actor,\n                ct);\n\n            return NoContent(); // 204\n        }\n\n        // üìÑ Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs\n        public sealed class UpdatePlanPermissionsRequest\n        {\n            public List<Guid> PermissionIds { get; set; } = new();\n            public bool ReplaceAll { get; set; } = true;\n        }\n\n\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/UserPermissionsController.cs",
      "sha256": "950672bd933736c854e3a9e88b13449a6458b03a05c906c78e9c5916d8c48787",
      "language": "csharp",
      "size": 7589,
      "content": "#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    /// <summary>\n    /// Manage per-user permission overrides.\n    ///\n    /// Important:\n    /// - We do NOT calculate effective permissions here.\n    ///   Plan ‚Üí permissions is handled by Plan/AccessControl services.\n    /// - This controller only manages rows in UserPermission (allow/deny overrides).\n    ///   The UI can merge:\n    ///     a) plan permissions  + \n    ///     b) these overrides\n    ///   to show the final state for each feature.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/admin/users/{userId:guid}/permissions\")]\n    [Authorize(Roles = \"admin\")]\n    public sealed class UserPermissionsController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n\n        public UserPermissionsController(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // --------- DTOs (you can later move them to Features/AccessControl/DTOs) ---------\n\n        public sealed class UserPermissionOverrideDto\n        {\n            public Guid PermissionId { get; set; }\n            public string Code { get; set; } = string.Empty;\n            public string Name { get; set; } = string.Empty;\n\n            /// <summary>\n            /// true  = explicit allow\n            /// false = explicit deny\n            /// </summary>\n            public bool IsGranted { get; set; }\n\n            /// <summary>\n            /// true  = override is logically removed (soft delete)\n            /// false = active override\n            /// </summary>\n            public bool IsRevoked { get; set; }\n\n            public DateTime AssignedAt { get; set; }\n            public string? AssignedBy { get; set; }\n        }\n\n        public sealed class UpsertUserPermissionRequest\n        {\n            public Guid PermissionId { get; set; }\n\n            /// <summary>\n            /// true  = allow\n            /// false = deny\n            /// </summary>\n            public bool IsGranted { get; set; }\n        }\n\n        // ---------------- GET: list overrides for a user ----------------\n\n        /// <summary>\n        /// Returns all active overrides for the given user.\n        /// The UI should combine this with plan permissions to show final state.\n        /// </summary>\n        [HttpGet]\n        public async Task<ActionResult<List<UserPermissionOverrideDto>>> GetOverridesForUser(\n            Guid userId,\n            CancellationToken ct)\n        {\n            // Ensure the user exists (optional but nice for admin UX)\n            var userExists = await _db.Set<User>()\n                .AnyAsync(u => u.Id == userId, ct);\n\n            if (!userExists)\n            {\n                return NotFound($\"User {userId} not found.\");\n            }\n\n            var overrides = await _db.Set<UserPermission>()\n                .AsNoTracking()\n                .Where(up => up.UserId == userId && !up.IsRevoked)\n                .Include(up => up.Permission)\n                .OrderBy(up => up.Permission.Code)\n                .Select(up => new UserPermissionOverrideDto\n                {\n                    PermissionId = up.PermissionId,\n                    Code = up.Permission.Code,\n                    Name = up.Permission.Name,\n                    IsGranted = up.IsGranted,\n                    IsRevoked = up.IsRevoked,\n                    AssignedAt = up.AssignedAt,\n                    AssignedBy = up.AssignedBy\n                })\n                .ToListAsync(ct);\n\n            return overrides;\n        }\n\n        // ---------------- POST: create/update override ----------------\n\n        /// <summary>\n        /// Create or update an override for the given user & permission.\n        /// If row exists, we update IsGranted and clear IsRevoked.\n        /// </summary>\n        [HttpPost]\n        public async Task<ActionResult<UserPermissionOverrideDto>> UpsertOverride(\n            Guid userId,\n            [FromBody] UpsertUserPermissionRequest request,\n            CancellationToken ct)\n        {\n            if (request.PermissionId == Guid.Empty)\n            {\n                return BadRequest(\"PermissionId is required.\");\n            }\n\n            var user = await _db.Set<User>()\n                .FirstOrDefaultAsync(u => u.Id == userId, ct);\n\n            if (user is null)\n            {\n                return NotFound($\"User {userId} not found.\");\n            }\n\n            var permission = await _db.Set<Permission>()\n                .FirstOrDefaultAsync(p => p.Id == request.PermissionId, ct);\n\n            if (permission is null)\n            {\n                return NotFound($\"Permission {request.PermissionId} not found.\");\n            }\n\n            var existing = await _db.Set<UserPermission>()\n                .FirstOrDefaultAsync(\n                    up => up.UserId == userId && up.PermissionId == request.PermissionId,\n                    ct);\n\n            if (existing is null)\n            {\n                existing = new UserPermission\n                {\n                    Id = Guid.NewGuid(),\n                    UserId = userId,\n                    PermissionId = request.PermissionId,\n                    IsGranted = request.IsGranted,\n                    IsRevoked = false,\n                    AssignedAt = DateTime.UtcNow,\n                    AssignedBy = User?.Identity?.Name ?? \"system\"\n                };\n\n                await _db.Set<UserPermission>().AddAsync(existing, ct);\n            }\n            else\n            {\n                existing.IsGranted = request.IsGranted;\n                existing.IsRevoked = false;\n                existing.AssignedAt = DateTime.UtcNow;\n                existing.AssignedBy = User?.Identity?.Name ?? existing.AssignedBy;\n            }\n\n            await _db.SaveChangesAsync(ct);\n\n            var dto = new UserPermissionOverrideDto\n            {\n                PermissionId = existing.PermissionId,\n                Code = permission.Code,\n                Name = permission.Name,\n                IsGranted = existing.IsGranted,\n                IsRevoked = existing.IsRevoked,\n                AssignedAt = existing.AssignedAt,\n                AssignedBy = existing.AssignedBy\n            };\n\n            return Ok(dto);\n        }\n\n        // ---------------- DELETE: soft-remove override ----------------\n\n        /// <summary>\n        /// Soft deletes an override by setting IsRevoked = true.\n        /// Effective permission will fall back to plan-level mapping.\n        /// </summary>\n        [HttpDelete(\"{permissionId:guid}\")]\n        public async Task<IActionResult> DeleteOverride(\n            Guid userId,\n            Guid permissionId,\n            CancellationToken ct)\n        {\n            var overrideRow = await _db.Set<UserPermission>()\n                .FirstOrDefaultAsync(\n                    up => up.UserId == userId && up.PermissionId == permissionId,\n                    ct);\n\n            if (overrideRow is null)\n            {\n                return NotFound();\n            }\n\n            overrideRow.IsRevoked = true;\n            // Optional: also reset grant flag ‚Äì your entitlement logic can ignore revoked rows anyway\n            // overrideRow.IsGranted = false;\n\n            await _db.SaveChangesAsync(ct);\n            return NoContent();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/CreatePlanDto.cs",
      "sha256": "15d5b4b092dc0019db6a3e33fc6ea49a5bd2e02c9c4fabde02403dc9c32feb90",
      "language": "csharp",
      "size": 320,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class CreatePlanDto\n    {\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\"\n        public string Name { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/GroupedPermissionDto.cs",
      "sha256": "d31e43145b8ed5908bd705af1dc96740d163615a183c30dc69b6d72097d37a76",
      "language": "csharp",
      "size": 255,
      "content": "using xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class GroupedPermissionDto\n    {\n        public string Group { get; set; }\n        public List<Permission> Features { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionDto.cs",
      "sha256": "46bfdeaa2a7dfa7bdaa56ed6c991868bae5fcc8ffb88cff1cc82d329e51eb92f",
      "language": "csharp",
      "size": 353,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PermissionDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionSummaryDto.cs",
      "sha256": "2ace6d04b01d7f967838d51fe0d7e0e0650479e1663c18f2559ca8246adf3e55",
      "language": "csharp",
      "size": 607,
      "content": "// üìÑ Features/AccessControl/DTOs/PermissionSummaryDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    /// <summary>\n    /// Flat DTO used by the Permissions admin grid.\n    /// </summary>\n    public sealed class PermissionSummaryDto\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } = default!;\n        public string Name { get; set; } = default!;\n\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionUpsertDto.cs",
      "sha256": "bc57fdb6495dbd689898b10e6b6afe9a7fc02feca1e3453f8a10250f48651a02",
      "language": "csharp",
      "size": 797,
      "content": "// üìÑ Features/AccessControl/DTOs/PermissionUpsertDto.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    /// <summary>\n    /// Payload for creating or updating a Permission.\n    /// Code is immutable once created (UI disables it for edit).\n    /// </summary>\n    public sealed class PermissionUpsertDto\n    {\n        [Required]\n        [MaxLength(200)]\n        public string Code { get; set; } = default!; // e.g. \"MESSAGING.SEND.TEXT\"\n\n        [Required]\n        [MaxLength(200)]\n        public string Name { get; set; } = default!; // friendly label\n\n        [MaxLength(200)]\n        public string? Group { get; set; } // \"Messaging\", \"Campaigns\", etc.\n\n        [MaxLength(1000)]\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PlanDto.cs",
      "sha256": "87bcc89fbc963d131fcc246a1bde5d2d1a9198a61fac73a55b6b985644c8ee89",
      "language": "csharp",
      "size": 303,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PlanDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/RoleDto.cs",
      "sha256": "890bec8d90e7068a2c8e49c4249b761506cdb9c26b2fd5a470bf14c6013954cf",
      "language": "csharp",
      "size": 479,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs;\n\n// DTO: Role details used across layers\npublic class RoleDto\n{\n    /// <summary>Unique identifier of the role.</summary>\n    public Guid Id { get; set; }\n\n   \n    public string Role { get; set; } = default!;\n\n   \n    public string Code { get; set; } = default!;\n\n   \n    public string? Description { get; set; }\n\n    \n    public bool IsActive { get; set; }\n\n       public RoleDto() { }\n\n    // Convenience constructor\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanDto.cs",
      "sha256": "e4a09d8fd1c1ff0cb720be4ff2ba80df60e06fc54795e1e2a23fd06b16bf8956",
      "language": "csharp",
      "size": 273,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanDto\n    {\n        public string Name { get; set; }\n        public string Code { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs",
      "sha256": "fb7246c045dc67de4e1841a2e77749da563069e5e02ebe856df70f4bb28e9c42",
      "language": "csharp",
      "size": 269,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanPermissionsRequest\n    {\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true; // optional flag your controller reads\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateRolePermissionsDto.cs",
      "sha256": "e00530db11a422793d96b8905211218a03a8e810c601034c76b75fbba37d40db",
      "language": "csharp",
      "size": 291,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdateRolePermissionsDto\n    {\n        [Required]\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateUserPermissionsDto.cs",
      "sha256": "aea509c8f87c9fda5473534a5c9926fd3af7d09a1041c2832071d1aa5ba60b31",
      "language": "csharp",
      "size": 416,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UpdateUserPermissionsDto\n    {\n        /// <summary>\n        /// List of Permission.Code values that should be enabled for this user.\n        /// Anything not in this list will be removed.\n        /// </summary>\n        public List<string> PermissionCodes { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpsertPermissionRequest.cs",
      "sha256": "f925b63f73851fa7462e56c3f9b53a56476af6cb976cbe35d813efd03db7889b",
      "language": "csharp",
      "size": 633,
      "content": "// üìÅ Features/AccessControl/DTOs/UpsertPermissionRequest.cs\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpsertPermissionRequest\n    {\n        // Code is required only on create. On update, we ignore it.\n        public string Code { get; set; } = string.Empty;\n\n        public string Name { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Logical group/module/workspace, e.g. \"Messaging\", \"Campaigns\", \"CRM\".\n        /// This maps to Permission.Group in the model.\n        /// </summary>\n        public string? Group { get; set; }\n\n        public string? Description { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UserPermissions.cs",
      "sha256": "2f1985d1584fedd86c23fe360a05781bd5ab974fe2833c7ba1222e55c531ee6e",
      "language": "csharp",
      "size": 340,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UserPermissionItemDto\n    {\n        public string PermissionCode { get; set; } = default!;\n        public string Name { get; set; } = default!;\n        public string? Description { get; set; }\n        public bool IsAssigned { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UserPermissionSummaryDto.cs",
      "sha256": "9d6539a51791e64bf141f4f8aea394a0befa161294ac9a6e2c794fdbdde78b60",
      "language": "csharp",
      "size": 440,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions\n{\n    public sealed class UserPermissionSummaryDto\n    {\n        public Guid UserId { get; set; }\n        public string UserEmail { get; set; } = default!;\n        public Guid BusinessId { get; set; }\n        public Guid PlanId { get; set; }\n\n        public List<UserPermissionItemDto> Items { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/MakeDump.bat",
      "sha256": "1f0c8a79e7859146dab81f8a13dcdf495c12b54b888024e8500fefb4abd58a9e",
      "language": "bat",
      "size": 1618,
      "content": "@echo off\nREM This script will find relevant source files and output their names and contents into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh and write a small header\n> \"%outputFile%\" (\n    echo Folder and File Content Report\n    echo Root folder: %cd%\n    echo Generated at: %date% %time%\n)\necho. >> \"%outputFile%\"\n\nREM NOTE:\nREM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)\nREM This keeps the file smaller and much easier to review.\n\nREM Loop through all relevant files in the current directory and subdirectories\nREM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML\nfor /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (\n\n    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)\n    echo \"%%F\" | findstr /I /C:\"\\node_modules\\\" /C:\"\\bin\\\" /C:\"\\obj\\\" /C:\"\\.git\\\" /C:\"\\dist\\\" /C:\"\\.vs\\\" >nul\n    if errorlevel 1 (\n        echo ====================================================== >> \"%outputFile%\"\n        echo FILE: %%F >> \"%outputFile%\"\n        echo ====================================================== >> \"%outputFile%\"\n        echo. >> \"%outputFile%\"\n        type \"%%F\" >> \"%outputFile%\" 2>nul\n        echo. >> \"%outputFile%\"\n        echo. >> \"%outputFile%\"\n    )\n)\n\necho Finished! All content has been extracted to %outputFile%\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Permission.cs",
      "sha256": "22c58f1f832014c6129b075f027045a186874bc7c20d0f312befe1d658bb0ab4",
      "language": "csharp",
      "size": 832,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Permission\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // Unique key like \"ViewDashboard\"\n\n        public string Name { get; set; } // Friendly name like \"View Dashboard\"\n\n        public string? Group { get; set; } // Optional grouping, e.g., \"CRM\", \"Catalog\", \"Admin\"\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n\n        public ICollection<UserPermission> UserPermissions { get; set; }\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Plan.cs",
      "sha256": "9f3414b6a49c2c27b0784e659367f5f64258b19e19195a52a4248936020542be",
      "language": "csharp",
      "size": 758,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Plan\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\", \"ADVANCED\"\n        public string Name { get; set; } // Friendly display name\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsInternal { get; set; } = false;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n        public ICollection<Business> Businesses { get; set; } = new List<Business>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/PlanPermission.cs",
      "sha256": "e6e65f0ae33c19e9d2585d73812bcf99ed207d52ac6d804a3c2bf86b3152eca7",
      "language": "csharp",
      "size": 525,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class PlanPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n        public Plan Plan { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin email or ID\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Role.cs",
      "sha256": "4c2e237e65d702febee355976cfc64209fd4cf2d98f87e7ef6de4b199dd048a4",
      "language": "csharp",
      "size": 760,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Role\n    {\n        public Guid Id { get; set; }\n\n        public string Name { get; set; } // e.g. SuperAdmin, PartnerAdmin, BusinessAdmin, Staff, etc.\n\n        public string? Description { get; set; }\n\n        public bool IsSystemDefined { get; set; } = false; // true for SuperAdmin, PartnerAdmin\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n        public ICollection<User> Users { get; set; } // üß© One-to-many relation: Role ‚Üí Users\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/RolePermission.cs",
      "sha256": "d9b31669bec3fbda1b95c89def9a6cc641e0dd21f5e38583b8dae4c0239b9a8a",
      "language": "csharp",
      "size": 619,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class RolePermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid RoleId { get; set; }\n        public Role Role { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin user email or ID\n\n        public bool IsActive { get; set; } = true; // ‚úÖ Add this line\n        public bool IsRevoked { get; set; } = false; // ‚úÖ Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/UserPermission.cs",
      "sha256": "6b85321ec68fced21477222e85ac56594106c4654b5d99061c42bc1c46d876aa",
      "language": "csharp",
      "size": 677,
      "content": "using System;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class UserPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid UserId { get; set; }\n        public User User { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsGranted { get; set; } = true; // ‚úÖ true = allow, false = explicitly deny\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin or system\n\n        public bool IsRevoked { get; set; } = false; // ‚úÖ Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/PermissionConstants.cs",
      "sha256": "47104d91bf08a96917121e247b83aac03fe402f24bb851d3fa4b1b9ee5375469",
      "language": "csharp",
      "size": 1126,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class PermissionConstants\n    {\n        public static class Dashboard\n        {\n            public const string View = \"dashboard.view\";\n        }\n\n        public static class Campaigns\n        {\n            public const string View = \"campaign.view\";\n            public const string Create = \"campaign.create\";\n            public const string Delete = \"campaign.delete\";\n        }\n\n        public static class Products\n        {\n            public const string View = \"product.view\";\n            public const string Create = \"product.create\";\n            public const string Delete = \"product.delete\";\n        }\n\n        public static class CRM\n        {\n            public const string ContactsView = \"contacts.view\";\n            public const string TagsEdit = \"tags.edit\";\n        }\n\n        public static class Admin\n        {\n            public const string BusinessApprove = \"admin.business.approve\";\n            public const string ViewLogs = \"admin.logs.view\";\n        }\n\n        // üÜï Add more modules and permissions here as needed\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/RolePermissionMapping.cs",
      "sha256": "47f001a1b2d6404c28e73be68faf79485c10c1c0a7dab0a5346cc06fff4f049a",
      "language": "csharp",
      "size": 1302,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class RolePermissionMapping\n    {\n        public static readonly Dictionary<string, List<string>> RolePermissions = new()\n        {\n            [\"admin\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.Campaigns.Create,\n                PermissionConstants.Campaigns.Delete,\n                PermissionConstants.Products.View,\n                PermissionConstants.Products.Create,\n                PermissionConstants.Products.Delete,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.CRM.TagsEdit,\n                PermissionConstants.Admin.BusinessApprove,\n                PermissionConstants.Admin.ViewLogs\n            },\n\n            [\"business\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.Products.View\n            },\n\n            [\"staff\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.CRM.ContactsView\n            }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/AccessControlService.cs",
      "sha256": "7715aa1fb932cf63407c3a5e5502b6c3f751e331055be04257cfd120a8671fcb",
      "language": "csharp",
      "size": 7685,
      "content": "//using Microsoft.EntityFrameworkCore;\n//using System.Collections.Generic;\n//using System.Security.Claims;\n//using System.Threading.Tasks;\n\n//using xbytechat.api.Features.AccessControl.Models;\n\n//namespace xbytechat.api.Features.AccessControl.Services\n//{\n//    public class AccessControlService : IAccessControlService\n//    {\n//        private readonly AppDbContext _context;\n\n//        public AccessControlService(AppDbContext context)\n//        {\n//            _context = context;\n//        }\n\n//        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()\n//        {\n//            return await _context.Permissions\n//                .AsNoTracking()\n//                .Where(p => p.IsActive)\n//                .ToListAsync();\n//        }\n//        //public async Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId)\n//        //{\n//        //    // First, check if the user has direct permissions\n//        //    var userPermissions = await _context.UserPermissions\n//        //        .Where(up => up.UserId == userId && up.IsGranted && !up.IsRevoked)\n//        //        .Select(up => up.Permission)\n//        //        .Where(p => p.IsActive)\n//        //        .ToListAsync();\n\n//        //    // If no direct permissions, fall back to role permissions\n//        //    if (!userPermissions.Any())\n//        //    {\n//        //        userPermissions = await _context.RolePermissions\n//        //            .Where(rp => rp.Role.Users.Any(u => u.Id == userId) && rp.IsActive && !rp.IsRevoked)\n//        //            .Select(rp => rp.Permission)\n//        //            .Where(p => p.IsActive)\n//        //            .ToListAsync();\n//        //    }\n\n//        //    return userPermissions;\n//        //}\n       \n        \n       \n//    }\n//}\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Repositories.Interfaces;\nusing System.Linq.Expressions;\n\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class AccessControlService : IAccessControlService\n    {\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IGenericRepository<RolePermission> _rolePermissionRepo;\n        private readonly IGenericRepository<UserPermission> _userPermissionRepo;\n        private readonly IGenericRepository<Permission> _permissionRepo;\n        private readonly AppDbContext _context;\n        public AccessControlService(\n            IGenericRepository<User> userRepo,\n            IGenericRepository<RolePermission> rolePermissionRepo,\n            IGenericRepository<UserPermission> userPermissionRepo,\n            IGenericRepository<Permission> permissionRepo, AppDbContext context\n        )\n        {\n            _userRepo = userRepo;\n            _rolePermissionRepo = rolePermissionRepo;\n            _userPermissionRepo = userPermissionRepo;\n            _permissionRepo = permissionRepo;\n            _context = context;\n        }\n\n        /// <summary>\n        /// ‚úÖ Fetch all permissions (Role-based + User-specific) for a given user\n        /// </summary>\n        //public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        //{\n        //    var user = await _userRepo.FindByIdAsync(userId);\n        //    if (user == null || user.RoleId == null)\n        //        return new List<string>();\n\n        //    // üîê Get Role-based permissions\n        //    var rolePerms = await _rolePermissionRepo\n        //        .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n        //    // üîê Get User-specific extra permissions\n        //    var userPerms = await _userPermissionRepo\n        //        .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n        //    // üß† Merge permission IDs\n        //    var permissionIds = rolePerms.Select(r => r.PermissionId)\n        //        .Union(userPerms.Select(u => u.PermissionId))\n        //        .Distinct()\n        //        .ToList();\n\n        //    // üéØ Get full permission names from Permission table\n        //    var allPerms = await _permissionRepo\n        //        .WhereAsync(p => permissionIds.Contains(p.Id));\n\n        //    return allPerms.Select(p => p.Code).Distinct().ToList(); // Use Code (standard)\n        //}\n\n        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()\n        {\n            return await _permissionRepo.WhereAsync(p => p.IsActive);\n        }\n\n\n        public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        {\n            var user = await _userRepo.FindByIdAsync(userId);\n\n            if (user == null || user.RoleId == null)\n                return new List<string>();\n\n            // üöÄ Bypass: SuperAdmin always gets full access\n            if (user.Role != null && user.Role.Name.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase))\n            {\n                var allPerms = await _permissionRepo.GetAllAsync();\n                return allPerms.Select(p => p.Code).Distinct().ToList();\n            }\n\n            // üîê Get Role-based permissions\n            var rolePerms = await _rolePermissionRepo\n                .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n            // üîê Get User-specific extra permissions\n            var userPerms = await _userPermissionRepo\n                .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n            // üß† Merge permission IDs\n            var permissionIds = rolePerms.Select(r => r.PermissionId)\n                .Union(userPerms.Select(u => u.PermissionId))\n                .Distinct()\n                .ToList();\n\n            // üéØ Get full permission names from Permission table\n            var allAllowedPerms = await _permissionRepo\n                .WhereAsync(p => permissionIds.Contains(p.Id));\n\n            return allAllowedPerms.Select(p => p.Code).Distinct().ToList();\n        }\n\n        public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        {\n            // üöÄ Bypass: SuperAdmin always passes\n            //var roleClaim = user.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Role)?.Value;\n            var roleClaim = user.Claims.FirstOrDefault(c =>\n                c.Type == ClaimTypes.Role || c.Type.Equals(\"role\", StringComparison.OrdinalIgnoreCase)\n            )?.Value;\n\n            if (!string.IsNullOrEmpty(roleClaim) && roleClaim.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase))\n                return true;\n\n            var perms = user.Claims\n                .Where(c => c.Type == \"permissions\")\n                .Select(c => c.Value)\n                .ToList();\n\n            return perms.Contains(requiredPermission);\n        }\n\n        /// <summary>\n        /// ‚úÖ Runtime permission checker (for controller/middleware)\n        /// </summary>\n        //public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        //{\n        //    var perms = user.Claims\n        //        .Where(c => c.Type == \"permissions\")\n        //        .Select(c => c.Value)\n        //        .ToList();\n\n        //    return perms.Contains(requiredPermission);\n        //}\n\n        public async Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId)\n        {\n            if (!planId.HasValue)\n                return new List<string>();\n\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId.Value && pp.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync();\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IAccessControlService.cs",
      "sha256": "a7175ca2ec5d8ac4aae9b09095d675ab36d2c52dd6a62b3d23c6b6990de055e2",
      "language": "csharp",
      "size": 853,
      "content": "//using System.Collections.Generic;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.AccessControl.Models;\n\n//namespace xbytechat.api.Features.AccessControl.Services\n//{\n//    public interface IAccessControlService\n//    {\n//        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n//        Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId);\n\n//    }\n//}\n\n\nusing System.Security.Claims;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IAccessControlService\n    {\n        Task<List<string>> GetPermissionsAsync(Guid userId);\n        bool HasPermission(ClaimsPrincipal user, string permission);\n        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n        Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPermissionService.cs.cs",
      "sha256": "9b90beeeaaf8c3d5077265251342d6ae3cf51e442106d302d2a143b7b00ae417",
      "language": "csharp",
      "size": 1071,
      "content": "// üìÑ Features/AccessControl/Services/IPermissionService.cs.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionService\n    {\n        // Existing grouped view (used by older UI / internal tools)\n        Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync();\n\n        // New flat CRUD endpoints\n        Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(\n            CancellationToken ct = default);\n\n        Task<PermissionSummaryDto> CreateAsync(\n            PermissionUpsertDto dto,\n            CancellationToken ct = default);\n\n        Task<PermissionSummaryDto> UpdateAsync(\n            Guid id,\n            PermissionUpsertDto dto,\n            CancellationToken ct = default);\n\n        /// <summary>\n        /// Soft-delete / deactivate a permission.\n        /// </summary>\n        Task DeactivateAsync(Guid id, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPlanService.cs",
      "sha256": "52ab5621692cbe324646331e6ac2ee6a1c4b4fe9fdfc5b75e602322a29263f19",
      "language": "csharp",
      "size": 1128,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPlanService\n    {\n        Task<IEnumerable<PlanDto>> GetAllPlansAsync();\n        Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId);\n       // Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task<Guid> CreatePlanAsync(CreatePlanDto dto);\n        Task<bool> DeletePlanAsync(Guid planId);\n        Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto);\n\n        // New methods for permissions\n        Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId);\n        //Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task UpdatePlanPermissionsAsync(\n    Guid planId,\n    IReadOnlyCollection<Guid> permissionIds,\n    bool replaceAll,\n    string? assignedBy,\n    CancellationToken ct);\n        Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionCacheService.cs",
      "sha256": "c268071425295dc74c3f7323b4ebcbc3f413d9eaea473b6b55ada75cc0117ea9",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionCacheService\n    {\n        Task<List<Permission>> GetPlanPermissionsAsync(Guid planId);\n        void ClearPlanPermissionsCache(Guid planId);\n    }\n\n    public class PermissionCacheService : IPermissionCacheService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMemoryCache _cache;\n        private const string CacheKeyPrefix = \"plan_permissions_\";\n\n        public PermissionCacheService(AppDbContext context, IMemoryCache cache)\n        {\n            _context = context;\n            _cache = cache;\n        }\n\n        public async Task<List<Permission>> GetPlanPermissionsAsync(Guid planId)\n        {\n            var cacheKey = $\"{CacheKeyPrefix}{planId}\";\n\n            // Try to get from cache\n            if (_cache.TryGetValue(cacheKey, out List<Permission> cachedPermissions))\n                return cachedPermissions;\n\n            // Fetch from DB\n            var permissions = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => pp.Permission)\n                .ToListAsync();\n\n            // Store in cache\n            _cache.Set(cacheKey, permissions, TimeSpan.FromHours(1));\n\n            return permissions;\n        }\n\n        public void ClearPlanPermissionsCache(Guid planId)\n        {\n            _cache.Remove($\"{CacheKeyPrefix}{planId}\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionService.cs",
      "sha256": "ae835be421a784aa982c1f38056103da2edb440cc7794714ff48ac0c3dfaa0fa",
      "language": "csharp",
      "size": 5344,
      "content": "// üìÑ Features/AccessControl/Services/PermissionService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PermissionService : IPermissionService\n    {\n        private readonly AppDbContext _context;\n\n        public PermissionService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync()\n        {\n            // Legacy / grouped view (kept for compatibility)\n            return await _context.Permissions\n                .Where(p => p.IsActive)\n                .GroupBy(p => p.Group ?? \"Ungrouped\")\n                .Select(g => new GroupedPermissionDto\n                {\n                    Group = g.Key,\n                    Features = g.ToList()\n                })\n                .ToListAsync();\n        }\n\n        public async Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(\n            CancellationToken ct = default)\n        {\n            return await _context.Permissions\n                .OrderBy(p => p.Group)\n                .ThenBy(p => p.Code)\n                .Select(p => new PermissionSummaryDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Group = p.Group,\n                    Description = p.Description,\n                    IsActive = p.IsActive,\n                    CreatedAt = p.CreatedAt\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<PermissionSummaryDto> CreateAsync(\n            PermissionUpsertDto dto,\n            CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var code = dto.Code?.Trim();\n            var name = dto.Name?.Trim();\n\n            if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(name))\n            {\n                throw new InvalidOperationException(\"Code and Name are required.\");\n            }\n\n            var normalizedCode = code.ToUpperInvariant();\n\n            var exists = await _context.Permissions\n                .AnyAsync(p => p.Code == normalizedCode, ct);\n\n            if (exists)\n            {\n                throw new InvalidOperationException(\n                    $\"Permission code '{normalizedCode}' already exists.\");\n            }\n\n            var permission = new Permission\n            {\n                Id = Guid.NewGuid(),\n                Code = normalizedCode,\n                Name = name,\n                Group = string.IsNullOrWhiteSpace(dto.Group)\n                    ? null\n                    : dto.Group!.Trim(),\n                Description = string.IsNullOrWhiteSpace(dto.Description)\n                    ? null\n                    : dto.Description!.Trim(),\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.Permissions.Add(permission);\n            await _context.SaveChangesAsync(ct);\n\n            return ToSummary(permission);\n        }\n\n        public async Task<PermissionSummaryDto> UpdateAsync(\n            Guid id,\n            PermissionUpsertDto dto,\n            CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n\n            var permission = await _context.Permissions\n                .FirstOrDefaultAsync(p => p.Id == id, ct);\n\n            if (permission == null)\n                throw new KeyNotFoundException(\"Permission not found.\");\n\n            var name = dto.Name?.Trim();\n            if (string.IsNullOrWhiteSpace(name))\n                throw new InvalidOperationException(\"Name is required.\");\n\n            // Code is intentionally immutable (UI keeps it disabled).\n            permission.Name = name;\n            permission.Group = string.IsNullOrWhiteSpace(dto.Group)\n                ? null\n                : dto.Group!.Trim();\n            permission.Description = string.IsNullOrWhiteSpace(dto.Description)\n                ? null\n                : dto.Description!.Trim();\n\n            await _context.SaveChangesAsync(ct);\n\n            return ToSummary(permission);\n        }\n\n        public async Task DeactivateAsync(Guid id, CancellationToken ct = default)\n        {\n            var permission = await _context.Permissions\n                .FirstOrDefaultAsync(p => p.Id == id, ct);\n\n            if (permission == null)\n                throw new KeyNotFoundException(\"Permission not found.\");\n\n            if (!permission.IsActive)\n                return;\n\n            permission.IsActive = false;\n            await _context.SaveChangesAsync(ct);\n        }\n\n        private static PermissionSummaryDto ToSummary(Permission p)\n        {\n            return new PermissionSummaryDto\n            {\n                Id = p.Id,\n                Code = p.Code,\n                Name = p.Name,\n                Group = p.Group,\n                Description = p.Description,\n                IsActive = p.IsActive,\n                CreatedAt = p.CreatedAt\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PlanService.cs",
      "sha256": "c4e23f3ca4fc67f7f1340294e9d4851943aa91acc14b4d402fe4116f1822a63c",
      "language": "csharp",
      "size": 11164,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PlanService : IPlanService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<PlanService> _logger;\n        private readonly IPermissionCacheService _permissionCacheService;\n\n        public PlanService(AppDbContext context, ILogger<PlanService> logger, IPermissionCacheService permissionCacheService)\n        {\n            _context = context;\n            _logger = logger;\n            _permissionCacheService = permissionCacheService;\n        }\n\n\n\n        public async Task<IEnumerable<PlanDto>> GetAllPlansAsync()\n        {\n            return await _context.Plans\n                .Where(p => p.IsActive)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description,\n                    IsActive = pp.Permission.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default)\n        {\n            return await _context.Plans\n                .AsNoTracking()\n                .Where(p => p.Id == planId)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .FirstOrDefaultAsync(ct);\n        }\n\n        //public async Task<IEnumerable<Permission>> GetPermissionsForPlanAsync(Guid planId)\n        //{\n        //    _logger.LogInformation(\"Fetching permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        return await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId && pp.IsActive)\n        //            .Include(pp => pp.Permission)\n        //            .Select(pp => pp.Permission)\n        //            .AsNoTracking()\n        //            .ToListAsync();\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error fetching permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    _logger.LogInformation(\"Updating permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        // Remove all existing permissions for the plan\n        //        var existing = await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId)\n        //            .ToListAsync();\n\n        //        _context.PlanPermissions.RemoveRange(existing);\n\n        //        // Add new permissions\n        //        var newPlanPermissions = permissionIds.Select(pid => new PlanPermission\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            PlanId = planId,\n        //            PermissionId = pid,\n        //            IsActive = true,\n        //            AssignedAt = DateTime.UtcNow,\n        //            AssignedBy = \"System\"\n        //        });\n\n        //        await _context.PlanPermissions.AddRangeAsync(newPlanPermissions);\n        //        await _context.SaveChangesAsync();\n        //        _logger.LogInformation(\"Permissions updated for plan {PlanId}\", planId);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error updating permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        public async Task<Guid> CreatePlanAsync(CreatePlanDto dto)\n        {\n            _logger.LogInformation(\"Creating new plan: {PlanName}\", dto.Name);\n            try\n            {\n                var plan = new Plan\n                {\n                    Id = Guid.NewGuid(),\n                    Code = dto.Code,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    IsActive = dto.IsActive\n                };\n\n                _context.Plans.Add(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan created with ID: {PlanId}\", plan.Id);\n                return plan.Id;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error creating plan {PlanName}\", dto.Name);\n                throw;\n            }\n        }\n\n        public async Task<bool> DeletePlanAsync(Guid planId)\n        {\n            _logger.LogInformation(\"Deleting (soft) plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null || !plan.IsActive)\n                {\n                    _logger.LogWarning(\"Plan not found or already inactive: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.IsActive = false;\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} soft deleted.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto)\n        {\n            _logger.LogInformation(\"Updating plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null)\n                {\n                    _logger.LogWarning(\"Plan not found: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.Code = dto.Code;\n                plan.Name = dto.Name;\n                plan.Description = dto.Description;\n                plan.IsActive = dto.IsActive;\n\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} updated successfully.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task UpdatePlanPermissionsAsync(\n         Guid planId,\n         IReadOnlyCollection<Guid> permissionIds,\n         bool replaceAll,\n         string? assignedBy,\n         CancellationToken ct)\n        {\n            using var trx = await _context.Database.BeginTransactionAsync(ct);\n\n            var existing = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId)\n                .ToListAsync(ct);\n\n            var want = new HashSet<Guid>(permissionIds);\n            var byPerm = existing.ToDictionary(pp => pp.PermissionId);\n\n            // upsert requested permissions ‚Üí Active\n            foreach (var pid in want)\n            {\n                if (byPerm.TryGetValue(pid, out var row))\n                {\n                    if (!row.IsActive)\n                    {\n                        row.IsActive = true;\n                        row.AssignedAt = DateTime.UtcNow;\n                        row.AssignedBy = assignedBy;\n                        _context.PlanPermissions.Update(row);\n                    }\n                }\n                else\n                {\n                    _context.PlanPermissions.Add(new PlanPermission\n                    {\n                        Id = Guid.NewGuid(),\n                        PlanId = planId,\n                        PermissionId = pid,\n                        IsActive = true,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = assignedBy\n                    });\n                }\n            }\n\n            // replaceAll => deactivate anything not requested\n            if (replaceAll)\n            {\n                foreach (var row in existing)\n                {\n                    if (!want.Contains(row.PermissionId) && row.IsActive)\n                    {\n                        row.IsActive = false;\n                        _context.PlanPermissions.Update(row);\n                    }\n                }\n            }\n\n            await _context.SaveChangesAsync(ct);\n            await trx.CommitAsync(ct);\n\n            // Bust the plan permission cache\n            _permissionCacheService.ClearPlanPermissionsCache(planId);\n        }\n\n\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    // Remove old mappings\n        //    var existing = await _context.PlanPermissions\n        //        .Where(pp => pp.PlanId == planId)\n        //        .ToListAsync();\n        //    _context.PlanPermissions.RemoveRange(existing);\n\n        //    // Add new mappings\n        //    var newMappings = permissionIds.Select(pid => new PlanPermission\n        //    {\n        //        PlanId = planId,\n        //        PermissionId = pid,\n        //        AssignedAt = DateTime.UtcNow,\n        //        AssignedBy = \"system\" // replace with logged-in admin\n        //    });\n\n        //    await _context.PlanPermissions.AddRangeAsync(newMappings);\n        //    await _context.SaveChangesAsync();\n        //    //// Clear cache\n        //    _permissionCacheService.ClearPlanPermissionsCache(planId);\n        //}\n        public async Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description\n                })\n                .ToListAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Controllers/AccountInsightsController.cs",
      "sha256": "64cd25ac7e7add6b1b977d821ca5a3bbd51f641bab27fe9b07eeef17c55d220e",
      "language": "csharp",
      "size": 8520,
      "content": "using System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AccountInsights.DTOs;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.AccountInsights.Services;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing System.Text.Json;\nnamespace xbytechat.api.Features.AccountInsights.Controllers\n{\n    [ApiController]\n    [Route(\"api/admin/account-insights\")]\n    [Authorize(Roles = \"admin,superadmin,partner\")]\n    public class AccountInsightsController : ControllerBase\n    {\n        private readonly IAccountInsightsService _svc;\n        private readonly AppDbContext _db;\n        public AccountInsightsController(IAccountInsightsService svc, AppDbContext db)\n        {\n            _svc = svc;\n            _db = db;\n        }\n\n        [HttpGet(\"{businessId:guid}\")]\n        public async Task<IActionResult> GetOne(Guid businessId)\n        {\n            var snapshot = await _svc.GetSnapshotAsync(businessId);\n            return Ok(snapshot);\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetMany([FromQuery] int page = 1, [FromQuery] int pageSize = 50, [FromQuery] Guid? partnerId = null)\n        {\n            var snapshots = await _svc.GetSnapshotsAsync(page, pageSize, partnerId);\n            return Ok(snapshots);\n        }\n        [HttpGet(\"summary\")]\n        public async Task<IActionResult> GetSummary([FromQuery] Guid? partnerId = null)\n        {\n            var summary = await _svc.GetSummaryAsync(partnerId);\n            return Ok(summary);\n        }\n\n        [HttpGet(\"trial-expiring-soon\")]\n        public async Task<IActionResult> GetTrialsExpiringSoon([FromQuery] int days = 3)\n        {\n            var items = await _svc.GetTrialsExpiringSoonAsync(days);\n            return Ok(items);\n        }\n        [HttpGet(\"by-stage\")]\n        public async Task<IActionResult> GetByStage(\n            [FromQuery] AccountLifecycleStage stage,\n            [FromQuery] Guid? partnerId = null,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 100)\n        {\n            var items = await _svc.GetByLifecycleStageAsync(stage, partnerId, page, pageSize);\n            return Ok(items);\n        }\n        [HttpGet(\"segment\")]\n        public async Task<IActionResult> GetSegment(\n            [FromQuery] string key,\n            [FromQuery] Guid? partnerId = null,\n            [FromQuery] int days = 3,\n            [FromQuery] int page = 1,\n            [FromQuery] int pageSize = 200)\n        {\n            if (string.IsNullOrWhiteSpace(key))\n                return BadRequest(\"Segment key is required.\");\n\n            key = key.Trim().ToLowerInvariant();\n\n            if (page <= 0) page = 1;\n            if (pageSize <= 0 || pageSize > 500) pageSize = 200;\n\n            IReadOnlyList<AccountInsightsSnapshotDto> items;\n\n            switch (key)\n            {\n                case \"trials-near-expiry\":\n                    // Trials whose trial window ends within next {days}\n                    items = await _svc.GetTrialsExpiringSoonAsync(days);\n                    break;\n\n                case \"no-usage-post-approval\":\n                case \"wa-setup-no-usage\":\n                    // Approved, never sent a message\n                    items = await _svc.GetByLifecycleStageAsync(\n                        AccountLifecycleStage.NoUsagePostApproval,\n                        partnerId,\n                        page,\n                        pageSize);\n                    break;\n\n                case \"at-risk\":\n                    items = await _svc.GetByLifecycleStageAsync(\n                        AccountLifecycleStage.AtRisk,\n                        partnerId,\n                        page,\n                        pageSize);\n                    break;\n\n                case \"dormant\":\n                    items = await _svc.GetByLifecycleStageAsync(\n                        AccountLifecycleStage.Dormant,\n                        partnerId,\n                        page,\n                        pageSize);\n                    break;\n\n                case \"healthy-active\":\n                    items = await _svc.GetByLifecycleStageAsync(\n                        AccountLifecycleStage.Active,\n                        partnerId,\n                        page,\n                        pageSize);\n                    break;\n\n                default:\n                    return BadRequest($\"Unknown segment key '{key}'.\");\n            }\n\n            return Ok(items);\n        }\n\n        [HttpGet(\"{businessId:guid}/actions\")]\n        public async Task<IActionResult> GetRecentActions(Guid businessId, [FromQuery] int limit = 10)\n        {\n            var items = await _svc.GetRecentActionsAsync(businessId, limit);\n            // Frontend supports both array and { items }; use { items } for clarity.\n            return Ok(new { items });\n        }\n        private string GetActor()\n        {\n            // Prefer email/username, fall back to subject or role\n            var email = User?.FindFirst(ClaimTypes.Email)?.Value;\n            var name = User?.Identity?.Name;\n\n            return !string.IsNullOrWhiteSpace(email)\n                ? email\n                : !string.IsNullOrWhiteSpace(name)\n                    ? name\n                    : \"admin\";\n        }\n\n        [HttpPost(\"{businessId:guid}/mark-contacted\")]\n        public async Task<IActionResult> MarkContacted(Guid businessId)\n        {\n            // No schema flag change; purely timeline-based\n            var actor = GetActor();\n\n            await _svc.LogActionAsync(\n                businessId,\n                AccountInsightActionTypes.TagContacted,\n                \"Marked as contacted\",\n                actor);\n\n            return Ok(new\n            {\n                ok = true,\n                businessId,\n                contacted = true\n            });\n        }\n        public class ExtendTrialRequest\n        {\n            public int ExtraDays { get; set; }\n        }\n\n        [HttpPost(\"{businessId:guid}/extend-trial\")]\n        public async Task<IActionResult> ExtendTrial(\n            Guid businessId,\n            [FromBody] ExtendTrialRequest body)\n        {\n            if (body == null || body.ExtraDays <= 0 || body.ExtraDays > 365)\n                return BadRequest(\"ExtraDays must be between 1 and 365.\");\n\n            var actor = GetActor();\n\n            var biz = await _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (biz == null)\n                return NotFound(\"Business not found.\");\n\n            var plan = biz.BusinessPlanInfo;\n            if (plan == null)\n                return BadRequest(\"Business has no plan info.\");\n\n            if (plan.Plan != PlanType.Trial)\n                return BadRequest(\"Trial extension is only allowed for Trial plan.\");\n\n            var now = DateTime.UtcNow;\n\n            // current end date resolution (aligned with BuildSnapshotAsync)\n            var trialStart = plan.CreatedAt != default\n                ? plan.CreatedAt\n                : biz.CreatedAt;\n\n            DateTime currentEnd;\n            if (plan.QuotaResetDate != default && plan.QuotaResetDate > trialStart)\n            {\n                currentEnd = plan.QuotaResetDate;\n            }\n            else\n            {\n                currentEnd = trialStart.AddDays(14); // fallback consistent with DefaultTrialDaysFallback\n            }\n\n            var oldEnd = currentEnd;\n            var newEnd = oldEnd.AddDays(body.ExtraDays);\n\n            plan.QuotaResetDate = newEnd;\n            await _db.SaveChangesAsync();\n\n            var meta = JsonSerializer.Serialize(new\n            {\n                oldEnd,\n                newEnd,\n                extraDays = body.ExtraDays\n            });\n\n            await _svc.LogActionAsync(\n                businessId,\n                AccountInsightActionTypes.ExtendTrial,\n                $\"Trial extended by {body.ExtraDays} days\",\n                actor,\n                meta);\n\n            // Return updated snapshot so frontend stays in sync without extra roundtrip\n            var snapshot = await _svc.GetSnapshotAsync(businessId);\n\n            return Ok(new\n            {\n                ok = true,\n                businessId,\n                oldEnd,\n                newEnd,\n                snapshot\n            });\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/DTOs/AccountInsightsActionDto.cs",
      "sha256": "b77b9c0ccf810b320dbbae050e075b6dc2da7cc80c8ac9316cc2136498311905",
      "language": "csharp",
      "size": 430,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccountInsights.DTOs\n{\n    public class AccountInsightsActionDto\n    {\n        public long Id { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Type { get; set; }\n        public string Label { get; set; }\n        public string Actor { get; set; }\n\n        public string MetaJson { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/DTOs/AccountInsightsSnapshotDto.cs",
      "sha256": "c2da56319228b929b1fd68165baacda30d7288b931c6c9a1c97c515c9c88d17f",
      "language": "csharp",
      "size": 1738,
      "content": "using System;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.PlanManagement.Models; // PlanType\n\nnamespace xbytechat.api.Features.AccountInsights.DTOs\n{\n    public class AccountInsightsSnapshotDto\n    {\n        public Guid BusinessId { get; set; }\n        public string BusinessName { get; set; }\n        public string BusinessEmail { get; set; }\n\n        public bool IsDeleted { get; set; }\n        public string Status { get; set; }           // Pending / Approved / Rejected (raw)\n        public bool IsApproved { get; set; }\n\n        public Guid? CreatedByPartnerId { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? ApprovedAt { get; set; }\n\n        // Plan / quota\n        public PlanType? PlanType { get; set; }\n        public int? TotalMonthlyQuota { get; set; }\n        public int? RemainingMessages { get; set; }\n        public DateTime? QuotaResetDate { get; set; }\n\n        // WhatsApp / onboarding\n        public bool HasWhatsAppConfig { get; set; }\n        public bool HasActiveWhatsAppNumber { get; set; }\n\n        // Usage\n        public bool HasAnyMessages { get; set; }\n        public DateTime? FirstMessageAt { get; set; }\n        public DateTime? LastMessageAt { get; set; }\n        public int MessagesLast30Days { get; set; }\n\n        // Lifecycle\n        public AccountLifecycleStage LifecycleStage { get; set; }\n        public int HealthScore { get; set; }\n\n        // Trial intelligence\n        public bool IsTrial { get; set; }\n        public DateTime? TrialStartAt { get; set; }\n        public DateTime? TrialEndsAt { get; set; }\n        public bool IsTrialExpiringSoon { get; set; }\n        public bool IsTrialExpired { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/DTOs/AccountInsightsSummaryDto.cs",
      "sha256": "ccd45ad696bb4109efbaacbef1df10cc2e041a085b7e001b951d6ed2eaee4560",
      "language": "csharp",
      "size": 1128,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccountInsights.DTOs\n{\n    public class AccountInsightsSummaryDto\n    {\n        public DateTime GeneratedAtUtc { get; set; }\n\n        // Core counts\n        public int TotalBusinesses { get; set; }\n        public int ActiveBusinesses { get; set; }\n        public int AtRiskBusinesses { get; set; }\n        public int DormantBusinesses { get; set; }\n        public int NoUsagePostApproval { get; set; }\n\n        public int PendingApproval { get; set; }\n        public int Rejected { get; set; }\n        public int Deleted { get; set; }\n\n        // Plan\n        public int TrialPlan { get; set; }\n        public int PaidPlan { get; set; }\n        public int UnknownPlan { get; set; }\n\n        // Trial lifecycle\n        public int TrialTotal { get; set; }\n        public int TrialExpiringSoon { get; set; }\n        public int TrialExpiredNoUpgrade { get; set; }\n\n        // Distributions\n        public Dictionary<string, int> ByLifecycleStage { get; set; } = new();\n        public Dictionary<string, int> ByPlanType { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Models/AccountInsightActionTypes.cs",
      "sha256": "7055e4c6a231ed5f9738be56baf19b9a6fe8cf019469c2a74616a2b04d373f09",
      "language": "csharp",
      "size": 875,
      "content": "namespace xbytechat.api.Features.AccountInsights.Models\n{\n    /// <summary>\n    /// Canonical action type codes for AccountInsightsAction.ActionType.\n    /// Keeps frontend and backend aligned and avoids random strings.\n    /// </summary>\n    public static class AccountInsightActionTypes\n    {\n        // Manual sales / CS actions\n        public const string TagContacted = \"TAG_CONTACTED\";\n\n        // Trial lifecycle (only log when an actual manual/system CHANGE happens)\n        public const string ExtendTrial = \"EXTEND_TRIAL\";\n\n        // Plan changes\n        public const string PlanUpgraded = \"PLAN_UPGRADED\";\n        public const string PlanDowngraded = \"PLAN_DOWNGRADED\";\n\n        // System nudges (emails / campaigns etc.)\n        public const string SystemNudge = \"SYSTEM_NUDGE\";\n\n        // Generic manual note\n        public const string Note = \"NOTE\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Models/AccountInsightsAction.cs",
      "sha256": "06bf45cb34c4a8d6d783ccbe9794df5a37e3972cbd2527ab66434170f5e5355b",
      "language": "csharp",
      "size": 1298,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccountInsights.Models\n{\n    /// <summary>\n    /// Lightweight append-only log of important micro-actions taken on an account.\n    /// Used to power the Recent Activity timeline in Account Insights UI.\n    /// </summary>\n    public class AccountInsightsAction\n    {\n        public long Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Machine-friendly action code, e.g. \"TAG_CONTACTED\", \"EXTEND_TRIAL\".\n        /// </summary>\n        public string ActionType { get; set; }\n\n        /// <summary>\n        /// Human-readable label shown in the UI timeline.\n        /// </summary>\n        public string Label { get; set; }\n\n        /// <summary>\n        /// Who performed the action (user email/id) or \"system\".\n        /// </summary>\n        public string Actor { get; set; }\n\n        /// <summary>\n        /// Optional JSON blob for extra context (e.g. { \"extraDays\": 7 }).\n        /// Stored as string for simplicity; can be mapped to JSONB on the DB side.\n        /// </summary>\n        public string MetaJson { get; set; }\n\n        /// <summary>\n        /// UTC timestamp when the action occurred.\n        /// </summary>\n        public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Models/AccountLifecycleStage.cs",
      "sha256": "4fcb2d0f0326c4bc85cc7e3e2836bc2c64d0956002e5807ee4cb1f3df2cef89c",
      "language": "csharp",
      "size": 695,
      "content": "namespace xbytechat.api.Features.AccountInsights.Models\n{\n    public enum AccountLifecycleStage\n    {\n        Unknown = 0,\n\n        PendingApproval = 10,      // Signed up, not yet approved\n        Rejected = 20,             // Explicitly rejected\n        InactiveDeleted = 25,      // Soft-deleted\n\n        Trial = 30,                // Trial plan, approved, some activity or in trial window\n        Active = 40,               // Approved + active usage\n        AtRisk = 50,               // Approved + low/no recent usage\n        Dormant = 60,              // Approved but idle for a long time\n\n        NoUsagePostApproval = 70   // Approved but literally never used (high churn risk)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Services/AccountInsightsAlertService.cs",
      "sha256": "ee402e60508d432937e55c465d3a883d5708315bd4e297cddca077f99e7793d8",
      "language": "csharp",
      "size": 2033,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AccountInsights.DTOs;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.AccountInsights.Services;\n\nnamespace xbytechat.api.Features.AccountInsights.Services\n{\n    public interface IAccountInsightsAlertService\n    {\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetTrialExpiringSoonAsync(int days = 3);\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetInactivePostApprovalAsync();\n    }\n\n    /// <summary>\n    /// Read-only helper for schedulers / workers to fetch cohorts that should be nudged.\n    /// This layer does NOT send messages itself.\n    /// </summary>\n    public class AccountInsightsAlertService : IAccountInsightsAlertService\n    {\n        private readonly IAccountInsightsService _insights;\n        private readonly ILogger<AccountInsightsAlertService> _log;\n\n        public AccountInsightsAlertService(\n            IAccountInsightsService insights,\n            ILogger<AccountInsightsAlertService> log)\n        {\n            _insights = insights;\n            _log = log;\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetTrialExpiringSoonAsync(int days = 3)\n        {\n            // Uses core logic; safe to call from a daily/cron job.\n            var list = await _insights.GetTrialsExpiringSoonAsync(days);\n            _log.LogInformation(\"Found {Count} trials expiring in next {Days} days\", list.Count, days);\n            return list;\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetInactivePostApprovalAsync()\n        {\n            // NoUsagePostApproval cohort: approved, no messages ever.\n            var list = await _insights.GetByLifecycleStageAsync(AccountLifecycleStage.NoUsagePostApproval);\n            _log.LogInformation(\"Found {Count} approved accounts with no usage post-approval\", list.Count);\n            return list;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Services/AccountInsightsService.cs",
      "sha256": "8d6457fc7aefe15956384777654cf665ca72fc9349990888d8ae9ba5764bdfe2",
      "language": "csharp",
      "size": 18261,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AccountInsights.DTOs;\nusing xbytechat.api.Features.AccountInsights.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.PlanManagement.Models; // PlanType\nusing xbytechat.api.Models.BusinessModel;          // BusinessPlanInfo\n\nnamespace xbytechat.api.Features.AccountInsights.Services\n{\n    public class AccountInsightsService : IAccountInsightsService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<AccountInsightsService> _log;\n\n        private const int TrialExpiringSoonDays = 3;\n        private const int DefaultTrialDaysFallback = 14;\n\n        public AccountInsightsService(AppDbContext db, ILogger<AccountInsightsService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task<AccountInsightsSnapshotDto> GetSnapshotAsync(Guid businessId)\n        {\n            var biz = await _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (biz == null)\n                throw new InvalidOperationException($\"Business {businessId} not found\");\n\n            return await BuildSnapshotAsync(biz);\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetSnapshotsAsync(\n            int page = 1,\n            int pageSize = 50,\n            Guid? partnerId = null)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0 || pageSize > 500) pageSize = 50;\n\n            var query = _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .AsQueryable();\n\n            if (partnerId.HasValue)\n            {\n                query = query.Where(b => b.CreatedByPartnerId == partnerId.Value);\n            }\n\n            query = query.OrderByDescending(b => b.CreatedAt);\n\n            var list = await query\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .ToListAsync();\n\n            var snapshots = new List<AccountInsightsSnapshotDto>(list.Count);\n            foreach (var biz in list)\n            {\n                snapshots.Add(await BuildSnapshotAsync(biz));\n            }\n\n            return snapshots;\n        }\n\n        // ---------- Core snapshot builder ----------\n\n        private async Task<AccountInsightsSnapshotDto> BuildSnapshotAsync(Business biz)\n        {\n            var now = DateTime.UtcNow;\n            var thirtyDaysAgo = now.AddDays(-30);\n            var ninetyDaysAgo = now.AddDays(-90);\n\n            var hasWaConfig = await _db.WhatsAppSettings\n                .AnyAsync(x => x.BusinessId == biz.Id && x.IsActive);\n\n            var hasActiveWaNumber = await _db.WhatsAppPhoneNumbers\n                .AnyAsync(x => x.BusinessId == biz.Id && x.IsActive);\n\n            var msgQuery = _db.MessageLogs.Where(m => m.BusinessId == biz.Id);\n            var hasAnyMessages = await msgQuery.AnyAsync();\n\n            DateTime? firstMessageAt = null;\n            DateTime? lastMessageAt = null;\n            var messagesLast30 = 0;\n\n            if (hasAnyMessages)\n            {\n                firstMessageAt = await msgQuery.MinAsync(m => (DateTime?)m.CreatedAt);\n                lastMessageAt = await msgQuery.MaxAsync(m => (DateTime?)m.CreatedAt);\n                messagesLast30 = await msgQuery.CountAsync(m => m.CreatedAt >= thirtyDaysAgo);\n            }\n\n            var planInfo = biz.BusinessPlanInfo;\n\n            // ---- Trial derivation ----\n            bool isTrial = false;\n            DateTime? trialStart = null;\n            DateTime? trialEnd = null;\n            bool trialExpiringSoon = false;\n            bool trialExpired = false;\n\n            if (planInfo != null &&\n                planInfo.Plan == PlanType.Trial &&\n                !biz.IsDeleted)\n            {\n                isTrial = true;\n\n                trialStart = planInfo.CreatedAt != default\n                    ? planInfo.CreatedAt\n                    : biz.CreatedAt;\n\n                if (trialStart.HasValue)\n                {\n                    if (planInfo.QuotaResetDate != default &&\n                        planInfo.QuotaResetDate > trialStart.Value)\n                    {\n                        trialEnd = planInfo.QuotaResetDate;\n                    }\n                    else\n                    {\n                        trialEnd = trialStart.Value.AddDays(DefaultTrialDaysFallback);\n                    }\n                }\n\n                if (trialEnd.HasValue)\n                {\n                    if (now <= trialEnd.Value)\n                    {\n                        var daysLeft = (trialEnd.Value - now).TotalDays;\n                        if (daysLeft >= 0 && daysLeft <= TrialExpiringSoonDays)\n                            trialExpiringSoon = true;\n                    }\n                    else\n                    {\n                        trialExpired = true;\n                    }\n                }\n            }\n\n            var stage = ComputeLifecycleStage(\n                biz,\n                hasWaConfig,\n                hasActiveWaNumber,\n                hasAnyMessages,\n                lastMessageAt,\n                messagesLast30,\n                now,\n                ninetyDaysAgo);\n\n            var health = ComputeHealthScore(\n                stage,\n                hasWaConfig,\n                hasActiveWaNumber,\n                messagesLast30,\n                lastMessageAt,\n                now);\n\n            return new AccountInsightsSnapshotDto\n            {\n                BusinessId = biz.Id,\n                BusinessName = biz.BusinessName,\n                BusinessEmail = biz.BusinessEmail,\n                IsDeleted = biz.IsDeleted,\n                Status = biz.Status.ToString(),\n                IsApproved = biz.IsApproved,\n                CreatedByPartnerId = biz.CreatedByPartnerId,\n                CreatedAt = biz.CreatedAt,\n                ApprovedAt = biz.ApprovedAt,\n\n                PlanType = planInfo?.Plan,\n                TotalMonthlyQuota = planInfo?.TotalMonthlyQuota,\n                RemainingMessages = planInfo?.RemainingMessages,\n                QuotaResetDate = planInfo?.QuotaResetDate,\n\n                HasWhatsAppConfig = hasWaConfig,\n                HasActiveWhatsAppNumber = hasActiveWaNumber,\n\n                HasAnyMessages = hasAnyMessages,\n                FirstMessageAt = firstMessageAt,\n                LastMessageAt = lastMessageAt,\n                MessagesLast30Days = messagesLast30,\n\n                LifecycleStage = stage,\n                HealthScore = health,\n\n                IsTrial = isTrial,\n                TrialStartAt = trialStart,\n                TrialEndsAt = trialEnd,\n                IsTrialExpiringSoon = trialExpiringSoon,\n                IsTrialExpired = trialExpired\n            };\n        }\n\n        private static AccountLifecycleStage ComputeLifecycleStage(\n            Business biz,\n            bool hasWaConfig,\n            bool hasActiveWaNumber,\n            bool hasAnyMessages,\n            DateTime? lastMessageAt,\n            int messagesLast30,\n            DateTime now,\n            DateTime ninetyDaysAgo)\n        {\n            if (biz.IsDeleted)\n                return AccountLifecycleStage.InactiveDeleted;\n\n            switch (biz.Status)\n            {\n                case Business.StatusType.Rejected:\n                    return AccountLifecycleStage.Rejected;\n                case Business.StatusType.Pending:\n                    return AccountLifecycleStage.PendingApproval;\n            }\n\n            if (!biz.IsApproved)\n                return AccountLifecycleStage.Unknown;\n\n            if (!hasAnyMessages)\n                return AccountLifecycleStage.NoUsagePostApproval;\n\n            if (messagesLast30 > 0)\n                return AccountLifecycleStage.Active;\n\n            if (lastMessageAt.HasValue && lastMessageAt.Value < ninetyDaysAgo)\n                return AccountLifecycleStage.Dormant;\n\n            return AccountLifecycleStage.AtRisk;\n        }\n\n        private static int ComputeHealthScore(\n            AccountLifecycleStage stage,\n            bool hasWaConfig,\n            bool hasActiveWaNumber,\n            int messagesLast30,\n            DateTime? lastMessageAt,\n            DateTime now)\n        {\n            if (stage == AccountLifecycleStage.InactiveDeleted ||\n                stage == AccountLifecycleStage.Rejected)\n                return 0;\n\n            var score = 0;\n\n            if (hasWaConfig) score += 15;\n            if (hasActiveWaNumber) score += 15;\n\n            if (messagesLast30 > 0)\n            {\n                score += 40;\n                if (messagesLast30 > 50) score += 10;\n                if (messagesLast30 > 200) score += 10;\n            }\n            else if (lastMessageAt.HasValue)\n            {\n                var days = (now - lastMessageAt.Value).TotalDays;\n                if (days <= 30) score += 30;\n                else if (days <= 90) score += 15;\n            }\n\n            switch (stage)\n            {\n                case AccountLifecycleStage.Active:\n                    score += 20;\n                    break;\n                case AccountLifecycleStage.AtRisk:\n                    score += 5;\n                    break;\n                case AccountLifecycleStage.NoUsagePostApproval:\n                    score -= 10;\n                    break;\n                case AccountLifecycleStage.Dormant:\n                    score -= 20;\n                    break;\n            }\n\n            if (score < 0) score = 0;\n            if (score > 100) score = 100;\n\n            return score;\n        }\n\n        // ---------- Summary ----------\n\n        public async Task<AccountInsightsSummaryDto> GetSummaryAsync(Guid? partnerId = null)\n        {\n            var now = DateTime.UtcNow;\n\n            var bizQuery = _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .AsQueryable();\n\n            if (partnerId.HasValue)\n                bizQuery = bizQuery.Where(b => b.CreatedByPartnerId == partnerId.Value);\n\n            var businesses = await bizQuery.ToListAsync();\n\n            var summary = new AccountInsightsSummaryDto\n            {\n                GeneratedAtUtc = now,\n                TotalBusinesses = businesses.Count\n            };\n\n            var stageCounts = new Dictionary<AccountLifecycleStage, int>();\n            var planCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n\n            foreach (var biz in businesses)\n            {\n                var snapshot = await BuildSnapshotAsync(biz);\n\n                if (snapshot.IsDeleted)\n                    summary.Deleted++;\n\n                switch (snapshot.Status)\n                {\n                    case nameof(Business.StatusType.Pending):\n                        summary.PendingApproval++;\n                        break;\n                    case nameof(Business.StatusType.Rejected):\n                        summary.Rejected++;\n                        break;\n                }\n\n                if (!stageCounts.ContainsKey(snapshot.LifecycleStage))\n                    stageCounts[snapshot.LifecycleStage] = 0;\n                stageCounts[snapshot.LifecycleStage]++;\n\n                switch (snapshot.LifecycleStage)\n                {\n                    case AccountLifecycleStage.Active:\n                        summary.ActiveBusinesses++;\n                        break;\n                    case AccountLifecycleStage.AtRisk:\n                        summary.AtRiskBusinesses++;\n                        break;\n                    case AccountLifecycleStage.Dormant:\n                        summary.DormantBusinesses++;\n                        break;\n                    case AccountLifecycleStage.NoUsagePostApproval:\n                        summary.NoUsagePostApproval++;\n                        break;\n                }\n\n                if (snapshot.PlanType.HasValue)\n                {\n                    var planKey = snapshot.PlanType.Value.ToString();\n                    if (!planCounts.ContainsKey(planKey))\n                        planCounts[planKey] = 0;\n                    planCounts[planKey]++;\n\n                    if (snapshot.PlanType.Value == PlanType.Trial)\n                        summary.TrialPlan++;\n                    else\n                        summary.PaidPlan++;\n                }\n                else\n                {\n                    summary.UnknownPlan++;\n                    if (!planCounts.ContainsKey(\"Unknown\"))\n                        planCounts[\"Unknown\"] = 0;\n                    planCounts[\"Unknown\"]++;\n                }\n\n                if (snapshot.IsTrial)\n                {\n                    summary.TrialTotal++;\n\n                    if (snapshot.IsTrialExpiringSoon &&\n                        !snapshot.IsDeleted &&\n                        snapshot.LifecycleStage != AccountLifecycleStage.Rejected)\n                    {\n                        summary.TrialExpiringSoon++;\n                    }\n\n                    if (snapshot.IsTrialExpired &&\n                        !snapshot.IsDeleted &&\n                        snapshot.PlanType == PlanType.Trial)\n                    {\n                        summary.TrialExpiredNoUpgrade++;\n                    }\n                }\n            }\n\n            foreach (var kv in stageCounts)\n                summary.ByLifecycleStage[kv.Key.ToString()] = kv.Value;\n\n            foreach (var kv in planCounts)\n                summary.ByPlanType[kv.Key] = kv.Value;\n\n            return summary;\n        }\n\n        // ---------- Queries used by AlertService ----------\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetTrialsExpiringSoonAsync(int days = TrialExpiringSoonDays)\n        {\n            if (days <= 0) days = TrialExpiringSoonDays;\n\n            var now = DateTime.UtcNow;\n            var maxDate = now.AddDays(days);\n\n            var trials = await _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .Where(b =>\n                    !b.IsDeleted &&\n                    b.BusinessPlanInfo != null &&\n                    b.BusinessPlanInfo.Plan == PlanType.Trial)\n                .ToListAsync();\n\n            var list = new List<AccountInsightsSnapshotDto>();\n\n            foreach (var biz in trials)\n            {\n                var snapshot = await BuildSnapshotAsync(biz);\n\n                if (snapshot.IsTrial &&\n                    snapshot.TrialEndsAt.HasValue &&\n                    snapshot.TrialEndsAt.Value >= now &&\n                    snapshot.TrialEndsAt.Value <= maxDate &&\n                    !snapshot.IsTrialExpired)\n                {\n                    list.Add(snapshot);\n                }\n            }\n\n            return list;\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetByLifecycleStageAsync(\n            AccountLifecycleStage stage,\n            Guid? partnerId = null,\n            int page = 1,\n            int pageSize = 100)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0 || pageSize > 500) pageSize = 100;\n\n            var query = _db.Businesses\n                .Include(b => b.BusinessPlanInfo)\n                .AsQueryable();\n\n            if (partnerId.HasValue)\n                query = query.Where(b => b.CreatedByPartnerId == partnerId.Value);\n\n            query = query.OrderByDescending(b => b.CreatedAt);\n\n            var businesses = await query\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .ToListAsync();\n\n            var result = new List<AccountInsightsSnapshotDto>();\n\n            foreach (var biz in businesses)\n            {\n                var snapshot = await BuildSnapshotAsync(biz);\n                if (snapshot.LifecycleStage == stage)\n                    result.Add(snapshot);\n            }\n\n            return result;\n        }\n\n        public async Task<IReadOnlyList<AccountInsightsActionDto>> GetRecentActionsAsync(\n        Guid businessId,\n        int limit = 10)\n        {\n            if (limit <= 0 || limit > 100)\n                limit = 10;\n\n            var actions = await _db.AccountInsightsActions\n                .Where(a => a.BusinessId == businessId)\n                .OrderByDescending(a => a.CreatedAtUtc)\n                .Take(limit)\n                .ToListAsync();\n\n            var dtos = actions\n                .Select(a => new AccountInsightsActionDto\n                {\n                    Id = a.Id,\n                    BusinessId = a.BusinessId,\n                    Type = a.ActionType,\n                    Label = a.Label,\n                    Actor = a.Actor,\n                    MetaJson = a.MetaJson,\n                    CreatedAt = a.CreatedAtUtc\n                })\n                .ToList();\n\n            return dtos;\n        }\n\n        public async Task LogActionAsync(\n    Guid businessId,\n    string actionType,\n    string label,\n    string actor,\n    string metaJson = null)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required\", nameof(businessId));\n\n            if (string.IsNullOrWhiteSpace(actionType))\n                throw new ArgumentException(\"ActionType is required\", nameof(actionType));\n\n            if (string.IsNullOrWhiteSpace(label))\n                label = actionType;\n\n            var safeActor = string.IsNullOrWhiteSpace(actor) ? \"system\" : actor.Trim();\n\n            var entity = new AccountInsightsAction\n            {\n                BusinessId = businessId,\n                ActionType = actionType,\n                Label = label,\n                Actor = safeActor,\n                MetaJson = metaJson ?? string.Empty,\n                CreatedAtUtc = DateTime.UtcNow\n            };\n\n            _db.AccountInsightsActions.Add(entity);\n            await _db.SaveChangesAsync();\n\n            _log.LogInformation(\n                \"AccountInsightsAction logged: {BusinessId} {Type} by {Actor}\",\n                businessId,\n                actionType,\n                safeActor);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccountInsights/Services/IAccountInsightsService.cs",
      "sha256": "a3ae86511f2774208f11cdbac7813469b4970c16ad5ff767b7f23273cc6bc1d8",
      "language": "csharp",
      "size": 1202,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccountInsights.DTOs;\nusing xbytechat.api.Features.AccountInsights.Models;\n\nnamespace xbytechat.api.Features.AccountInsights.Services\n{\n    public interface IAccountInsightsService\n    {\n        Task<AccountInsightsSnapshotDto> GetSnapshotAsync(Guid businessId);\n\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetSnapshotsAsync(\n            int page = 1,\n            int pageSize = 50,\n            Guid? partnerId = null);\n\n        Task<AccountInsightsSummaryDto> GetSummaryAsync(Guid? partnerId = null);\n\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetTrialsExpiringSoonAsync(int days = 3);\n\n        Task<IReadOnlyList<AccountInsightsSnapshotDto>> GetByLifecycleStageAsync(\n            AccountLifecycleStage stage,\n            Guid? partnerId = null,\n            int page = 1,\n            int pageSize = 100);\n\n        Task<IReadOnlyList<AccountInsightsActionDto>> GetRecentActionsAsync(\n       Guid businessId,\n       int limit = 10);\n\n        Task LogActionAsync(\n           Guid businessId, string actionType,string label, string actor,string metaJson = null);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Controllers/AudienceController.cs",
      "sha256": "36755710674031902cf3133a3308170d732b23a2eb5cc6c6dcba17589b8fec7e",
      "language": "csharp",
      "size": 2865,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.Audiences.DTOs;\nusing xbytechat.api.Features.Audiences.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Audiences.Controllers\n{\n    [ApiController]\n    [Route(\"api/audiences\")]\n    [Authorize]\n    public class AudienceController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly IAudienceService _svc;\n\n        public AudienceController(AppDbContext db, IAudienceService svc)\n        { _db = db; _svc = svc; }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] AudienceCreateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userName = User.Identity?.Name ?? \"system\";\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            if (string.IsNullOrWhiteSpace(dto?.Name))\n                return BadRequest(new { success = false, message = \"Name is required\" });\n\n            var id = await _svc.CreateAsync(businessId, dto!, userName);\n            return Ok(new { success = true, id });\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> List()\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var items = await _svc.ListAsync(businessId);\n            return Ok(new { success = true, items });\n        }\n\n        [HttpPost(\"{audienceId:guid}/assign\")]\n        public async Task<IActionResult> Assign(Guid audienceId, [FromBody] AudienceAssignDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userName = User.Identity?.Name ?? \"system\";\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var ok = await _svc.AssignAsync(businessId, audienceId, dto ?? new AudienceAssignDto(), userName);\n            return Ok(new { success = ok });\n        }\n\n        [HttpGet(\"{audienceId:guid}/members\")]\n        public async Task<IActionResult> Members(Guid audienceId, [FromQuery] int page = 1, [FromQuery] int pageSize = 50)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Audiences.AnyAsync(a => a.Id == audienceId && a.BusinessId == businessId && !a.IsDeleted);\n            if (!exists) return NotFound(new { success = false, message = \"Audience not found\" });\n\n            var rows = await _svc.GetMembersAsync(businessId, audienceId, page, pageSize);\n            return Ok(new { success = true, items = rows, page, pageSize });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Controllers/AudienceImportController.cs",
      "sha256": "3b83d236a62b4def34dc67cda4f095665cdc144985151dd97565eb8de142268d",
      "language": "csharp",
      "size": 1639,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.Audiences.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Audiences.Controllers\n{\n    [ApiController]\n    [Route(\"api/audiences/import\")]\n    [Authorize]\n    public class AudienceImportController : ControllerBase\n    {\n        private readonly IAudienceImportService _svc;\n\n        public AudienceImportController(IAudienceImportService svc)\n        {\n            _svc = svc;\n        }\n\n        //[HttpPost(\"csv\")]\n        //[RequestSizeLimit(64_000_000)] // 64 MB\n        //public async Task<IActionResult> ImportCsv([FromForm] IFormFile file)\n        //{\n        //    var businessId = User.GetBusinessId();\n        //    if (businessId == Guid.Empty) return Unauthorized();\n\n        //    if (file == null || file.Length == 0)\n        //        return BadRequest(new { success = false, message = \"CSV file is required\" });\n\n        //    try\n        //    {\n        //        await using var stream = file.OpenReadStream();\n        //        var resp = await _svc.ImportCsvAsync(businessId, stream, file.FileName, HttpContext.RequestAborted);\n\n        //        return Ok(new { success = true, data = resp });\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        Log.Error(ex, \"‚ùå CSV import failed | biz={Biz}\", businessId);\n        //        return StatusCode(500, new { success = false, message = \"CSV import failed\" });\n        //    }\n        //}\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/DTOs/AudienceDtos.cs",
      "sha256": "36380702ffe3286aab70c4f45799ef8fc330b26eb9eae08190a307598ade1aa7",
      "language": "csharp",
      "size": 1198,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Audiences.DTOs\n{\n    public class AudienceCreateDto\n    {\n        public string Name { get; set; } = \"\";\n        public string? Description { get; set; }\n    }\n\n    public class AudienceSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = \"\";\n        public string? Description { get; set; }\n        public int MemberCount { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public class AudienceMemberDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }   // optional link to CRM contact\n        public string? Name { get; set; }\n        public string? PhoneNumber { get; set; }\n        public string? Email { get; set; }\n        public string? VariablesJson { get; set; } // if your model stores row-level vars\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public class AudienceAssignDto\n    {\n        public List<Guid> ContactIds { get; set; } = new(); // optional: assign CRM contacts\n        public Guid? CsvBatchId { get; set; }               // optional: attach CSV batch to audience\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/DTOs/CsvImportDtos.cs",
      "sha256": "c93d41ac64223fad52cd0ce3cb909af0347cac1e44b642fcdc9139c013b1ba73",
      "language": "csharp",
      "size": 342,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Audiences.DTOs\n{\n    public class CsvImportResponseDto\n    {\n        public Guid BatchId { get; set; }\n        public int RowCount { get; set; }\n        public List<string> Columns { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/AudienceImportService.cs",
      "sha256": "d7d97123d74025c2ac1e15973dd9e31f977706e2312d898a3af8a8374cc9af38",
      "language": "csharp",
      "size": 4327,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.Audiences.DTOs;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public class AudienceImportService : IAudienceImportService\n    {\n        private readonly AppDbContext _db;\n\n        public AudienceImportService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<CsvImportResponseDto> ImportCsvAsync(\n            Guid businessId,\n            Stream csvStream,\n            string fileName,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new UnauthorizedAccessException(\"Invalid business id.\");\n\n            if (csvStream == null || !csvStream.CanRead)\n                throw new ArgumentException(\"CSV stream is not readable.\");\n\n            using var reader = new StreamReader(csvStream);\n\n            // --- header row ---\n            var headerLine = await reader.ReadLineAsync();\n            if (string.IsNullOrWhiteSpace(headerLine))\n                throw new InvalidOperationException(\"Empty CSV.\");\n\n            var headers = headerLine.Split(',')\n                                    .Select(h => (h ?? string.Empty).Trim())\n                                    .Where(h => !string.IsNullOrWhiteSpace(h))\n                                    .ToList();\n\n            if (headers.Count == 0)\n                throw new InvalidOperationException(\"No columns.\");\n\n            var batchId = Guid.NewGuid();\n            var now = DateTime.UtcNow;\n\n            // Pre-create batch\n            _db.CsvBatches.Add(new Features.CampaignModule.Models.CsvBatch\n            {\n                Id = batchId,\n                BusinessId = businessId,\n                FileName = fileName,\n                // ‚úÖ match your model: CsvBatch.HeadersJson\n                HeadersJson = Newtonsoft.Json.JsonConvert.SerializeObject(headers),\n                RowCount = 0,\n                CreatedAt = now\n            });\n\n            var rowsBuffer = new List<Features.CampaignModule.Models.CsvRow>(capacity: 1024);\n            var total = 0;\n\n            // naive CSV parse (comma-only, no quoting in v1)\n            while (!reader.EndOfStream)\n            {\n                var line = await reader.ReadLineAsync();\n                if (string.IsNullOrWhiteSpace(line)) continue;\n\n                var cells = line.Split(',');\n                var dict = new Dictionary<string, string?>();\n                for (int i = 0; i < headers.Count; i++)\n                {\n                    var v = (i < cells.Length ? cells[i] : null)?.Trim();\n                    dict[headers[i]] = v;\n                }\n\n                rowsBuffer.Add(new Features.CampaignModule.Models.CsvRow\n                {\n                    Id = Guid.NewGuid(),\n                    BatchId = batchId,\n                    // üîÅ If your property is not RowJson, change this to the correct one (e.g., DataJson)\n                    RowJson = Newtonsoft.Json.JsonConvert.SerializeObject(dict),\n                    CreatedAt = DateTime.UtcNow\n                });\n\n                total++;\n\n                // chunked insert every 1k for memory safety\n                if (rowsBuffer.Count >= 1000)\n                {\n                    await _db.CsvRows.AddRangeAsync(rowsBuffer, ct);\n                    await _db.SaveChangesAsync(ct);\n                    rowsBuffer.Clear();\n                }\n            }\n\n            if (rowsBuffer.Count > 0)\n            {\n                await _db.CsvRows.AddRangeAsync(rowsBuffer, ct);\n            }\n\n            // update batch row count\n            var batchRow = await _db.CsvBatches.FirstAsync(b => b.Id == batchId, ct);\n            batchRow.RowCount = total;\n\n            await _db.SaveChangesAsync(ct);\n\n            Log.Information(\"üì• CSV imported | biz={Biz} batch={Batch} rows={Rows} file={File}\",\n                businessId, batchId, total, fileName);\n\n            return new CsvImportResponseDto\n            {\n                BatchId = batchId,\n                RowCount = total,\n                Columns = headers,\n                CreatedAt = now\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/AudienceService.cs",
      "sha256": "acea478fd0c7f1b94f7d4159e409b2d5d00a6e5dcf0b337b267d071577fcccfc",
      "language": "csharp",
      "size": 7441,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.Audiences.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public interface IAudienceService\n    {\n        Task<Guid> CreateAsync(Guid businessId, AudienceCreateDto dto, string createdBy);\n        Task<List<AudienceSummaryDto>> ListAsync(Guid businessId);\n        Task<bool> AssignAsync(Guid businessId, Guid audienceId, AudienceAssignDto dto, string createdBy);\n        Task<List<AudienceMemberDto>> GetMembersAsync(Guid businessId, Guid audienceId, int page = 1, int pageSize = 50);\n    }\n\n    public class AudienceService : IAudienceService\n    {\n        private readonly AppDbContext _db;\n\n        public AudienceService(AppDbContext db) { _db = db; }\n\n        public async Task<Guid> CreateAsync(Guid businessId, AudienceCreateDto dto, string createdBy)\n        {\n            var id = Guid.NewGuid();\n            try\n            {\n                var now = DateTime.UtcNow;\n                Guid? createdByUserId = null;\n                if (Guid.TryParse(createdBy, out var parsed)) createdByUserId = parsed;\n\n                var model = new Audience\n                {\n                    Id = id,\n                    BusinessId = businessId,\n                    Name = dto?.Name?.Trim() ?? \"Untitled Audience\",\n                    Description = dto?.Description,\n                    CsvBatchId = null,\n                    IsDeleted = false,\n                    CreatedByUserId = createdByUserId,\n                    CreatedAt = now,\n                    UpdatedAt = now\n                };\n\n                _db.Set<Audience>().Add(model);\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Audience created | biz={Biz} id={Id} name={Name}\", businessId, id, model.Name);\n                return id;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed creating audience | biz={Biz}\", businessId);\n                throw;\n            }\n        }\n\n        public async Task<List<AudienceSummaryDto>> ListAsync(Guid businessId)\n        {\n            var audiences = _db.Set<Audience>()\n                .AsNoTracking()\n                .Where(a => a.BusinessId == businessId && !a.IsDeleted);\n\n            var members = _db.Set<AudienceMember>();\n\n            var items = await audiences\n                .OrderByDescending(a => a.CreatedAt)\n                .Select(a => new AudienceSummaryDto\n                {\n                    Id = a.Id,\n                    Name = a.Name,\n                    Description = a.Description,\n                    MemberCount = members.Count(m => m.BusinessId == businessId && m.AudienceId == a.Id && !m.IsDeleted),\n                    CreatedAt = a.CreatedAt\n                })\n                .ToListAsync();\n\n            return items;\n        }\n\n        public async Task<bool> AssignAsync(Guid businessId, Guid audienceId, AudienceAssignDto dto, string createdBy)\n        {\n            var audience = await _db.Set<Audience>()\n                .FirstOrDefaultAsync(a => a.Id == audienceId && a.BusinessId == businessId && !a.IsDeleted);\n\n            if (audience == null) return false;\n\n            var now = DateTime.UtcNow;\n\n            // 1) Assign CRM contacts (if provided)\n            if (dto?.ContactIds != null && dto.ContactIds.Count > 0)\n            {\n                var contacts = await _db.Set<Contact>()\n                    .Where(c => c.BusinessId == businessId && dto.ContactIds.Contains(c.Id))\n                    .Select(c => new { c.Id, c.Name, c.PhoneNumber, c.Email })\n                    .ToListAsync();\n\n                var newMembers = contacts.Select(c =>\n                {\n                    var phoneRaw = (c.PhoneNumber ?? \"\").Trim();\n                    var phoneE164 = ToE164OrNull(phoneRaw);\n\n                    return new AudienceMember\n                    {\n                        Id = Guid.NewGuid(),\n                        AudienceId = audienceId,\n                        BusinessId = businessId,\n                        ContactId = c.Id,\n                        Name = c.Name,\n                        Email = string.IsNullOrWhiteSpace(c.Email) ? null : c.Email,\n                        PhoneRaw = phoneRaw,\n                        PhoneE164 = phoneE164,\n                        AttributesJson = null,            // keep as null unless you want to pack extra vars\n                        IsTransientContact = false,\n                        IsDeleted = false,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n                });\n\n                await _db.Set<AudienceMember>().AddRangeAsync(newMembers);\n            }\n\n            // 2) Optionally link a CSV batch\n            if (dto?.CsvBatchId.HasValue == true && dto.CsvBatchId.Value != Guid.Empty)\n            {\n                var batch = await _db.Set<CsvBatch>()\n                    .FirstOrDefaultAsync(b => b.Id == dto.CsvBatchId.Value && b.BusinessId == businessId);\n\n                if (batch != null)\n                {\n                    audience.CsvBatchId = batch.Id;\n                }\n            }\n\n            audience.UpdatedAt = now;\n\n            await _db.SaveChangesAsync();\n\n            Log.Information(\"üë• Audience assigned | biz={Biz} audience={AudienceId} contacts={Contacts} batch={Batch}\",\n                businessId, audienceId, dto?.ContactIds?.Count ?? 0, dto?.CsvBatchId);\n\n            return true;\n        }\n\n        public async Task<List<AudienceMemberDto>> GetMembersAsync(Guid businessId, Guid audienceId, int page = 1, int pageSize = 50)\n        {\n            page = Math.Max(1, page);\n            pageSize = Clamp(pageSize, 10, 200);\n\n            var q = _db.Set<AudienceMember>()\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.AudienceId == audienceId && !m.IsDeleted)\n                .OrderByDescending(m => m.CreatedAt);\n\n            var items = await q\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .Select(m => new AudienceMemberDto\n                {\n                    Id = m.Id,\n                    ContactId = m.ContactId,\n                    Name = m.Name,\n                    PhoneNumber = string.IsNullOrWhiteSpace(m.PhoneE164) ? m.PhoneRaw : m.PhoneE164,\n                    Email = m.Email,\n                    VariablesJson = m.AttributesJson,\n                    CreatedAt = m.CreatedAt\n                })\n                .ToListAsync();\n\n            return items;\n        }\n\n        // ---- helpers ----\n\n        private static int Clamp(int value, int min, int max)\n        {\n            if (value < min) return min;\n            if (value > max) return max;\n            return value;\n        }\n\n        private static string? ToE164OrNull(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var digits = new string(raw.Where(char.IsDigit).ToArray());\n            if (string.IsNullOrEmpty(digits)) return null;\n\n            // naive normalization: ensure leading +\n            if (raw.Trim().StartsWith(\"+\")) return \"+\" + digits;\n            return \"+\" + digits;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/CampaignVariableMapService.cs",
      "sha256": "fde5d702d281a92a4bbe0caa800ed3ab47c52fb28be71324666f3a9c7f34c3c7",
      "language": "csharp",
      "size": 6105,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignVariableMapService\n    {\n        Task<bool> SaveAsync(Guid businessId, CampaignVariableMapDto dto, string updatedBy);\n        Task<CampaignVariableMapDto?> GetAsync(Guid businessId, Guid campaignId);\n    }\n\n    public class CampaignVariableMapService : ICampaignVariableMapService\n    {\n        private readonly AppDbContext _db;\n\n        public CampaignVariableMapService(AppDbContext db) { _db = db; }\n\n        public async Task<bool> SaveAsync(Guid businessId, CampaignVariableMapDto dto, string updatedBy)\n        {\n            try\n            {\n                if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n                if (dto == null) throw new ArgumentNullException(nameof(dto));\n                if (dto.CampaignId == Guid.Empty) throw new ArgumentException(\"CampaignId is required.\", nameof(dto));\n\n                // Ensure campaign ownership\n                var owns = await _db.Campaigns\n                    .AsNoTracking()\n                    .AnyAsync(c => c.Id == dto.CampaignId && c.BusinessId == businessId);\n                if (!owns) return false;\n\n                // Load existing rows for this campaign\n                var existing = await _db.CampaignVariableMaps\n                    .Where(m => m.BusinessId == businessId && m.CampaignId == dto.CampaignId)\n                    .ToListAsync();\n\n                // Normalize incoming:\n                // - tolerate null Items\n                // - default Component ‚Üí \"BODY\" if missing\n                // - trim strings\n                // - keep last occurrence per (Component, Index)\n                var incoming = (dto.Items?.AsEnumerable() ?? Enumerable.Empty<CampaignVariableMapItemDto>())\n                    .Where(i => i != null && i.Index >= 1)\n                    .Select(i => new\n                    {\n                        Component = string.IsNullOrWhiteSpace(i.Component) ? \"BODY\" : i.Component!.Trim(),\n                        i.Index,\n                        SourceType = string.IsNullOrWhiteSpace(i.SourceType) ? \"Static\" : i.SourceType!.Trim(),\n                        SourceKey = string.IsNullOrWhiteSpace(i.SourceKey) ? null : i.SourceKey!.Trim(),\n                        StaticValue = i.StaticValue,\n                        Expression = i.Expression,\n                        DefaultValue = i.DefaultValue,\n                        i.IsRequired\n                    })\n                    .GroupBy(x => new { x.Component, x.Index })\n                    .Select(g => g.Last())\n                    .ToList();\n\n                var incomingKeySet = incoming\n                    .Select(i => (i.Component, i.Index))\n                    .ToHashSet();\n\n                // Upsert each incoming row\n                foreach (var item in incoming)\n                {\n                    var row = existing.FirstOrDefault(x => x.Component == item.Component && x.Index == item.Index);\n                    if (row == null)\n                    {\n                        row = new CampaignVariableMap\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            CampaignId = dto.CampaignId,\n                            Component = item.Component,\n                            Index = item.Index\n                        };\n                        _db.CampaignVariableMaps.Add(row);\n                        existing.Add(row); // keep local cache in sync in case of duplicates\n                    }\n\n                    row.SourceType = item.SourceType;\n                    row.SourceKey = item.SourceKey;\n                    row.StaticValue = item.StaticValue;\n                    row.Expression = item.Expression;\n                    row.DefaultValue = item.DefaultValue;\n                    row.IsRequired = item.IsRequired;\n                }\n\n                // Remove deleted mappings (anything not present in incoming)\n                var toRemove = existing.Where(x => !incomingKeySet.Contains((x.Component, x.Index))).ToList();\n                if (toRemove.Count > 0)\n                    _db.CampaignVariableMaps.RemoveRange(toRemove);\n\n                await _db.SaveChangesAsync();\n\n                var upserted = incoming.Count;\n                var removed = toRemove.Count;\n\n                Log.Information(\"‚úÖ Variable map saved | biz={Biz} campaign={Campaign} upserted={Up} removed={Rm}\",\n                    businessId, dto.CampaignId, upserted, removed);\n\n                return true;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed saving campaign variable map | biz={Biz} campaign={Campaign}\", businessId, dto?.CampaignId);\n                throw;\n            }\n        }\n        public async Task<CampaignVariableMapDto?> GetAsync(Guid businessId, Guid campaignId)\n        {\n            var rows = await _db.CampaignVariableMaps\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.CampaignId == campaignId)\n                .OrderBy(m => m.Component).ThenBy(m => m.Index)\n                .ToListAsync();\n\n            var items = rows.Select(r => new CampaignVariableMapItemDto\n            {\n                Component = r.Component,\n                Index = r.Index,\n                SourceType = r.SourceType,\n                SourceKey = r.SourceKey,\n                StaticValue = r.StaticValue,\n                Expression = r.Expression,\n                DefaultValue = r.DefaultValue,\n                IsRequired = r.IsRequired\n            }).ToList();\n\n            return new CampaignVariableMapDto\n            {\n                CampaignId = campaignId,\n                Items = items\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/IAudienceImportService.cs",
      "sha256": "80df51144eb035b0134e49bbdb7de6c48754a7800e72ee354b158ddf5401a202",
      "language": "csharp",
      "size": 586,
      "content": "using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Audiences.DTOs;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public interface IAudienceImportService\n    {\n        /// <summary>\n        /// Parses a CSV stream (first row = headers), creates a CsvBatch and CsvRows, and returns batch summary.\n        /// </summary>\n        Task<CsvImportResponseDto> ImportCsvAsync(\n            Guid businessId,\n            Stream csvStream,\n            string fileName,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/Controllers/FlowExecutionsController.cs",
      "sha256": "cd9482252d3b70cb771d4826a5a216a9c93b9c5074a29b9ae1dadc60743a3612",
      "language": "csharp",
      "size": 3843,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\nusing xbytechat.api.Features.Auditing.FlowExecutions.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Controllers\n{\n    /// <summary>\n    /// Internal / debugging API for exploring flow execution logs.\n    /// This is not meant to be exposed to end customers directly.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/flow-executions\")]\n    public class FlowExecutionsController : ControllerBase\n    {\n        private readonly IFlowExecutionQueryService _queryService;\n        private readonly ILogger<FlowExecutionsController> _logger;\n\n        public FlowExecutionsController(\n            IFlowExecutionQueryService queryService,\n            ILogger<FlowExecutionsController> logger)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        /// <summary>\n        /// Returns recent flow execution steps for a business, ordered by latest first.\n        /// \n        /// Example:\n        /// GET /api/flow-executions/recent?businessId=...&origin=AutoReply&limit=50\n        /// </summary>\n        [HttpGet(\"recent\")]\n        public async Task<ActionResult<IReadOnlyList<FlowExecutionLogDto>>> GetRecent(\n            [FromQuery] Guid businessId,\n            [FromQuery] FlowExecutionOrigin? origin,\n            [FromQuery] Guid? flowId,\n            [FromQuery] string? contactPhone,\n            [FromQuery] int limit = 50,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            var filter = new FlowExecutionFilter\n            {\n                Origin = origin,\n                FlowId = flowId,\n                ContactPhone = contactPhone,\n                Limit = limit\n            };\n\n            _logger.LogInformation(\n                \"[FlowExecutions] GetRecent biz={BusinessId} origin={Origin} flowId={FlowId} phone={Phone} limit={Limit}\",\n                businessId,\n                origin,\n                flowId,\n                contactPhone,\n                limit);\n\n            var results = await _queryService\n                .GetRecentExecutionsAsync(businessId, filter, ct)\n                .ConfigureAwait(false);\n\n            return Ok(results);\n        }\n\n        [HttpGet(\"run/{runId:guid}\")]\n        public async Task<ActionResult<IReadOnlyList<FlowExecutionLogDto>>> GetRunTimeline(\n           [FromRoute] Guid runId,\n           [FromQuery] Guid businessId,\n           CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required\");\n            }\n\n            if (runId == Guid.Empty)\n            {\n                return BadRequest(\"runId is required\");\n            }\n\n            try\n            {\n                var rows = await _queryService.GetRunTimelineAsync(\n                    businessId,\n                    runId,\n                    ct);\n\n                // Even if no rows, that's a valid 200 with empty list.\n                return Ok(rows);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"[FlowExecutions] Error in GetRunTimeline for BusinessId={BusinessId}, RunId={RunId}\",\n                    businessId,\n                    runId);\n\n                return StatusCode(500, \"Failed to fetch run timeline.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/DTOs/FlowExecutionFilter.cs",
      "sha256": "4b5d3d9134e83169856fccecac2a1e261d435e0aa4ddfc3fd81d79dcd9bc3519",
      "language": "csharp",
      "size": 1252,
      "content": "using System;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.DTOs\n{\n    /// <summary>\n    /// Filter options when querying flow execution logs.\n    /// All fields are optional except BusinessId (which is passed separately).\n    /// </summary>\n    public class FlowExecutionFilter\n    {\n        /// <summary>\n        /// Optional: restrict to a specific origin (AutoReply, Campaign, etc.).\n        /// </summary>\n        public FlowExecutionOrigin? Origin { get; set; }\n\n        /// <summary>\n        /// Optional: restrict to a specific flow id.\n        /// This is usually the CTAFlowConfig.Id or AutoReplyFlow.Id,\n        /// depending on how FlowId is populated.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// Optional: restrict to a specific contact phone number.\n        /// Stored exactly as in FlowExecutionLogs (usually WhatsApp \"from\" number).\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        /// <summary>\n        /// Maximum number of rows to return.\n        /// Defaults to 50; upper capped in service for safety.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/DTOs/FlowExecutionLogDto.cs",
      "sha256": "fe73dcb4340e01df3f5dafa5035c89bd7bca11471759f98c08afe2287908de06",
      "language": "csharp",
      "size": 3418,
      "content": "using System;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.DTOs\n{\n    /// <summary>\n    /// Lightweight projection of a FlowExecutionLog row for debugging/analytics.\n    /// Matches the current FlowExecutionLog entity in CTAFlowBuilder.Models.\n    /// </summary>\n    public class FlowExecutionLogDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Correlation id for a single run of a flow (e.g. one user journey).\n        /// Nullable because older rows might not have it.\n        /// </summary>\n        public Guid? RunId { get; set; }\n\n        /// <summary>\n        /// Flow id being executed:\n        /// - For CTA flows: CTAFlowConfig.Id\n        /// - For AutoReply flows: AutoReplyFlow.Id (depending on how you log it)\n        /// Nullable because your entity uses Guid?.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// If this execution was started by an AutoReply flow, this can carry that flow id.\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// If this execution was started as part of a campaign, this can carry Campaign.Id.\n        /// </summary>\n        public Guid? CampaignId { get; set; }\n\n        /// <summary>\n        /// Optional link to a specific campaign send log.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; set; }\n\n        /// <summary>\n        /// Optional link to a tracking log row (e.g. button click tracking).\n        /// </summary>\n        public Guid? TrackingLogId { get; set; }\n\n        public FlowExecutionOrigin Origin { get; set; }\n\n        /// <summary>\n        /// Contact's WhatsApp phone number (as stored in FlowExecutionLog).\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        public Guid StepId { get; set; }\n\n        public string StepName { get; set; } = string.Empty;\n\n        /// <summary>\n        /// If the step was triggered by a button click, this can store the button text.\n        /// </summary>\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        /// <summary>\n        /// True if the step was executed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Error message when Success == false.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n\n        /// <summary>\n        /// Raw provider response (optional).\n        /// </summary>\n        public string? RawResponse { get; set; }\n\n        /// <summary>\n        /// Optional link back to the originating MessageLog.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n\n        /// <summary>\n        /// Which button index (0..2) was clicked, if applicable.\n        /// </summary>\n        public short? ButtonIndex { get; set; }\n\n        /// <summary>\n        /// Optional request id correlation (for cross-service tracing).\n        /// </summary>\n        public Guid? RequestId { get; set; }\n\n        /// <summary>\n        /// When this step was executed (UTC). Backed by FlowExecutionLog.ExecutedAt.\n        /// </summary>\n        public DateTime ExecutedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/Services/FlowExecutionQueryService.cs",
      "sha256": "934d7e5e7f2aeadcdb33937ca6db5cab3241978f0ffcdcab048e27a2c4e1ba8b",
      "language": "csharp",
      "size": 8423,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Services\n{\n    /// <summary>\n    /// Default implementation of IFlowExecutionQueryService.\n    /// Performs filtered, read-only queries over FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionQueryService : IFlowExecutionQueryService\n    {\n        private readonly AppDbContext _db;\n\n        public FlowExecutionQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRecentExecutionsAsync(\n            Guid businessId,\n            FlowExecutionFilter filter,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            filter ??= new FlowExecutionFilter();\n\n            // Hard cap to avoid accidental huge result sets\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 500)\n            {\n                limit = 500;\n            }\n\n            var query = _db.FlowExecutionLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId);\n\n            if (filter.Origin.HasValue)\n            {\n                query = query.Where(x => x.Origin == filter.Origin.Value);\n            }\n\n            if (filter.FlowId.HasValue)\n            {\n                var flowId = filter.FlowId.Value;\n                // Entity FlowId is Guid?, so we just compare directly.\n                query = query.Where(x => x.FlowId == flowId);\n            }\n\n            if (!string.IsNullOrWhiteSpace(filter.ContactPhone))\n            {\n                var phone = filter.ContactPhone.Trim();\n                query = query.Where(x => x.ContactPhone == phone);\n            }\n\n            // Order by latest execution first, using FlowExecutionLog.ExecutedAt\n            query = query\n                .OrderByDescending(x => x.ExecutedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit);\n\n            var results = await query\n                .Select(x => new FlowExecutionLogDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    RunId = x.RunId,\n                    FlowId = x.FlowId,\n                    AutoReplyFlowId = x.AutoReplyFlowId,\n                    CampaignId = x.CampaignId,\n                    CampaignSendLogId = x.CampaignSendLogId,\n                    TrackingLogId = x.TrackingLogId,\n                    Origin = x.Origin,\n                    ContactPhone = x.ContactPhone,\n                    StepId = x.StepId,\n                    StepName = x.StepName,\n                    TriggeredByButton = x.TriggeredByButton,\n                    TemplateName = x.TemplateName,\n                    TemplateType = x.TemplateType,\n                    Success = x.Success,\n                    ErrorMessage = x.ErrorMessage,\n                    RawResponse = x.RawResponse,\n                    MessageLogId = x.MessageLogId,\n                    ButtonIndex = x.ButtonIndex,\n                    RequestId = x.RequestId,\n                    ExecutedAtUtc = x.ExecutedAt\n                })\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            return results;\n        }\n\n        //public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n        //    Guid businessId,\n        //    Guid runId,\n        //    CancellationToken ct = default)\n        //{\n        //    if (businessId == Guid.Empty)\n        //        throw new ArgumentException(\"BusinessId is required\", nameof(businessId));\n\n        //    if (runId == Guid.Empty)\n        //        throw new ArgumentException(\"RunId is required\", nameof(runId));\n\n        //    var query = _db.FlowExecutionLogs\n        //        .AsNoTracking()\n        //        .Where(x =>\n        //            x.BusinessId == businessId &&\n        //            x.RunId == runId);\n\n        //    // For a timeline we want oldest ‚Üí newest.\n        //    query = query\n        //        .OrderBy(x => x.ExecutedAt)\n        //        .ThenBy(x => x.Id);\n\n        //    return await query\n        //        .Select(x => new FlowExecutionLogDto\n        //        {\n        //            Id = x.Id,\n        //            RunId = x.RunId,\n        //            BusinessId = x.BusinessId,\n        //            FlowId = x.FlowId,\n        //            AutoReplyFlowId = x.AutoReplyFlowId,\n        //            CampaignId = x.CampaignId,\n        //            Origin = x.Origin,\n\n        //            StepId = x.StepId,\n        //            StepName = x.StepName,\n        //            ContactPhone = x.ContactPhone,\n        //            TriggeredByButton = x.TriggeredByButton,\n        //            TemplateName = x.TemplateName,\n        //            TemplateType = x.TemplateType,\n        //            Success = x.Success,\n        //            ErrorMessage = x.ErrorMessage,\n        //            RawResponse = x.RawResponse,\n        //            MessageLogId = x.MessageLogId,\n        //            ButtonIndex = x.ButtonIndex,\n        //            RequestId = x.RequestId,\n        //            ExecutedAtUtc = x.ExecutedAt\n        //        })\n        //        .ToListAsync(ct)\n        //        .ConfigureAwait(false);\n        //}\n        public async Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n            Guid businessId,\n            Guid runId,\n            CancellationToken ct = default)\n        {\n            if (runId == Guid.Empty)\n                throw new ArgumentException(\"RunId is required\", nameof(runId));\n\n            // Primary query: business-scoped (what we expect normally)\n            IQueryable<FlowExecutionLog> query = _db.FlowExecutionLogs\n                .AsNoTracking()\n                .Where(x => x.RunId == runId);\n\n            if (businessId != Guid.Empty)\n            {\n                query = query.Where(x => x.BusinessId == businessId);\n            }\n\n            var primary = await query\n                .OrderBy(x => x.ExecutedAt)\n                .ThenBy(x => x.Id)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            // If nothing found, fall back to \"by RunId only\" (no business filter).\n            // This makes the explorer robust against any mismatched BusinessId data.\n            List<FlowExecutionLog> rows;\n            if (primary.Count > 0)\n            {\n                rows = primary;\n            }\n            else\n            {\n                rows = await _db.FlowExecutionLogs\n                    .AsNoTracking()\n                    .Where(x => x.RunId == runId)\n                    .OrderBy(x => x.ExecutedAt)\n                    .ThenBy(x => x.Id)\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n            }\n\n            return rows\n                .Select(x => new FlowExecutionLogDto\n                {\n                    Id = x.Id,\n                    RunId = x.RunId,\n                    BusinessId = x.BusinessId,\n                    FlowId = x.FlowId,\n                    AutoReplyFlowId = x.AutoReplyFlowId,\n                    CampaignId = x.CampaignId,\n                    CampaignSendLogId = x.CampaignSendLogId,\n                    TrackingLogId = x.TrackingLogId,\n                    Origin = x.Origin,\n                    StepId = x.StepId,\n                    StepName = x.StepName,\n                    ContactPhone = x.ContactPhone,\n                    TriggeredByButton = x.TriggeredByButton,\n                    TemplateName = x.TemplateName,\n                    TemplateType = x.TemplateType,\n                    Success = x.Success,\n                    ErrorMessage = x.ErrorMessage,\n                    RawResponse = x.RawResponse,\n                    MessageLogId = x.MessageLogId,\n                    ButtonIndex = x.ButtonIndex,\n                    RequestId = x.RequestId,\n                    ExecutedAtUtc = x.ExecutedAt\n                })\n                .ToList();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Auditing/FlowExecutions/Services/IFlowExecutionQueryService.cs",
      "sha256": "39152ea71e1d5e0622da76c594765c55a889dd175676f056cc875e966c1043f5",
      "language": "csharp",
      "size": 1167,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Auditing.FlowExecutions.DTOs;\n\nnamespace xbytechat.api.Features.Auditing.FlowExecutions.Services\n{\n    /// <summary>\n    /// Read-only query service for inspecting flow execution logs.\n    /// Used by internal tools / analytics / debug endpoints.\n    /// </summary>\n    public interface IFlowExecutionQueryService\n    {\n        /// <summary>\n        /// Returns recent flow execution steps for a given business,\n        /// ordered by ExecutedAtUtc descending.\n        /// </summary>\n        /// <param name=\"businessId\">The tenant/business id to filter by (required).</param>\n        /// <param name=\"filter\">Optional filters for origin, flow, contact, and limit.</param>\n        Task<IReadOnlyList<FlowExecutionLogDto>> GetRecentExecutionsAsync(\n            Guid businessId,\n            FlowExecutionFilter filter,\n            CancellationToken ct = default);\n\n        Task<IReadOnlyList<FlowExecutionLogDto>> GetRunTimelineAsync(\n           Guid businessId,\n           Guid runId,\n           CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/DTOs/CreateAuditLogDto.cs",
      "sha256": "845322cca23fe6666ea3c5947bf45d55d34363c27d5bacec30375a04b24a73ef",
      "language": "csharp",
      "size": 471,
      "content": "namespace xbytechat.api.Features.AuditTrail.DTOs;\n\npublic class CreateAuditLogDto\n{\n    public string ActionType { get; set; }\n    public string Module { get; set; }\n    public string? RecordId { get; set; }\n\n    public string? OldValues { get; set; }\n    public string? NewValues { get; set; }\n    public string? Description { get; set; }\n\n    public string? IPAddress { get; set; }\n    public string? UserAgent { get; set; }\n    public string? Location { get; set; }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Models/AuditLog.cs",
      "sha256": "91e4760f6e10564db50d99acec9f1c83de5fd0b8ca2e0d3bc5874d645ac93a45",
      "language": "csharp",
      "size": 1034,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AuditTrail.Models\n{\n    public class AuditLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üìç Business Context (Multi-Tenant)\n        public Guid BusinessId { get; set; }\n\n        // üôã Who performed the action\n        public Guid PerformedByUserId { get; set; }\n        public string? PerformedByUserName { get; set; } // Optional for display\n        public string? RoleAtTime { get; set; } // admin / business / agent\n\n        // üîç Action Details\n        public string ActionType { get; set; } = \"\"; // e.g., campaign.created, user.login\n        public string? Description { get; set; } // Free text for summary or custom note\n\n        // üåê Optional: Technical metadata\n        public string? IPAddress { get; set; }\n        public string? UserAgent { get; set; }\n        public string? Location { get; set; } // Optional for geo-capture later\n\n        // üïí Timestamp\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Services/AuditLogService.cs",
      "sha256": "6b18d820c4191681a1bf26d6672f189bce0cadcfba3c8beb9e29dbed4ad4fdd9",
      "language": "csharp",
      "size": 536,
      "content": "using xbytechat.api.Features.AuditTrail.Models;\nusing xbytechat.api.Repositories;\nusing xbytechat.api.Repositories.Interfaces;\n\nnamespace xbytechat.api.Features.AuditTrail.Services\n{\n    public class AuditLogService : IAuditLogService\n    {\n        private readonly IGenericRepository<AuditLog> _repo;\n\n        public AuditLogService(IGenericRepository<AuditLog> repo)\n        {\n            _repo = repo;\n        }\n\n        public async Task SaveLogAsync(AuditLog log)\n        {\n            await _repo.AddAsync(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Services/IAuditLogService.cs",
      "sha256": "65d811af2c7dc349002b7b1a340a765025625f9fe31c241dccc8f3eaeab15330",
      "language": "csharp",
      "size": 197,
      "content": "using xbytechat.api.Features.AuditTrail.Models;\n\nnamespace xbytechat.api.Features.AuditTrail.Services\n{\n    public interface IAuditLogService\n    {\n        Task SaveLogAsync(AuditLog log);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/ChoiceConfig.cs",
      "sha256": "0d09e0bc40325856d625ab31e93694e661b6df532e5de78f2a55254783e40c1c",
      "language": "csharp",
      "size": 354,
      "content": "namespace xbytechat.api.Features.Automation.Config\n{\n    public class ChoiceConfig\n    {\n        public List<ChoiceCondition> Conditions { get; set; } = new();\n        public string FallbackNodeId { get; set; }\n    }\n\n    public class ChoiceCondition\n    {\n        public string Match { get; set; }\n        public string NextNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/MessageConfig.cs",
      "sha256": "564fbd35e79d9ef3f8b48ed54e15d55a9d0226b7d6ea72315d81b562a7a4ecae",
      "language": "csharp",
      "size": 225,
      "content": "namespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n\n        // Future: Add support for media, buttons, templates\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/TagNodeConfig.cs",
      "sha256": "81144c1418ba70285c6af13bf7aee6346f8f6674416ffc9ab79614bceb3be4d0",
      "language": "csharp",
      "size": 197,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/WaitConfig.cs",
      "sha256": "d13667732f9e18370123b10c2881aa385e8d11a33bc01acaf0f7eb96f4903bd6",
      "language": "csharp",
      "size": 170,
      "content": "namespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; } = 2; // Default wait time\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Controllers/AutomationController.cs",
      "sha256": "a8918574633489f57249d757a1f1c883a0c86531cbc734c67de68ba419caa957",
      "language": "csharp",
      "size": 2153,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Automation.DTOs;\nusing xbytechat.api.Features.Automation.Repositories;\nusing xbytechat.api.Features.Automation.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.CRM.Interfaces;\n\nnamespace xbytechat.api.Features.Automation.Controllers\n{\n    [ApiController]\n    [Route(\"api/automation\")]\n    [Authorize]\n    public class AutomationController : ControllerBase\n    {\n        private readonly IAutomationFlowRepository _automationRepository;\n        private readonly IAutomationRunner _automationRunner;\n        private readonly IContactService _contactService;\n\n        public AutomationController(\n            IAutomationFlowRepository automationRepository,\n            IAutomationRunner automationRunner,\n            IContactService contactService)\n        {\n            _automationRepository = automationRepository;\n            _automationRunner = automationRunner;\n            _contactService = contactService;\n        }\n\n        [HttpPost(\"trigger\")]\n        public async Task<IActionResult> TriggerByKeyword([FromBody] AutomationTriggerRequest request)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (string.IsNullOrWhiteSpace(request.Keyword) || string.IsNullOrWhiteSpace(request.Phone))\n                return BadRequest(\"Keyword and phone are required.\");\n\n            var flow = await _automationRepository.GetFlowByKeywordAsync(businessId, request.Keyword);\n            if (flow == null || !flow.IsActive)\n                return NotFound(\"‚ö†Ô∏è No matching active automation flow found.\");\n\n            var contact = await _contactService.FindOrCreateAsync(businessId, request.Phone);\n\n            var result = await _automationRunner.RunFlowAsync(\n                flow,\n                businessId,\n                contact.Id,\n                request.Phone,\n                request.SourceChannel ?? \"manual\",\n                request.IndustryTag ?? \"manual\"\n            );\n\n            return Ok(result);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/AutomationEdgeDto.cs",
      "sha256": "d9093a43a35fa0c12238f7c78daec3980190c4160320cfe73c6b93ff2d41c5ce",
      "language": "csharp",
      "size": 450,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.DTOs\n{\n    /// <summary>\n    /// Represents a connection (edge) between two automation nodes.\n    /// </summary>\n    public class AutomationEdgeDto\n    {\n        public Guid SourceNodeId { get; set; }\n\n        public Guid TargetNodeId { get; set; }\n\n        public string? Condition { get; set; }  // Optional: for future conditional routing (e.g., \"if clicked\", \"if not responded\")\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/AutomationTriggerRequest.cs",
      "sha256": "aeca572a0bab580b70dddd50cb6f4e1b282f17508311aaeb9beaefef34d8fa46",
      "language": "csharp",
      "size": 296,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class AutomationTriggerRequest\n    {\n        public string Keyword { get; set; }\n\n        public string Phone { get; set; }\n\n        public string? SourceChannel { get; set; }\n\n        public string? IndustryTag { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/MessageNodeConfig.cs",
      "sha256": "8fdadb2bb6457b35ed85d89655b1f6d1d9bc5028a0ec212d9dd7eaa70b1a8e0d",
      "language": "csharp",
      "size": 218,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class MessageNodeConfig\n    {\n        public string Text { get; set; } = string.Empty;\n\n        // Optional: Later you can add buttons, media, etc.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/TagNodeConfig.cs",
      "sha256": "2feaf9902643a6bb0e59b019cfca34a41ada3abf9f66afffcac065c6bb545b6c",
      "language": "csharp",
      "size": 199,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.DTOs\n{\n    public class TagNodeConfig\n    {\n        public List<Guid> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/WaitNodeConfig.cs",
      "sha256": "f520007158ae72db229b2a23f437666e64d34fcc96cdd728ad57a4320f152b75",
      "language": "csharp",
      "size": 143,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class WaitNodeConfig\n    {\n        public int Seconds { get; set; } = 3;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlow.cs",
      "sha256": "7dd5063615cfa824960a08fdd88d9fdf500a3c0461151b27e09fcaa7d97b45fe",
      "language": "csharp",
      "size": 803,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Represents a saved automation flow with nodes and edges.\n    /// </summary>\n    public class AutomationFlow\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n\n        public string TriggerKeyword { get; set; } = string.Empty; // ‚úÖ Better naming\n\n        public string NodesJson { get; set; } = \"[]\";\n\n        public string EdgesJson { get; set; } = \"[]\";\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowEdge.cs",
      "sha256": "ad1f63ff8580807f996a658e2a95652c94370929e8dd75eac9f1fdc98c398105",
      "language": "csharp",
      "size": 280,
      "content": "namespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowEdge\n    {\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n        public string? Condition { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowNode.cs",
      "sha256": "c18876f0d4c8fdf851da8df67ddff902fee66217b804a6765a9b533f8402e76d",
      "language": "csharp",
      "size": 354,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowNode\n    {\n        public string Id { get; set; } = Guid.NewGuid().ToString(\"N\");\n        public string Label { get; set; } = string.Empty;\n        public NodeTypeEnum NodeType { get; set; }\n        public string ConfigJson { get; set; } = \"{}\";\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowRunResult.cs",
      "sha256": "61407553e4f66fbfdc8c0a51868372170e58411cd6c74e857e8e9cab13e27b6b",
      "language": "csharp",
      "size": 403,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n        public Guid? HandoffNodeId { get; set; } = null;\n\n        public string? Notes { get; set; }  // Optional: track execution info (e.g., exit reason)\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/FlowExecutionContext.cs",
      "sha256": "aef2132567e314889ae4d98f06dd96c43873ab3513b6c02cd8553346e3e7ff57",
      "language": "csharp",
      "size": 523,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Context required to run an automation flow.\n    /// </summary>\n    public class FlowExecutionContext\n    {\n        public AutomationFlow Flow { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public Guid ContactId { get; set; }\n\n        public string ContactPhone { get; set; }\n\n        public string SourceChannel { get; set; } = \"manual\";\n\n        public string IndustryTag { get; set; } = \"manual\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/FlowRunResult.cs",
      "sha256": "64baa95c50dc4528fa36e8ad36a12ac82a0528c8c640797d16b58e17455d6125",
      "language": "csharp",
      "size": 345,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Represents the result of running an automation flow.\n    /// </summary>\n    public class FlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n        public Guid? HandoffNodeId { get; set; } // If agent handoff requested\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/NodeConfigs.cs",
      "sha256": "0e8b3fb72dd676ec59568e34b569e1302a621a35a6efca4553736f89b15b21c4",
      "language": "csharp",
      "size": 167,
      "content": "namespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/NodeTypeEnum.cs",
      "sha256": "ac2b60c1ffd633136ef56df710b0cf7f141496e92e30cd1c4bd42f201f4d85d3",
      "language": "csharp",
      "size": 223,
      "content": "namespace xbytechat.api.Features.Automation.Models\n{\n    public enum NodeTypeEnum\n    {\n        Message,\n        Wait,\n        Tag,\n        AgentHandoff,\n        Choice,\n        Condition,\n        Loop,\n        End\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/TagNodeConfig.cs",
      "sha256": "9cec10f188aea021e4b186075bf0f84e18cb4071046ade7098c2658d077559f5",
      "language": "csharp",
      "size": 201,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/WaitConfig.cs",
      "sha256": "641533b56ae811de7505263f827bc5f89cc405f67645b053fd06737f1e5fa621",
      "language": "csharp",
      "size": 153,
      "content": "namespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; } = 1;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Repositories/AutomationFlowRepository.cs",
      "sha256": "0e6a38673480db7c067e41901c2725f6c93683975ffaacfdcefb67bcfe90820e",
      "language": "csharp",
      "size": 3297,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Repositories\n{\n    public class AutomationFlowRepository : IAutomationFlowRepository\n    {\n        private readonly AppDbContext _db;\n\n        public AutomationFlowRepository(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<AutomationFlow?> GetByIdAsync(Guid flowId, Guid businessId)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n        }\n\n        public async Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f =>\n                    f.BusinessId == businessId &&\n                    f.TriggerKeyword.ToLower() == keyword.ToLower() &&\n                    f.IsActive);\n        }\n\n        public async Task<IEnumerable<AutomationFlow>> GetAllByBusinessAsync(Guid businessId)\n        {\n            return await _db.AutomationFlows\n                .Where(f => f.BusinessId == businessId && f.IsActive)\n                .OrderBy(f => f.Name)\n                .ToListAsync();\n        }\n\n        public async Task<AutomationFlow> CreateAsync(AutomationFlow flow)\n        {\n            flow.Id = Guid.NewGuid();\n            flow.CreatedAt = DateTime.UtcNow;\n            flow.IsActive = true;\n\n            _db.AutomationFlows.Add(flow);\n            await _db.SaveChangesAsync();\n            return flow;\n        }\n\n        public async Task<AutomationFlow> UpdateAsync(AutomationFlow flow)\n        {\n            var existing = await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flow.Id && f.BusinessId == flow.BusinessId && f.IsActive);\n\n            if (existing == null)\n                throw new KeyNotFoundException(\"Automation flow not found.\");\n\n            existing.Name = flow.Name;\n            existing.TriggerKeyword = flow.TriggerKeyword;\n            existing.NodesJson = flow.NodesJson;\n            existing.EdgesJson = flow.EdgesJson;\n            existing.UpdatedAt = DateTime.UtcNow;\n\n            _db.AutomationFlows.Update(existing);\n            await _db.SaveChangesAsync();\n\n            return existing;\n        }\n\n        public async Task<bool> DeleteAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n            if (flow == null)\n                return false;\n\n            flow.IsActive = false;\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            _db.AutomationFlows.Update(flow);\n            await _db.SaveChangesAsync();\n            return true;\n        }\n        public async Task<AutomationFlow?> GetByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f =>\n                f.BusinessId == businessId &&\n                EF.Functions.ILike(f.TriggerKeyword, keyword) &&\n                f.IsActive);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Repositories/IAutomationFlowRepository.cs",
      "sha256": "3c0e87413a797f0b2cb7de16b419204f9f84555fd58a4435ca5bffc5f570b2fe",
      "language": "csharp",
      "size": 1022,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Repositories\n{\n    public interface IAutomationFlowRepository\n    {\n        // üîç Get flow by unique FlowId + BusinessId (strict filtering)\n        Task<AutomationFlow?> GetByIdAsync(Guid flowId, Guid businessId);\n\n        // üîç Get flow by keyword for auto-trigger\n        Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword);\n\n        // üìã List all flows for business\n        Task<IEnumerable<AutomationFlow>> GetAllByBusinessAsync(Guid businessId);\n\n        // ‚ûï Create flow\n        Task<AutomationFlow> CreateAsync(AutomationFlow flow);\n\n        // ‚úèÔ∏è Update flow\n        Task<AutomationFlow> UpdateAsync(AutomationFlow flow);\n\n        // ‚ùå Delete flow\n        Task<bool> DeleteAsync(Guid flowId, Guid businessId);\n        Task<AutomationFlow?> GetByKeywordAsync(Guid businessId, string keyword);\n\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/AutomationRunner.cs",
      "sha256": "a72d4f5b71367cbace05c222c0bedc1f4eb84d97e9096a52211881f032a2323a",
      "language": "csharp",
      "size": 12642,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.EntityFrameworkCore;\nusing Newtonsoft.Json;\nusing xbytechat.api.Features.Automation.Models;\nusing xbytechat.api.Features.Automation.Models.Configs;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.Automation.Config;\nusing xbytechat.api.Features.CRM.Interfaces;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public class AutomationRunner : IAutomationRunner\n    {\n        private readonly IMessageEngineService _messageService;\n        private readonly IContactService _contactService;\n        private readonly ILogger<AutomationRunner> _logger;\n        private readonly AppDbContext _appDbContext;\n        public AutomationRunner(\n            IMessageEngineService messageService,\n            IContactService contactService,\n            ILogger<AutomationRunner> logger, AppDbContext appDbContext)\n        {\n            _messageService = messageService;\n            _contactService = contactService;\n            _logger = logger;\n            _appDbContext = appDbContext;\n        }\n\n        public async Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string sourceChannel,\n            string industryTag)\n        {\n            var nodes = JsonConvert.DeserializeObject<List<AutomationFlowNode>>(flow.NodesJson);\n            var edges = JsonConvert.DeserializeObject<List<AutomationFlowEdge>>(flow.EdgesJson);\n\n            var result = new AutomationFlowRunResult();\n            var currentNode = nodes.FirstOrDefault(); // Start from first node\n\n            if (currentNode == null)\n            {\n                _logger.LogWarning(\"üö´ Flow has no start node.\");\n                result.NeedsAgent = true;\n                result.Notes = \"No start node found.\";\n                return result;\n            }\n\n            while (currentNode != null)\n            {\n                _logger.LogInformation(\"‚û°Ô∏è Running node: {NodeType} | {NodeId}\", currentNode.NodeType, currentNode.Id);\n\n                switch (currentNode.NodeType)\n                {\n                    case NodeTypeEnum.Message:\n                        var msgCfg = JsonConvert.DeserializeObject<MessageConfig>(currentNode.ConfigJson);\n                        var msgDto = new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            RecipientNumber = contactPhone,\n                            TextContent = msgCfg.Text,\n                            Source = \"automation\"\n                        };\n                        _logger.LogInformation(\"üì§ Sending message: {Text}\", msgCfg.Text);\n                        await _messageService.SendAutomationReply(msgDto);\n                        break;\n\n                    case NodeTypeEnum.Wait:\n                        var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(currentNode.ConfigJson);\n                        _logger.LogInformation(\"‚è≥ Waiting {Seconds}s\", waitCfg.Seconds);\n                        await Task.Delay(waitCfg.Seconds * 1000);\n                        break;\n\n                    case NodeTypeEnum.Tag:\n                        var tagCfg = JsonConvert.DeserializeObject<TagNodeConfig>(currentNode.ConfigJson);\n                        _logger.LogInformation(\"üè∑Ô∏è Assigning tags: {Tags}\", string.Join(\", \", tagCfg.Tags));\n                        await _contactService.AssignTagsAsync(businessId, contactPhone, tagCfg.Tags);\n                        break;\n\n                    case NodeTypeEnum.AgentHandoff:\n                        result.NeedsAgent = true;\n                        if (Guid.TryParse(currentNode.Id, out var parsedId))\n                        {\n                            result.HandoffNodeId = parsedId;\n                        }\n                        else\n                        {\n                            _logger.LogWarning(\"‚ö†Ô∏è Invalid node ID format for AgentHandoff node: {Id}\", currentNode.Id);\n                            result.HandoffNodeId = null;\n                        }\n                        result.Notes = \"Flow routed to human agent.\";\n                        return result;\n\n                    case NodeTypeEnum.End:\n                        _logger.LogInformation(\"‚úÖ End node reached.\");\n                        currentNode = null;\n                        continue;\n\n                    case NodeTypeEnum.Choice:\n                        _logger.LogInformation(\"üß† Reached Choice node. Saving session state to wait for user input...\");\n\n                        var session = await _appDbContext.ChatSessionStates.FirstOrDefaultAsync(s =>\n                            s.BusinessId == businessId && s.ContactId == contactId);\n\n                        if (session == null)\n                        {\n                            session = new ChatSessionState\n                            {\n                                Id = Guid.NewGuid(),\n                                BusinessId = businessId,\n                                ContactId = contactId\n                            };\n                            _appDbContext.ChatSessionStates.Add(session);\n                        }\n\n                        session.Mode = \"awaiting_choice\";\n                        session.UpdatedBy = currentNode.Id.ToString();\n                        session.LastUpdatedAt = DateTime.UtcNow;\n\n                        await _appDbContext.SaveChangesAsync();\n\n                        result.Notes = \"Choice node reached. Flow paused.\";\n                        return result;\n                }\n\n                var edge = edges.FirstOrDefault(e => e.SourceNodeId == currentNode.Id);\n                currentNode = edge == null ? null : nodes.FirstOrDefault(n => n.Id == edge.TargetNodeId);\n            }\n\n            result.Notes = \"Flow completed.\";\n            return result;\n        }\n        public async Task<AutomationFlowRunResult> ResumeFlowAsync(\n           Guid businessId,\n           Guid contactId,\n           string contactPhone,\n           string incomingMessage)\n        {\n            var session = await _appDbContext.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            if (session == null || session.Mode != \"awaiting_choice\")\n            {\n                _logger.LogWarning(\"‚ùå No active automation session found or mode not awaiting_choice.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"No active automation session.\" };\n            }\n\n            var flow = await _appDbContext.AutomationFlows\n                .Where(f => f.BusinessId == businessId && f.IsActive)\n                .OrderByDescending(f => f.UpdatedAt)\n                .FirstOrDefaultAsync();\n\n            if (flow == null)\n            {\n                _logger.LogWarning(\"‚ùå No active automation flow found for business.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"No active flow found.\" };\n            }\n\n            var nodes = JsonConvert.DeserializeObject<List<AutomationFlowNode>>(flow.NodesJson);\n            var edges = JsonConvert.DeserializeObject<List<AutomationFlowEdge>>(flow.EdgesJson);\n\n            var choiceNode = nodes.FirstOrDefault(n => n.Id == session.UpdatedBy && n.NodeType == NodeTypeEnum.Choice);\n            if (choiceNode == null)\n            {\n                _logger.LogWarning(\"‚ùå Stored session node not found or not a Choice node.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Invalid Choice node in session.\" };\n            }\n\n            var cfg = JsonConvert.DeserializeObject<ChoiceConfig>(choiceNode.ConfigJson);\n            if (cfg?.Conditions == null)\n            {\n                _logger.LogWarning(\"‚ùå Choice config is null or empty.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Invalid Choice config.\" };\n            }\n\n            var match = cfg.Conditions.FirstOrDefault(c =>\n                string.Equals(c.Match.Trim(), incomingMessage.Trim(), StringComparison.OrdinalIgnoreCase));\n\n            string nextNodeId = match?.NextNodeId ?? cfg.FallbackNodeId;\n            if (match == null)\n            {\n                _logger.LogWarning(\"üîÅ No matching condition found. Using fallback: {Fallback}\", nextNodeId);\n            }\n\n            var nextNode = nodes.FirstOrDefault(n => n.Id == nextNodeId);\n            if (nextNode == null)\n            {\n                _logger.LogWarning(\"‚ùå Next node after choice not found.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Next node not found.\" };\n            }\n\n            // ‚úÖ Clear session after resume\n            _appDbContext.ChatSessionStates.Remove(session);\n            await _appDbContext.SaveChangesAsync();\n\n            // ‚úÖ Resume from the matched node using shared loop\n            return await ExecuteNodeLoopAsync(flow, nextNode, nodes, edges, businessId, contactId, contactPhone);\n        }\n\n\n        private async Task<AutomationFlowRunResult> ExecuteNodeLoopAsync(\n    AutomationFlow flow,\n    AutomationFlowNode startNode,\n    List<AutomationFlowNode> nodes,\n    List<AutomationFlowEdge> edges,\n    Guid businessId,\n    Guid contactId,\n    string contactPhone)\n        {\n            var result = new AutomationFlowRunResult();\n            var currentNode = startNode;\n\n            while (currentNode != null)\n            {\n                _logger.LogInformation(\"‚û°Ô∏è Executing node: {NodeType} | {NodeId}\", currentNode.NodeType, currentNode.Id);\n\n                switch (currentNode.NodeType)\n                {\n                    case NodeTypeEnum.Message:\n                        var msgCfg = JsonConvert.DeserializeObject<MessageConfig>(currentNode.ConfigJson);\n                        var msgDto = new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            RecipientNumber = contactPhone,\n                            TextContent = msgCfg.Text,\n                            Source = \"automation\"\n                        };\n                        await _messageService.SendAutomationReply(msgDto);\n                        break;\n\n                    case NodeTypeEnum.Tag:\n                        var tagCfg = JsonConvert.DeserializeObject<TagNodeConfig>(currentNode.ConfigJson);\n                        await _contactService.AssignTagsAsync(businessId, contactPhone, tagCfg.Tags);\n                        break;\n\n                    case NodeTypeEnum.Wait:\n                        var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(currentNode.ConfigJson);\n                        await Task.Delay(waitCfg.Seconds * 1000);\n                        break;\n\n                    case NodeTypeEnum.End:\n                        return new AutomationFlowRunResult { Notes = \"‚úÖ Flow ended.\" };\n\n                    case NodeTypeEnum.AgentHandoff:\n                        return new AutomationFlowRunResult\n                        {\n                            NeedsAgent = true,\n                            Notes = \"Routed to human agent.\"\n                        };\n\n                    case NodeTypeEnum.Choice:\n                        var session = new ChatSessionState\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            Mode = \"awaiting_choice\",\n                            UpdatedBy = currentNode.Id.ToString(),\n                            LastUpdatedAt = DateTime.UtcNow\n                        };\n                        _appDbContext.ChatSessionStates.Add(session);\n                        await _appDbContext.SaveChangesAsync();\n\n                        return new AutomationFlowRunResult { Notes = \"Paused at Choice node.\" };\n                }\n\n                var edge = edges.FirstOrDefault(e => e.SourceNodeId == currentNode.Id);\n                currentNode = edge == null ? null : nodes.FirstOrDefault(n => n.Id == edge.TargetNodeId);\n            }\n\n            return new AutomationFlowRunResult { Notes = \"Flow completed.\" };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/AutomationService.cs",
      "sha256": "ff80f3aa6181772b1eae30360dc0e8fb364a432f380e12f8a79d03f24618bdc4",
      "language": "csharp",
      "size": 5110,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Automation.Models;\nusing xbytechat.api.Features.Automation.Repositories;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public class AutomationService : IAutomationService\n    {\n        private readonly IAutomationFlowRepository _flowRepository;\n        private readonly IAutomationRunner _runner;\n        private readonly IContactService _contactService;\n        private readonly ILogger<AutomationService> _logger;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public AutomationService(\n            IAutomationFlowRepository flowRepository,\n            IAutomationRunner runner,\n            IContactService contactService,\n            ILogger<AutomationService> logger,\n            IHttpContextAccessor httpContextAccessor)\n        {\n            _flowRepository = flowRepository;\n            _runner = runner;\n            _contactService = contactService;\n            _logger = logger;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        public async Task<AutomationFlow?> GetFlowByIdAsync(Guid flowId, Guid businessId)\n        {\n            return await _flowRepository.GetByIdAsync(flowId, businessId);\n        }\n\n        public async Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _flowRepository.GetByKeywordAsync(businessId, keyword);\n        }\n\n        public async Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string phone,\n            string sourceChannel,\n            string industryTag)\n        {\n            return await _runner.RunFlowAsync(flow, businessId, contactId, phone, sourceChannel, industryTag);\n        }\n\n        public async Task<IEnumerable<AutomationFlow>> GetAllFlowsAsync(Guid businessId)\n        {\n            return await _flowRepository.GetAllByBusinessAsync(businessId);\n        }\n\n        public async Task<AutomationFlow> CreateFlowAsync(Guid businessId, AutomationFlow flow)\n        {\n            flow.BusinessId = businessId;\n            return await _flowRepository.CreateAsync(flow);\n        }\n\n        public async Task<bool> DeleteFlowAsync(Guid flowId, Guid businessId)\n        {\n            return await _flowRepository.DeleteAsync(flowId, businessId);\n        }\n\n        public async Task RunByKeywordAsync(string messageText, string phoneNumber, string sourceChannel = \"whatsapp\")\n        {\n            var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                ?? throw new UnauthorizedAccessException(\"BusinessId could not be resolved from context.\");\n\n            var flow = await _flowRepository.GetByKeywordAsync(businessId, messageText);\n            if (flow == null)\n            {\n                _logger.LogInformation(\"No matching automation flow for keyword: {Keyword}\", messageText);\n                return;\n            }\n\n            var contact = await _contactService.FindOrCreateAsync(businessId, phoneNumber);\n            await _runner.RunFlowAsync(flow, businessId, contact.Id, contact.PhoneNumber, sourceChannel, industryTag: \"default\");\n        }\n\n        public async Task<bool> TryRunFlowByKeywordAsync(\n         Guid businessId,\n         string messageText,\n         string userPhone,\n         string sourceChannel,\n         string industryTag)\n        {\n            try\n            {\n                // üîç Normalize keyword\n                var normalizedKeyword = messageText.Trim().ToLower();\n\n                // ‚úÖ Fetch flow by trigger keyword\n                var flow = await _flowRepository.GetByKeywordAsync(businessId, normalizedKeyword);\n                if (flow == null)\n                {\n                    _logger.LogInformation(\"TryRun: No matching automation flow found for keyword: '{Keyword}'\", normalizedKeyword);\n                    return false;\n                }\n\n                // üë§ Ensure contact exists\n                var contact = await _contactService.FindOrCreateAsync(businessId, userPhone);\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"‚ùå TryRun: Failed to resolve or create contact for phone: {Phone}\", userPhone);\n                    return false;\n                }\n\n                // ‚ñ∂Ô∏è Run automation flow\n                _logger.LogInformation(\"üöÄ Running flow '{FlowName}' for keyword '{Keyword}'\", flow.Name, normalizedKeyword);\n                await _runner.RunFlowAsync(flow, businessId, contact.Id, contact.PhoneNumber, sourceChannel, industryTag);\n\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå TryRun: Exception while executing flow for keyword '{Keyword}'\", messageText);\n                return false;\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/IAutomationRunner.cs",
      "sha256": "0aa081c7006bb76ff84c8cee9da21e51a021a69c4e0b6d191ffdc1356b5e4001",
      "language": "csharp",
      "size": 453,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public interface IAutomationRunner\n    {\n        Task<AutomationFlowRunResult> RunFlowAsync(\n             AutomationFlow flow,\n             Guid businessId,\n             Guid contactId,\n             string contactPhone,\n             string sourceChannel,\n             string industryTag\n );\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/IAutomationService.cs",
      "sha256": "fd32d83e0e970571048b14fb8805162a0b1139c917ed0bf99ad84b4a244ce609",
      "language": "csharp",
      "size": 1688,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public interface IAutomationService\n    {\n        // üìå Get flow by FlowId (for admin UI or debugging)\n        Task<AutomationFlow?> GetFlowByIdAsync(Guid flowId, Guid businessId);\n\n        // üìå Get flow by keyword match (used for auto-triggering)\n        Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword);\n\n        // üõ†Ô∏è Execute a flow with contact and channel info\n        Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string phone,\n            string sourceChannel,\n            string industryTag\n        );\n\n        // üìã List all flows (for admin or dashboard)\n        Task<IEnumerable<AutomationFlow>> GetAllFlowsAsync(Guid businessId);\n\n        // ‚ûï Create new flow\n        Task<AutomationFlow> CreateFlowAsync(Guid businessId, AutomationFlow flow);\n\n        // ‚ùå Delete existing flow\n        Task<bool> DeleteFlowAsync(Guid flowId, Guid businessId);\n\n        // ‚ö° Runtime entry point ‚Äì called when a message arrives\n        Task RunByKeywordAsync(\n            string messageText,\n            string phoneNumber,\n            string sourceChannel = \"whatsapp\"\n        );\n\n        // ‚úÖ Returns true if flow matched and executed\n        Task<bool> TryRunFlowByKeywordAsync(\n            Guid businessId,\n            string messageText,\n            string userPhone,\n            string sourceChannel,\n            string industryTag\n        );\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyFlowsController.cs",
      "sha256": "25ac7814daf6df137e5beb976fe5ba21a8d94fdb458c29a1a8531aea723c3077",
      "language": "csharp",
      "size": 12787,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    /// <summary>\n    /// Controller for AutoReply builder operations:\n    /// - CRUD for AutoReply flows used by the canvas UI\n    /// - Test-match endpoint used by the \"Test Auto-Reply Match\" panel\n    /// </summary>\n    [ApiController]\n    [Route(\"api/autoreplyflows\")]\n    [Authorize]\n    public sealed class AutoReplyFlowsController : ControllerBase\n    {\n        private readonly IAutoReplyFlowService _service;\n        private readonly IAutoReplyRuntimeService _runtime;\n        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n        public AutoReplyFlowsController(\n            IAutoReplyFlowService service,\n            IAutoReplyRuntimeService runtime,\n            ILogger<AutoReplyFlowsController> logger)\n        {\n            _service = service;\n            _runtime = runtime;\n            _logger = logger;\n        }\n\n        // ---------------------------------------------------------\n        // 1) LIST FLOWS  - used when the builder page loads\n        // GET /api/autoreplyflows\n        // ---------------------------------------------------------\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<AutoReplyFlowSummaryDto>>> GetAll(\n            CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var flows = await _service.GetFlowsForBusinessAsync(bizId, ct);\n            return Ok(flows);\n        }\n\n        // ---------------------------------------------------------\n        // 2) GET SINGLE FLOW - used when opening a specific flow\n        // GET /api/autoreplyflows/{id}\n        // ---------------------------------------------------------\n        [HttpGet(\"{id:guid}\")]\n        public async Task<ActionResult<AutoReplyFlowDto>> Get(Guid id, CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var flow = await _service.GetFlowAsync(bizId, id, ct);\n            if (flow is null) return NotFound();\n            return Ok(flow);\n        }\n\n        // ---------------------------------------------------------\n        // 3) CREATE / UPDATE FLOW - used when you click Save in builder\n        // POST /api/autoreplyflows\n        // ---------------------------------------------------------\n        [HttpPost]\n        public async Task<ActionResult<AutoReplyFlowDto>> Save(\n            [FromBody] AutoReplyFlowDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                _logger.LogWarning(\"AutoReplyFlow model invalid: {@ModelState}\", ModelState);\n                return ValidationProblem(ModelState);\n            }\n\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            var saved = await _service.SaveFlowAsync(bizId, dto, ct);\n            return Ok(saved);\n        }\n\n        // ---------------------------------------------------------\n        // 3a) BACK-COMPAT ALIAS FOR OLDER FRONTEND\n        // POST /api/autoreplyflows/save\n        // ---------------------------------------------------------\n        [HttpPost(\"save\")]\n        public Task<ActionResult<AutoReplyFlowDto>> SaveAlias(\n            [FromBody] AutoReplyFlowDto dto,\n            CancellationToken ct)\n            => Save(dto, ct);\n\n        // ---------------------------------------------------------\n        // 4) DELETE FLOW\n        // DELETE /api/autoreplyflows/{id}\n        // ---------------------------------------------------------\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete(Guid id, CancellationToken ct)\n        {\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n            await _service.DeleteFlowAsync(bizId, id, ct);\n            return NoContent();\n        }\n        // ---------------------------------------------------------\n        // 4a) UPDATE FLOW STATUS (ACTIVE / INACTIVE)\n        // PATCH /api/autoreplyflows/{id}/status\n        // ---------------------------------------------------------\n        [HttpPatch(\"{id:guid}/status\")]\n        public async Task<IActionResult> UpdateStatus(\n            Guid id,\n            [FromBody] AutoReplyFlowStatusUpdateDto dto,\n            CancellationToken ct)\n        {\n            if (dto is null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            var bizId = ClaimsBusinessDetails.GetBusinessId(User);\n\n            await _service.SetActiveAsync(\n                bizId,\n                id,\n                dto.IsActive,\n                ct);\n\n            return NoContent();\n        }\n\n        // ---------------------------------------------------------\n        // 5) TEST-MATCH ENDPOINT FOR BUILDER PANEL\n        // POST /api/autoreplyflows/test-match\n        //\n        // Frontend sends: { businessId, incomingText }\n        // Response: { isMatch, flowId, flowName, matchedKeyword, startNodeType, startNodeName }\n        // ---------------------------------------------------------\n        [HttpPost(\"test-match\")]\n        public async Task<ActionResult<AutoReplyTestMatchResponseDto>> TestMatchAsync(\n            [FromBody] AutoReplyTestMatchRequestDto dto,\n            CancellationToken ct)\n        {\n            if (!ModelState.IsValid)\n            {\n                return ValidationProblem(ModelState);\n            }\n\n            _logger.LogInformation(\n                \"üîç AutoReply test-match requested for Business {BusinessId} with text: {Text}\",\n                dto.BusinessId,\n                dto.IncomingText\n            );\n\n            // NOTE: Right now the runtime is mostly stubbed.\n            // This call will later contain the real keyword/flow matching logic.\n            var result = await _runtime.TestMatchAsync(dto.BusinessId, dto.IncomingText, ct);\n\n            var response = new AutoReplyTestMatchResponseDto\n            {\n                IsMatch = result.Handled,\n                FlowId = result.AutoReplyFlowId ?? result.CtaFlowConfigId,\n                FlowName = null, // will be filled when runtime returns metadata\n                MatchedKeyword = result.MatchedKeyword,\n                StartNodeType = null, // will be wired from CTAFlow metadata later\n                StartNodeName = null\n            };\n\n            return Ok(response);\n        }\n    }\n}\n\n\n//using System;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.AutoReplyBuilder.Services;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n//{\n//    /// <summary>\n//    /// Controller for AutoReply builder operations (test match, later maybe listing flows, etc.).\n//    /// </summary>\n//    [ApiController]\n//    [Route(\"api/autoreplyflows\")]\n//    public sealed class AutoReplyFlowsController : ControllerBase\n//    {\n//        private readonly IAutoReplyRuntimeService _autoReplyRuntime;\n//        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n//        public AutoReplyFlowsController(\n//            IAutoReplyRuntimeService autoReplyRuntime,\n//            ILogger<AutoReplyFlowsController> logger)\n//        {\n//            _autoReplyRuntime = autoReplyRuntime;\n//            _logger = logger;\n//        }\n\n//        /// <summary>\n//        /// Test whether a given incoming text would match any AutoReply rule.\n//        /// Used by the AutoReplyBuilder \"Test Auto-Reply Match\" panel.\n//        /// </summary>\n//        [HttpPost(\"test-match\")]\n//        public async Task<ActionResult<AutoReplyTestMatchResponseDto>> TestMatchAsync(\n//            [FromBody] AutoReplyTestMatchRequestDto dto,\n//            CancellationToken ct)\n//        {\n//            if (!ModelState.IsValid)\n//            {\n//                return ValidationProblem(ModelState);\n//            }\n\n//            _logger.LogInformation(\n//                \"üîç AutoReply test-match requested for Business {BusinessId} with text: {Text}\",\n//                dto.BusinessId,\n//                dto.IncomingText\n//            );\n\n//            var result = await _autoReplyRuntime.TestMatchAsync(dto.BusinessId, dto.IncomingText, ct);\n\n//            // For now, runtime always returns NotHandled, so IsMatch will be false.\n//            // Later, when we implement matching, Handled = true will mean a rule matched.\n//            var response = new AutoReplyTestMatchResponseDto\n//            {\n//                IsMatch = result.Handled,\n//                FlowId = result.AutoReplyFlowId ?? result.CtaFlowConfigId,\n//                FlowName = null, // will be populated once runtime can surface flow metadata\n//                MatchedKeyword = result.MatchedKeyword,\n//                StartNodeType = null, // to be filled when CTAFlow metadata is integrated\n//                StartNodeName = null  // same as above\n//            };\n\n//            return Ok(response);\n//        }\n//    }\n//}\n\n\n////using Microsoft.AspNetCore.Authorization;\n////using Microsoft.AspNetCore.Mvc;\n////using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n////using xbytechat.api.Shared;\n////using xbytechat.api.Features.AutoReplyBuilder.Services;\n////using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\n////namespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n////{\n////    [ApiController]\n////    [Route(\"api/autoreplyflows\")]\n////    [Authorize]\n////    public sealed class AutoReplyFlowsController : ControllerBase\n////    {\n////        private readonly IAutoReplyFlowService _service;\n////        private readonly IAutoReplyRuntimeService _runtime;\n////        private readonly ILogger<AutoReplyFlowsController> _logger;\n\n////        public AutoReplyFlowsController(\n////            IAutoReplyFlowService service,\n////            IAutoReplyRuntimeService runtime,\n////            ILogger<AutoReplyFlowsController> logger)\n////        {\n////            _service = service;\n////            _runtime = runtime;\n////            _logger = logger;\n////        }\n\n////        // GET /api/autoreplyflows\n////        [HttpGet]\n////        public async Task<ActionResult<IEnumerable<AutoReplyFlowSummaryDto>>> GetAll(CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            var flows = await _service.GetFlowsForBusinessAsync(bizId, ct);\n////            return Ok(flows);\n////        }\n\n////        // GET /api/autoreplyflows/{id}\n////        [HttpGet(\"{id:guid}\")]\n////        public async Task<ActionResult<AutoReplyFlowDto>> Get(Guid id, CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            var flow = await _service.GetFlowAsync(bizId, id, ct);\n////            if (flow is null) return NotFound();\n////            return Ok(flow);\n////        }\n\n////        // POST /api/autoreplyflows (create or update)\n////        [HttpPost]\n////        public async Task<ActionResult<AutoReplyFlowDto>> Save([FromBody] AutoReplyFlowDto dto, CancellationToken ct)\n////        {\n////            if (!ModelState.IsValid)\n////            {\n////                _logger.LogWarning(\"AutoReplyFlow model invalid: {@ModelState}\", ModelState);\n////                return ValidationProblem(ModelState);\n////            }\n\n////            var bizId = User.GetBusinessId();\n////            var saved = await _service.SaveFlowAsync(bizId, dto, ct);\n////            return Ok(saved);\n////        }\n\n////        // Back-compat alias for older frontend\n////        [HttpPost(\"save\")]\n////        public Task<ActionResult<AutoReplyFlowDto>> SaveAlias([FromBody] AutoReplyFlowDto dto, CancellationToken ct) => Save(dto, ct);\n\n////        // DELETE /api/autoreplyflows/{id}\n////        [HttpDelete(\"{id:guid}\")]\n////        public async Task<IActionResult> Delete(Guid id, CancellationToken ct)\n////        {\n////            var bizId = User.GetBusinessId();\n////            await _service.DeleteFlowAsync(bizId, id, ct);\n////            return NoContent();\n////        }\n\n////        // POST /api/autoreplyflows/test-match\n////        [HttpPost(\"test-match\")]\n////        public async Task<ActionResult<AutoReplyMatchResultDto>> TestMatch([FromBody] AutoReplyMatchRequestDto request, CancellationToken ct)\n////        {\n////            var result = await _runtime.FindMatchAsync(request, ct);\n////            return Ok(result);\n////        }\n////    }\n////}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyLogsController.cs",
      "sha256": "73bd3aafc0179cf97c57ab38413426d298cba586c91bbed26edadc7c77b691f8",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    /// <summary>\n    /// Read-only endpoints for AutoReply logs, used by the builder UI.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize] // same auth pattern as other feature controllers\n    public class AutoReplyLogsController : ControllerBase\n    {\n        private readonly IAutoReplyLogService _logService;\n\n        public AutoReplyLogsController(IAutoReplyLogService logService)\n        {\n            _logService = logService;\n        }\n\n        /// <summary>\n        /// Returns most recent auto-reply triggers for the current business.\n        /// GET /api/autoreplylogs/recent?take=20\n        /// </summary>\n        [HttpGet(\"recent\")]\n        [ProducesResponseType(typeof(IReadOnlyList<AutoReplyLogSummaryDto>), 200)]\n        public async Task<ActionResult<IReadOnlyList<AutoReplyLogSummaryDto>>> GetRecentAsync(\n            [FromQuery] int take = 20,\n            CancellationToken cancellationToken = default)\n        {\n            // BusinessId comes from JWT claims\n            var businessId = User.GetBusinessId();\n\n            if (businessId == Guid.Empty)\n            {\n                return Unauthorized(\"Missing or invalid business id in token.\");\n            }\n\n            var items = await _logService.GetRecentAsync(\n                businessId,\n                take,\n                cancellationToken);\n\n            return Ok(items);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyRuntimeController.cs",
      "sha256": "a9f67fd1830276dc16b500b095809916f5e927e4468ad792e90bb991da999ceb",
      "language": "csharp",
      "size": 2328,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"api/auto-reply-runtime\")]\n    [Authorize]\n    public class AutoReplyRuntimeController : ControllerBase\n    {\n        private readonly IAutoReplyRuntimeService _runtimeService;\n        private readonly ILogger<AutoReplyRuntimeController> _logger;\n\n        public AutoReplyRuntimeController(\n            IAutoReplyRuntimeService runtimeService,\n            ILogger<AutoReplyRuntimeController> logger)\n        {\n            _runtimeService = runtimeService;\n            _logger = logger;\n        }\n\n        // üîÅ Simple button-click matcher (uses the new keyword matcher under the hood)\n        [HttpPost(\"button-click\")]\n        public async Task<ActionResult<AutoReplyMatchResultDto>> HandleButtonClick([FromBody] AutoReplyButtonClickDto dto)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n\n            _logger.LogInformation(\"üîò Button clicked: BusinessId={BusinessId}, Phone={Phone}, Button={ButtonText}, RefMsg={RefMessageId}\",\n                businessId, dto.Phone, dto.ButtonText, dto.RefMessageId?.ToString() ?? \"null\");\n\n            var result = await _runtimeService.FindMatchAsync(\n                new AutoReplyMatchRequestDto\n                {\n                    BusinessId = businessId,\n                    IncomingText = dto.ButtonText ?? string.Empty\n                });\n\n            return Ok(result);\n        }\n\n        // üß™ Manual test (canvas-based flow trigger) - now returns a match preview only\n        [HttpPost(\"flow-by-button\")]\n        public async Task<ActionResult<AutoReplyMatchResultDto>> TriggerFlowByButton([FromBody] AutoReplyButtonClickDto dto)\n        {\n            var businessId = dto.BusinessId != Guid.Empty ? dto.BusinessId : ClaimsBusinessDetails.GetBusinessId(User);\n            var match = await _runtimeService.FindMatchAsync(new AutoReplyMatchRequestDto\n            {\n                BusinessId = businessId,\n                IncomingText = dto.ButtonText ?? string.Empty\n            });\n\n            return Ok(match);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/TemplatesController.cs",
      "sha256": "555d0e0c3deaa65e82290ddcf55e06bb4fa67bbcf43e5b9d56ea5109f7c236b8",
      "language": "csharp",
      "size": 995,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.TemplateMessages.DTOs;\n\nnamespace xbytechat.api.Features.TemplateMessages.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TemplatesController : ControllerBase\n    {\n        private static readonly List<TemplateDto> MockTemplates = new()\n        {\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Welcome Template\",\n                Placeholders = 2\n            },\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Offer Reminder\",\n                Placeholders = 1\n            },\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Follow Up\",\n                Placeholders = 3\n            }\n        };\n\n        [HttpGet]\n        public ActionResult<List<TemplateDto>> GetAll()\n        {\n            return Ok(MockTemplates);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyButtonClickDto.cs",
      "sha256": "c33e345f9a02ff4d627ba42ba92505f5819a034035b07bde678784a244b9d6ac",
      "language": "csharp",
      "size": 412,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class AutoReplyButtonClickDto\n    {\n        public Guid FlowId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string Phone { get; set; } = string.Empty;\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? RefMessageId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowDefinitionDto.cs",
      "sha256": "4c8f724416a637942e075af6566e476ec364a649fe98839fc0288bcefbc2277d",
      "language": "csharp",
      "size": 3849,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Runtime shape for an AutoReply flow definition, deserialized from AutoReplyFlow.NodesJson.\n    /// This is NOT an EF entity and is never mapped to a DB table.\n    /// </summary>\n    public sealed class AutoReplyFlowDefinitionDto\n    {\n        /// <summary>\n        /// Optional ‚Äì if your NodesJson stores the starting node id.\n        /// If your runtime method uses this, it will be populated; otherwise it can stay null/empty.\n        /// </summary>\n        public string? StartNodeId { get; set; }\n\n        /// <summary>\n        /// All nodes that belong to this flow, in whatever order they were saved by the builder.\n        /// ExecuteFlowLinearAsync can order or chain them as it likes.\n        /// </summary>\n        public List<AutoReplyFlowNodeDto> Nodes { get; set; } = new();\n    }\n\n    /// <summary>\n    /// Runtime shape for a single node inside an AutoReply flow.\n    /// This is intentionally kept as a \"flattened\" shape that matches the\n    /// needs of ExecuteFlowLinearAsync:\n    /// - Node type (message / template / set-tag / wait)\n    /// - Content fields for that type\n    /// - Linear chaining info (Order / NextNodeId)\n    /// </summary>\n    public sealed class AutoReplyFlowNodeDto\n    {\n        /// <summary>\n        /// Unique id of the node inside this flow (often the same as the ReactFlow node id).\n        /// </summary>\n        public string Id { get; set; } = null!;\n\n        /// <summary>\n        /// Node type. Expected values (by the new runtime) include:\n        /// \"message\", \"template\", \"set-tag\", \"wait\"\n        /// </summary>\n        public string Type { get; set; } = null!;\n\n        /// <summary>\n        /// Optional friendly name / label shown in the builder UI.\n        /// Not required for runtime, but useful for logs and debugging.\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// Execution order for linear flows, if you are ordering by an explicit number.\n        /// If your runtime doesn‚Äôt use this, it can safely remain 0.\n        /// </summary>\n        public int Order { get; set; }\n\n        // ----- Content for \"message\" nodes -----\n\n        /// <summary>\n        /// Plain text to send for \"message\" type nodes.\n        /// </summary>\n        public string? Text { get; set; }\n\n        // ----- Content for \"template\" nodes -----\n\n        /// <summary>\n        /// Template name for \"template\" type nodes.\n        /// </summary>\n        public string? TemplateName { get; set; }\n\n        /// <summary>\n        /// Optional template namespace / category if you store it.\n        /// </summary>\n        public string? TemplateNamespace { get; set; }\n\n        /// <summary>\n        /// Optional template language code (e.g., \"en\", \"en_US\").\n        /// </summary>\n        public string? TemplateLanguage { get; set; }\n\n        // ----- Content for \"set-tag\" nodes -----\n\n        /// <summary>\n        /// Tag key to set on the contact (e.g., \"lead_stage\").\n        /// </summary>\n        public string? TagKey { get; set; }\n\n        /// <summary>\n        /// Tag value to set on the contact (e.g., \"hot\", \"warm\", \"cold\").\n        /// </summary>\n        public string? TagValue { get; set; }\n\n        // ----- Content for \"wait\" nodes -----\n\n        /// <summary>\n        /// Delay for \"wait\" nodes, in seconds.\n        /// </summary>\n        public int? WaitSeconds { get; set; }\n\n        // ----- Basic chaining -----\n\n        /// <summary>\n        /// Next node id for simple linear flows.\n        /// If your runtime walks the flow by following NextNodeId,\n        /// this will be populated when saving from the builder.\n        /// </summary>\n        public string? NextNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowDto.cs",
      "sha256": "8e0d6126ca3f97d47b6802a4f859f24ab1ba134be25ee89b6746df52ffc34fee",
      "language": "csharp",
      "size": 3507,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Full flow DTO (including nodes) for CRUD in the builder.\n    /// </summary>\n    public sealed class AutoReplyFlowDto\n    {\n        public Guid? Id { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; }\n\n        /// <summary>\n        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\".\n        /// </summary>\n        public string? TriggerKeyword { get; set; }\n\n        public string? IndustryTag { get; set; }\n\n        public string? UseCase { get; set; }\n\n        public bool IsDefaultTemplate { get; set; }\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Defaults to \"Word\" on the backend when not provided.\n        /// </summary>\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher values win. Default is 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n\n        /// <summary>\n        /// When the flow was first created (UTC).\n        /// </summary>\n        public DateTime CreatedAt { get; set; }\n\n        /// <summary>\n        /// When the flow was last updated (UTC). Null if never updated after creation.\n        /// </summary>\n        public DateTime? UpdatedAt { get; set; }\n\n        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n    }\n}\n\n\n//using System;\n//using System.Collections.Generic;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n//{\n//    /// <summary>\n//    /// Full flow DTO (including nodes) for CRUD in the builder.\n//    /// </summary>\n//    public sealed class AutoReplyFlowDto\n//    {\n//        public Guid? Id { get; set; }\n\n//        public string Name { get; set; } = string.Empty;\n\n//        public string? Description { get; set; }\n\n//        public bool IsActive { get; set; }\n\n//        public string? TriggerKeyword { get; set; }\n\n//        public string? IndustryTag { get; set; }\n\n//        public string? UseCase { get; set; }\n\n//        public bool IsDefaultTemplate { get; set; }\n\n//        /// <summary>\n//        /// When the flow was first created (UTC).\n//        /// </summary>\n//        public DateTime CreatedAt { get; set; }\n\n//        /// <summary>\n//        /// When the flow was last updated (UTC). Null if never updated after creation.\n//        /// </summary>\n//        public DateTime? UpdatedAt { get; set; }\n\n//        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n//    }\n//}\n\n\n//using System;\n//using System.Collections.Generic;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n//{\n//    /// <summary>\n//    /// Full flow DTO (including nodes) for CRUD in the builder.\n//    /// </summary>\n//    public sealed class AutoReplyFlowDto\n//    {\n//        public Guid? Id { get; set; }\n//        public string Name { get; set; } = string.Empty;\n//        public string? Description { get; set; }\n//        public bool IsActive { get; set; }\n//        public string? TriggerKeyword { get; set; }\n//        public string? IndustryTag { get; set; }\n//        public string? UseCase { get; set; }\n//        public bool IsDefaultTemplate { get; set; }\n//        public List<AutoReplyNodeDto> Nodes { get; set; } = new();\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowStatusUpdateDto.cs",
      "sha256": "ba3e8768d81a1c89519ccb2061a16b269765b8bf58fd2874adecfb0e99fe7903",
      "language": "csharp",
      "size": 459,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Simple DTO used to toggle the active status of an AutoReplyFlow\n    /// from the Flows modal (Activate / Deactivate).\n    /// </summary>\n    public sealed class AutoReplyFlowStatusUpdateDto\n    {\n        /// <summary>\n        /// True to mark the flow as active, false to deactivate it.\n        /// </summary>\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyFlowSummaryDto.cs",
      "sha256": "0e7186cfa19fdb74bd8833bdf02389698600b368428dfde4f96d1f8290035540",
      "language": "csharp",
      "size": 944,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Lightweight projection for list screens.\n    /// </summary>\n    public sealed class AutoReplyFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public bool IsActive { get; set; }\n\n        public string? TriggerKeyword { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? UpdatedAt { get; set; }\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Default is \"Word\".\n        /// </summary>\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher values win. Default is 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyLogDto.cs",
      "sha256": "dd13070b128bd950f4a1234e9f4d72c462a54c9add4b75cdd3146d7a05c7c4e6",
      "language": "csharp",
      "size": 1728,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// DTO used to log when an AutoReply flow is triggered for a contact.\n    /// </summary>\n    public class AutoReplyLogDto\n    {\n        /// <summary>\n        /// Primary key of the log entry.\n        /// </summary>\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// Business (tenant) that owns this log entry.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact that triggered this auto-reply.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Type of trigger. Currently always \"flow\" since the legacy rule engine is removed.\n        /// </summary>\n        public string TriggerType { get; set; } = \"flow\";\n\n        /// <summary>\n        /// The keyword that matched and caused the flow to trigger.\n        /// </summary>\n        public string TriggerKeyword { get; set; } = string.Empty;\n\n        /// <summary>\n        /// The reply content that was sent (for auditing / analytics).\n        /// </summary>\n        public string ReplyContent { get; set; } = string.Empty;\n\n        /// <summary>\n        /// UTC timestamp when the auto-reply was triggered.\n        /// </summary>\n        public DateTime TriggeredAt { get; set; }\n\n        /// <summary>\n        /// Optional human-friendly name of the flow that handled the message.\n        /// </summary>\n        public string? FlowName { get; set; }\n\n        /// <summary>\n        /// Optional reference to the outbound MessageLog row that represents the sent auto-reply.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyLogSummaryDto.cs",
      "sha256": "2f6883f2a2298da7abbafad539c5126c4a8ec49cd73c4da82f53b7e8d0ed26b8",
      "language": "csharp",
      "size": 644,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Lightweight read model for showing recent auto-reply triggers\n    /// in the builder UI.\n    /// </summary>\n    public sealed class AutoReplyLogSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string? TriggerType { get; set; }\n        public string? TriggerKeyword { get; set; }\n        public string? FlowName { get; set; }\n        public string? ReplyContent { get; set; }\n        public Guid? ContactId { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public DateTime TriggeredAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyMatchRequestDto.cs",
      "sha256": "25f4ad69dbe593fa20f959847f215102af791cbd025936ae93b6658d4344be13",
      "language": "csharp",
      "size": 352,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Minimal request for testing runtime auto-reply flow matching.\n    /// </summary>\n    public sealed class AutoReplyMatchRequestDto\n    {\n        public Guid BusinessId { get; set; }\n        public string IncomingText { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyMatchResultDto.cs",
      "sha256": "6ed66ea75c1c11f1baa718db9002019e755393a93e1dae1b941a84b4c6a2fd65",
      "language": "csharp",
      "size": 598,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Result of a runtime match attempt.\n    /// </summary>\n    public sealed class AutoReplyMatchResultDto\n    {\n        public Guid? FlowId { get; set; }\n        public string? FlowName { get; set; }\n        public string? MatchedKeyword { get; set; }\n        public string? MatchType { get; set; }\n        public Guid? StartNodeId { get; set; }\n        public string? StartNodeType { get; set; }\n        public string? StartNodeConfigJson { get; set; }\n        public bool IsMatch { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyNodeDto.cs",
      "sha256": "82540be38bfc3ac4fea1deafff566c384f68b97f8492374619440e52133f21bd",
      "language": "csharp",
      "size": 689,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// DTO for a single node inside an auto-reply flow.\n    /// Maps directly to <see cref=\"Models.AutoReplyFlowNode\"/> so builder edits round-trip cleanly.\n    /// </summary>\n    public sealed class AutoReplyNodeDto\n    {\n        public Guid? Id { get; set; }\n        public string NodeType { get; set; } = string.Empty;\n        public string? Label { get; set; }\n        public string? NodeName { get; set; }\n        public string? ConfigJson { get; set; }\n        public double PositionX { get; set; }\n        public double PositionY { get; set; }\n        public int Order { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyTestMatchRequestDto.cs",
      "sha256": "a8c862e0b53ae6f8dd27d5e7491b372192ed4bb196cf42e7fb15364c7a82efc6",
      "language": "csharp",
      "size": 692,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Request body for POST /api/autoreplyflows/test-match.\n    /// Sent by the AutoReplyBuilder UI when testing a sample message.\n    /// </summary>\n    public sealed class AutoReplyTestMatchRequestDto\n    {\n        /// <summary>\n        /// Business (tenant) ID ‚Äì taken from the logged-in user's auth context in the UI.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Sample incoming text typed by the user in the \"Test Auto-Reply Match\" panel.\n        /// </summary>\n        public string IncomingText { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyTestMatchResponseDto.cs",
      "sha256": "c52ef35fdd714cd41dcb48bd3729017170cbec767dbd748c362495b94ba9f5a3",
      "language": "csharp",
      "size": 1244,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Response shape for POST /api/autoreplyflows/test-match.\n    /// This is what the AutoReplyBuilder UI expects in testResult.\n    /// </summary>\n    public sealed class AutoReplyTestMatchResponseDto\n    {\n        /// <summary>\n        /// True if a matching AutoReply flow was found for the given text.\n        /// </summary>\n        public bool IsMatch { get; set; }\n\n        /// <summary>\n        /// The matched AutoReply flow ID, if any.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// The matched AutoReply flow name, if available.\n        /// </summary>\n        public string? FlowName { get; set; }\n\n        /// <summary>\n        /// The keyword or rule that matched, for display/debugging.\n        /// </summary>\n        public string? MatchedKeyword { get; set; }\n\n        /// <summary>\n        /// The type of the Start node (e.g. \"message\", \"template\", etc.).\n        /// </summary>\n        public string? StartNodeType { get; set; }\n\n        /// <summary>\n        /// The name/label of the Start node.\n        /// </summary>\n        public string? StartNodeName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowExecutionContextDto.cs",
      "sha256": "46002b4a0231f0341915cd9d899d5264fb27bdaa0b829348f628f9e655a274fc",
      "language": "csharp",
      "size": 1390,
      "content": "using System;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// Runtime-only context for executing an AutoReply flow.\n    /// This is NOT an EF entity ‚Äì it will never create a DB table.\n    /// </summary>\n    public class FlowExecutionContextDto\n    {\n        /// <summary>\n        /// The AutoReply flow being executed (DB entity loaded from AutoReplyFlow table).\n        /// </summary>\n        public AutoReplyFlow Flow { get; set; } = null!;\n\n        /// <summary>\n        /// Business (tenant) ID for scoping.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact ID in your CRM / Contacts table.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (MSISDN) of the contact.\n        /// </summary>\n        public string ContactPhone { get; set; } = null!;\n\n        /// <summary>\n        /// Channel source, e.g. \"whatsapp\". Kept flexible for future multi-channel.\n        /// </summary>\n        public string SourceChannel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Optional industry tag (restaurant, clinic, etc.) for analytics / specialization.\n        /// </summary>\n        public string IndustryTag { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ButtonChoiceNodeConfig.cs",
      "sha256": "a573ed18c3b3cce438f3f126b958408f9c6245ac01be98c3db1d0c4a92adbb18",
      "language": "csharp",
      "size": 577,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ButtonChoiceNodeConfig\n    {\n        public string PromptText { get; set; } = \"Please choose an option:\";\n\n        public List<ButtonOption> Options { get; set; } = new();\n    }\n\n    public class ButtonOption\n    {\n        public string Label { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n\n        // Optional metadata to control button behavior\n        public string? NextStepHint { get; set; } // Can guide user or be used for logging\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ConditionNodeConfig.cs",
      "sha256": "836736c40f25f700d3a84836ee147930568713f5f623bcdc1569b42ff5b4432e",
      "language": "csharp",
      "size": 306,
      "content": "using System.Collections.Generic;\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ConditionNodeConfig\n    {\n    \n        public string InputKey { get; set; } = \"buttonText\";\n\n        public Dictionary<string, string> PathMap { get; set; } = new();\n       \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/DecisionNodeConfig.cs",
      "sha256": "5575668b5865a5bb2847165208e60278c44386e8f710abb968606e22bb52fe70",
      "language": "csharp",
      "size": 418,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class DecisionNodeConfig\n    {\n        public string ConditionType { get; set; } = \"keyword\"; // or \"tag\", \"time\", \"plan\", etc.\n        public string Parameter { get; set; } = string.Empty;   // e.g. \"yes\", \"vip\", \"evening\"\n        public string SourceChannel { get; set; } = \"whatsapp\"; // Optional for multi-channel control\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/FormInputNodeConfig.cs",
      "sha256": "34b1ef9a54bc19dbb2163a80371edaf8d5bf75420e9924e90e82762fa4831216",
      "language": "csharp",
      "size": 596,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class FormInputNodeConfig\n    {\n        public string QuestionText { get; set; } = \"Please enter your response:\";\n\n        public string FieldKey { get; set; } = \"customer_name\";\n        // Used for storing user response under a label\n\n        public string? ValidationRegex { get; set; }\n        // Optional, e.g., @\"^[0-9]{10}$\" for phone numbers\n\n        public string? PlaceholderHint { get; set; }\n        // e.g., \"Full Name\", \"10-digit Phone\"\n\n        public bool IsRequired { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/FormNodeConfig.cs",
      "sha256": "f839475742eb0fc23ab0c6e58e1f23a0583e4b649301ac588feb0808dd1c243d",
      "language": "csharp",
      "size": 818,
      "content": "using System.Collections.Generic;\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class FormNodeConfig\n    {\n        public string Title { get; set; } = \"Please fill out this form\";\n\n        public List<FormFieldConfig> Fields { get; set; } = new();\n\n        public bool SaveToContact { get; set; } = true; // Whether to update contact info\n\n        public string? SubmitMessage { get; set; } = \"Thanks for submitting!\";\n    }\n\n    public class FormFieldConfig\n    {\n        public string Key { get; set; } = string.Empty;      // contactName, email, phone\n        public string Label { get; set; } = string.Empty;    // \"Your Name\"\n        public string Type { get; set; } = \"text\";           // text, number, email, etc.\n        public bool Required { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ForwardToAgentNodeConfig.cs",
      "sha256": "486eab52256f3ee2bfea5f06ada3bf8fade4f055f1012e4a1291ac0e61c9f35c",
      "language": "csharp",
      "size": 268,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ForwardToAgentNodeConfig\n    {\n        public string? NoteToAgent { get; set; } // Optional instruction for agent\n        public bool MarkAsUrgent { get; set; } = false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/NodeIconMap.cs",
      "sha256": "e56ce9b9bdedf03682aaa6c56815fb85dd510ecd2ec1e4c82f53c0fa5c8f9401",
      "language": "csharp",
      "size": 591,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class NodeIconMap\n    {\n        public static readonly Dictionary<string, string> IconMap = new()\n        {\n            { NodeTypeEnum.Message, \"üó®Ô∏è\" },\n            { NodeTypeEnum.Template, \"üìÑ\" },\n            { NodeTypeEnum.Tag, \"üè∑Ô∏è\" },\n            { NodeTypeEnum.Wait, \"‚è±Ô∏è\" },\n            { NodeTypeEnum.ButtonChoice, \"üîò\" },\n            { NodeTypeEnum.Branch, \"üåø\" },\n            { NodeTypeEnum.AgentHandoff, \"üë®‚Äçüíº\" },\n            { NodeTypeEnum.End, \"‚õî\" }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/NodeTypeEnum.cs",
      "sha256": "d21739b3b7651f2a026a4e412de76d45fe215ae50907b0c7ee025bee0c1ed189",
      "language": "csharp",
      "size": 572,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class NodeTypeEnum\n    {\n        public const string Message = \"message\";\n        public const string Template = \"template\";\n        public const string Tag = \"tag\";\n        public const string Wait = \"wait\";\n        public const string ButtonChoice = \"button_choice\";\n        public const string Branch = \"branch\";\n        public const string End = \"end\"; // Optional: Used for flow exit\n        public const string AgentHandoff = \"agent_handoff\"; // Optional: Transfer to human\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/RenameFlowDto.cs",
      "sha256": "c2ad4577f121df77190a9463e0eb6528c20054bd0901e7bc9a355aedfb53031c",
      "language": "csharp",
      "size": 146,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class RenameFlowDto\n    {\n        public string NewName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/SaveFlowDto.cs",
      "sha256": "b4b9d49533bad3114236c255a28ecc08bc82a01f1141b981146f320c76cc39f4",
      "language": "csharp",
      "size": 2315,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs\n{\n    public class SaveFlowDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; }\n        public string? TriggerKeyword { get; set; }\n        public List<NodeDto> Nodes { get; set; } = new();\n        public List<EdgeDto> Edges { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n\n        public string? IndustryTag { get; set; }     // e.g. \"restaurant\", \"clinic\", etc.\n        public string? UseCase { get; set; }         // e.g. \"Order Flow\", \"Appointment Flow\"\n        public bool IsDefaultTemplate { get; set; } = false; // Flag for prebuilt templates\n\n    }\n\n    public class NodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n        public string Type { get; set; } = string.Empty;\n        public AutoPositionDto Position { get; set; } = new();\n        public NodeDataDto Data { get; set; } = new();\n    }\n\n    public class AutoPositionDto\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n    }\n\n    public class NodeDataDto\n    {\n        public string Label { get; set; } = string.Empty;\n        public object Config { get; set; } = new { };\n    }\n\n    public class EdgeDto\n    {\n        public string Id { get; set; } = string.Empty;\n        public string Source { get; set; } = string.Empty;\n        public string Target { get; set; } = string.Empty;\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n        public string SourceHandle { get; set; } = string.Empty;\n        public string TargetHandle { get; set; } = string.Empty;\n    }\n}\n\n\n//using System;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs\n//{\n//    public class SaveFlowDto\n//    {\n//        public Guid Id { get; set; }\n//        public Guid BusinessId { get; set; }\n//        public string Name { get; set; } = string.Empty;\n//        public List<Dictionary<string, object>> Nodes { get; set; }\n\n//        public List<Dictionary<string, object>> Edges { get; set; }\n//        public DateTime CreatedAt { get; set; }\n//        public string? TriggerKeyword { get; set; }\n\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/TemplateDto.cs",
      "sha256": "42ae32842447bb89f8178a8bae3c490d1fe646b526c27cbe72571e23536f7116",
      "language": "csharp",
      "size": 240,
      "content": "namespace xbytechat.api.Features.TemplateMessages.DTOs\n{\n    public class TemplateDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public int Placeholders { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/AutoReplyEdgeDto.cs",
      "sha256": "5cbac1daff177794f7ae69aabf6b323f279f0b7132dc060e462a91226849f868",
      "language": "csharp",
      "size": 264,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class AutoReplyEdgeDto\n    {\n        public string Id { get; set; }\n        public string SourceNodeId { get; set; }\n        public string TargetNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/MessageConfig.cs",
      "sha256": "6e7673134b9b3fabb432529dd4b510007ff1d934f016b3a2d831a4503d01c2c7",
      "language": "csharp",
      "size": 201,
      "content": "// MessageConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/RuntimeConfigs.cs",
      "sha256": "280793d810ae7ce0f016f2671b3627cd52a4029b6ea574d0fee20e0c0e11e5ae",
      "language": "csharp",
      "size": 125,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class RuntimeConfigs\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/TagNodeConfig.cs",
      "sha256": "d9fade9fca5845b7cb33279a01288a4dd94a90aaaed58d384a778209656b5ead",
      "language": "csharp",
      "size": 197,
      "content": "// TagConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/TemplateConfig.cs",
      "sha256": "5c7ea8f78b131705f6bccf1ced0e21a754dadf67bbd6420696995f565c07767a",
      "language": "csharp",
      "size": 682,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class TemplateConfig\n    {\n        public string TemplateName { get; set; } = string.Empty;\n        public List<string> Placeholders { get; set; } = new();\n        public string? Language { get; set; } = \"en_US\";\n        public string? ImageUrl { get; set; }\n        public List<TemplateButtonDto>? MultiButtons { get; set; } = new();\n    }\n\n    public class TemplateButtonDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"url\"; // or \"quick_reply\"\n        public string TargetUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/WaitConfig.cs",
      "sha256": "afe336952d0d4959422bbbc499884b286291888fcbd64dd068f26013160261c6",
      "language": "csharp",
      "size": 179,
      "content": "// WaitConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/Enum/NodeTypes.cs",
      "sha256": "94b210bd5bbbbce823c3a1beb8172eddf708305bfbb8b897d1e3c7ef10097b36",
      "language": "csharp",
      "size": 538,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.Enum\n{\n    public class NodeTypes\n    {\n        public const string Start = \"start\";\n        public const string Message = \"message\";\n        public const string Template = \"template\";\n        public const string Wait = \"wait\";\n        public const string Tag = \"tag\";\n        public const string Agent = \"agent\";\n        public const string Condition = \"condition\"; // Coming soon\n        public const string Form = \"form\";           // For ‚ÄúAsk Name‚Äù, ‚ÄúAsk Email‚Äù\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlow.cs",
      "sha256": "4010a313f312dd02ea7373389accf18917c52426f75519fa7691d773cb7e60ce",
      "language": "csharp",
      "size": 3631,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Models\n{\n    public class AutoReplyFlow\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public string Name { get; set; } = string.Empty;\n\n        [Required]\n        public string NodesJson { get; set; } = string.Empty;\n\n        [Required]\n        public string EdgesJson { get; set; } = string.Empty;\n\n        // Stored in UTC; set on first create\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // Nullable; updated on every SaveFlowAsync\n        public DateTime? UpdatedAt { get; set; }\n\n        /// <summary>\n        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\"\n        /// </summary>\n        public string? TriggerKeyword { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        // Optional metadata for templates / catalog\n        public string? IndustryTag { get; set; }    // e.g., \"restaurant\", \"clinic\", \"education\"\n        public string? UseCase { get; set; }        // e.g., \"Order Flow\", \"Booking Flow\"\n\n        /// <summary>\n        /// Flag to indicate system-provided template (vs user-created).\n        /// </summary>\n        public bool IsDefaultTemplate { get; set; } = false;\n\n        /// <summary>\n        /// Matching mode for this flow:\n        /// \"Exact\" | \"Word\" | \"StartsWith\" | \"Contains\".\n        /// Default: \"Word\".\n        /// </summary>\n        [MaxLength(32)]\n        public string MatchMode { get; set; } = \"Word\";\n\n        /// <summary>\n        /// Priority for choosing between multiple matching flows.\n        /// Higher value wins.\n        /// Default: 0.\n        /// </summary>\n        public int Priority { get; set; } = 0;\n\n        /// <summary>\n        /// Legacy alias for TriggerKeyword; still populated for older code paths.\n        /// </summary>\n        public string? Keyword { get; set; }\n    }\n}\n\n\n\n\n//using System;\n//using System.ComponentModel.DataAnnotations;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Flows.Models\n//{\n//    public class AutoReplyFlow\n//    {\n//        [Key]\n//        public Guid Id { get; set; }\n\n//        public Guid BusinessId { get; set; }\n\n//        [Required]\n//        public string Name { get; set; } = string.Empty;\n\n//        [Required]\n//        public string NodesJson { get; set; } = string.Empty;\n\n//        [Required]\n//        public string EdgesJson { get; set; } = string.Empty;\n\n//        // Stored in UTC; set on first create\n//        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n//        // Nullable; updated on every SaveFlowAsync\n//        public DateTime? UpdatedAt { get; set; }\n\n//        /// <summary>\n//        /// Comma / newline separated trigger keywords, e.g. \"hi, hello\"\n//        /// </summary>\n//        public string? TriggerKeyword { get; set; }\n\n//        public bool IsActive { get; set; } = true;\n\n//        // Optional metadata for templates / catalog\n//        public string? IndustryTag { get; set; }    // e.g., \"restaurant\", \"clinic\", \"education\"\n//        public string? UseCase { get; set; }        // e.g., \"Order Flow\", \"Booking Flow\"\n\n//        /// <summary>\n//        /// Flag to indicate system-provided template (vs user-created).\n//        /// </summary>\n//        public bool IsDefaultTemplate { get; set; } = false;\n\n//        /// <summary>\n//        /// Legacy alias for TriggerKeyword; still populated for older code paths.\n//        /// </summary>\n//        public string? Keyword { get; set; }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlowEdge.cs",
      "sha256": "7996bdb8fa1917943e90dad9ad4225984a34b6342eb153028849b30ca63abd7f",
      "language": "csharp",
      "size": 763,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyFlowEdge\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow Flow { get; set; }\n\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n    \n        public string? SourceHandle { get; set; }\n        public string? TargetHandle { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlowNode.cs",
      "sha256": "88a50d45fe3b72f6c3bc0593104b7ee549180c842628cb3d9048c5227a025871",
      "language": "csharp",
      "size": 1013,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyFlowNode\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow Flow { get; set; }\n\n        // üîÑ Use a constrained string or enum (recommended for future)\n        [Required]\n        public string NodeType { get; set; } = string.Empty;\n\n        public string Label { get; set; } = string.Empty;\n\n        public string? NodeName { get; set; } // üÜï Optional internal label for debugging\n\n        [Required]\n        public string ConfigJson { get; set; } = string.Empty;\n\n        public Position Position { get; set; } = new();\n\n        public int Order { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyLog.cs",
      "sha256": "6683278ee0d8c068bb3a8b08629bb11c8b223bb71c9b00f2b1567560ad515d22",
      "language": "csharp",
      "size": 908,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    [Table(\"AutoReplyLogs\")]\n    public class AutoReplyLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string TriggerKeyword { get; set; } = string.Empty; // e.g., \"hi\", \"price\"\n        public string TriggerType { get; set; } = \"flow\";    // \"flow\" or \"rule\"\n\n        public string ReplyContent { get; set; } = string.Empty;    // Plaintext summary of what was sent\n        public string? FlowName { get; set; }                       // Nullable if rule-based\n\n        public Guid? MessageLogId { get; set; }                     // Optional link to MessageLog\n        public DateTime TriggeredAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowNode.cs",
      "sha256": "8991ad6277d58a2785f6a93fd8b8ca815af4ce80351d38f30aaf47890909471f",
      "language": "csharp",
      "size": 318,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class FlowNode\n    {\n        public string Id { get; set; }\n        public string Type { get; set; }\n        public Position Position { get; set; }\n        public Dictionary<string, object> Data { get; set; }  // This should capture config\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowRunResult.cs",
      "sha256": "67982580319a635214c13b2ec05cc279d9afc21fdeb1224248a8060036e27f5c",
      "language": "csharp",
      "size": 463,
      "content": "// File: Features/AutoReplyBuilder/Models/FlowRunResult.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    /// <summary>\n    /// Encapsulates the result of running a visual flow, including agent handoff status.\n    /// </summary>\n    public class FlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n\n        public Guid? HandoffNodeId { get; set; }\n\n        public string? ContextJson { get; set; }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/Position.cs",
      "sha256": "0c352c43f4dfcebdc462622ca0acdcd8c1eaafa07a91a70804793d8c76724201",
      "language": "csharp",
      "size": 176,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class Position\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyFlowRepository.cs",
      "sha256": "d919b1d695c3c29ccc653b806d4884197b3d52fb9eb5f86c0f32f893eb198671",
      "language": "csharp",
      "size": 4350,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\npublic class AutoReplyFlowRepository : IAutoReplyFlowRepository\n{\n    private readonly AppDbContext _context;\n    private readonly ILogger<AutoReplyFlowRepository> _logger;\n\n    public AutoReplyFlowRepository(AppDbContext context, ILogger<AutoReplyFlowRepository> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public async Task<AutoReplyFlow> SaveAsync(AutoReplyFlow flow)\n    {\n        _context.AutoReplyFlows.Add(flow);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"‚ùå Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return flow;\n    }\n\n    public async Task SaveNodesAndEdgesAsync(IEnumerable<AutoReplyFlowNode> nodes, IEnumerable<AutoReplyFlowEdge> edges)\n    {\n        _context.AutoReplyFlowNodes.AddRange(nodes);\n        _context.AutoReplyFlowEdges.AddRange(edges);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"‚ùå Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n    }\n\n    public async Task<List<AutoReplyFlow>> GetAllByBusinessIdAsync(Guid businessId)\n    {\n        return await _context.AutoReplyFlows\n            .Where(f => f.BusinessId == businessId)\n            .OrderByDescending(f => f.CreatedAt)\n            .ToListAsync();\n    }\n\n    public async Task<AutoReplyFlow?> GetByIdAsync(Guid flowId, Guid businessId)\n    {\n        return await _context.AutoReplyFlows\n            .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n    }\n\n    public async Task<int> GetFlowCountAsync(Guid businessId)\n    {\n        return await _context.AutoReplyFlows.CountAsync(f => f.BusinessId == businessId);\n    }\n\n    public async Task<bool> RenameFlowAsync(Guid id, string newName)\n    {\n        var flow = await _context.AutoReplyFlows.FindAsync(id);\n        if (flow == null) return false;\n\n        flow.Name = newName;\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"‚ùå Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return true;\n    }\n\n    public async Task<bool> DeleteFlowAsync(Guid id, Guid businessId)\n    {\n        var flow = await _context.AutoReplyFlows\n            .FirstOrDefaultAsync(f => f.Id == id && f.BusinessId == businessId);\n\n        if (flow == null) return false;\n\n        _context.AutoReplyFlows.Remove(flow);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"‚ùå Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return true;\n    }\n    public async Task<List<AutoReplyFlowNode>> GetNodesByFlowIdAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowNodes\n            .Where(n => n.FlowId == flowId)\n            .ToListAsync();\n    }\n\n    public async Task<List<AutoReplyFlowEdge>> GetEdgesByFlowIdAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowEdges\n            .Where(e => e.FlowId == flowId)\n            .ToListAsync();\n    }\n    public async Task<AutoReplyFlow?> FindFlowByKeywordAsync(Guid businessId, string keyword)\n    {\n        return await _context.AutoReplyFlows\n            .Where(f => f.BusinessId == businessId && f.IsActive && f.TriggerKeyword == keyword)\n            .OrderByDescending(f => f.CreatedAt)\n            .FirstOrDefaultAsync();\n    }\n    public async Task<List<AutoReplyFlowNode>> GetStructuredNodesAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowNodes\n            .Where(n => n.FlowId == flowId)\n            .ToListAsync();\n    }\n\n    public async Task<List<AutoReplyFlowEdge>> GetStructuredEdgesAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowEdges\n            .Where(e => e.FlowId == flowId)\n            .ToListAsync();\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyLogRepository.cs",
      "sha256": "4a8777aecfb95fef141063dfa3475992a3848fdd582209819e66ab552d045f71",
      "language": "csharp",
      "size": 1569,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Models;\nusing xbytechat.api.Shared;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public class AutoReplyLogRepository : IAutoReplyLogRepository\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<AutoReplyLogRepository> _logger;\n\n        public AutoReplyLogRepository(AppDbContext context, ILogger<AutoReplyLogRepository> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task SaveAsync(AutoReplyLogDto dto)\n        {\n            try\n            {\n                var log = new AutoReplyLog\n                {\n                    Id = dto.Id,\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    TriggerKeyword = dto.TriggerKeyword,\n                    TriggerType = dto.TriggerType,\n                    ReplyContent = dto.ReplyContent,\n                    TriggeredAt = dto.TriggeredAt,\n                    FlowName = dto.FlowName,\n                    MessageLogId = dto.MessageLogId\n                };\n\n                _context.AutoReplyLogs.Add(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to save AutoReplyLog\");\n                throw;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyFlowRepository.cs",
      "sha256": "f78ae431c2892c49cc0844c2f19e5df301598c964326722b3ca52aec7e9ba61d",
      "language": "csharp",
      "size": 1161,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories\n{\n    public interface IAutoReplyFlowRepository\n    {\n        Task<AutoReplyFlow> SaveAsync(AutoReplyFlow flow);\n        Task<AutoReplyFlow?> GetByIdAsync(Guid flowId, Guid businessId);\n        Task<List<AutoReplyFlow>> GetAllByBusinessIdAsync(Guid businessId);\n        Task<int> GetFlowCountAsync(Guid businessId);\n        Task<bool> RenameFlowAsync(Guid id, string newName);\n        Task<bool> DeleteFlowAsync(Guid id, Guid businessId);\n        Task SaveNodesAndEdgesAsync(IEnumerable<AutoReplyFlowNode> nodes, IEnumerable<AutoReplyFlowEdge> edges);\n        Task<List<AutoReplyFlowNode>> GetNodesByFlowIdAsync(Guid flowId);\n        Task<List<AutoReplyFlowEdge>> GetEdgesByFlowIdAsync(Guid flowId);\n        Task<AutoReplyFlow?> FindFlowByKeywordAsync(Guid businessId, string keyword);\n        Task<List<AutoReplyFlowNode>> GetStructuredNodesAsync(Guid flowId);\n        Task<List<AutoReplyFlowEdge>> GetStructuredEdgesAsync(Guid flowId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyLogRepository.cs",
      "sha256": "49f1ecf8c4ab7bb6a0122d7d98e22eb4cb6e2b4b522c99c3963ca64d57889264",
      "language": "csharp",
      "size": 255,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public interface IAutoReplyLogRepository\n    {\n        Task SaveAsync(AutoReplyLogDto logDto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyFlowService.cs",
      "sha256": "2145c395e2e5488a5f0e21d854bba3ab8c61fc831b8369e19789c390c8f6d5ef",
      "language": "csharp",
      "size": 9422,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Minimal CRUD service for the Auto-Reply flow builder.\n    /// Keeps one flow -> many nodes persisted in PostgreSQL.\n    /// </summary>\n    public class AutoReplyFlowService : IAutoReplyFlowService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<AutoReplyFlowService> _log;\n\n        public AutoReplyFlowService(AppDbContext db, ILogger<AutoReplyFlowService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task<IReadOnlyList<AutoReplyFlowSummaryDto>> GetFlowsForBusinessAsync(Guid businessId, CancellationToken ct = default)\n        {\n            return await _db.AutoReplyFlows\n                .AsNoTracking()\n                .Where(f => f.BusinessId == businessId)\n                .OrderByDescending(f => f.CreatedAt)\n                .Select(f => new AutoReplyFlowSummaryDto\n                {\n                    Id = f.Id,\n                    Name = f.Name,\n                    IsActive = f.IsActive,\n                    TriggerKeyword = f.TriggerKeyword,\n                    CreatedAt = f.CreatedAt,\n                    UpdatedAt = f.UpdatedAt // entity does not currently track updates\n                })\n                .ToListAsync(ct);\n        }\n\n        public async Task<AutoReplyFlowDto?> GetFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows\n                .AsNoTracking()\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n\n            if (flow == null)\n            {\n                return null;\n            }\n\n            var nodes = await _db.AutoReplyNodes\n                .AsNoTracking()\n                .Where(n => n.FlowId == flowId)\n                .OrderBy(n => n.Order)\n                .ThenBy(n => n.CreatedAt)\n                .ToListAsync(ct);\n\n            return MapToDto(flow, nodes);\n        }\n\n        public async Task<AutoReplyFlowDto> SaveFlowAsync(\n        Guid businessId,\n        AutoReplyFlowDto dto,\n        CancellationToken ct = default)\n        {\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n            if (string.IsNullOrWhiteSpace(dto.Name))\n                throw new ArgumentException(\"Name is required\", nameof(dto));\n\n            _log.LogInformation(\n                \"[AutoReplyFlow] SaveFlowAsync biz={BusinessId} flow={FlowName}\",\n                businessId,\n                dto.Name);\n\n            var flow = dto.Id.HasValue\n                ? await _db.AutoReplyFlows.FirstOrDefaultAsync(\n                    f => f.Id == dto.Id.Value && f.BusinessId == businessId,\n                    ct)\n                : null;\n\n            var isNew = flow == null;\n            if (isNew)\n            {\n                flow = new AutoReplyFlow\n                {\n                    Id = dto.Id ?? Guid.NewGuid(),\n                    BusinessId = businessId,\n                    CreatedAt = DateTime.UtcNow,\n                };\n                _db.AutoReplyFlows.Add(flow);\n            }\n\n            // üîß Core fields\n            flow.Name = dto.Name.Trim();\n            flow.TriggerKeyword = dto.TriggerKeyword?.Trim();\n            flow.Keyword = dto.TriggerKeyword?.Trim(); // legacy alias used elsewhere\n            flow.IsActive = dto.IsActive;\n            flow.IndustryTag = dto.IndustryTag;\n            flow.UseCase = dto.UseCase;\n            flow.IsDefaultTemplate = dto.IsDefaultTemplate;\n\n            // üïí Always stamp \"last updated\"\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            // Ensure required JSON columns never stay null (legacy storage)\n            flow.NodesJson = string.IsNullOrWhiteSpace(flow.NodesJson) ? \"[]\" : flow.NodesJson;\n            flow.EdgesJson = string.IsNullOrWhiteSpace(flow.EdgesJson) ? \"[]\" : flow.EdgesJson;\n\n            // Replace nodes wholesale for now (simple + safe for MVP)\n            var existingNodes = await _db.AutoReplyNodes\n                .Where(n => n.FlowId == flow.Id)\n                .ToListAsync(ct);\n\n            if (existingNodes.Count > 0)\n            {\n                _db.AutoReplyNodes.RemoveRange(existingNodes);\n            }\n\n            var incomingNodes = dto.Nodes ?? new List<AutoReplyNodeDto>();\n\n            var newNodes = incomingNodes.Select((n, index) => new AutoReplyFlowNode\n            {\n                Id = n.Id == null || n.Id == Guid.Empty ? Guid.NewGuid() : n.Id.Value,\n                FlowId = flow.Id,\n                NodeType = n.NodeType,\n                Label = n.Label ?? string.Empty,\n                NodeName = string.IsNullOrWhiteSpace(n.NodeName) ? n.Label : n.NodeName,\n                ConfigJson = string.IsNullOrWhiteSpace(n.ConfigJson) ? \"{}\" : n.ConfigJson,\n                Position = new Position\n                {\n                    X = n.PositionX,\n                    Y = n.PositionY\n                },\n                Order = n.Order != 0 ? n.Order : index,\n                CreatedAt = DateTime.UtcNow\n            }).ToList();\n\n            if (newNodes.Count > 0)\n            {\n                _db.AutoReplyNodes.AddRange(newNodes);\n\n                // üîÅ Keep NodesJson in sync with the rows (only fields runtime cares about)\n                var nodesJsonPayload = newNodes\n                    .Select(n => new\n                    {\n                        Id = (Guid?)n.Id,\n                        NodeType = n.NodeType,\n                        NodeName = n.NodeName,\n                        ConfigJson = n.ConfigJson,\n                        Order = n.Order\n                    })\n                    .ToList();\n\n                flow.NodesJson = System.Text.Json.JsonSerializer.Serialize(nodesJsonPayload);\n            }\n            else\n            {\n                flow.NodesJson = \"[]\";\n            }\n\n            await _db.SaveChangesAsync(ct);\n\n            return MapToDto(flow, newNodes);\n        }\n\n\n\n        public async Task DeleteFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows.FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n            if (flow == null)\n            {\n                _log.LogInformation(\"[AutoReplyFlow] Delete skipped - not found biz={BusinessId} flowId={FlowId}\", businessId, flowId);\n                return;\n            }\n\n            _db.AutoReplyFlows.Remove(flow); // nodes cascade via FK\n            await _db.SaveChangesAsync(ct);\n            _log.LogInformation(\"[AutoReplyFlow] Deleted biz={BusinessId} flowId={FlowId}\", businessId, flowId);\n        }\n        public async Task SetActiveAsync(\n    Guid businessId,\n    Guid flowId,\n    bool isActive,\n    CancellationToken ct = default)\n        {\n            var flow = await _db.AutoReplyFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId, ct);\n\n            if (flow == null)\n            {\n                _log.LogWarning(\n                    \"[AutoReplyFlow] SetActiveAsync: flow not found. Biz={BusinessId}, Flow={FlowId}\",\n                    businessId,\n                    flowId);\n                return;\n            }\n\n            if (flow.IsActive == isActive)\n            {\n                _log.LogDebug(\n                    \"[AutoReplyFlow] SetActiveAsync: no-op, already IsActive={IsActive}. Biz={BusinessId}, Flow={FlowId}\",\n                    isActive,\n                    businessId,\n                    flowId);\n                return;\n            }\n\n            flow.IsActive = isActive;\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync(ct);\n\n            _log.LogInformation(\n                \"[AutoReplyFlow] SetActiveAsync: updated IsActive={IsActive}. Biz={BusinessId}, Flow={FlowId}\",\n                isActive,\n                businessId,\n                flowId);\n        }\n\n        private static AutoReplyFlowDto MapToDto(\n     AutoReplyFlow flow,\n     IReadOnlyCollection<AutoReplyFlowNode> nodes)\n        {\n            return new AutoReplyFlowDto\n            {\n                Id = flow.Id,\n                Name = flow.Name,\n                IsActive = flow.IsActive,\n                TriggerKeyword = flow.TriggerKeyword ?? flow.Keyword,\n                IndustryTag = flow.IndustryTag,\n                UseCase = flow.UseCase,\n                IsDefaultTemplate = flow.IsDefaultTemplate,\n                CreatedAt = flow.CreatedAt,\n                UpdatedAt = flow.UpdatedAt,\n                Nodes = nodes.Select(n => new AutoReplyNodeDto\n                {\n                    Id = n.Id,\n                    NodeType = n.NodeType,\n                    Label = n.Label,\n                    NodeName = n.NodeName,\n                    ConfigJson = n.ConfigJson,\n                    PositionX = n.Position?.X ?? 0,\n                    PositionY = n.Position?.Y ?? 0,\n                    Order = n.Order\n                }).ToList()\n            };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyLogService.cs",
      "sha256": "62ff3476179f2420bd95eb00c54f7ad8a33f2600eac49979f8a8e0886d429e43",
      "language": "csharp",
      "size": 4764,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Query-only service for reading AutoReplyLogs for analytics / UI.\n    /// </summary>\n    public sealed class AutoReplyLogService : IAutoReplyLogService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly ILogger<AutoReplyLogService> _logger;\n\n        public AutoReplyLogService(\n            AppDbContext dbContext,\n            ILogger<AutoReplyLogService> logger)\n        {\n            _dbContext = dbContext;\n            _logger = logger;\n        }\n\n        public async Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n            Guid businessId,\n            int take,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return Array.Empty<AutoReplyLogSummaryDto>();\n            }\n\n            // Clamp \"take\" to safe range\n            if (take <= 0) take = 20;\n            if (take > 100) take = 100;\n\n            _logger.LogDebug(\n                \"Fetching {Take} recent AutoReplyLogs for BusinessId={BusinessId}\",\n                take, businessId);\n\n            var query = _dbContext.Set<AutoReplyLog>()\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId)\n                .OrderByDescending(x => x.TriggeredAt)\n                .Take(take);\n\n            var items = await query\n                .Select(x => new AutoReplyLogSummaryDto\n                {\n                    Id = x.Id,\n                    TriggerType = x.TriggerType,\n                    TriggerKeyword = x.TriggerKeyword,\n                    FlowName = x.FlowName,\n                    ReplyContent = x.ReplyContent,\n                    ContactId = x.ContactId,\n                    MessageLogId = x.MessageLogId,\n                    TriggeredAt = x.TriggeredAt\n                })\n                .ToListAsync(cancellationToken);\n\n            return items;\n        }\n    }\n}\n\n\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api;\n//using xbytechat.api.Features.AutoReplyBuilder.DTOs;\n//using xbytechat.api.Features.AutoReplyBuilder.Models;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Services\n//{\n//    /// <summary>\n//    /// Query-only service for reading AutoReplyLogs for analytics / UI.\n//    /// </summary>\n//    public sealed class AutoReplyLogService : IAutoReplyLogService\n//    {\n//        private readonly AppDbContext _dbContext;\n//        private readonly ILogger<AutoReplyLogService> _logger;\n\n//        public AutoReplyLogService(\n//            AppDbContext dbContext,\n//            ILogger<AutoReplyLogService> logger)\n//        {\n//            _dbContext = dbContext;\n//            _logger = logger;\n//        }\n\n//        public async Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n//            Guid businessId,\n//            int take,\n//            CancellationToken cancellationToken = default)\n//        {\n//            if (businessId == Guid.Empty)\n//            {\n//                return Array.Empty<AutoReplyLogSummaryDto>();\n//            }\n\n//            // clamp \"take\" to a safe range\n//            if (take <= 0) take = 20;\n//            if (take > 100) take = 100;\n\n//            _logger.LogDebug(\n//                \"Fetching {Take} recent AutoReplyLogs for BusinessId={BusinessId}\",\n//                take, businessId);\n\n//            var query = _dbContext.Set<AutoReplyLog>()\n//                .AsNoTracking()\n//                .Where(x => x.BusinessId == businessId)\n//                .OrderByDescending(x => x.TriggeredAt)\n//                .Take(take);\n\n//            var items = await query\n//                .Select(x => new AutoReplyLogSummaryDto\n//                {\n//                    Id = x.Id,\n//                    TriggerType = x.TriggerType,\n//                    TriggerKeyword = x.TriggerKeyword,\n//                    FlowName = x.FlowName,\n//                    ReplyContent = x.ReplyContent,\n//                    ContactId = x.ContactId,\n//                    MessageLogId = x.MessageLogId,\n//                    TriggeredAt = x.TriggeredAt\n//                })\n//                .ToListAsync(cancellationToken);\n\n//            return items;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyRuntimeResult.cs",
      "sha256": "73f400851fbb9d03de3a8766167d5fff0a8f423760ac0a9e1f73c549d712987d",
      "language": "csharp",
      "size": 3973,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Result of trying to handle an incoming message via AutoReply.\n    /// This is used by the webhook and by the test-match endpoint.\n    /// </summary>\n    public class AutoReplyRuntimeResult\n    {\n        /// <summary>\n        /// True if this incoming message was handled by AutoReply logic\n        /// (either by sending a simple reply or starting a CTA flow).\n        /// </summary>\n        public bool Handled { get; set; }\n\n        /// <summary>\n        /// True if we sent an immediate/simple reply (text/template) as part of handling.\n        /// </summary>\n        public bool SentSimpleReply { get; set; }\n\n        /// <summary>\n        /// True if, instead of only replying once, we started a CTA flow journey.\n        /// </summary>\n        public bool StartedCtaFlow { get; set; }\n\n        /// <summary>\n        /// The AutoReply flow/rule that matched (if any).\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// If a CTA flow was started, this is the CTAFlowConfig.Id that was kicked off.\n        /// </summary>\n        public Guid? CtaFlowConfigId { get; set; }\n\n        /// <summary>\n        /// The keyword or pattern that matched, for debugging/analytics.\n        /// </summary>\n        public string? MatchedKeyword { get; set; }\n\n        /// <summary>\n        /// Optional notes for logging / debugging (e.g. why nothing matched).\n        /// </summary>\n        public string? Notes { get; set; }\n\n        /// <summary>\n        /// (Test-mode only) Type of the first action node we plan to execute\n        /// in the matched flow (e.g. \"message\", \"wait\", \"set-tag\").\n        /// </summary>\n        public string? StartNodeType { get; set; }\n\n        /// <summary>\n        /// (Test-mode only) Display name of the first action node.\n        /// </summary>\n        public string? StartNodeName { get; set; }\n\n        // ---- Helper factories ----\n\n        public static AutoReplyRuntimeResult NotHandled(string? notes = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = false,\n                SentSimpleReply = false,\n                StartedCtaFlow = false,\n                Notes = notes,\n                AutoReplyFlowId = null,\n                CtaFlowConfigId = null,\n                MatchedKeyword = null,\n                StartNodeType = null,\n                StartNodeName = null\n            };\n\n        public static AutoReplyRuntimeResult SimpleReply(\n            Guid? autoReplyFlowId,\n            string? matchedKeyword = null,\n            string? notes = null,\n            string? startNodeType = null,\n            string? startNodeName = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = true,\n                SentSimpleReply = true,\n                StartedCtaFlow = false,\n                AutoReplyFlowId = autoReplyFlowId,\n                CtaFlowConfigId = null,\n                MatchedKeyword = matchedKeyword,\n                Notes = notes,\n                StartNodeType = startNodeType,\n                StartNodeName = startNodeName\n            };\n\n        public static AutoReplyRuntimeResult CtaFlowStarted(\n            Guid? autoReplyFlowId,\n            Guid? ctaFlowConfigId,\n            string? matchedKeyword = null,\n            string? notes = null,\n            string? startNodeType = null,\n            string? startNodeName = null) =>\n            new AutoReplyRuntimeResult\n            {\n                Handled = true,\n                SentSimpleReply = false,\n                StartedCtaFlow = true,\n                AutoReplyFlowId = autoReplyFlowId,\n                CtaFlowConfigId = ctaFlowConfigId,\n                MatchedKeyword = matchedKeyword,\n                Notes = notes,\n                StartNodeType = startNodeType,\n                StartNodeName = startNodeName\n            };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyRuntimeService.cs",
      "sha256": "7e58549520774f608f999c6463dc18dbad0f2a61054d16c309d35127a257015b",
      "language": "csharp",
      "size": 50616,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing System.Text.Json.Serialization;\nusing xbytechat.api.Features.MessagesEngine.Enums;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    /// <summary>\n    /// Default implementation of the AutoReply runtime engine.\n    ///\n    /// Responsibilities:\n    /// - Match inbound text against AutoReplyFlow.TriggerKeyword (builder flows).\n    /// - Provide:\n    ///     * Test-only matching for the AutoReplyBuilder UI (no sending).\n    ///     * Runtime matching for the WhatsApp webhook (executes multi-step flows).\n    ///     * Legacy DTO-based matching for existing APIs (FindMatchAsync).\n    /// - For builder flows, can inspect NodesJson and execute \"message\" / \"template\" /\n    ///   \"tag\" / \"wait\" nodes in order (simple linear runner for now).\n    /// </summary>\n    public sealed class AutoReplyRuntimeService : IAutoReplyRuntimeService\n    {\n        private readonly AppDbContext _dbContext;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ILogger<AutoReplyRuntimeService> _logger;\n        private readonly IFlowExecutionLogger _flowExecutionLogger;\n        private readonly ICtaFlowRuntimeService _ctaFlowRuntime;\n\n        public AutoReplyRuntimeService(\n            AppDbContext dbContext,\n            IMessageEngineService messageEngine,\n            ILogger<AutoReplyRuntimeService> logger,\n            IFlowExecutionLogger flowExecutionLogger,\n            ICtaFlowRuntimeService ctaFlowRuntime)\n        {\n            _dbContext = dbContext;\n            _messageEngine = messageEngine;\n            _logger = logger;\n            _flowExecutionLogger = flowExecutionLogger;\n            _ctaFlowRuntime = ctaFlowRuntime;\n        }\n\n        // ----------------------------------------------------\n        // 1) Runtime ‚Äì used by the webhook\n        // ----------------------------------------------------\n\n        public async Task<AutoReplyRuntimeResult> TryHandleAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string incomingText,\n            CancellationToken cancellationToken = default)\n        {\n            var text = (incomingText ?? string.Empty).Trim();\n\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(text))\n            {\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"BusinessId was empty or incoming text was blank (runtime).\");\n            }\n\n            _logger.LogInformation(\n                \"ü§ñ AutoReplyRuntime invoked (runtime) for Business={BusinessId}, Contact={ContactId}, Phone={Phone}, Text={Text}\",\n                businessId,\n                contactId,\n                contactPhone,\n                text);\n\n            // Reuse the canonical matching logic (builder flows only)\n            var matchResult = await TestMatchAsync(businessId, text, cancellationToken);\n\n            // ‚õî Only short-circuit when we have NO builder flow id at all.\n            // If AutoReplyFlowId is present, we still try to execute the flow\n            // even if Handled == false.\n            if (!matchResult.Handled && !matchResult.AutoReplyFlowId.HasValue)\n            {\n                _logger.LogDebug(\n                    \"üëÇ AutoReplyRuntime (runtime) found no matching visual flow for Business={BusinessId}\",\n                    businessId);\n\n                return matchResult;\n            }\n\n            _logger.LogInformation(\n                \"ü§ñ AutoReplyRuntime (runtime) matched flow {FlowId} with keyword '{Keyword}'. Notes: {Notes}\",\n                matchResult.AutoReplyFlowId ?? matchResult.CtaFlowConfigId,\n                matchResult.MatchedKeyword,\n                matchResult.Notes);\n\n            // New behaviour: execute the full visual builder flow as a linear sequence.\n            if (matchResult.AutoReplyFlowId.HasValue)\n            {\n                var flowId = matchResult.AutoReplyFlowId.Value;\n\n                var flow = await _dbContext.Set<AutoReplyFlow>()\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(\n                        f => f.Id == flowId && f.BusinessId == businessId,\n                        cancellationToken);\n\n                if (flow == null)\n                {\n                    _logger.LogWarning(\n                        \"AutoReplyRuntime matched flow id {FlowId} but could not reload AutoReplyFlow from DB.\",\n                        flowId);\n\n                    matchResult.SentSimpleReply = false;\n                    // Keep original Handled flag; webhook can decide what to do.\n                    return matchResult;\n                }\n\n                // Extra visibility for debugging\n                var matchMode = string.IsNullOrWhiteSpace(flow.MatchMode) ? \"Word\" : flow.MatchMode;\n                _logger.LogInformation(\n                    \"ü§ñ AutoReplyRuntime (runtime) executing flow {FlowId} '{FlowName}' for Business={BusinessId}, Contact={ContactId}. Mode={MatchMode}, Priority={Priority}, Keyword='{Keyword}'\",\n                    flow.Id,\n                    flow.Name,\n                    businessId,\n                    contactId,\n                    matchMode,\n                    flow.Priority,\n                    matchResult.MatchedKeyword);\n\n                var outcome = await ExecuteFlowLinearAsync(\n                    flow,\n                    businessId,\n                    contactId,\n                    contactPhone,\n                    cancellationToken);\n\n                // Mark as ‚Äúwe responded‚Äù only if at least one step sent something.\n                matchResult.SentSimpleReply = outcome.AnySent;\n                if (outcome.AnySent)\n                {\n                    // Force Handled = true so webhook does NOT fall back\n                    // to the legacy AutomationService greeting.\n                    matchResult.Handled = true;\n                }\n\n                if (!outcome.AnySent)\n                {\n                    _logger.LogWarning(\n                        \"AutoReplyRuntime executed flow {FlowId} for Business={BusinessId} but no messages/templates were sent.\",\n                        flowId,\n                        businessId);\n\n                    return matchResult;\n                }\n\n                _logger.LogInformation(\n                    \"‚úÖ AutoReplyRuntime executed flow {FlowId} for Business={BusinessId}, Contact={ContactId}. Summary={Summary}\",\n                    flowId,\n                    businessId,\n                    contactId,\n                    outcome.Summary ?? \"(no summary)\");\n\n                // üìù Always log the trigger (match + executed steps)\n                await LogAutoReplyAsync(\n                    businessId,\n                    contactId,\n                    matchResult.MatchedKeyword,\n                    flow,\n                    outcome.Summary,\n                    messageLogId: null, // we can wire a real MessageLogId later\n                    ct: cancellationToken);\n\n                return matchResult;\n            }\n\n            // In future we can support direct CTA-flow start via matchResult.CtaFlowConfigId.\n            return matchResult;\n        }\n\n\n        // ----------------------------------------------------\n        // 2) Test mode ‚Äì used by AutoReplyBuilder \"Test Match\"\n        // ----------------------------------------------------\n        public async Task<AutoReplyRuntimeResult> TestMatchAsync(\n            Guid businessId,\n            string incomingText,\n            CancellationToken cancellationToken = default)\n        {\n            var text = (incomingText ?? string.Empty).Trim();\n\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(text))\n            {\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"BusinessId was empty or incoming text was blank (test).\");\n            }\n\n            _logger.LogDebug(\n                \"üß™ AutoReplyRuntime test-match for Business={BusinessId}, Text={Text}\",\n                businessId,\n                text);\n\n            var normalizedText = text.ToLowerInvariant();\n            var incomingWords = SplitIntoWords(normalizedText);\n\n            // 2.1) Builder flows (new AutoReplyBuilder)\n            var flows = await _dbContext.Set<AutoReplyFlow>()\n                .AsNoTracking()\n                .Where(f =>\n                    f.BusinessId == businessId &&\n                    f.IsActive &&\n                    !string.IsNullOrWhiteSpace(f.TriggerKeyword))\n                .OrderBy(f => f.Name)\n                .ThenBy(f => f.Id)\n                .ToListAsync(cancellationToken);\n\n            var candidates = new List<FlowMatchCandidate>();\n\n            foreach (var flow in flows)\n            {\n                var triggerField = flow.TriggerKeyword ?? string.Empty;\n\n                // Support comma / newline separated triggers\n                var keywords = triggerField\n                    .Split(new[] { ',', '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries)\n                    .Select(k => k.Trim())\n                    .Where(k => !string.IsNullOrWhiteSpace(k))\n                    .ToList();\n\n                if (keywords.Count == 0)\n                    continue;\n\n                var rawMatchMode = string.IsNullOrWhiteSpace(flow.MatchMode)\n                    ? \"Word\"\n                    : flow.MatchMode.Trim();\n\n                var matchMode = rawMatchMode.ToUpperInvariant();\n\n                foreach (var kw in keywords)\n                {\n                    var normalizedKeyword = kw.ToLowerInvariant();\n\n                    if (IsKeywordMatch(\n                            normalizedKeyword,\n                            normalizedText,\n                            matchMode,\n                            incomingWords))\n                    {\n                        candidates.Add(new FlowMatchCandidate\n                        {\n                            Flow = flow,\n                            Keyword = kw,\n                            MatchMode = matchMode,\n                            Priority = flow.Priority,\n                            KeywordLength = normalizedKeyword.Length\n                        });\n                    }\n                }\n            }\n\n            if (candidates.Count == 0)\n            {\n                // ‚úÖ No legacy rule fallback anymore: if no flow matches, we just say \"not handled\".\n                return AutoReplyRuntimeResult.NotHandled(\n                    \"No AutoReply flow matched the incoming text.\");\n            }\n\n            // üéØ Big-player style selection:\n            // 1) Highest Priority\n            // 2) Longest keyword (more specific)\n            // 3) Newest flow (CreatedAt)\n            // 4) Stable by Id\n            var winner = candidates\n                .OrderByDescending(c => c.Priority)\n                .ThenByDescending(c => c.KeywordLength)\n                .ThenByDescending(c => c.Flow.CreatedAt)\n                .ThenBy(c => c.Flow.Id)\n                .First();\n\n            var matchedFlow = winner.Flow;\n            var matchedKeyword = winner.Keyword;\n\n            var startSummary = GetFirstActionNodeSummary(matchedFlow);\n\n            var note =\n                $\"Matched flow '{matchedFlow.Name}' ({matchedFlow.Id}) by trigger '{matchedKeyword}'. \" +\n                $\"Mode={winner.MatchMode}, Priority={winner.Priority}, Candidates={candidates.Count}.\";\n\n            _logger.LogInformation(\n                \"üß™ AutoReplyRuntime (test) matched winner flow {FlowId} '{FlowName}' with keyword '{Keyword}'. Mode={MatchMode}, Priority={Priority}, Candidates={CandidateCount}.\",\n                matchedFlow.Id,\n                matchedFlow.Name,\n                matchedKeyword,\n                winner.MatchMode,\n                winner.Priority,\n                candidates.Count);\n\n            // Still treat as \"simple reply\" from the point of view of the test API,\n            // even though runtime now executes multi-step flows.\n            return AutoReplyRuntimeResult.SimpleReply(\n                autoReplyFlowId: matchedFlow.Id,\n                matchedKeyword: matchedKeyword,\n                notes: note,\n                startNodeType: startSummary?.NodeType,\n                startNodeName: startSummary?.NodeName\n            );\n        }\n\n        // ----------------------------------------------------\n        // 3) Legacy DTO adapter ‚Äì for existing APIs\n        // ----------------------------------------------------\n        public async Task<AutoReplyMatchResultDto> FindMatchAsync(\n            AutoReplyMatchRequestDto request,\n            CancellationToken cancellationToken = default)\n        {\n            var runtimeResult = await TestMatchAsync(\n                request.BusinessId,\n                request.IncomingText,\n                cancellationToken);\n\n            if (!runtimeResult.Handled)\n            {\n                // Back-compat: previously returned IsMatch=false with everything else null.\n                return new AutoReplyMatchResultDto\n                {\n                    IsMatch = false\n                };\n            }\n\n            var dto = new AutoReplyMatchResultDto\n            {\n                IsMatch = true,\n                FlowId = runtimeResult.AutoReplyFlowId ?? runtimeResult.CtaFlowConfigId,\n                FlowName = null, // TODO: surface flow name once we propagate it from flow entity.\n                MatchedKeyword = runtimeResult.MatchedKeyword,\n                MatchType = runtimeResult.StartedCtaFlow ? \"CTA_FLOW\" : \"SIMPLE_REPLY\",\n                StartNodeId = null,\n                StartNodeType = null,\n                StartNodeConfigJson = null\n            };\n\n            return dto;\n        }\n\n        // ----------------------------------------------------\n        // 4) Multi-step flow execution (builder flows)\n        // ----------------------------------------------------\n\n        /// <summary>\n        /// Represents the outcome of executing a visual AutoReply flow.\n        /// </summary>\n        private sealed class FlowExecutionOutcome\n        {\n            /// <summary>\n            /// True if at least one message/template was sent.\n            /// </summary>\n            public bool AnySent { get; set; }\n\n            /// <summary>\n            /// Number of plain text messages sent in this run.\n            /// </summary>\n            public int SentTextMessages { get; set; }\n\n            /// <summary>\n            /// Number of template messages sent in this run.\n            /// </summary>\n            public int SentTemplates { get; set; }\n\n            /// <summary>\n            /// Extra notes about execution (e.g. errors, loop guards, tags/waits summary).\n            /// </summary>\n            public string? Notes { get; set; }\n\n            /// <summary>\n            /// Short human-readable summary for logs.\n            /// </summary>\n            public string? Summary\n            {\n                get\n                {\n                    var parts = new List<string>();\n\n                    if (SentTextMessages > 0)\n                    {\n                        parts.Add($\"Text x{SentTextMessages}\");\n                    }\n\n                    if (SentTemplates > 0)\n                    {\n                        parts.Add($\"Template x{SentTemplates}\");\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(Notes))\n                    {\n                        parts.Add(Notes!);\n                    }\n\n                    return parts.Count == 0 ? null : string.Join(\" | \", parts);\n                }\n            }\n\n            public static FlowExecutionOutcome Empty { get; } = new();\n        }\n\n        /// <summary>\n        /// Execute a builder-based flow as a simple linear sequence of nodes.\n        /// For now:\n        /// - Supports: \"message\", \"template\", \"wait\", \"tag\".\n        /// - Executes in the order defined by node.Order, ignoring the visual \"start\" node.\n        /// </summary>\n        private async Task<FlowExecutionOutcome> ExecuteFlowLinearAsync(\n            AutoReplyFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            CancellationToken ct)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n            {\n                _logger.LogWarning(\n                    \"AutoReply flow {FlowId} for Business={BusinessId} has no nodes; nothing to execute.\",\n                    flow.Id,\n                    businessId);\n\n                return FlowExecutionOutcome.Empty;\n            }\n\n            // For now we treat flows as linear sequences:\n            // - ignore the explicit edges graph\n            // - skip the visual \"start\" node\n            var orderedNodes = nodes\n                .Where(n => !string.Equals(n.NodeType, \"start\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .ToList();\n\n            if (orderedNodes.Count == 0)\n            {\n                _logger.LogWarning(\n                    \"AutoReply flow {FlowId} for Business={BusinessId} has only a start node and no action nodes.\",\n                    flow.Id,\n                    businessId);\n\n                return FlowExecutionOutcome.Empty;\n            }\n\n            var outcome = new FlowExecutionOutcome();\n            var pieces = new List<string>();\n\n            foreach (var node in orderedNodes)\n            {\n                if (ct.IsCancellationRequested)\n                {\n                    _logger.LogInformation(\n                        \"AutoReply flow execution cancelled for FlowId={FlowId}, Business={BusinessId}, Contact={ContactId}.\",\n                        flow.Id,\n                        businessId,\n                        contactId);\n                    break;\n                }\n\n                var nodeType = node.NodeType?.Trim().ToLowerInvariant();\n                AutoReplyNodeConfig? cfg = null;\n\n                if (!string.IsNullOrWhiteSpace(node.ConfigJson))\n                {\n                    try\n                    {\n                        var options = new JsonSerializerOptions\n                        {\n                            PropertyNameCaseInsensitive = true\n                        };\n                        cfg = JsonSerializer.Deserialize<AutoReplyNodeConfig>(node.ConfigJson, options);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogError(\n                            ex,\n                            \"Failed to parse ConfigJson for AutoReply node {NodeId} in flow {FlowId}. ConfigJson={ConfigJson}\",\n                            node.Id,\n                            flow.Id,\n                            node.ConfigJson);\n\n                        // Log as failed step and continue\n                        await LogFlowStepAsync(\n                            businessId,\n                            flow,\n                            node,\n                            contactPhone,\n                            messageLogId: null,\n                            success: false,\n                            errorMessage: \"ConfigJson deserialization failed\",\n                            templateName: null,\n                            templateType: null,\n                            cancellationToken: ct);\n\n                        continue;\n                    }\n                }\n\n                switch (nodeType)\n                {\n                    case \"message\":\n                        {\n                            var body = cfg?.Text ?? cfg?.Body;\n                            if (string.IsNullOrWhiteSpace(body))\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply message node {NodeId} in flow {FlowId} has empty body.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Empty message body\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEXT\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            var trimmedBody = body.Trim();\n\n                            _logger.LogInformation(\n                                \"üìÑ AutoReplyRuntime sending text message node {NodeId} for flow {FlowId}.\",\n                                node.Id,\n                                flow.Id);\n\n                            // ‚úÖ Now use DeliveryMode.Immediate (conversational reply)\n                            var sendResult = await _messageEngine.SendAutoReplyTextAsync(\n                                businessId,\n                                contactPhone,\n                                trimmedBody,\n                                DeliveryMode.Immediate,\n                                ct);\n\n                            if (!sendResult.Success)\n                            {\n                                _logger.LogWarning(\n                                    \"‚ùå AutoReplyRuntime failed to send text node {NodeId} in flow {FlowId}, Business={BusinessId}, Contact={ContactId}: {Message}\",\n                                    node.Id,\n                                    flow.Id,\n                                    businessId,\n                                    contactId,\n                                    sendResult.Message);\n\n                                outcome.Notes = $\"Failed to send text node {node.Id}: {sendResult.Message}\";\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null, // TODO: wire real MessageLogId from sendResult if available\n                                    success: false,\n                                    errorMessage: sendResult.Message,\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEXT\",\n                                    cancellationToken: ct);\n\n                                return outcome;\n                            }\n\n                            outcome.AnySent = true;\n                            outcome.SentTextMessages++;\n                            pieces.Add(trimmedBody);\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null, // TODO: from sendResult\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_TEXT\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"template\":\n                        {\n                            var templateName = cfg?.TemplateName;\n                            if (string.IsNullOrWhiteSpace(templateName))\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply template node {NodeId} in flow {FlowId} has no TemplateName configured.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Missing TemplateName\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TEMPLATE\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            var dto = new SimpleTemplateMessageDto\n                            {\n                                RecipientNumber = contactPhone,\n                                TemplateName = templateName!,\n                                TemplateParameters = new List<string>(),\n                                HasStaticButtons = false\n                            };\n\n                            _logger.LogInformation(\n                                \"üìÑ AutoReplyRuntime sending template node {NodeId} (template={TemplateName}) for flow {FlowId}.\",\n                                node.Id,\n                                templateName,\n                                flow.Id);\n\n                            // ‚úÖ Now use DeliveryMode.Immediate (conversational template)\n                            var sendResult = await _messageEngine.SendTemplateMessageSimpleAsync(\n                                businessId,\n                                dto,\n                                DeliveryMode.Immediate);\n\n                            if (!sendResult.Success)\n                            {\n                                _logger.LogWarning(\n                                    \"‚ùå AutoReplyRuntime failed to send template node {NodeId} in flow {FlowId}, Business={BusinessId}, Contact={ContactId}: {Message}\",\n                                    node.Id,\n                                    flow.Id,\n                                    businessId,\n                                    contactId,\n                                    sendResult.Message);\n\n                                outcome.Notes = $\"Failed to send template node {node.Id}: {sendResult.Message}\";\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: sendResult.Message,\n                                    templateName: templateName,\n                                    templateType: \"AUTO_REPLY_TEMPLATE\",\n                                    cancellationToken: ct);\n\n                                return outcome;\n                            }\n\n                            outcome.AnySent = true;\n                            outcome.SentTemplates++;\n                            pieces.Add($\"[TEMPLATE:{templateName}]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: templateName,\n                                templateType: \"AUTO_REPLY_TEMPLATE\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"tag\":\n                        {\n                            var tags = cfg?.Tags\n                                        ?? cfg?.TagIds\n                                        ?? Array.Empty<string>();\n\n                            if (tags.Length == 0)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply tag node {NodeId} in flow {FlowId} has no tags configured.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"No tags configured\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_TAG\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            _logger.LogInformation(\n                                \"üè∑ AutoReply tag node {NodeId} in flow {FlowId} would apply tags: {Tags}.\",\n                                node.Id,\n                                flow.Id,\n                                string.Join(\",\", tags));\n\n                            pieces.Add($\"[TAGS:{string.Join(\",\", tags)}]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_TAG\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"wait\":\n                        {\n                            var seconds = cfg?.Seconds\n                                           ?? cfg?.DelaySeconds\n                                           ?? cfg?.WaitSeconds\n                                           ?? 0;\n\n                            if (seconds <= 0)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply wait node {NodeId} in flow {FlowId} has invalid or zero Seconds.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Invalid wait seconds\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_WAIT\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            const int MaxWaitSeconds = 15;\n                            var requestedSeconds = seconds;\n                            if (seconds > MaxWaitSeconds)\n                            {\n                                seconds = MaxWaitSeconds;\n                            }\n\n                            _logger.LogInformation(\n                                \"‚è± AutoReply wait node {NodeId} in flow {FlowId} performing inline wait of {Seconds}s (requested {RequestedSeconds}s).\",\n                                node.Id,\n                                flow.Id,\n                                seconds,\n                                requestedSeconds);\n\n                            try\n                            {\n                                await Task.Delay(TimeSpan.FromSeconds(seconds), ct);\n                            }\n                            catch (TaskCanceledException)\n                            {\n                                _logger.LogInformation(\n                                    \"AutoReply wait node {NodeId} in flow {FlowId} was cancelled during wait of {Seconds}s.\",\n                                    node.Id,\n                                    flow.Id,\n                                    seconds);\n                                throw;\n                            }\n\n                            pieces.Add($\"[WAIT:{seconds}s]\");\n\n                            await LogFlowStepAsync(\n                                businessId,\n                                flow,\n                                node,\n                                contactPhone,\n                                messageLogId: null,\n                                success: true,\n                                errorMessage: null,\n                                templateName: null,\n                                templateType: \"AUTO_REPLY_WAIT\",\n                                cancellationToken: ct);\n\n                            break;\n                        }\n\n                    case \"cta_flow\":\n                        {\n                            // ‚¨áÔ∏è use the Guid parsed from the string\n                            var ctaConfigId = cfg?.CtaFlowConfigGuid ?? Guid.Empty;\n                            if (ctaConfigId == Guid.Empty)\n                            {\n                                _logger.LogWarning(\n                                    \"AutoReply CTA_FLOW node {NodeId} in flow {FlowId} has no CtaFlowConfigId configured.\",\n                                    node.Id,\n                                    flow.Id);\n\n                                await LogFlowStepAsync(\n                                    businessId,\n                                    flow,\n                                    node,\n                                    contactPhone,\n                                    messageLogId: null,\n                                    success: false,\n                                    errorMessage: \"Missing CtaFlowConfigId\",\n                                    templateName: null,\n                                    templateType: \"AUTO_REPLY_CTA_FLOW\",\n                                    cancellationToken: ct);\n\n                                break;\n                            }\n\n                            _logger.LogInformation(\n                                \"üöÄ AutoReply CTA_FLOW node {NodeId} in flow {FlowId} starting CTA flow config {ConfigId} for Business={BusinessId}, Contact={ContactId}.\",\n                                node.Id,\n                                flow.Id,\n                                ctaConfigId,\n                                businessId,\n                                contactId);\n\n                            var runResult = await _ctaFlowRuntime.StartFlowAsync(\n                                businessId,\n                                contactId,\n                                contactPhone,\n                                ctaConfigId,\n                                FlowExecutionOrigin.AutoReply,\n                                flow.Id,\n                                ct);\n\n                            // ... existing success/error handling for CTA flow (unchanged) ...\n\n                            break;\n                        }\n\n                    default:\n                        {\n                            _logger.LogDebug(\n                                \"AutoReplyRuntime encountered unsupported node type '{NodeType}' in flow {FlowId}, node {NodeId}.\",\n                                node.NodeType,\n                                flow.Id,\n                                node.Id);\n                            break;\n                        }\n\n                }\n            }\n\n            if (pieces.Count > 0)\n            {\n                outcome.Notes = string.Join(\" | \", pieces);\n            }\n\n            return outcome;\n        }\n\n        // ----------------------------------------------------\n        // Helpers ‚Äì keyword matching\n        // ----------------------------------------------------\n        private static List<string> SplitIntoWords(string normalizedIncoming)\n        {\n            if (string.IsNullOrWhiteSpace(normalizedIncoming))\n                return new List<string>();\n\n            var parts = normalizedIncoming.Split(\n                new[]\n                {\n                    ' ', '\\t', '\\r', '\\n',\n                    '.', ',', '!', '?', ';', ':',\n                    '-', '_', '/', '\\\\',\n                    '(', ')', '[', ']', '{', '}',\n                    '\"', '\\'', '‚Äô'\n                },\n                StringSplitOptions.RemoveEmptyEntries);\n\n            return parts.ToList();\n        }\n\n        private static bool IsKeywordMatch(\n            string normalizedKeyword,\n            string normalizedIncoming,\n            string matchMode,\n            IReadOnlyList<string> incomingWords)\n        {\n            if (string.IsNullOrWhiteSpace(normalizedKeyword) ||\n                string.IsNullOrWhiteSpace(normalizedIncoming))\n            {\n                return false;\n            }\n\n            var mode = string.IsNullOrWhiteSpace(matchMode)\n                ? \"WORD\"\n                : matchMode.Trim().ToUpperInvariant();\n\n            switch (mode)\n            {\n                case \"EXACT\":\n                    // Entire text must be exactly the keyword\n                    return string.Equals(\n                        normalizedIncoming,\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"WORD\":\n                    // For single words: token-based match (message must contain that word).\n                    // For multi-word keywords: fall back to simple substring contains.\n                    if (!normalizedKeyword.Contains(' '))\n                    {\n                        if (incomingWords == null || incomingWords.Count == 0)\n                            return false;\n\n                        foreach (var w in incomingWords)\n                        {\n                            if (string.Equals(w, normalizedKeyword, StringComparison.Ordinal))\n                                return true;\n                        }\n\n                        return false;\n                    }\n\n                    return normalizedIncoming.Contains(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"STARTSWITH\":\n                    return normalizedIncoming.StartsWith(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n\n                case \"CONTAINS\":\n                default:\n                    return normalizedIncoming.Contains(\n                        normalizedKeyword,\n                        StringComparison.Ordinal);\n            }\n        }\n\n        // ----------------------------------------------------\n        // Helpers ‚Äì nodes / configs\n        // ----------------------------------------------------\n        private FlowNodeSummary? GetFirstActionNodeSummary(AutoReplyFlow flow)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n                return null;\n\n            var firstAction = nodes\n                .Where(n => !string.Equals(n.NodeType, \"start\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .FirstOrDefault();\n\n            if (firstAction == null)\n                return null;\n\n            return new FlowNodeSummary(\n                firstAction.NodeType ?? \"?\",\n                firstAction.NodeName ?? \"?\");\n        }\n\n        /// <summary>\n        /// Reads the first \"message\" node and extracts the text/body we want to send.\n        /// Kept for compatibility; not used by the new multi-step runner.\n        /// </summary>\n        private string? GetSimpleReplyText(AutoReplyFlow flow)\n        {\n            var nodes = DeserializeNodes(flow.NodesJson);\n            if (nodes == null || nodes.Count == 0)\n                return null;\n\n            var msgNode = nodes\n                .Where(n =>\n                    string.Equals(n.NodeType, \"message\", StringComparison.OrdinalIgnoreCase))\n                .OrderBy(n => n.Order)\n                .FirstOrDefault();\n\n            if (msgNode == null || string.IsNullOrWhiteSpace(msgNode.ConfigJson))\n                return null;\n\n            try\n            {\n                // ‚öôÔ∏è IMPORTANT: make it case-insensitive so \"text\" / \"body\" also bind.\n                var options = new JsonSerializerOptions\n                {\n                    PropertyNameCaseInsensitive = true\n                };\n\n                var cfg = JsonSerializer.Deserialize<AutoReplyNodeConfig>(msgNode.ConfigJson, options);\n                var text = cfg?.Text ?? cfg?.Body;\n\n                return string.IsNullOrWhiteSpace(text)\n                    ? null\n                    : text.Trim();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex,\n                    \"Failed to parse AutoReply message node config for flow {FlowId}. ConfigJson={ConfigJson}\",\n                    flow.Id,\n                    msgNode.ConfigJson);\n\n                return null;\n            }\n        }\n\n        private static List<AutoReplyNodeRecord>? DeserializeNodes(string? nodesJson)\n        {\n            if (string.IsNullOrWhiteSpace(nodesJson))\n                return null;\n\n            try\n            {\n                var options = new JsonSerializerOptions\n                {\n                    PropertyNameCaseInsensitive = true\n                };\n\n                return JsonSerializer.Deserialize<List<AutoReplyNodeRecord>>(nodesJson, options);\n            }\n            catch\n            {\n                // If we cannot parse nodes, treat as no nodes.\n                return null;\n            }\n        }\n\n        // ----------------------------------------------------\n        // AutoReply logging helper\n        // ----------------------------------------------------\n        private async Task LogAutoReplyAsync(\n            Guid businessId,\n            Guid contactId,\n            string? matchedKeyword,\n            AutoReplyFlow? flow,\n            string? replyText,\n            Guid? messageLogId,\n            CancellationToken ct)\n        {\n            try\n            {\n                var log = new AutoReplyLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    TriggerType = \"flow\",\n                    TriggerKeyword = matchedKeyword ?? string.Empty,\n                    ReplyContent = replyText ?? string.Empty,\n                    FlowName = flow?.Name,\n                    MessageLogId = messageLogId,\n                    TriggeredAt = DateTime.UtcNow\n                };\n\n                _dbContext.Set<AutoReplyLog>().Add(log);\n                await _dbContext.SaveChangesAsync(ct);\n\n                _logger.LogInformation(\n                    \"üìù AutoReplyLog inserted for BusinessId={BusinessId}, ContactId={ContactId}, FlowName={FlowName}, Keyword='{Keyword}'.\",\n                    businessId,\n                    contactId,\n                    flow?.Name,\n                    matchedKeyword);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"‚ùå Failed to insert AutoReplyLog for BusinessId={BusinessId}, ContactId={ContactId}, FlowName={FlowName}.\",\n                    businessId,\n                    contactId,\n                    flow?.Name);\n            }\n        }\n\n        /// <summary>\n        /// Helper to write a single origin-aware FlowExecutionLog row for an AutoReply step.\n        /// </summary>\n        private async Task LogFlowStepAsync(\n           Guid businessId,\n           AutoReplyFlow flow,\n           AutoReplyNodeRecord node,\n           string contactPhone,\n           Guid? messageLogId,\n           bool success,\n           string? errorMessage,\n           string? templateName,\n           string? templateType,\n           CancellationToken cancellationToken)\n        {\n            try\n            {\n                if (flow == null)\n                {\n                    _logger.LogWarning(\n                        \"Skipping FlowExecution log because AutoReplyFlow is null. BusinessId={BusinessId}, Contact={ContactPhone}\",\n                        businessId,\n                        contactPhone);\n\n                    return;\n                }\n\n                if (node == null)\n                {\n                    _logger.LogWarning(\n                        \"Skipping FlowExecution log because AutoReply node is null. BusinessId={BusinessId}, AutoReplyFlowId={FlowId}, Contact={ContactPhone}\",\n                        businessId,\n                        flow.Id,\n                        contactPhone);\n\n                    return;\n                }\n\n                // AutoReplyNodeRecord.Id is Guid?; if somehow missing, keep Guid.Empty so we can see it in logs.\n                var stepId = node.Id ?? Guid.Empty;\n\n                var ctx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    Origin = FlowExecutionOrigin.AutoReply,\n\n                    // For AutoReply we DO NOT use CTA FlowId; that column is reserved for CTAFlowConfigId.\n                    FlowId = null,\n\n                    StepId = stepId,\n                    StepName = node.NodeName ?? node.NodeType ?? \"AUTO_REPLY_STEP\",\n\n                    // No per-run grouping yet; can add when you introduce FlowRunId\n                    RunId = null,\n\n                    // AutoReply-origin, not a campaign broadcast\n                    CampaignId = null,\n                    AutoReplyFlowId = flow.Id,\n                    CampaignSendLogId = null,\n                    TrackingLogId = null,\n\n                    MessageLogId = messageLogId,\n                    ContactPhone = contactPhone,\n\n                    // No buttons involved for plain AutoReply nodes (we log button stuff in CTAFlowRuntime)\n                    TriggeredByButton = null,\n                    ButtonIndex = null,\n\n                    TemplateName = templateName,\n                    TemplateType = templateType,\n\n                    RequestId = null,\n                    Success = success,\n                    ErrorMessage = errorMessage,\n                    RawResponse = null,\n\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowExecutionLogger.LogStepAsync(ctx, cancellationToken);\n\n                _logger.LogInformation(\n                    \"[AutoReplyFlowLog] Logged step. Biz={BusinessId}, AutoReplyFlowId={FlowId}, StepId={StepId}, StepName={StepName}, Success={Success}, Template={TemplateName}\",\n                    businessId,\n                    flow.Id,\n                    stepId,\n                    ctx.StepName,\n                    ctx.Success,\n                    ctx.TemplateName ?? \"(none)\");\n            }\n            catch (Exception ex)\n            {\n                // Never break AutoReply runtime because logging failed.\n                _logger.LogError(\n                    ex,\n                    \"Failed to log AutoReply FlowExecution step for BusinessId={BusinessId}, AutoReplyFlowId={FlowId}, NodeId={NodeId}\",\n                    businessId,\n                    flow?.Id,\n                    node?.Id);\n            }\n        }\n\n        // ----------------------------------------------------\n        // Private types for node parsing / choosing winners\n        // ----------------------------------------------------\n\n        private sealed class AutoReplyNodeRecord\n        {\n            public Guid? Id { get; set; }\n            public string? NodeType { get; set; }\n            public string? NodeName { get; set; }\n            public string? ConfigJson { get; set; }\n            public int Order { get; set; }\n            // positionX/positionY etc exist in JSON but we don't need them here\n        }\n\n        private sealed class AutoReplyNodeConfig\n        {\n            public string? Text { get; set; }           // for \"message\" nodes\n            public string? Body { get; set; }           // sometimes templates/body may reuse this\n            public string? TemplateName { get; set; }   // for template nodes\n\n            // Tag node ‚Äì support both \"tags\" and \"tagIds\" shapes\n            public string[]? Tags { get; set; }\n            public string[]? TagIds { get; set; }\n\n            // Wait node ‚Äì support multiple property names coming from builder\n            public int? Seconds { get; set; }\n            public int? DelaySeconds { get; set; }\n            public int? WaitSeconds { get; set; }\n\n            // CTA flow node ‚Äì ID of the CTA flow config to start\n            public string? CtaFlowConfigId { get; set; }\n\n            [JsonIgnore]\n            public Guid? CtaFlowConfigGuid =>\n              Guid.TryParse(CtaFlowConfigId, out var g) ? g : (Guid?)null;\n        }\n\n        private sealed record FlowNodeSummary(string NodeType, string NodeName);\n\n        private sealed class FlowMatchCandidate\n        {\n            public AutoReplyFlow Flow { get; init; } = null!;\n            public string Keyword { get; init; } = string.Empty;\n            public string MatchMode { get; init; } = \"WORD\";\n            public int Priority { get; init; }\n            public int KeywordLength { get; init; }\n        }\n    }\n}\n\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/FlowRunner.cs",
      "sha256": "d8c0004b19eb4964915bcf51a0ecdadf6dc89cfe50220970befa0fe58a5d4307",
      "language": "csharp",
      "size": 103,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class FlowRunner\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyFlowService.cs",
      "sha256": "ed0bc4cbd7017360eb700dcd3012a016a2189ba01c7a945a5056e1e5d8177c65",
      "language": "csharp",
      "size": 876,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyFlowService\n    {\n        Task<IReadOnlyList<AutoReplyFlowSummaryDto>> GetFlowsForBusinessAsync(Guid businessId, CancellationToken ct = default);\n\n        Task<AutoReplyFlowDto?> GetFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default);\n\n        Task<AutoReplyFlowDto> SaveFlowAsync(Guid businessId, AutoReplyFlowDto dto, CancellationToken ct = default);\n\n        Task DeleteFlowAsync(Guid businessId, Guid flowId, CancellationToken ct = default);\n        Task SetActiveAsync(\n            Guid businessId,\n            Guid flowId,\n            bool isActive,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyLogService.cs",
      "sha256": "f684d51cf8e980999c33b87dc4aa280b02eb818e12b7f4b8bc90368ce5458fd2",
      "language": "csharp",
      "size": 609,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyLogService\n    {\n        /// <summary>\n        /// Returns the most recent auto-reply triggers for a business,\n        /// ordered by TriggeredAt desc.\n        /// </summary>\n        Task<IReadOnlyList<AutoReplyLogSummaryDto>> GetRecentAsync(\n            Guid businessId,\n            int take,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyRuntimeService.cs",
      "sha256": "4182b20e2a5b814027abc73f1a31f3b96f2a70b8d9ccaacf33ea64b98514e014",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyRuntimeService\n    {\n        /// <summary>\n        /// Real runtime handler used by the webhook when an inbound WhatsApp message arrives.\n        /// </summary>\n        Task<AutoReplyRuntimeResult> TryHandleAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string incomingText,\n            CancellationToken cancellationToken = default);\n\n        /// <summary>\n        /// Test-only match used by the AutoReply Builder UI (\"Test Auto-Reply Match\" panel).\n        /// MUST NOT send any real messages.\n        /// </summary>\n        Task<AutoReplyRuntimeResult> TestMatchAsync(\n            Guid businessId,\n            string incomingText,\n            CancellationToken cancellationToken = default);\n\n        /// <summary>\n        /// Legacy DTO-based matcher used by existing endpoints\n        /// (e.g. /api/auto-reply-runtime/button-click).\n        /// Thin adapter over <see cref=\"TestMatchAsync\"/>.\n        /// </summary>\n        Task<AutoReplyMatchResultDto> FindMatchAsync(\n            AutoReplyMatchRequestDto request,\n            CancellationToken cancellationToken = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IFlowRunner.cs",
      "sha256": "11438f4864857ba65f652f4ed62baf47119c77fcd6933106db70602675dce48b",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class IFlowRunner\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyTemplates/Restaurant/Configs/MenuNodeConfig.cs",
      "sha256": "f20da12fb12eed3191a2998cb2e7a7dbc65b03bfcb571cf1b6a413f52d78d42a",
      "language": "csharp",
      "size": 527,
      "content": "namespace xbytechat.api.Features.AutoReplyTemplates.Restaurant.Configs\n{\n    public class MenuNodeConfig\n    {\n        public string MenuTitle { get; set; } = string.Empty;         // e.g., \"Today's Specials\"\n        public string Description { get; set; } = string.Empty;       // e.g., \"Lunch combos starting at ‚Çπ199\"\n        public string MenuImageUrl { get; set; } = string.Empty;      // CDN or public link\n        public string MenuDownloadUrl { get; set; } = string.Empty;   // PDF link or product catalog URL\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppMetaWebhookController.cs",
      "sha256": "5d6058aacf89412c04875981d4a5cb9a6231ff533ce9db9796e201479e55a252",
      "language": "csharp",
      "size": 2829,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Billing.Security;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/meta\")]\n    public class WhatsAppMetaWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppMetaWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n        private readonly IConfiguration _config;\n        private readonly IMetaSignatureValidator _metaSigValidator;\n        public WhatsAppMetaWebhookController(ILogger<WhatsAppMetaWebhookController> log,\n            IBillingIngestService ingest, IConfiguration config, IMetaSignatureValidator metaSigValidator)\n        {\n            _log = log;\n            _ingest = ingest;\n            _config = config;\n            _metaSigValidator = metaSigValidator;\n        }\n\n        // Meta verification handshake\n        // GET /api/webhooks/whatsapp/meta?hub.mode=subscribe&hub.challenge=...&hub.verify_token=...&businessId=...\n        [HttpGet]\n        public IActionResult Verify([FromQuery(Name = \"hub.mode\")] string mode,\n                                    [FromQuery(Name = \"hub.challenge\")] string challenge,\n                                    [FromQuery(Name = \"hub.verify_token\")] string verifyToken,\n                                    [FromQuery] Guid? businessId = null)\n        {\n            var expected = _config[\"WhatsApp:MetaVerifyToken\"]; // optional; if empty we accept\n            if (!string.IsNullOrWhiteSpace(expected) && !string.Equals(expected, verifyToken))\n            {\n                _log.LogWarning(\"Meta webhook verify failed. Provided token does not match.\");\n                return Unauthorized();\n            }\n            _log.LogInformation(\"Meta webhook verified. BusinessId={BusinessId}\", businessId);\n            return Content(challenge ?? string.Empty, \"text/plain\");\n        }\n\n        // POST /api/webhooks/whatsapp/meta?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            var sig = Request.Headers[\"X-Hub-Signature-256\"].ToString();\n\n            if (!_metaSigValidator.IsValid(sig, payload))\n            {\n                _log.LogWarning(\"Meta webhook: invalid signature for business {BusinessId}\", businessId);\n                return Unauthorized();\n            }\n\n            await _ingest.IngestFromWebhookAsync(businessId, \"META_CLOUD\", payload);\n\n            return Ok();\n        }\n\n\n        // If you need GET verification for Meta webhook, add it here.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppPinnacleWebhookController.cs",
      "sha256": "50c4e7ef562320331826b09fa5210313b19967296a61f89daf10e2e421b8bf73",
      "language": "csharp",
      "size": 1268,
      "content": "using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/pinnacle\")]\n    public class WhatsAppPinnacleWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppPinnacleWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n\n        public WhatsAppPinnacleWebhookController(\n            ILogger<WhatsAppPinnacleWebhookController> log,\n            IBillingIngestService ingest)\n        {\n            _log = log;\n            _ingest = ingest;\n        }\n\n        // POST /api/webhooks/whatsapp/pinnacle?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            _log.LogInformation(\"Pinnacle webhook payload ({Len} chars) for Biz {Biz}\", payload?.Length ?? 0, businessId);\n            await _ingest.IngestFromWebhookAsync(businessId, \"PINNACLE\", payload);\n\n            return Ok();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/DTOs/BillingSnapshotDto.cs",
      "sha256": "ccb71af46ccda4580bcf96c49ae7cab671224aa519eaaf63e561d2fa39d0eb26",
      "language": "csharp",
      "size": 534,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat_api.Features.Billing.DTOs\n{\n    public class BillingSnapshotDto\n    {\n        public int TotalMessages { get; set; }\n        public int ChargeableMessages { get; set; }\n        public int FreeMessages { get; set; }\n        public Dictionary<string, int> CountByCategory { get; set; } = new();    // marketing, utility, authentication, service, free_entry\n        public Dictionary<string, decimal> SpendByCurrency { get; set; } = new();// \"USD\" => 12.34, \"INR\" => 250.00\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Models/ProviderBillingEvent.cs",
      "sha256": "f923e2377733fecf0ad48ff39d28f1a6e1bbfe4e78f370748b864f1568285824",
      "language": "csharp",
      "size": 1179,
      "content": "using System;\n\nnamespace xbytechat_api.Features.Billing.Models\n{\n    public class ProviderBillingEvent\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n\n        // Link if we can; may be null if webhook arrives before we create MessageLog\n        public Guid? MessageLogId { get; set; }\n\n        public string Provider { get; set; } = \"\";          // \"Meta_cloud\", \"Pinnacle\"\n        public string EventType { get; set; } = \"\";         // \"conversation_started\", \"message_delivered\", \"pricing_update\", etc.\n\n        public string? ProviderMessageId { get; set; }      // \"wamid...\"\n        public string? ConversationId { get; set; }\n        public string? ConversationCategory { get; set; }\n        public bool? IsChargeable { get; set; }\n        public decimal? PriceAmount { get; set; }\n        public string? PriceCurrency { get; set; }\n\n        public string PayloadJson { get; set; } = \"\";       // original provider payload for audit\n        public DateTimeOffset OccurredAt { get; set; }      // when provider says it happened\n        public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Security/MetaSignatureValidator.cs",
      "sha256": "2f5296dfd490f127acd70615ed255b07d30937004ef7b3f58ee8d2a6b1521863",
      "language": "csharp",
      "size": 1745,
      "content": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.Extensions.Configuration;\n\nnamespace xbytechat.api.Features.Billing.Security\n{\n    public interface IMetaSignatureValidator\n    {\n        bool IsValid(string signatureHeader, string payload);\n    }\n\n    public class MetaSignatureValidator : IMetaSignatureValidator\n    {\n        private readonly string _appSecret;\n\n        public MetaSignatureValidator(IConfiguration config)\n        {\n            _appSecret = config[\"WhatsApp:MetaAppSecret\"]\n                         ?? throw new InvalidOperationException(\"WhatsApp:MetaAppSecret is not configured\");\n        }\n\n        public bool IsValid(string signatureHeader, string payload)\n        {\n            if (string.IsNullOrWhiteSpace(signatureHeader) || string.IsNullOrEmpty(payload))\n                return false;\n\n            // header format: sha256=HEX\n            const string prefix = \"sha256=\";\n            if (!signatureHeader.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))\n                return false;\n\n            var sent = signatureHeader.Substring(prefix.Length);\n\n            using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(_appSecret));\n            var hashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(payload));\n            var expected = BitConverter.ToString(hashBytes).Replace(\"-\", \"\").ToLowerInvariant();\n\n            return CryptographicEquals(expected, sent);\n        }\n\n        private static bool CryptographicEquals(string a, string b)\n        {\n            if (a.Length != b.Length) return false;\n\n            var result = 0;\n            for (int i = 0; i < a.Length; i++)\n                result |= a[i] ^ b[i];\n\n            return result == 0;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingIngestService.cs",
      "sha256": "c608eae99d94309f2e21fc3c2fb7843c97bb8301e0f262a34cbe263bce124153",
      "language": "csharp",
      "size": 26626,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // AppDbContext\nusing xbytechat_api.Features.Billing.Models;\nusing Npgsql;\nusing Serilog;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingIngestService : IBillingIngestService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<BillingIngestService> _log;\n\n        public BillingIngestService(AppDbContext db, ILogger<BillingIngestService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson)\n        {\n            // Guard: only accept events for known businesses\n            var hasBiz = await _db.Businesses.AnyAsync(b => b.Id == businessId);\n            if (!hasBiz)\n            {\n                _log.LogWarning(\"Ignoring send-response for unknown business {BusinessId}\", businessId);\n                return;\n            }\n\n            try\n            {\n                using var doc = JsonDocument.Parse(rawResponseJson);\n\n                string? providerMessageId =\n                    doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0\n                        ? (msgs[0].TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null)\n                        : (doc.RootElement.TryGetProperty(\"id\", out var idEl2) ? idEl2.GetString() : null);\n\n                var logRow = await _db.MessageLogs\n                    .FirstOrDefaultAsync(x => x.Id == messageLogId && x.BusinessId == businessId);\n\n                if (logRow != null)\n                {\n                    logRow.Provider = provider;\n                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                        logRow.ProviderMessageId = providerMessageId;\n                }\n\n                var ev = new ProviderBillingEvent\n                {\n                    BusinessId = businessId,\n                    MessageLogId = messageLogId,\n                    Provider = provider,\n                    EventType = \"send_response\",\n                    ProviderMessageId = providerMessageId,\n                    PayloadJson = rawResponseJson,\n                    OccurredAt = DateTimeOffset.UtcNow\n                };\n\n                _db.ProviderBillingEvents.Add(ev);\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to ingest send response payload for business {BusinessId}\", businessId);\n            }\n        }\n\n        public async Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson)\n        {\n            // Guard: only accept events for known businesses\n            var hasBiz = await _db.Businesses.AnyAsync(b => b.Id == businessId);\n            if (!hasBiz)\n            {\n                _log.LogWarning(\"Ignoring {Provider} webhook for unknown business {BusinessId}\", provider, businessId);\n                return;\n            }\n\n            try\n            {\n                using var doc = JsonDocument.Parse(payloadJson);\n                var now = DateTimeOffset.UtcNow;\n\n                // For the common/strong-keyed case (ProviderMessageId), we rely on DB unique index.\n                // For weaker cases (no ProviderMessageId, only ConversationId), we still probe with ExistsAsync.\n\n                Task<bool> ExistsForConversationAsync(string eventType, string? conversationId)\n                {\n                    if (string.IsNullOrWhiteSpace(conversationId))\n                        return Task.FromResult(false);\n\n                    return _db.ProviderBillingEvents.AsNoTracking().AnyAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.Provider == provider &&\n                        x.EventType == eventType &&\n                        x.ConversationId == conversationId);\n                }\n\n                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n                {\n                    foreach (var entry in Enumerate(doc.RootElement, \"entry\"))\n                        foreach (var change in Enumerate(entry, \"changes\"))\n                        {\n                            if (!change.TryGetProperty(\"value\", out var value))\n                                continue;\n\n                            foreach (var st in Enumerate(value, \"statuses\"))\n                            {\n                                string? providerMessageId = st.TryGetProperty(\"id\", out var idEl)\n                                    ? idEl.GetString()\n                                    : null;\n\n                                string? status = null;\n                                if (st.TryGetProperty(\"status\", out var statusEl) && statusEl.ValueKind == JsonValueKind.String)\n                                    status = statusEl.GetString()?.ToLowerInvariant();\n\n                                // OccurredAt from provider if present\n                                var occurredAt = now;\n                                if (st.TryGetProperty(\"timestamp\", out var tsEl))\n                                {\n                                    if (tsEl.ValueKind == JsonValueKind.String &&\n                                        long.TryParse(tsEl.GetString(), out var tsLong))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsLong);\n                                    else if (tsEl.ValueKind == JsonValueKind.Number &&\n                                             tsEl.TryGetInt64(out var tsNum))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsNum);\n                                }\n\n                                // Conversation info\n                                string? conversationId = null;\n                                DateTimeOffset? convStartedAt = null;\n\n                                if (st.TryGetProperty(\"conversation\", out var convEl) &&\n                                    convEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (convEl.TryGetProperty(\"id\", out var cidEl))\n                                        conversationId = cidEl.GetString();\n\n                                    if (convEl.TryGetProperty(\"expiration_timestamp\", out var expEl))\n                                    {\n                                        long exp = 0;\n                                        if (expEl.ValueKind == JsonValueKind.String &&\n                                            long.TryParse(expEl.GetString(), out var expStr))\n                                            exp = expStr;\n                                        else if (expEl.ValueKind == JsonValueKind.Number &&\n                                                 expEl.TryGetInt64(out var expNum))\n                                            exp = expNum;\n\n                                        if (exp > 0)\n                                        {\n                                            var expiration = DateTimeOffset.FromUnixTimeSeconds(exp);\n                                            convStartedAt = expiration.AddHours(-24);\n                                        }\n                                    }\n                                }\n\n                                // Pricing block (optional)\n                                string? category = null;\n                                bool? billable = null;\n                                decimal? amount = null;\n                                string? currency = null;\n\n                                if (st.TryGetProperty(\"pricing\", out var pEl) &&\n                                    pEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (pEl.TryGetProperty(\"category\", out var catEl))\n                                        category = catEl.GetString()?.ToLowerInvariant();\n\n                                    if (pEl.TryGetProperty(\"billable\", out var bilEl) &&\n                                        (bilEl.ValueKind == JsonValueKind.True ||\n                                         bilEl.ValueKind == JsonValueKind.False))\n                                        billable = bilEl.GetBoolean();\n\n                                    if (pEl.TryGetProperty(\"amount\", out var amtEl) &&\n                                        amtEl.ValueKind == JsonValueKind.Number)\n                                        amount = amtEl.GetDecimal();\n\n                                    if (pEl.TryGetProperty(\"currency\", out var curEl) &&\n                                        curEl.ValueKind == JsonValueKind.String)\n                                        currency = curEl.GetString();\n                                }\n\n                                // 1) Status event (if present)\n                                if (!string.IsNullOrWhiteSpace(status))\n                                {\n                                    var ev = new ProviderBillingEvent\n                                    {\n                                        BusinessId = businessId,\n                                        Provider = provider,\n                                        EventType = status, // sent/delivered/read etc.\n                                        ProviderMessageId = providerMessageId,\n                                        ConversationId = conversationId,\n                                        ConversationCategory = category,\n                                        IsChargeable = billable,\n                                        PriceAmount = amount,\n                                        PriceCurrency = currency,\n                                        PayloadJson = payloadJson,\n                                        OccurredAt = occurredAt\n                                    };\n\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                    {\n                                        await TryAddBillingEventAsync(ev);\n                                    }\n                                    else\n                                    {\n                                        // fallback: dedupe via conversation id if no provider message id\n                                        if (!await ExistsForConversationAsync(status, conversationId))\n                                        {\n                                            _db.ProviderBillingEvents.Add(ev);\n                                        }\n                                    }\n                                }\n\n                                // 2) Pricing update (if any pricing fields)\n                                var hasAnyPricing =\n                                    !string.IsNullOrWhiteSpace(category) ||\n                                    billable.HasValue ||\n                                    amount.HasValue ||\n                                    !string.IsNullOrWhiteSpace(currency);\n\n                                if (hasAnyPricing)\n                                {\n                                    var pricingEv = new ProviderBillingEvent\n                                    {\n                                        BusinessId = businessId,\n                                        Provider = provider,\n                                        EventType = \"pricing_update\",\n                                        ProviderMessageId = providerMessageId,\n                                        ConversationId = conversationId,\n                                        ConversationCategory = category,\n                                        IsChargeable = billable,\n                                        PriceAmount = amount,\n                                        PriceCurrency = currency,\n                                        PayloadJson = payloadJson,\n                                        OccurredAt = occurredAt\n                                    };\n\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                    {\n                                        await TryAddBillingEventAsync(pricingEv);\n                                    }\n                                    else\n                                    {\n                                        if (!await ExistsForConversationAsync(\"pricing_update\", conversationId))\n                                        {\n                                            _db.ProviderBillingEvents.Add(pricingEv);\n                                        }\n                                    }\n                                }\n\n                                // Keep MessageLog in sync (best effort)\n                                var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                                if (logRow != null)\n                                {\n                                    logRow.Provider = provider;\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                        logRow.ProviderMessageId = providerMessageId;\n                                    if (!string.IsNullOrWhiteSpace(conversationId))\n                                        logRow.ConversationId = conversationId;\n                                    if (convStartedAt.HasValue)\n                                        logRow.ConversationStartedAt = convStartedAt;\n\n                                    if (billable.HasValue)\n                                        logRow.IsChargeable = billable.Value;\n                                    if (!string.IsNullOrWhiteSpace(category))\n                                        logRow.ConversationCategory = category;\n                                    if (amount.HasValue)\n                                        logRow.PriceAmount = amount;\n                                    if (!string.IsNullOrWhiteSpace(currency))\n                                        logRow.PriceCurrency = currency;\n                                }\n                            }\n                        }\n                }\n                else if (string.Equals(provider, \"PINNACLE\", StringComparison.OrdinalIgnoreCase))\n                {\n                    // Best-effort scan for pricing blocks\n                    foreach (var pricing in JsonPathAll(doc.RootElement, \"pricing\"))\n                    {\n                        string? category = pricing.TryGetProperty(\"category\", out var catEl)\n                            ? catEl.GetString()?.ToLowerInvariant()\n                            : null;\n\n                        bool? billable =\n                            pricing.TryGetProperty(\"billable\", out var bilEl) &&\n                            (bilEl.ValueKind == JsonValueKind.True ||\n                             bilEl.ValueKind == JsonValueKind.False)\n                                ? bilEl.GetBoolean()\n                                : (bool?)null;\n\n                        decimal? amount = null;\n                        if (pricing.TryGetProperty(\"amount\", out var amtEl) &&\n                            amtEl.ValueKind == JsonValueKind.Number)\n                            amount = amtEl.GetDecimal();\n\n                        string? currency = pricing.TryGetProperty(\"currency\", out var curEl)\n                            ? curEl.GetString()\n                            : null;\n\n                        var parent = TryGetParentObject(doc.RootElement, pricing);\n                        string? providerMessageId =\n                            TryGetString(parent, \"id\")\n                            ?? TryGetString(parent, \"message_id\")\n                            ?? TryGetString(parent, \"wamid\");\n\n                        string? conversationId =\n                            TryGetString(parent, \"conversation_id\")\n                            ?? TryGetNestedString(parent, \"conversation\", \"id\");\n\n                        string? status = TryGetString(parent, \"status\")?.ToLowerInvariant();\n\n                        // Pricing event\n                        var pricingEv = new ProviderBillingEvent\n                        {\n                            BusinessId = businessId,\n                            Provider = provider,\n                            EventType = \"pricing_update\",\n                            ProviderMessageId = providerMessageId,\n                            ConversationId = conversationId,\n                            ConversationCategory = category,\n                            IsChargeable = billable,\n                            PriceAmount = amount,\n                            PriceCurrency = currency,\n                            PayloadJson = payloadJson,\n                            OccurredAt = now\n                        };\n\n                        if (!string.IsNullOrWhiteSpace(providerMessageId))\n                        {\n                            await TryAddBillingEventAsync(pricingEv);\n                        }\n                        else\n                        {\n                            if (!await ExistsForConversationAsync(\"pricing_update\", conversationId))\n                                _db.ProviderBillingEvents.Add(pricingEv);\n                        }\n\n                        // Optional status event from same parent\n                        if (!string.IsNullOrWhiteSpace(status))\n                        {\n                            var statusEv = new ProviderBillingEvent\n                            {\n                                BusinessId = businessId,\n                                Provider = provider,\n                                EventType = status,\n                                ProviderMessageId = providerMessageId,\n                                ConversationId = conversationId,\n                                ConversationCategory = category,\n                                IsChargeable = billable,\n                                PriceAmount = amount,\n                                PriceCurrency = currency,\n                                PayloadJson = payloadJson,\n                                OccurredAt = now\n                            };\n\n                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n                            {\n                                await TryAddBillingEventAsync(statusEv);\n                            }\n                            else\n                            {\n                                if (!await ExistsForConversationAsync(status, conversationId))\n                                    _db.ProviderBillingEvents.Add(statusEv);\n                            }\n                        }\n\n                        // Sync MessageLog where possible\n                        var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                        if (logRow != null)\n                        {\n                            logRow.Provider = provider;\n                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                logRow.ProviderMessageId = providerMessageId;\n                            if (!string.IsNullOrWhiteSpace(conversationId))\n                                logRow.ConversationId = conversationId;\n\n                            if (billable.HasValue)\n                                logRow.IsChargeable = billable.Value;\n                            if (!string.IsNullOrWhiteSpace(category))\n                                logRow.ConversationCategory = category;\n                            if (amount.HasValue)\n                                logRow.PriceAmount = amount;\n                            if (!string.IsNullOrWhiteSpace(currency))\n                                logRow.PriceCurrency = currency;\n                        }\n                    }\n                }\n                else\n                {\n                    // Unknown provider; keep audit trail, but flagged\n                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                    {\n                        BusinessId = businessId,\n                        Provider = provider,\n                        EventType = \"unknown_provider_webhook\",\n                        PayloadJson = payloadJson,\n                        OccurredAt = now\n                    });\n                }\n\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to ingest webhook payload for business {BusinessId}\", businessId);\n            }\n        }\n\n        // -------- helpers --------\n\n\n\n        private async Task<ProviderBillingEvent?> TryAddBillingEventAsync(ProviderBillingEvent ev)\n        {\n            if (string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n            {\n                // No strong key; let caller handle SaveChanges once.\n                _db.ProviderBillingEvents.Add(ev);\n                return ev;\n            }\n\n            _db.ProviderBillingEvents.Add(ev);\n\n            try\n            {\n                await _db.SaveChangesAsync();\n                return ev;\n            }\n            catch (DbUpdateException ex) when (IsUniqueViolation(ex))\n            {\n                _log.LogDebug(\"Duplicate ProviderBillingEvent ignored for message {ProviderMessageId}\", ev.ProviderMessageId);\n                _db.Entry(ev).State = EntityState.Detached;\n                return null;\n            }\n        }\n\n        private static bool IsUniqueViolation(DbUpdateException ex)\n        {\n            // Postgres example\n            if (ex.InnerException is PostgresException pg &&\n                pg.SqlState == PostgresErrorCodes.UniqueViolation)\n            {\n                return true;\n            }\n\n            // For SQL Server / others, check error numbers here.\n\n            return false;\n        }\n\n        private async Task<MessageLog?> FindMatchingMessageLog(Guid businessId, string? providerMessageId, string? conversationId)\n        {\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var byMsgId = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.ProviderMessageId == providerMessageId);\n                if (byMsgId != null) return byMsgId;\n            }\n\n            if (!string.IsNullOrWhiteSpace(conversationId))\n            {\n                var byConv = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x =>\n                        x.BusinessId == businessId &&\n                        x.ConversationId == conversationId);\n                if (byConv != null) return byConv;\n            }\n\n            return null;\n        }\n\n        private static IEnumerable<JsonElement> Enumerate(JsonElement root, string name)\n        {\n            if (root.ValueKind != JsonValueKind.Object) yield break;\n            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) yield break;\n\n            foreach (var x in arr.EnumerateArray())\n                yield return x;\n        }\n\n        private static IEnumerable<JsonElement> JsonPathAll(JsonElement root, string name)\n        {\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (string.Equals(p.Name, name, StringComparison.OrdinalIgnoreCase))\n                        yield return p.Value;\n\n                    foreach (var x in JsonPathAll(p.Value, name))\n                        yield return x;\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var item in root.EnumerateArray())\n                    foreach (var x in JsonPathAll(item, name))\n                        yield return x;\n            }\n        }\n\n        private static JsonElement? TryGetParentObject(JsonElement root, JsonElement node)\n        {\n            // Best-effort: System.Text.Json has no parent pointer; we scan recursively.\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (p.Value.ValueKind == JsonValueKind.Object)\n                    {\n                        if (object.ReferenceEquals(p.Value, node)) return root;\n                        var cand = TryGetParentObject(p.Value, node);\n                        if (cand.HasValue) return cand;\n                    }\n                    else if (p.Value.ValueKind == JsonValueKind.Array)\n                    {\n                        foreach (var e in p.Value.EnumerateArray())\n                        {\n                            if (object.ReferenceEquals(e, node)) return root;\n                            var cand = TryGetParentObject(e, node);\n                            if (cand.HasValue) return cand;\n                        }\n                    }\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var e in root.EnumerateArray())\n                {\n                    var cand = TryGetParentObject(e, node);\n                    if (cand.HasValue) return cand;\n                }\n            }\n\n            return null;\n        }\n\n        private static string? TryGetString(JsonElement? obj, string name)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object)\n                return null;\n\n            return obj.Value.TryGetProperty(name, out var el) ? el.GetString() : null;\n        }\n\n        private static string? TryGetNestedString(JsonElement? obj, string name1, string name2)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object)\n                return null;\n\n            if (!obj.Value.TryGetProperty(name1, out var inner) || inner.ValueKind != JsonValueKind.Object)\n                return null;\n\n            return inner.TryGetProperty(name2, out var v) ? v.GetString() : null;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingReadService.cs",
      "sha256": "0298676bbd8d96132ccbaf42ca893f76a03f769606106dfe82a6bed17982b5fc",
      "language": "csharp",
      "size": 7066,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\n\nusing xbytechat.api;                               // AppDbContext\nusing xbytechat_api.Features.Billing.DTOs;         // BillingSnapshotDto\nusing xbytechat_api.Features.Billing.Models;       // ProviderBillingEvent (for _db.ProviderBillingEvents)\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingReadService : IBillingReadService\n    {\n        private readonly AppDbContext _db;\n        public BillingReadService(AppDbContext db) => _db = db;\n\n        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n        {\n            // Build inclusive [from..to] range in UTC\n            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n            // 1) Volume: total messages in the period (unchanged behavior)\n            var totalMessages = await _db.MessageLogs.AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt)\n                .CountAsync();\n\n            // 2) Billing source of truth: pricing_update events in the period\n            //    (Only select small projection; we'll dedupe in-memory safely.)\n            var evRaw = await _db.ProviderBillingEvents.AsNoTracking()\n                .Where(e => e.BusinessId == businessId\n                            && e.EventType == \"pricing_update\"\n                            && e.OccurredAt >= fromDt && e.OccurredAt <= toDt)\n                .Select(e => new {\n                    e.Provider,\n                    e.ProviderMessageId,\n                    e.EventType,\n                    e.ConversationId,\n                    e.ConversationCategory,\n                    e.IsChargeable,\n                    e.PriceAmount,\n                    e.PriceCurrency\n                })\n                .ToListAsync();\n\n            // 2a) Defend against webhook replays (if DB unique index not yet deployed)\n            //     Deduplicate on Provider+ProviderMessageId+EventType to drop repeats of the same message event.\n            var evDedup = evRaw\n                .GroupBy(e => new { e.Provider, e.ProviderMessageId, e.EventType })\n                .Select(g => g.First())\n                .ToList();\n\n            // 2b) Group by conversation to compute window-level metrics\n            var convGroups = evDedup\n                .Where(e => !string.IsNullOrWhiteSpace(e.ConversationId))\n                .GroupBy(e => e.ConversationId!)\n                .ToList();\n\n            // Chargeable windows: any event in the conversation marked billable == true\n            var chargeableWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == true));\n\n            // Free windows: conversations explicitly marked billable == false and NOT marked true anywhere\n            var freeWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == false) && !g.Any(x => x.IsChargeable == true));\n\n            // Count by category (per conversation, pick first non-empty category; default \"unknown\")\n            var countByCategory = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                var category = g.Select(x => x.ConversationCategory)\n                                .FirstOrDefault(s => !string.IsNullOrWhiteSpace(s))\n                                ?.ToLowerInvariant() ?? \"unknown\";\n                countByCategory[category] = countByCategory.TryGetValue(category, out var c) ? c + 1 : 1;\n            }\n\n            // Spend by currency: for each conversation, take the latest non-null amount (if any), then sum by currency\n            var spendByCurrency = new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                // Prefer an explicit currency on any event in the conversation\n                var amountWithCurrency = g.LastOrDefault(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency));\n                if (amountWithCurrency?.IsChargeable == true) // only count billable windows\n                {\n                    var cur = amountWithCurrency.PriceCurrency!.ToUpperInvariant();\n                    var amt = amountWithCurrency.PriceAmount!.Value;\n                    spendByCurrency[cur] = spendByCurrency.TryGetValue(cur, out var sum) ? sum + amt : amt;\n                }\n            }\n\n            // Compose DTO\n            var dto = new BillingSnapshotDto\n            {\n                TotalMessages = totalMessages,\n                // These two are now \"window\"-level metrics (conversations) ‚Äì most accurate for billing with Meta.\n                ChargeableMessages = chargeableWindows,\n                FreeMessages = freeWindows,\n                CountByCategory = countByCategory,\n                SpendByCurrency = spendByCurrency\n            };\n\n            return dto;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n//using xbytechat_api.Features.Billing.DTOs;\n\n//namespace xbytechat_api.Features.Billing.Services\n//{\n//    public class BillingReadService : IBillingReadService\n//    {\n//        private readonly AppDbContext _db;\n//        public BillingReadService(AppDbContext db) => _db = db;\n\n//        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n//        {\n//            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n//            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n//            var q = _db.MessageLogs.AsNoTracking()\n//                    .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt);\n\n//            var list = await q.Select(x => new {\n//                x.IsChargeable,\n//                x.ConversationCategory,\n//                x.PriceAmount,\n//                x.PriceCurrency\n//            }).ToListAsync();\n\n//            var dto = new BillingSnapshotDto\n//            {\n//                TotalMessages = list.Count,\n//                ChargeableMessages = list.Count(x => x.IsChargeable == true),\n//                FreeMessages = list.Count(x => x.IsChargeable == false)\n//            };\n\n//            dto.CountByCategory = list\n//                .GroupBy(x => string.IsNullOrWhiteSpace(x.ConversationCategory) ? \"unknown\" : x.ConversationCategory!.ToLowerInvariant())\n//                .ToDictionary(g => g.Key, g => g.Count());\n\n//            dto.SpendByCurrency = list\n//                .Where(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency))\n//                .GroupBy(x => x.PriceCurrency!)\n//                .ToDictionary(g => g.Key, g => g.Sum(v => v.PriceAmount!.Value));\n\n//            return dto;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingIngestService.cs",
      "sha256": "8678a1ec3a5979b124caa81faa47d93d5ca21bd8c0d97bf35a8d55bb50824bdf",
      "language": "csharp",
      "size": 416,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingIngestService\n    {\n        Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson);\n        Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson);\n        \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingReadService.cs",
      "sha256": "146ab2ebc0dea7d43cd6d050c51c28118cf4c7655b369657e198861aa6c9c3ca",
      "language": "csharp",
      "size": 306,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingReadService\n    {\n        Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Controllers/BusinessesController.cs",
      "sha256": "0d631762644dc2d0cbed26c956d521e1d93f26689a5ba243146689be0fd375f6",
      "language": "csharp",
      "size": 6135,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Helpers;\nusing Serilog;\nusing System.Security.Claims;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.BusinessModule.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.BusinessModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class BusinessesController : ControllerBase\n    {\n        private readonly IBusinessService _businessService;\n\n        public BusinessesController(IBusinessService businessService)\n        {\n            _businessService = businessService;\n        }\n\n\n\n        [HttpGet(\"pending\")]\n        [Authorize(Roles = \"admin,superadmin,partner\")] // partners see scoped; admin/superadmin see ALL\n        public async Task<IActionResult> GetPendingBusinesses()\n        {\n            try\n            {\n                // Read role/id from multiple possible claim types\n                var role = User.FindFirst(ClaimTypes.Role)?.Value\n                           ?? User.FindFirst(\"role\")?.Value\n                           ?? User.FindFirst(\"roles\")?.Value\n                           ?? \"\";\n\n                var userId = User.FindFirst(\"id\")?.Value\n                           ?? User.FindFirst(ClaimTypes.NameIdentifier)?.Value\n                           ?? User.FindFirst(\"sub\")?.Value\n                           ?? \"\";\n\n                var result = await _businessService.GetPendingBusinessesAsync(role, userId);\n                return Ok(ResponseResult.SuccessInfo(\"‚úÖ Pending businesses fetched successfully.\", result));\n            }\n            catch\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"‚ùå Failed to fetch pending businesses. Please try again later.\"));\n            }\n        }\n\n\n        // ‚úÖ Get business by ID (used for profile completion)\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetBusinessById(Guid id)\n        {\n            try\n            {\n                var business = await _businessService.GetByIdAsync(id);\n                if (business == null)\n                    return NotFound(ResponseResult.ErrorInfo(\"‚ùå Business not found.\"));\n\n                return Ok(business);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"üö® Failed to fetch business. \" + ex.Message));\n            }\n        }\n\n        //[HttpPut(\"assigned-to/{id}\")]\n        [HttpPut(\"{id}\")]\n        [Authorize]\n        public async Task<IActionResult> UpdateBusiness(Guid id, [FromBody] UpdateBusinessDto dto)\n        {\n            if (dto == null)\n                return BadRequest(ResponseResult.ErrorInfo(\"‚ùå Invalid payload.\"));\n\n            var result = await _businessService.UpdateBusinessAsync(id, dto);\n\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n\n        // üü¢ Approve a business\n        [HttpPost(\"approve/{id}\")]\n        public async Task<IActionResult> Approve(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.ApproveBusinessAsync(id);\n\n                if (result.Success)\n                {\n                    // ‚úÖ Optional Success Logging\n                    Log.Information(\"‚úÖ Business approved successfully. BusinessId: {BusinessId}\", id);\n                    return Ok(result);\n                }\n                else\n                {\n                    // ‚úÖ Optional Warning Logging\n                    Log.Warning(\"‚ö†Ô∏è Business approval failed. BusinessId: {BusinessId} - Message: {Message}\", id, result.Message);\n                    return BadRequest(result);\n                }\n            }\n            catch (Exception ex)\n            {\n                // ‚úÖ Proper Error Logging\n                Log.Error(ex, \"‚ùå Exception occurred while approving business. BusinessId: {BusinessId}\", id);\n\n                return StatusCode(500, ResponseResult.ErrorInfo(\n                    \"‚ùå Something went wrong while approving business. Please try again later.\"\n                ));\n            }\n        }\n\n\n        // üî¥ Reject a business\n        [HttpPost(\"reject/{id}\")]\n        public async Task<IActionResult> Reject(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.RejectBusinessAsync(id);\n                return result.Success ? Ok(result) : NotFound(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"‚ùå Failed to reject business. \" + ex.Message));\n            }\n        }\n\n        // üü° Put a business on hold\n        [HttpPost(\"hold/{id}\")]\n        public async Task<IActionResult> Hold(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.HoldBusinessAsync(id);\n                return result.Success ? Ok(result) : NotFound(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"‚ùå Failed to hold business. \" + ex.Message));\n            }\n        }\n\n        // üõ† Complete profile after signup\n        [HttpPost(\"profile-completion/{businessId}\")]\n        public async Task<IActionResult> CompleteProfile(Guid businessId, [FromBody] ProfileCompletionDto dto)\n        {\n            try\n            {\n                var result = await _businessService.CompleteProfileAsync(businessId, dto);\n                return result.Success ? Ok(result) : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"‚ùå Failed to update profile. \" + ex.Message));\n            }\n        }\n\n        [HttpGet(\"approved\")]\n        [Authorize(Roles = \"SuperAdmin\")]\n        public async Task<IActionResult> GetApprovedBusinesses()\n        {\n            var result = await _businessService.GetApprovedBusinessesAsync();\n            return Ok(result);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/PendingBusinessDto.cs",
      "sha256": "262c7390254b692bef62525ec48c34eb502354e446d2e98e77586b32f640f2be",
      "language": "csharp",
      "size": 482,
      "content": "namespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class PendingBusinessDto\n    {\n        public Guid BusinessId { get; set; }\n        public string CompanyName { get; set; }\n        public string BusinessEmail { get; set; }\n        public string? RepresentativeName { get; set; }\n        public string? Phone { get; set; }\n        public string Plan { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public bool? IsApproved { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/ProfileCompletionDto.cs",
      "sha256": "cbd238cd045c0ee7bfc5061311058fa84005f29244727a11ef5b7a6eedbcf64f",
      "language": "csharp",
      "size": 489,
      "content": "namespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class ProfileCompletionDto\n    {\n        public string? BusinessName { get; set; }\n        public string? ReperesentativeName { get; set; }\n        public string? CompanyPhone { get; set; }\n        public string? Phone { get; set; }\n        public string? Website { get; set; }\n        public string? Address { get; set; }\n        public string? Industry { get; set; }\n        public string? LogoUrl { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/SignupBusinessDto.cs",
      "sha256": "daebace2d54e91a96825decc469c8acd57822d3e74bd5271ca80792e36cbb30e",
      "language": "csharp",
      "size": 717,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class SignupBusinessDto\n    {\n        [Required]\n        public string CompanyName { get; set; }\n\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; }\n\n        [Required]\n        public string Password { get; set; }\n\n        public string? RepresentativeName { get; set; }\n\n        public string? Phone { get; set; }\n        public string RoleName { get; set; } = \"business\"; // Default to business role\n\n        // üÜï NEW FIELD (Internal use only)\n        public Guid? CreatedByPartnerId { get; set; } // to assign the business to a specific user/agent/partner}\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/UpdateBusinessDto.cs",
      "sha256": "d220065497b49d19e2e1ee681723ac965ddecc155c3de606f397fbdcc87ac585",
      "language": "csharp",
      "size": 756,
      "content": "namespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    /// <summary>\n    /// Allowed fields for business profile updates.\n    /// No lifecycle / plan / ownership fields here.\n    /// </summary>\n    public class UpdateBusinessDto\n    {\n        public string? CompanyName { get; set; }\n        public string? BusinessName { get; set; }\n        public string? BusinessEmail { get; set; }\n        public string? Phone { get; set; }\n        public string? CompanyPhone { get; set; }\n        public string? Website { get; set; }\n        public string? Address { get; set; }\n        public string? Industry { get; set; }\n        public string? LogoUrl { get; set; }\n        public string? Tags { get; set; }\n        public string? Notes { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Models/Business.cs",
      "sha256": "88684dd541d49eb7c1c8d896f46aa2a50c59c2f7385cdbaae206d7829b0616c3",
      "language": "csharp",
      "size": 2914,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.BusinessModule.Models\n{\n    public class Business\n    {\n        public Guid Id { get; set; }\n\n        // üè¢ Basic Info\n        public string? CompanyName { get; set; }\n        public string BusinessName { get; set; }\n        public string BusinessEmail { get; set; }  // Not used for login, just business contact\n        public string? RepresentativeName { get; set; }\n\n        public Guid? CreatedByPartnerId { get; set; }\n        public string? Phone { get; set; }\n        public string? CompanyPhone { get; set; }\n        public string? Website { get; set; }\n        public string? Address { get; set; }\n        public string? Industry { get; set; }\n        public string? LogoUrl { get; set; }\n\n        // üì¶ SaaS Plan & Status using Enums\n        // public enum PlanType { Basic, Smart, Advanced } -- moved to bisinessinfo\n        // public PlanType Plan { get; set; } = PlanType.Basic;  // moved to bisinessinfo\n        public enum StatusType { Pending, Approved, Rejected }\n        public StatusType Status { get; set; } = StatusType.Pending;  // Default to Pending\n\n        // üìù Metadata\n        public string? Tags { get; set; }\n        public string? Source { get; set; }\n        public string? Notes { get; set; }\n\n        // üìÖ Timestamps\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n        public bool IsApproved { get; set; } = false;\n        public string? ApprovedBy { get; set; }\n        public DateTime? ApprovedAt { get; set; }\n        public DateTime? LastLoginAt { get; set; }\n\n        // üóë Soft Deletion\n        public bool IsDeleted { get; set; } = false;\n        public DateTime? DeletedAt { get; set; }\n        public string? DeletedBy { get; set; }\n\n        // üë• Navigation Property - List of Users (nullable if no users)\n        public List<User> Users { get; set; } = new();\n\n\n        public ICollection<MessageStatusLog> MessageStatusLogs { get; set; }\n        public ICollection<Campaign> Campaigns { get; set; } = new List<Campaign>();\n        // üîó Plan Info linked\n\n        /// This is a one-to-one relationship with BusinessPlanInfo\n        public BusinessPlanInfo? BusinessPlanInfo { get; set; }\n\n        public Guid? PlanId { get; set; } // Nullable in case no plan is assigned yet\n        public Plan? Plan { get; set; }   // Navigation property to the Plan entity\n\n       // public WhatsAppSettingEntity WhatsAppSettings { get; set; }\n        public ICollection<WhatsAppSettingEntity> WhatsAppSettings { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Services/BusinessService.cs",
      "sha256": "26049eafd3bce6b1a72d895f5d7a310df8623bc0e268b3b24ec76c92fd3eb69a",
      "language": "csharp",
      "size": 22613,
      "content": "using Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing System.Security.Claims;\nusing System.Security.Cryptography;\nusing System.Text;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.AuditTrail.Models;\nusing xbytechat.api.Features.AuditTrail.Services;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.Repositories.Interfaces;\n\nnamespace xbytechat.api.Features.BusinessModule.Services\n{\n    public class BusinessService : IBusinessService\n    {\n        private readonly IGenericRepository<Business> _businessRepo;\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IGenericRepository<Role> _roleRepo;\n        private readonly IAuditLogService _auditLogService;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        // inside BusinessService class (class scope, not inside a method)\n        private static readonly Guid BASIC_PLAN_ID = Guid.Parse(\"5f9f5de1-a0b2-48ba-b03d-77b27345613f\");\n        private readonly IPasswordHasher<User> _passwordHasher;\n\n        private readonly AppDbContext _db;\n        public BusinessService(\n            AppDbContext db,\n            IGenericRepository<Business> businessRepo,\n            IGenericRepository<User> userRepo,\n            IGenericRepository<Role> roleRepo,\n            IAuditLogService auditLogService,\n            IHttpContextAccessor httpContextAccessor, IPasswordHasher<User> passwordHasher)\n        {\n            _db = db;\n            _passwordHasher = passwordHasher;\n            _businessRepo = businessRepo;\n            _userRepo = userRepo;\n            _roleRepo = roleRepo;\n            _auditLogService = auditLogService;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        //public async Task<ResponseResult> SignupBusinessAsync(SignupBusinessDto dto)\n        //{\n        //    var normalizedEmail = dto.Email.Trim().ToLower();\n        //    var existing = await _userRepo.FirstOrDefaultAsync(u => u.Email == normalizedEmail);\n        //    if (existing != null)\n        //        return ResponseResult.ErrorInfo(\"‚ùå Email already exists\");\n\n        //    var business = new Business\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        CompanyName = dto.CompanyName,\n        //        BusinessName = dto.CompanyName,\n        //        BusinessEmail = normalizedEmail,\n        //        RepresentativeName = dto.RepresentativeName,\n        //        Phone = dto.Phone,\n        //        CreatedByPartnerId = dto.CreatedByPartnerId,\n        //        Status = Business.StatusType.Pending,\n        //        // Plan = PlanType.Basic,\n        //        IsApproved = false,\n        //        CreatedAt = DateTime.UtcNow,\n        //        PlanId = BASIC_PLAN_ID   // ‚úÖ hard-code Basic plan here\n        //    };\n        //    // STEP 2: Create Plan Info separately\n        //    var planInfo = new BusinessPlanInfo\n        //    {\n        //        BusinessId = business.Id,\n        //        Plan = PlanType.Basic,\n        //        TotalMonthlyQuota = 1000,\n        //        RemainingMessages = 1000,\n        //        QuotaResetDate = DateTime.UtcNow.AddMonths(1),\n        //        WalletBalance = 0\n        //    };\n        //    // STEP 3: Link them\n        //    business.BusinessPlanInfo = planInfo;\n        //    // STEP 4: Save both\n        //    await _businessRepo.AddAsync(business);\n        //    await _businessRepo.SaveAsync();\n\n        //    var role = await _roleRepo.FirstOrDefaultAsync(r => r.Name.ToLower() == dto.RoleName.Trim().ToLower());\n\n        //    if (role == null)\n        //        return ResponseResult.ErrorInfo(\"‚ùå Invalid role specified\");\n\n        //    var user = new User\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        Name = dto.CompanyName,\n        //        Email = normalizedEmail,\n        //        PasswordHash = HashPassword(dto.Password),\n        //        //PasswordHash = _passwordHasher.HashPassword(null!, dto.Password),\n        //        Role = role,\n        //        Status = \"Pending\",\n        //        BusinessId = business.Id\n        //    };\n\n        //    await _userRepo.AddAsync(user);\n        //    await _userRepo.SaveAsync();\n\n        //    await _auditLogService.SaveLogAsync(new AuditLog\n        //    {\n        //        BusinessId = business.Id,\n        //        PerformedByUserId = user.Id,\n        //        PerformedByUserName = user.Name,\n        //        RoleAtTime = \"business\",\n        //        ActionType = \"business.signup\",\n        //        Description = $\"New business signup: {business.CompanyName}\",\n        //        IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n        //        UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n        //    });\n\n        //    return ResponseResult.SuccessInfo(\"‚úÖ Signup successful. Pending approval.\", new { BusinessId = business.Id });\n        //}\n\n        public async Task<ResponseResult> SignupBusinessAsync(SignupBusinessDto dto)\n        {\n            var normalizedEmail = dto.Email.Trim().ToLower();\n            var existing = await _userRepo.FirstOrDefaultAsync(u => u.Email == normalizedEmail);\n            if (existing != null)\n                return ResponseResult.ErrorInfo(\"‚ùå Email already exists\");\n\n            var business = new Business\n            {\n                Id = Guid.NewGuid(),\n                CompanyName = dto.CompanyName,\n                BusinessName = dto.CompanyName,\n                BusinessEmail = normalizedEmail,\n                RepresentativeName = dto.RepresentativeName,\n                Phone = dto.Phone,\n                CreatedByPartnerId = dto.CreatedByPartnerId,\n                Status = Business.StatusType.Pending,\n                IsApproved = false,\n                CreatedAt = DateTime.UtcNow,\n\n                // ‚ùå IMPORTANT: no plan yet at signup\n                PlanId = null,              // if Guid?  (or just omit setting it)\n                                            // BusinessPlanInfo = null   // will be created at plan-selection time\n            };\n\n            // Only save the business now, without plan info\n            await _businessRepo.AddAsync(business);\n            await _businessRepo.SaveAsync();\n\n            var role = await _roleRepo.FirstOrDefaultAsync(\n                r => r.Name.ToLower() == dto.RoleName.Trim().ToLower()\n            );\n\n            if (role == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid role specified\");\n\n            var user = new User\n            {\n                Id = Guid.NewGuid(),\n                Name = dto.CompanyName,\n                Email = normalizedEmail,\n                PasswordHash = HashPassword(dto.Password),\n                Role = role,\n                Status = \"Pending\",\n                BusinessId = business.Id\n            };\n\n            await _userRepo.AddAsync(user);\n            await _userRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = user.Id,\n                PerformedByUserName = user.Name,\n                RoleAtTime = \"business\",\n                ActionType = \"business.signup\",\n                Description = $\"New business signup: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\n                \"‚úÖ Signup successful. Pending approval.\",\n                new { BusinessId = business.Id }\n            );\n        }\n\n\n\n        public async Task<ResponseResult> UpdateBusinessAsync(Guid businessId, UpdateBusinessDto dto)\n        {\n            if (dto == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Invalid business update payload.\");\n\n            var business = await _businessRepo.AsQueryable()\n                .FirstOrDefaultAsync(b => b.Id == businessId && !b.IsDeleted);\n\n            if (business == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Business not found.\");\n\n            // ---- Authorization: who is allowed to edit this business? ----\n\n            var httpContext = _httpContextAccessor.HttpContext;\n            var user = httpContext?.User;\n\n            if (user == null || !user.Identity?.IsAuthenticated == true)\n                return ResponseResult.ErrorInfo(\"‚ùå Unauthorized. Please login again.\");\n\n            var role =\n                user.FindFirst(ClaimTypes.Role)?.Value ??\n                user.FindFirst(\"role\")?.Value ??\n                user.FindFirst(\"roles\")?.Value ??\n                string.Empty;\n\n            var userIdStr =\n                user.FindFirst(\"id\")?.Value ??\n                user.FindFirst(ClaimTypes.NameIdentifier)?.Value ??\n                user.FindFirst(\"sub\")?.Value ??\n                string.Empty;\n\n            Guid.TryParse(userIdStr, out var userId);\n\n            var roleLc = (role ?? string.Empty).ToLowerInvariant();\n            var isAdmin = roleLc == \"admin\" || roleLc == \"superadmin\";\n            var isPartner = roleLc == \"partner\";\n            var isAssignedPartner = isPartner && business.CreatedByPartnerId.HasValue &&\n                                    business.CreatedByPartnerId.Value == userId;\n\n            var isBusinessUser = false;\n            if (userId != Guid.Empty)\n            {\n                var userEntity = await _userRepo.AsQueryable()\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(u => u.Id == userId);\n\n                if (userEntity != null && userEntity.BusinessId == business.Id)\n                    isBusinessUser = true;\n            }\n\n            if (!isAdmin && !isAssignedPartner && !isBusinessUser)\n            {\n                return ResponseResult.ErrorInfo(\"‚õî You are not allowed to update this business.\");\n            }\n\n            // ---- Apply only allowed fields ----\n\n            if (!string.IsNullOrWhiteSpace(dto.CompanyName))\n                business.CompanyName = dto.CompanyName.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.BusinessName))\n                business.BusinessName = dto.BusinessName.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.BusinessEmail))\n                business.BusinessEmail = dto.BusinessEmail.Trim().ToLowerInvariant();\n\n            if (!string.IsNullOrWhiteSpace(dto.Phone))\n                business.Phone = dto.Phone.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.CompanyPhone))\n                business.CompanyPhone = dto.CompanyPhone.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Website))\n                business.Website = dto.Website.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Address))\n                business.Address = dto.Address.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Industry))\n                business.Industry = dto.Industry.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.LogoUrl))\n                business.LogoUrl = dto.LogoUrl.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Tags))\n                business.Tags = dto.Tags.Trim();\n\n            if (!string.IsNullOrWhiteSpace(dto.Notes))\n                business.Notes = dto.Notes.Trim();\n\n            // ‚ùå DO NOT touch:\n            // - business.Status\n            // - business.IsApproved\n            // - business.PlanId\n            // - business.BusinessPlanInfo\n            // - business.CreatedByPartnerId\n            // - deletion flags\n            // These are controlled only by dedicated admin/partner flows.\n\n            try\n            {\n                _businessRepo.Update(business);\n                await _businessRepo.SaveAsync();\n                return ResponseResult.SuccessInfo(\"‚úÖ Business updated successfully.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to update business: \" + ex.Message);\n            }\n        }\n\n\n        public async Task<List<PendingBusinessDto>> GetPendingBusinessesAsync(string role, string userId)\n        {\n            try\n            {\n                var roleLc = (role ?? \"\").ToLowerInvariant();\n\n                // base: pending + not deleted\n                IQueryable<Business> q = _businessRepo.AsQueryable()\n                    .AsNoTracking()\n                    .Include(b => b.BusinessPlanInfo)   // ‚úÖ load enum Plan from BusinessPlanInfo\n                                                        // .Include(b => b.Plan)            // ‚Üê only if you have a Plan navigation property\n                    .Where(b => b.Status == Business.StatusType.Pending && !b.IsDeleted);\n\n                // scope for partner\n                if (roleLc == \"partner\")\n                {\n                    if (!Guid.TryParse(userId, out var partnerId)) return new();\n                    q = q.Where(b => b.CreatedByPartnerId == partnerId);\n                }\n                else if (roleLc != \"admin\" && roleLc != \"superadmin\")\n                {\n                    return new(); // anyone else: nothing\n                }\n\n                var items = await q.OrderByDescending(b => b.CreatedAt).ToListAsync();\n\n                // Map to your existing DTO; with Include() the enum will be present\n                return items.Select(b => new PendingBusinessDto\n                {\n                    BusinessId = b.Id,\n                    CompanyName = b.CompanyName ?? \"\",\n                    BusinessEmail = b.BusinessEmail ?? \"\",\n                    RepresentativeName = b.RepresentativeName ?? \"\",\n                    Phone = b.Phone ?? \"\",\n                    // Shows \"Basic\" etc. because BusinessPlanInfo is now loaded\n                    Plan = b.BusinessPlanInfo?.Plan.ToString() ?? \"Unknown\",\n                    CreatedAt = b.CreatedAt,\n                    IsApproved = b.IsApproved\n                }).ToList();\n            }\n            catch\n            {\n                return new();\n            }\n        }\n\n        public async Task<ResponseResult> ApproveBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo\n                .AsQueryable()\n                .Include(b => b.Users)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (business == null)\n                return ResponseResult.ErrorInfo(\"‚ùå Business not found.\");\n\n            // ‚úÖ Current Logged-in User Details\n            var httpContext = _httpContextAccessor.HttpContext;\n            var currentUserId = httpContext?.User?.FindFirst(\"id\")?.Value;\n            var currentUserRole = httpContext?.User?.Claims\n    .FirstOrDefault(c => c.Type.Contains(\"role\"))?.Value;\n            //httpContext?.User?.FindFirst(\"role\")?.Value;\n\n            // var currentUserName = httpContext?.User?.FindFirst(\"name\")?.Value ?? \"Unknown\";\n            var currentUserName = httpContext?.User?.Claims\n    .FirstOrDefault(c => c.Type.Contains(\"name\"))?.Value ?? \"Unknown\";\n            if (string.IsNullOrEmpty(currentUserId) || string.IsNullOrEmpty(currentUserRole))\n                return ResponseResult.ErrorInfo(\"‚ùå Unauthorized access. Please login again.\");\n\n            var currentGuid = Guid.Parse(currentUserId);\n\n            // ‚úÖ Authorization Logic\n            var isSuperAdmin = currentUserRole.Equals(\"admin\", StringComparison.OrdinalIgnoreCase) ||\n                               currentUserRole.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase);\n\n            var isAssignedPartner = business.CreatedByPartnerId.HasValue &&\n                                     business.CreatedByPartnerId.Value == currentGuid;\n\n            if (!isSuperAdmin && !isAssignedPartner)\n            {\n                return ResponseResult.ErrorInfo(\"‚õî You are not authorized to approve this business.\");\n            }\n\n            // ‚úÖ Approve Business\n\n            business.IsApproved = true;\n            business.Status = Business.StatusType.Approved;\n            business.ApprovedAt = DateTime.UtcNow;\n            business.ApprovedBy = currentUserName;\n            _businessRepo.Update(business);\n\n            // ‚úÖ Update all Users to \"ProfilePending\"\n            foreach (var user in business.Users)\n            {\n                user.Status = \"Active\";\n                _userRepo.Update(user);\n            }\n\n            await _businessRepo.SaveAsync();\n            await _userRepo.SaveAsync();\n\n            // ‚úÖ Audit Log\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = currentGuid,\n                PerformedByUserName = currentUserName,\n                RoleAtTime = currentUserRole,\n                ActionType = \"business.approved\",\n                Description = $\"Business approved: {business.CompanyName}\",\n                IPAddress = httpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = httpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Business approved successfully.\");\n        }\n\n        public async Task<ResponseResult> RejectBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"‚ùå Business not found\");\n\n            business.Status = Business.StatusType.Rejected;\n            business.IsDeleted = true;\n            business.DeletedAt = DateTime.UtcNow;\n\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = Guid.TryParse(_httpContextAccessor.HttpContext?.User?.FindFirst(\"id\")?.Value, out var userId) ? userId : Guid.Empty,\n                PerformedByUserName = _httpContextAccessor.HttpContext?.User?.FindFirst(\"email\")?.Value,\n                RoleAtTime = _httpContextAccessor.HttpContext?.User?.FindFirst(\"role\")?.Value,\n                ActionType = \"business.rejected\",\n                Description = $\"Business rejected: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"‚úÖ Business rejected and marked as deleted\");\n        }\n\n        public async Task<ResponseResult> HoldBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"‚ùå Business not found\");\n\n            business.IsApproved = false;\n            business.Status = Business.StatusType.Pending;\n\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = Guid.TryParse(_httpContextAccessor.HttpContext?.User?.FindFirst(\"id\")?.Value, out var userId) ? userId : Guid.Empty,\n                PerformedByUserName = _httpContextAccessor.HttpContext?.User?.FindFirst(\"email\")?.Value,\n                RoleAtTime = _httpContextAccessor.HttpContext?.User?.FindFirst(\"role\")?.Value,\n                ActionType = \"business.hold\",\n                Description = $\"Business put on hold: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"‚è∏ Business put on hold\");\n        }\n\n        public async Task<ResponseResult> CompleteProfileAsync(Guid businessId, ProfileCompletionDto dto)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"‚ùå Business not found\");\n\n            if (!string.IsNullOrEmpty(dto.BusinessName)) business.BusinessName = dto.BusinessName;\n            if (!string.IsNullOrEmpty(dto.CompanyPhone)) business.CompanyPhone = dto.CompanyPhone;\n            if (!string.IsNullOrEmpty(dto.Website)) business.Website = dto.Website;\n            if (!string.IsNullOrEmpty(dto.Address)) business.Address = dto.Address;\n            if (!string.IsNullOrEmpty(dto.Industry)) business.Industry = dto.Industry;\n            if (!string.IsNullOrEmpty(dto.LogoUrl)) business.LogoUrl = dto.LogoUrl;\n            if (!string.IsNullOrEmpty(dto.ReperesentativeName)) business.RepresentativeName = dto.ReperesentativeName;\n            if (!string.IsNullOrEmpty(dto.Phone)) business.Phone = dto.Phone;\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n            return ResponseResult.SuccessInfo(\"‚úÖ Profile updated successfully\");\n        }\n\n        public async Task<Business?> GetBusinessByEmailAsync(string email)\n        {\n            return await _businessRepo.FirstOrDefaultAsync(b => b.BusinessEmail.ToLower() == email.Trim().ToLower());\n        }\n\n        private string HashPassword(string password)\n        {\n            using var sha = SHA256.Create();\n            var bytes = Encoding.UTF8.GetBytes(password);\n            var hash = sha.ComputeHash(bytes);\n            return Convert.ToBase64String(hash);\n        }\n\n        public async Task<Business?> GetByIdAsync(Guid businessId)\n        {\n            return await _businessRepo.FindByIdAsync(businessId);\n        }\n\n        public async Task<List<Business>> GetApprovedBusinessesAsync()\n        {\n            return await _businessRepo.AsQueryable()\n               .Where(b => b.IsApproved && !b.IsDeleted)\n               .OrderBy(b => b.CompanyName)\n               .ToListAsync();\n        }\n        public IQueryable<Business> Query()\n        {\n            return _businessRepo.AsQueryable();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Services/IBusinessService.cs",
      "sha256": "9220e7179eb4f63c8d9bd1278f36663493dd9e12a997747aef396415cdf99fab",
      "language": "csharp",
      "size": 1204,
      "content": "using System.Runtime.CompilerServices;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;\nnamespace xbytechat.api.Features.BusinessModule.Services\n{\n\n    public interface IBusinessService\n    {\n        IQueryable<Business> Query();\n        Task<ResponseResult> SignupBusinessAsync(SignupBusinessDto dto); /// Signup + create admin user\n\n        Task<ResponseResult> ApproveBusinessAsync(Guid businessId);      // Admin action\n        Task<ResponseResult> RejectBusinessAsync(Guid businessId);       // Admin action\n        Task<ResponseResult> HoldBusinessAsync(Guid businessId);         // Admin action\n        Task<ResponseResult> CompleteProfileAsync(Guid businessId, ProfileCompletionDto dto); // Post-login completion\n        Task<Business?> GetBusinessByEmailAsync(string email);\n        Task<Business?> GetByIdAsync(Guid businessId);\n \n        Task<ResponseResult> UpdateBusinessAsync(Guid businessId, UpdateBusinessDto dto);\n\n        Task<List<PendingBusinessDto>> GetPendingBusinessesAsync(string role, string userId);\n        Task<List<Business>> GetApprovedBusinessesAsync();\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignController.cs",
      "sha256": "c3bb5378a0e811f9d7020c9b0852a706b2c4ca892f0c59de50809785e449d428",
      "language": "csharp",
      "size": 17689,
      "content": "using DocumentFormat.OpenXml.InkML;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing Serilog.Context;\nusing System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.BusinessModule.Services;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing static xbytechat.api.Features.MessagesEngine.Controllers.MessageEngineController;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class CampaignController : ControllerBase\n    {\n        private readonly ICampaignService _campaignService;\n        private readonly IBusinessService _businessService;\n        private readonly IMessageEngineService _messageService;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public CampaignController(\n            ICampaignService campaignService,\n            IBusinessService businessService,\n            IMessageEngineService messageEngineService,\n            IHttpContextAccessor httpContextAccessor)\n        {\n            _campaignService = campaignService;\n            _businessService = businessService;\n            _messageService = messageEngineService;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n\n        [HttpGet(\"get-image-campaign\")]\n        public async Task<IActionResult> GetAll([FromQuery] string? type)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            var items = await _campaignService.GetAllCampaignsAsync(businessId, type);\n            return Ok(items);\n        }\n    \n\n        [HttpPost(\"create-text-campaign\")]\n        public async Task<IActionResult> CreateTextCampaign([FromBody] CampaignCreateDto dto)\n        {\n            try\n            {\n                var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n                if (!Guid.TryParse(businessIdClaim, out var businessId))\n                    return Unauthorized(new { message = \"üö´ Invalid or missing BusinessId claim.\" });\n\n                var createdBy = User.Identity?.Name ?? \"system\";\n\n                if (string.IsNullOrWhiteSpace(dto.Name))\n                    return BadRequest(new { message = \"üö´ Campaign name is required.\" });\n\n                if (string.IsNullOrWhiteSpace(dto.TemplateId))\n                    return BadRequest(new { message = \"üö´ TemplateId is required for template campaigns.\" });\n\n            \n\n                var campaignId = await _campaignService.CreateTextCampaignAsync(dto, businessId, createdBy);\n\n                return campaignId != null\n                    ? Ok(new\n                    {\n                        success = true,\n                        message = \"‚úÖ Campaign created successfully\",\n                        campaignId = campaignId.Value\n                    })\n                    : BadRequest(new { success = false, message = \"‚ùå Failed to create campaign\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception in CreateTextCampaign\");\n                return StatusCode(500, new { message = \"üö® Internal server error\", error = ex.Message });\n            }\n        }\n\n        [HttpPost(\"create-image-campaign\")]\n        public async Task<IActionResult> CreateImageCampaign([FromBody] CampaignCreateDto dto)\n        {\n            try\n            {\n                var user = HttpContext.User;\n                var businessIdClaim = user.FindFirst(\"businessId\");\n\n                if (businessIdClaim == null || !Guid.TryParse(businessIdClaim.Value, out var businessId))\n                    return Unauthorized(new { message = \"üö´ Invalid or missing BusinessId claim.\" });\n\n                if (dto.MultiButtons != null && dto.MultiButtons.Any())\n                {\n                    var allowedTypes = new[] { \"url\", \"copy_code\", \"flow\", \"phone_number\", \"quick_reply\" };\n                    foreach (var button in dto.MultiButtons)\n                    {\n                        var type = button.ButtonType?.Trim().ToLower();\n\n                        if (!allowedTypes.Contains(type))\n                            return BadRequest(new { message = $\"‚ùå Invalid ButtonType: '{type}' is not supported.\" });\n\n                        var needsValue = new[] { \"url\", \"flow\", \"copy_code\", \"phone_number\" };\n                        if (needsValue.Contains(type) && string.IsNullOrWhiteSpace(button.TargetUrl))\n                            return BadRequest(new { message = $\"‚ùå Button '{button.ButtonText}' requires a valid TargetUrl or Value for type '{type}'.\" });\n\n                        if (button.TargetUrl?.ToLower() == \"unknown\")\n                            return BadRequest(new { message = $\"‚ùå Invalid value 'unknown' found in button '{button.ButtonText}'.\" });\n                    }\n                }\n\n                var createdBy = user.Identity?.Name ?? \"system\";\n                var campaignId = await _campaignService.CreateImageCampaignAsync(businessId, dto, createdBy);\n\n                return Ok(new\n                {\n                    success = true,\n                    message = \"‚úÖ Campaign created successfully\",\n                    campaignId\n                });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception in CreateImageCampaign\");\n                return StatusCode(500, new { message = \"üö® Internal server error\", error = ex.Message });\n            }\n        }\n\n        // ‚úÖ Moved above {id} routes\n        [HttpPost(\"{id}/assign-contacts\")]\n        public async Task<IActionResult> AssignContactsToCampaign(Guid id, [FromBody] AssignContactsDto request)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var success = await _campaignService.AssignContactsToCampaignAsync(id, businessId, request.ContactIds);\n\n                return success\n                    ? Ok(new { message = \"‚úÖ Contacts assigned\" })\n                    : BadRequest(new { message = \"‚ùå Failed to assign contacts\" });\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Error assigning contacts: \" + ex.Message);\n                return StatusCode(500, new { message = \"Internal error\", error = ex.Message });\n            }\n        }\n\n        [HttpDelete(\"{campaignId}/recipients/{contactId}\")]\n        public async Task<IActionResult> RemoveCampaignRecipient(Guid campaignId, Guid contactId)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var success = await _campaignService.RemoveRecipientAsync(businessId, campaignId, contactId);\n\n                if (!success)\n                    return NotFound(new { message = \"Recipient not found or not assigned\" });\n\n                return NoContent();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Remove recipient failed: \" + ex.Message);\n                return StatusCode(500, new { message = \"Error removing recipient\", detail = ex.Message });\n            }\n        }\n\n        // Put this inside CampaignService (same class as SendTemplateCampaignWithTypeDetectionAsync)\n        private static string? ResolveRecipientPhone(CampaignRecipient r)\n        {\n            // Try Contact first, then AudienceMember fallbacks\n            return r?.Contact?.PhoneNumber\n                ?? r?.AudienceMember?.PhoneE164\n                ?? r?.AudienceMember?.PhoneRaw;\n        }\n\n    \n        // Send All Type of campaign method \n\n        [Authorize]\n        [HttpPost(\"send-campaign/{campaignId}\")]\n        //[ProducesResponseType(typeof(ResponseResult), StatusCodes.Status202Accepted)]\n        //[ProducesResponseType(typeof(ResponseResult), StatusCodes.Status400BadRequest)]\n        //[ProducesResponseType(typeof(ResponseResult), StatusCodes.Status401Unauthorized)]\n        //[ProducesResponseType(typeof(ResponseResult), StatusCodes.Status500InternalServerError)]\n        public async Task<IActionResult> SendTemplateCampaign(Guid campaignId, CancellationToken ct)\n        {\n            using var _ = LogContext.PushProperty(\"CampaignId\", campaignId);\n\n            try\n            {\n                     var result = await _campaignService.SendTemplateCampaignWithTypeDetectionAsync(campaignId, ct);\n\n                if (result.Success) return Accepted(result);\n\n                // For now: any non-success from the service is treated as a client error\n                return BadRequest(result);\n            }\n            catch (OperationCanceledException)\n            {\n                Log.Warning(\"‚õî SendTemplateCampaign cancelled\");\n                return StatusCode(StatusCodes.Status499ClientClosedRequest,\n                    ResponseResult.ErrorInfo(\"Request cancelled\"));\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception while sending campaign\");\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    ResponseResult.ErrorInfo(\"üö® Server error while sending campaign\", ex.ToString()));\n            }\n        }\n\n\n\n        [HttpPost(\"send-template-campaign/{id}\")]\n        public async Task<IActionResult> SendImageCampaign(Guid id)\n        {\n            var result = await _campaignService.SendTemplateCampaignAsync(id);\n            return result.Success ? Ok(result) : BadRequest(result);\n        }\n\n        [HttpPost(\"send/{campaignId}\")]\n        public async Task<IActionResult> SendCampaign(Guid campaignId)\n        {\n            try\n            {\n                var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n                var userAgent = Request.Headers[\"User-Agent\"].ToString() ?? \"unknown\";\n\n                var success = await _campaignService.SendCampaignAsync(campaignId, ipAddress, userAgent);\n\n                return success\n                    ? Ok(new { success = true, message = \"‚úÖ Campaign sent successfully\" })\n                    : BadRequest(new { success = false, message = \"‚ùå Campaign sending failed\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception in SendCampaign\");\n                return StatusCode(500, new { success = false, message = \"üö® Internal Server Error\", error = ex.Message });\n            }\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateCampaign(Guid id, [FromBody] CampaignCreateDto dto)\n        {\n            var result = await _campaignService.UpdateCampaignAsync(id, dto);\n            return result\n                ? Ok(new { message = \"‚úèÔ∏è Campaign updated successfully\" })\n                : BadRequest(new { message = \"‚ùå Update failed ‚Äî only draft campaigns can be edited\" });\n        }\n\n\n\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> DeleteCampaign([FromRoute] Guid id, [FromQuery] bool force = false)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            var opt = new CampaignDeletionOptions { Force = force };\n            var res = await _campaignService.DeleteCampaignAsync(businessId, id, opt);\n\n            return res.Status switch\n            {\n                CampaignDeletionStatus.Deleted => Ok(new\n                {\n                    message = force\n                        ? \"üóëÔ∏è Campaign deleted permanently\"\n                        : \"üóëÔ∏è Campaign deleted successfully\",\n                    telemetry = new\n                    {\n                        recipients = res.Recipients,\n                        queuedJobs = res.QueuedJobs,\n                        sendLogs = res.SendLogs\n                    }\n                }),\n                CampaignDeletionStatus.BlockedSending => Conflict(new\n                {\n                    message = \"‚ùå Cannot delete while campaign is sending. Cancel or wait to finish.\"\n                }),\n                CampaignDeletionStatus.BlockedState => BadRequest(new\n                {\n                    message = \"‚ùå Delete failed ‚Äî only draft campaigns can be deleted without force.\"\n                }),\n                CampaignDeletionStatus.NotFound => NotFound(new\n                {\n                    message = \"‚ùå Campaign not found.\"\n                }),\n                _ => StatusCode(500, new\n                {\n                    message = \"üö® Internal error while deleting campaign.\"\n                })\n            };\n        }\n\n        private Guid GetBusinessIdOrThrow()\n        {\n            string? raw =\n                User?.FindFirst(\"business_id\")?.Value ??\n                User?.FindFirst(\"BusinessId\")?.Value ??\n                User?.FindFirst(\"businessId\")?.Value ??\n                Request.Headers[\"X-Business-Id\"].FirstOrDefault();\n\n            if (!Guid.TryParse(raw, out var id))\n                throw new UnauthorizedAccessException(\"Business context missing.\");\n            return id;\n        }\n        [HttpGet(\"recipients/{id}\")]\n        public async Task<IActionResult> GetCampaignRecipients(Guid id)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var recipients = await _campaignService.GetRecipientsByCampaignIdAsync(id, businessId);\n                return Ok(recipients);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"‚ùå Error fetching campaign recipients: \" + ex.Message);\n                return StatusCode(500, new { message = \"Error fetching recipients\", detail = ex.Message });\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<CampaignDto>> GetCampaignById(Guid id)\n        {\n            var businessId = GetBusinessId();\n            var campaign = await _campaignService.GetCampaignByIdAsync(id, businessId);\n\n            if (campaign == null)\n                return NotFound();\n\n            return Ok(campaign);\n        }\n\n        private Guid GetBusinessId()\n        {\n            var claim = HttpContext.User.FindFirst(\"businessId\")?.Value;\n            if (string.IsNullOrEmpty(claim))\n                throw new UnauthorizedAccessException(\"BusinessId not found in token claims.\");\n\n            return Guid.Parse(claim);\n        }\n\n        [HttpGet(\"list/{businessId:guid}\")]\n        public async Task<IActionResult> GetAvailableFlows(Guid businessId, [FromQuery] bool onlyPublished = true)\n        {\n            var items = await _campaignService.GetAvailableFlowsAsync(businessId, onlyPublished);\n            return Ok(new { success = true, items });\n        }\n\n        [HttpGet(\"check-name\")]\n        public async Task<IActionResult> CheckName([FromQuery] string name)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            var available = await _campaignService.CheckNameAvailableAsync(businessId, name);\n            return Ok(new { available });\n        }\n\n        [HttpPut(\"{id:guid}/reschedule\")]\n        public async Task<IActionResult> Reschedule([FromRoute] Guid id, [FromBody] RescheduleDto body)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            await _campaignService.RescheduleAsync(businessId, id, body.NewUtcTime);\n            return Ok(new { ok = true });\n        }\n\n        [HttpPost(\"{id:guid}/enqueue-now\")]\n        public async Task<IActionResult> EnqueueNow([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            await _campaignService.EnqueueNowAsync(businessId, id);\n            return Ok(new { ok = true });\n        }\n\n        [HttpPost(\"{id:guid}/cancel-schedule\")]\n        public async Task<IActionResult> CancelSchedule([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            await _campaignService.CancelScheduleAsync(businessId, id);\n            return Ok(new { ok = true });\n        }\n        [HttpGet(\"{id:guid}/usage\")]\n        public async Task<IActionResult> GetCampaignUsage([FromRoute] Guid id)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            var usage = await _campaignService.GetCampaignUsageAsync(businessId, id);\n            if (usage == null) return NotFound(new { message = \"‚ùå Campaign not found.\" });\n            return Ok(usage);\n        }\n        [HttpGet(\"paginated\")]\n        public async Task<IActionResult> GetPaginatedCampaigns([FromQuery] PaginatedRequest request)\n        {\n            var user = HttpContext.User;\n            var businessIdClaim = user.FindFirst(\"businessId\");\n\n            if (businessIdClaim == null || !Guid.TryParse(businessIdClaim.Value, out var businessId))\n                return Unauthorized(new { message = \"üö´ Invalid or missing BusinessId claim.\" });\n\n            var result = await _campaignService.GetPaginatedCampaignsAsync(businessId, request);\n            return Ok(result);\n        }\n\n        [HttpGet(\"debug-claims\")]\n        public IActionResult DebugClaims()\n        {\n            var user = HttpContext.User;\n            var businessId = user.FindFirst(\"businessId\")?.Value;\n\n            return Ok(new\n            {\n                name = user.Identity?.Name,\n                businessId\n            });\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignCsvSampleController.cs",
      "sha256": "f4fd7c573dfdea09237f9783d5d076402eb23f1466c25bc3468bf46ded9a8eff",
      "language": "csharp",
      "size": 4175,
      "content": "// üìÑ File: Features/CampaignModule/Controllers/CampaignCsvSampleController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Import;   // <-- use the builder\nusing xbytechat.api.Shared;\nusing xbytechat_api.WhatsAppSettings.Services;       // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/csv-sample\")]\n    [Authorize]\n    public sealed class CampaignCsvSampleController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly CampaignCsvSchemaBuilder _schemaBuilder;\n\n        public CampaignCsvSampleController(AppDbContext db, CampaignCsvSchemaBuilder schemaBuilder)\n        {\n            _db = db;\n            _schemaBuilder = schemaBuilder;\n        }\n\n        // === Canonical schema (delegates to builder) ===\n        // GET /api/campaigns/{campaignId}/csv-sample/schema\n        [HttpGet(\"schema\")]\n        public async Task<IActionResult> GetSchema([FromRoute] Guid campaignId, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Use canonical builder (parameterN, header.text_paramN, button{1..3}.url_param)\n            IReadOnlyList<string> headers;\n            try\n            {\n                headers = await _schemaBuilder.BuildAsync(businessId, campaignId, ct);\n            }\n            catch (KeyNotFoundException)\n            {\n                return NotFound();\n            }\n\n            // For backward compatibility with your FE contract:\n            // placeholderCount = number of BODY positional placeholders (parameterN)\n            var placeholderCount = headers.Count(h => h.StartsWith(\"parameter\", StringComparison.OrdinalIgnoreCase));\n\n            // Infer header meta for convenience\n            var headerSlots = headers.Count(h => h.StartsWith(\"header.text_param\", StringComparison.OrdinalIgnoreCase));\n            var headerType = headerSlots > 0 ? \"text\" : \"none\";\n            var needsUrl = false; // only true for image/video/doc templates; leave false here (data-only endpoint)\n\n            return Ok(new\n            {\n                headers,\n                placeholderCount,\n                header = new { type = headerType, needsUrl }\n            });\n        }\n\n        // === Canonical sample CSV (you already made this canonical) ===\n        // GET /api/campaigns/{campaignId}/csv-sample/sample\n        [HttpGet(\"sample\")]\n        public IActionResult DownloadSample([FromQuery] int bodyParams = 2, [FromQuery] int headerTextParams = 1, [FromQuery] int urlButtons = 1)\n        {\n            bodyParams = Math.Max(0, Math.Min(10, bodyParams));        // safety caps\n            headerTextParams = Math.Max(0, Math.Min(5, headerTextParams));\n            urlButtons = Math.Max(0, Math.Min(3, urlButtons));\n\n            var headers = new List<string> { \"phone\" };\n\n            for (int i = 1; i <= bodyParams; i++) headers.Add($\"parameter{i}\");\n            for (int i = 1; i <= headerTextParams; i++) headers.Add($\"header.text_param{i}\");\n            for (int i = 1; i <= urlButtons; i++) headers.Add($\"button{i}.url_param\");\n\n            var example = new List<string> { \"+911234567890\" };\n            for (int i = 1; i <= bodyParams; i++) example.Add($\"body_value_{i}\");\n            for (int i = 1; i <= headerTextParams; i++) example.Add($\"header_text_{i}\");\n            for (int i = 1; i <= urlButtons; i++) example.Add($\"https://example.com/order/{{id}}\");\n\n            var sb = new StringBuilder();\n            sb.AppendLine(string.Join(\",\", headers));\n            sb.AppendLine(string.Join(\",\", example.Select(v => v.Replace(\",\", \" \"))));\n\n            var bytes = System.Text.Encoding.UTF8.GetBytes(sb.ToString());\n            return File(bytes, \"text/csv\", \"campaign_sample.csv\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignCsvSchemaBuilder.cs",
      "sha256": "a694fdc231c120d666b13fdfb3c1135a39ccf4e262fa351e19f7646c1acc1816",
      "language": "csharp",
      "size": 4974,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.WhatsAppSettings.Helpers; // TemplateJsonHelper\n\nnamespace xbytechat.api.Features.CampaignModule.Import\n{\n    /// <summary>\n    /// Builds the CSV header schema for a campaign/template.\n    /// - BODY placeholders:\n    ///     * POSITIONAL => parameter1..N\n    ///     * NAMED      => one column per distinct body token name (e.g., name, slug),\n    ///                    and we ALSO include parameter1..N for backward compatibility.\n    /// - HEADER text placeholders => header.text_param1..K\n    /// - Dynamic URL buttons => button{1..3}.url_param (only when template button has {{..}})\n    /// - Always includes \"phone\" (first column).\n    /// </summary>\n    public sealed class CampaignCsvSchemaBuilder\n    {\n        private readonly AppDbContext _db;\n\n        public CampaignCsvSchemaBuilder(AppDbContext db) => _db = db;\n\n        public async Task<IReadOnlyList<string>> BuildAsync(Guid businessId, Guid campaignId, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n            if (campaignId == Guid.Empty) throw new ArgumentException(\"campaignId is required.\");\n\n            // Resolve template name from Campaign\n            var campaign = await _db.Campaigns\n                .AsNoTracking()\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct)\n                ?? throw new KeyNotFoundException(\"Campaign not found.\");\n\n            var templateName = (campaign.TemplateId ?? campaign.MessageTemplate ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(templateName))\n                throw new InvalidOperationException(\"Campaign does not have a template selected.\");\n\n            // Get the freshest active WhatsAppTemplate row for this name\n            var tpl = await _db.WhatsAppTemplates\n                .AsNoTracking()\n                .Where(t => t.BusinessId == businessId && t.Name == templateName && t.IsActive)\n                .OrderByDescending(t => t.UpdatedAt > t.CreatedAt ? t.UpdatedAt : t.CreatedAt)\n                .FirstOrDefaultAsync(ct)\n                ?? throw new KeyNotFoundException($\"Template '{templateName}' not found in cache.\");\n\n            // Parse raw JSON canonically (works even if you don‚Äôt store the extra JSON columns)\n            var summary = TemplateJsonHelper.SummarizeDetailed(tpl.RawJson, tpl.Body);\n\n            // ‚Äî‚Äî‚Äî Collect tokens ‚Äî‚Äî‚Äî\n            var bodyCountPositional = summary.BodyParamIndices?.Distinct().Count() ?? 0;\n            var bodyNamed = summary.Placeholders\n                .Where(p => p.Location == PlaceholderLocation.Body && p.Type == PlaceholderType.Named)\n                .Select(p => p.Name!)\n                .Where(n => !string.IsNullOrWhiteSpace(n))\n                .Distinct(StringComparer.OrdinalIgnoreCase)\n                .OrderBy(n => n, StringComparer.OrdinalIgnoreCase)\n                .ToList();\n\n            var headerTextSlots = (summary.HeaderKind?.Equals(\"text\", StringComparison.OrdinalIgnoreCase) == true)\n                ? (summary.HeaderParamIndices?.Distinct().Count() ?? 0)\n                : 0;\n\n            // Buttons with a dynamic param ({{..}}) in the parameter field\n            var dynamicButtonOrders = summary.Placeholders\n                .Where(p => p.Location == PlaceholderLocation.Button && string.Equals(p.ButtonField, \"param\", StringComparison.OrdinalIgnoreCase))\n                .Select(p => p.ButtonOrder ?? 0)\n                .Where(o => o > 0 && o <= 3)\n                .Distinct()\n                .OrderBy(o => o)\n                .ToList();\n\n            // ‚Äî‚Äî‚Äî Build headers in a stable order ‚Äî‚Äî‚Äî\n            var headers = new List<string> { \"phone\" };\n\n            // BODY: positional or named\n            if (bodyNamed.Count > 0)\n            {\n                // ‚Ä¢ preferred: named columns\n                headers.AddRange(bodyNamed);\n                // ‚Ä¢ backward compatible: parameter1..N (with N from placeholder count)\n                for (int i = 1; i <= Math.Max(bodyCountPositional, summary.PlaceholderCount); i++)\n                    headers.Add($\"parameter{i}\");\n            }\n            else\n            {\n                for (int i = 1; i <= bodyCountPositional; i++)\n                    headers.Add($\"parameter{i}\");\n            }\n\n            // HEADER text placeholders remain numeric\n            for (int i = 1; i <= headerTextSlots; i++)\n                headers.Add($\"header.text_param{i}\");\n\n            // Dynamic URL buttons (at most 3 in Meta)\n            foreach (var ord in dynamicButtonOrders)\n                headers.Add($\"button{ord}.url_param\");\n\n            return headers;\n        }\n    }\n}\n"
    }
  ]
}
