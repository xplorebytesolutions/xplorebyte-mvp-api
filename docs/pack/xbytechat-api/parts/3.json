{
  "name": "xbytechat-api",
  "part": 3,
  "of": 25,
  "generatedAt": "2025-12-10 08:27:07 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/OutboundCampaignSendWorker.cs",
      "sha256": "87b84f4ac6b994c6b307f46968b63be7090fa022a3681ae696e01ae348432261",
      "language": "csharp",
      "size": 13092,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Claims due OutboundCampaignJobs and invokes the campaign sender.\n    /// Uses ExecuteUpdateAsync to flip Campaign.Status without tracking entities,\n    /// eliminating \"already being tracked\" conflicts.\n    /// </summary>\n    public class OutboundCampaignSendWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundCampaignSendWorker> _log;\n\n        // Global cap & polling cadence\n        private const int MaxParallel = 3;\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(10);\n\n        public OutboundCampaignSendWorker(IServiceProvider sp, ILogger<OutboundCampaignSendWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            // small warm-up delay\n            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var now = DateTime.UtcNow;\n\n                    // Find up to MaxParallel due jobs\n                    var due = await db.OutboundCampaignJobs\n                        .Where(j => j.Status == \"queued\" && j.NextAttemptAt <= now)\n                        .OrderBy(j => j.NextAttemptAt)\n                        .ThenBy(j => j.CreatedAt)\n                        .Take(MaxParallel)\n                        .ToListAsync(stoppingToken);\n\n                    // Claim jobs (do NOT increment Attempt here)\n                    foreach (var job in due)\n                    {\n                        job.Status = \"running\";\n                        job.UpdatedAt = DateTime.UtcNow;\n                    }\n\n                    if (due.Count > 0)\n                        await db.SaveChangesAsync(stoppingToken);\n\n                    // Process in parallel within this sweep\n                    var tasks = due.Select(job => ProcessJobAsync(job.Id, stoppingToken)).ToArray();\n                    await Task.WhenAll(tasks);\n                }\n                catch (Exception ex)\n                {\n                    _log.LogWarning(ex, \"Send queue sweep failed\");\n                }\n\n                await Task.Delay(SweepEvery, stoppingToken);\n            }\n        }\n\n        private async Task ProcessJobAsync(Guid jobId, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var queue = scope.ServiceProvider.GetRequiredService<IOutboundCampaignQueueService>();\n            var campaignService = scope.ServiceProvider.GetRequiredService<ICampaignService>();\n            var log = scope.ServiceProvider.GetRequiredService<ILogger<OutboundCampaignSendWorker>>();\n\n            var job = await db.OutboundCampaignJobs.FirstOrDefaultAsync(j => j.Id == jobId, ct);\n            if (job == null) return;\n\n            // Flip to \"Sending\" (no entity tracked)\n            await db.Campaigns\n                .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId && c.Status != \"Sending\")\n                .ExecuteUpdateAsync(s => s\n                    .SetProperty(c => c.Status, _ => \"Sending\")\n                    .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                    ct);\n\n            try\n            {\n                // Call by ID only â€“ service manages its own DbContext/queries\n                var result = await campaignService.SendTemplateCampaignWithTypeDetectionAsync(job.CampaignId);\n\n                if (result.Success)\n                {\n                    await db.Campaigns\n                        .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(c => c.Status, _ => \"Sent\")\n                            .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                            ct);\n\n                    await queue.MarkSucceededAsync(job.Id);\n                    log.LogInformation(\"Job {Job} succeeded for campaign {Campaign}\", jobId, job.CampaignId);\n                }\n                else\n                {\n                    var willRetry = job.Attempt + 1 < job.MaxAttempts;\n                    var nextStatus = willRetry ? \"Queued\" : \"Failed\";\n\n                    await db.Campaigns\n                        .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(c => c.Status, _ => nextStatus)\n                            .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                            ct);\n\n                    await queue.MarkFailedAsync(job.Id, result.Message ?? \"Unknown send error\", scheduleRetry: true);\n                    log.LogWarning(\"Job {Job} failed for campaign {Campaign}: {Msg}\", jobId, job.CampaignId, result.Message);\n                }\n            }\n            catch (Exception ex)\n            {\n                var willRetry = job.Attempt + 1 < job.MaxAttempts;\n                var nextStatus = willRetry ? \"Queued\" : \"Failed\";\n\n                await db.Campaigns\n                    .Where(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId)\n                    .ExecuteUpdateAsync(s => s\n                        .SetProperty(c => c.Status, _ => nextStatus)\n                        .SetProperty(c => c.UpdatedAt, _ => DateTime.UtcNow),\n                        ct);\n\n                await queue.MarkFailedAsync(job.Id, ex.ToString(), scheduleRetry: true);\n                log.LogWarning(ex, \"Job {Job} exception for campaign {Campaign}\", jobId, job.CampaignId);\n            }\n        }\n    }\n}\n\n\n//////using System;\n//////using System.Linq;\n//////using System.Threading;\n//////using System.Threading.Tasks;\n//////using Microsoft.EntityFrameworkCore;\n//////using Microsoft.Extensions.DependencyInjection;\n//////using Microsoft.Extensions.Hosting;\n//////using Microsoft.Extensions.Logging;\n//////using xbytechat.api;\n//////using xbytechat.api.Features.CampaignModule.Services;\n\n//////namespace xbytechat.api.Features.CampaignModule.Services\n//////{\n//////    /// <summary>\n//////    /// Background worker that claims due jobs and invokes CampaignService to send.\n//////    /// Flips Campaign.Status for truthful UI: Queued -> Sending -> Sent / Queued / Failed\n//////    /// </summary>\n//////    public class OutboundCampaignSendWorker : BackgroundService\n//////    {\n//////        private readonly IServiceProvider _sp;\n//////        private readonly ILogger<OutboundCampaignSendWorker> _log;\n\n//////        // Simple global concurrency cap & polling cadence\n//////        private const int MaxParallel = 3;\n//////        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(10);\n//////        private readonly IDbContextFactory<AppDbContext> _dbFactory;\n\n//////        public OutboundCampaignSendWorker(IServiceProvider sp, ILogger<OutboundCampaignSendWorker> log, IDbContextFactory<AppDbContext> dbFactory)\n//////        {\n//////            _sp = sp; _log = log;\n//////            _dbFactory = dbFactory;\n//////        }\n\n//////        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//////        {\n//////            await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);\n\n//////            while (!stoppingToken.IsCancellationRequested)\n//////            {\n//////                try\n//////                {\n//////                    using var scope = _sp.CreateScope();\n//////                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//////                    var now = DateTimeOffset.UtcNow;\n\n//////                    // Find up to MaxParallel due jobs\n//////                    var due = await db.OutboundCampaignJobs\n//////                        .Where(j => j.Status == \"queued\" && j.NextAttemptAt <= now)\n//////                        .OrderBy(j => j.NextAttemptAt)\n//////                        .ThenBy(j => j.CreatedAt)\n//////                        .Take(MaxParallel)\n//////                        .ToListAsync(stoppingToken);\n\n//////                    // Claim jobs (do NOT increment Attempt here)\n//////                    foreach (var job in due)\n//////                    {\n//////                        job.Status = \"running\";\n//////                        job.UpdatedAt = DateTime.UtcNow;\n//////                    }\n//////                    if (due.Count > 0)\n//////                        await db.SaveChangesAsync(stoppingToken);\n\n//////                    var tasks = due.Select(job => ProcessJobAsync(job.Id, stoppingToken)).ToArray();\n//////                    await Task.WhenAll(tasks);\n//////                }\n//////                catch (Exception ex)\n//////                {\n//////                    _log.LogWarning(ex, \"Send queue sweep failed\");\n//////                }\n\n//////                await Task.Delay(SweepEvery, stoppingToken);\n//////            }\n//////        }\n\n//////        private async Task ProcessJobAsync(Guid jobId, CancellationToken ct)\n//////        {\n//////            using var scope = _sp.CreateScope();\n//////            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//////            var queue = scope.ServiceProvider.GetRequiredService<IOutboundCampaignQueueService>();\n//////            var campaignService = scope.ServiceProvider.GetRequiredService<ICampaignService>();\n//////            var log = scope.ServiceProvider.GetRequiredService<ILogger<OutboundCampaignSendWorker>>();\n\n//////            var job = await db.OutboundCampaignJobs.FirstOrDefaultAsync(j => j.Id == jobId, ct);\n//////            if (job == null) return;\n\n//////            // Mark Campaign -> Sending\n//////            var campaign = await db.Campaigns\n//////                .FirstOrDefaultAsync(c => c.Id == job.CampaignId && c.BusinessId == job.BusinessId, ct);\n\n//////            if (campaign != null && campaign.Status != \"Sending\")\n//////            {\n//////                campaign.Status = \"Sending\";\n//////                campaign.UpdatedAt = DateTime.UtcNow;\n//////                await db.SaveChangesAsync(ct);\n//////            }\n\n//////            try\n//////            {\n//////                var result = await campaignService.SendTemplateCampaignWithTypeDetectionAsync(job.CampaignId);\n\n//////                if (result.Success)\n//////                {\n//////                    if (campaign != null)\n//////                    {\n//////                        campaign.Status = \"Sent\";\n//////                        campaign.UpdatedAt = DateTime.UtcNow;\n//////                        await db.SaveChangesAsync(ct);\n//////                    }\n\n//////                    await queue.MarkSucceededAsync(job.Id);\n//////                    log.LogInformation(\"Job {Job} succeeded for campaign {Campaign}\", jobId, job.CampaignId);\n//////                }\n//////                else\n//////                {\n//////                    // Compute whether we will retry BEFORE calling MarkFailed (Attempt not yet incremented)\n//////                    var willRetry = job.Attempt + 1 < job.MaxAttempts;\n\n//////                    if (campaign != null)\n//////                    {\n//////                        campaign.Status = willRetry ? \"Queued\" : \"Failed\";\n//////                        campaign.UpdatedAt = DateTime.UtcNow;\n//////                        await db.SaveChangesAsync(ct);\n//////                    }\n\n//////                    await queue.MarkFailedAsync(job.Id, result.Message ?? \"Unknown send error\", scheduleRetry: true);\n//////                    log.LogWarning(\"Job {Job} failed for campaign {Campaign}: {Msg}\", jobId, job.CampaignId, result.Message);\n//////                }\n//////            }\n//////            catch (Exception ex)\n//////            {\n//////                var willRetry = job.Attempt + 1 < job.MaxAttempts;\n\n//////                if (campaign != null)\n//////                {\n//////                    campaign.Status = willRetry ? \"Queued\" : \"Failed\";\n//////                    campaign.UpdatedAt = DateTime.UtcNow;\n//////                    await db.SaveChangesAsync(ct);\n//////                }\n\n//////                await queue.MarkFailedAsync(job.Id, ex.ToString(), scheduleRetry: true);\n//////                log.LogWarning(ex, \"Job {Job} exception for campaign {Campaign}\", jobId, job.CampaignId);\n//////            }\n//////        }\n//////    }\n//////}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboundSenderWorker.cs",
      "sha256": "74e4df795d756850a50bdf962865fd3ff0b38fa2cd0e5ba71aa402aa94a6a6de",
      "language": "csharp",
      "size": 63230,
      "content": "// ðŸ“„ File: Features/CampaignModule/Workers/OutboundSenderWorker.cs\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Channels;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Npgsql;\n\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Logging;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.MessageLogging.Services;\nusing xbytechat.api.Features.MessagesEngine.Abstractions;\nusing xbytechat.api.Features.CampaignModule.SendEngine;\nusing xbytechat_api.Features.Billing.Services;\nusing xbytechat.api.Infrastructure.Observability;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.WhatsAppSettings.Helpers;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public class OutboundSenderWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboundSenderWorker> _log;\n        private readonly Channel<OutboundMessageJob> _channel;\n        private const int DEFAULT_MAX_ATTEMPTS = 3;\n\n        // Concurrency caps\n        private readonly int _globalDop = 32;   // total parallel consumers\n        private readonly int _perNumberDop = 8; // per (provider, PhoneNumberId)\n\n        private readonly TimeSpan _pollInterval = TimeSpan.FromMilliseconds(250);\n        private static readonly TimeSpan _flightTimeout = TimeSpan.FromMinutes(5);\n\n        private int _inChannel;\n        private readonly Random _rand = new();\n\n        // =========================[ Template Button Cache + Parsers ]=========================\n        private static readonly ConcurrentDictionary<string, IReadOnlyList<ButtonMeta>> _btnCache =\n            new(StringComparer.Ordinal);\n\n        private static readonly Regex RxButtonTypeMeta = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n        private static readonly Regex RxButtonTypePinn = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n        private static string CacheKeyForTemplate(WhatsAppTemplate tpl)\n            => $\"{tpl.BusinessId}|{tpl.Provider}|{tpl.Name}|{tpl.LanguageCode}\".ToUpperInvariant();\n\n        private static IReadOnlyList<ButtonMeta> GetTemplateButtonsCached(WhatsAppTemplate tpl)\n            => _btnCache.GetOrAdd(CacheKeyForTemplate(tpl), _ => ParseButtonsFromTemplateRow(tpl));\n\n        private static IReadOnlyList<ButtonMeta> ParseButtonsFromTemplateRow(WhatsAppTemplate tpl)\n        {\n            if (!string.IsNullOrWhiteSpace(tpl.UrlButtons))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.UrlButtons);\n                    if (doc.RootElement.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n                        foreach (var el in doc.RootElement.EnumerateArray())\n                        {\n                            var text = el.TryGetProperty(\"ButtonText\", out var pText) ? pText.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Text\", out var pText2) ? pText2.GetString() ?? \"\" : \"\";\n                            var type = el.TryGetProperty(\"ButtonType\", out var pType) ? pType.GetString() ?? \"\" :\n                                       el.TryGetProperty(\"Type\", out var pType2) ? pType2.GetString() ?? \"\" : \"\";\n                            var url = el.TryGetProperty(\"TargetUrl\", out var pUrl) ? pUrl.GetString() : null;\n\n                            if (!string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(type))\n                                list.Add(new ButtonMeta(text, type, url));\n                        }\n                        return list;\n                    }\n                }\n                catch { /* fallthrough */ }\n            }\n\n            if (!string.IsNullOrWhiteSpace(tpl.RawJson))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(tpl.RawJson);\n\n                    JsonElement comps = default;\n                    if (doc.RootElement.TryGetProperty(\"template\", out var tplNode) &&\n                        tplNode.TryGetProperty(\"components\", out var comps1))\n                    {\n                        comps = comps1;\n                    }\n                    else if (doc.RootElement.TryGetProperty(\"components\", out var comps2))\n                    {\n                        comps = comps2;\n                    }\n\n                    if (comps.ValueKind == JsonValueKind.Array)\n                    {\n                        var list = new List<ButtonMeta>(capacity: 3);\n\n                        foreach (var c in comps.EnumerateArray())\n                        {\n                            if (!c.TryGetProperty(\"type\", out var tProp)) continue;\n                            if (!string.Equals(tProp.GetString(), \"button\", StringComparison.OrdinalIgnoreCase)) continue;\n\n                            var isUrl =\n                                (c.TryGetProperty(\"sub_type\", out var st) && RxButtonTypeMeta.IsMatch(st.GetString() ?? \"\")) ||\n                                (c.TryGetProperty(\"subType\", out var st2) && RxButtonTypePinn.IsMatch(st2.GetString() ?? \"\"));\n\n                            if (!isUrl) continue;\n\n                            string text = \"Open\";\n                            string type = \"url\";\n                            string? url = null;\n\n                            if (c.TryGetProperty(\"parameters\", out var pars) && pars.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var p in pars.EnumerateArray())\n                                {\n                                    if (p.TryGetProperty(\"text\", out var txtProp))\n                                    {\n                                        var v = txtProp.GetString();\n                                        if (!string.IsNullOrWhiteSpace(v)) { url = v; break; }\n                                    }\n                                }\n                            }\n\n                            list.Add(new ButtonMeta(text, type, url));\n                            if (list.Count >= 3) break;\n                        }\n\n                        return list;\n                    }\n                }\n                catch { /* ignore */ }\n            }\n\n            return Array.Empty<ButtonMeta>();\n        }\n        // =====================================================================================\n\n        public OutboundSenderWorker(IServiceProvider sp, ILogger<OutboundSenderWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n\n            _channel = Channel.CreateBounded<OutboundMessageJob>(new BoundedChannelOptions(5000)\n            {\n                SingleReader = false,\n                SingleWriter = false,\n                FullMode = BoundedChannelFullMode.Wait\n            });\n        }\n\n\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);\n            var ct = cts.Token;\n\n            var consumers = Enumerable.Range(0, _globalDop)\n                .Select(_ => Task.Run(() => ConsumeAsync(ct), ct))\n                .ToArray();\n\n            var producer = Task.Run(() => ProduceAsync(ct), ct);\n\n            var all = consumers.Append(producer).ToArray();\n\n            try\n            {\n                await Task.WhenAll(all);\n            }\n            catch\n            {\n                try { cts.Cancel(); } catch { /* ignore */ }\n                throw;\n            }\n        }\n\n        private async Task ProduceAsync(CancellationToken ct)\n        {\n            const int ChannelCapacity = 5000;\n\n            var idleDelay = _pollInterval;\n            var maxIdleDelay = TimeSpan.FromSeconds(1);\n            var longIdleDelay = TimeSpan.FromSeconds(30);\n            int consecutiveEmpty = 0;\n\n            const string sql = @\"\nWITH cte AS (\n    SELECT \"\"Id\"\"\n    FROM \"\"OutboundMessageJobs\"\"\n    WHERE \"\"Status\"\" = 'Pending'\n      AND (\"\"NextAttemptAt\"\" IS NULL OR \"\"NextAttemptAt\"\" <= NOW())\n    ORDER BY \"\"NextAttemptAt\"\" NULLS FIRST, \"\"CreatedAt\"\"\n    FOR UPDATE SKIP LOCKED\n    LIMIT @take\n)\nUPDATE \"\"OutboundMessageJobs\"\" j\nSET \"\"Status\"\" = 'InFlight',\n    \"\"NextAttemptAt\"\" = NOW() + make_interval(secs => @flight),\n    \"\"LastError\"\" = NULL\nWHERE j.\"\"Id\"\" IN (SELECT \"\"Id\"\" FROM cte)\nRETURNING j.*;\";\n\n            try { await Task.Delay(_rand.Next(100, 500), ct); } catch { /* ignore */ }\n\n            while (!ct.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var approxCount = Volatile.Read(ref _inChannel);\n                    var budget = Math.Max(0, ChannelCapacity - approxCount);\n\n                    if (budget <= 0)\n                    {\n                        await Task.Delay(idleDelay, ct);\n                        idleDelay = TimeSpan.FromMilliseconds(\n                            Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 1.25)\n                        );\n                        continue;\n                    }\n\n                    idleDelay = _pollInterval;\n\n                    var take = Math.Min(budget, 2000);\n                    var flightSecs = (int)Math.Ceiling(_flightTimeout.TotalSeconds);\n\n                    var takeParam = new NpgsqlParameter<int>(\"take\", take);\n                    var flightParam = new NpgsqlParameter<int>(\"flight\", flightSecs);\n\n                    var prevTimeout = db.Database.GetCommandTimeout();\n                    db.Database.SetCommandTimeout(5);\n\n                    List<OutboundMessageJob> jobs;\n                    try\n                    {\n                        jobs = await db.OutboundMessageJobs\n                            .FromSqlRaw(sql, takeParam, flightParam)\n                            .AsNoTracking()\n                            .ToListAsync(ct);\n                    }\n                    finally\n                    {\n                        db.Database.SetCommandTimeout(prevTimeout);\n                    }\n\n                    foreach (var job in jobs)\n                    {\n                        await _channel.Writer.WriteAsync(job, ct);\n                        Interlocked.Increment(ref _inChannel);\n                    }\n\n                    if (jobs.Count == 0)\n                    {\n                        consecutiveEmpty++;\n                        var jitterMs = _rand.Next(0, 200);\n                        var delay = idleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        if (consecutiveEmpty >= 8 && idleDelay >= maxIdleDelay)\n                            delay = longIdleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n                        await Task.Delay(delay, ct);\n\n                        if (idleDelay < maxIdleDelay)\n                        {\n                            idleDelay = TimeSpan.FromMilliseconds(\n                                Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 2)\n                            );\n                        }\n                    }\n                    else\n                    {\n                        consecutiveEmpty = 0;\n                        idleDelay = _pollInterval;\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[Outbox] Producer loop error\");\n                    try { await Task.Delay(TimeSpan.FromSeconds(2), ct); } catch { /* ignore */ }\n                }\n            }\n        }\n\n        // ---- keyed concurrency gate (per sender) ---------------------------------------\n        private sealed class KeyedSemaphore\n        {\n            private readonly ConcurrentDictionary<string, SemaphoreSlim> _map = new();\n            public async Task<IDisposable> AcquireAsync(string key, int dop, CancellationToken ct)\n            {\n                var sem = _map.GetOrAdd(key, _ => new SemaphoreSlim(dop));\n                await sem.WaitAsync(ct);\n                return new Releaser(sem);\n            }\n            private sealed class Releaser : IDisposable\n            {\n                private readonly SemaphoreSlim _s;\n                public Releaser(SemaphoreSlim s) => _s = s;\n                public void Dispose() => _s.Release();\n            }\n        }\n        private static readonly KeyedSemaphore _perSenderGate = new();\n        // -------------------------------------------------------------------------------\n\n        // Best-effort extraction of provider message id from a Meta success body\n        private static string? TryExtractProviderMessageId(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            try\n            {\n                using var doc = JsonDocument.Parse(raw);\n                if (doc.RootElement.TryGetProperty(\"messages\", out var msgs) &&\n                    msgs.ValueKind == JsonValueKind.Array &&\n                    msgs.GetArrayLength() > 0 &&\n                    msgs[0].TryGetProperty(\"id\", out var idProp))\n                {\n                    return idProp.GetString();\n                }\n            }\n            catch { /* ignore */ }\n            return null;\n        }\n\n        private async Task ConsumeAsync(CancellationToken ct)\n        {\n            static async Task<string> ResolveRecipientPhoneAsync(AppDbContext db, Guid recipientId, CancellationToken ct2)\n            {\n                var phone = await db.CampaignRecipients\n                    .AsNoTracking()\n                    .Where(r => r.Id == recipientId)\n                    .Select(r =>\n                        r.Contact != null\n                            ? r.Contact.PhoneNumber\n                            : (r.AudienceMember != null\n                                ? (r.AudienceMember.PhoneE164 ?? r.AudienceMember.PhoneRaw)\n                                : null))\n                    .FirstOrDefaultAsync(ct2);\n\n                return phone ?? string.Empty;\n            }\n\n            while (await _channel.Reader.WaitToReadAsync(ct))\n            {\n                if (!_channel.Reader.TryRead(out var job))\n                    continue;\n\n                Interlocked.Decrement(ref _inChannel);\n\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var engine = scope.ServiceProvider.GetRequiredService<IMessageEngineService>();\n                    var billing = scope.ServiceProvider.GetRequiredService<IBillingIngestService>();\n                    var logger = scope.ServiceProvider.GetRequiredService<ILogger<OutboundSenderWorker>>();\n                    var logSink = scope.ServiceProvider.GetRequiredService<ICampaignLogSink>();\n                    var limiter = scope.ServiceProvider.GetRequiredService<xbytechat.api.Infrastructure.RateLimiting.IPhoneNumberRateLimiter>();\n                    var messageLogSink = scope.ServiceProvider.GetRequiredService<IMessageLogSink>();\n                    var builder = scope.ServiceProvider.GetRequiredService<ITemplatePayloadBuilder>();\n                    var validator = scope.ServiceProvider.GetRequiredService<ICampaignSendValidator>();\n\n                    var senderKey = $\"{job.Provider}|{job.PhoneNumberId}\";\n\n                    using (await _perSenderGate.AcquireAsync(senderKey, _perNumberDop, ct))\n                    {\n                        var lease = await limiter.AcquireAsync(senderKey, ct);\n                        if (!lease.IsAcquired)\n                        {\n                            await Task.Delay(50, ct);\n                            continue;\n                        }\n\n                        var recipientPhone = await ResolveRecipientPhoneAsync(db, job.RecipientId, ct);\n                        if (string.IsNullOrWhiteSpace(recipientPhone))\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = \"Recipient phone not found.\";\n                            var backoff1 = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff1);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Recipient phone not found. job={JobId} recipient={RecipientId}\", job.Id, job.RecipientId);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        var lang = job.LanguageCode ?? \"en_US\";\n                        var tmplRow = await db.WhatsAppTemplates\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(t =>\n                                t.BusinessId == job.BusinessId &&\n                                t.Provider == job.Provider &&\n                                t.Name == job.TemplateName &&\n                                t.LanguageCode == lang,\n                                ct);\n\n                        if (tmplRow == null)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = $\"Template not found: {job.TemplateName} ({lang}) for {job.Provider}.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Template not found. job={JobId} template={Template} lang={Lang} provider={Provider}\",\n                                job.Id, job.TemplateName, lang, job.Provider);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        HeaderKind headerKind = tmplRow.HeaderKind?.ToLowerInvariant() switch\n                        {\n                            \"text\" => HeaderKind.Text,\n                            \"image\" => HeaderKind.Image,\n                            \"video\" => HeaderKind.Video,\n                            \"document\" => HeaderKind.Document,\n                            \"none\" or null => HeaderKind.None,\n                            _ => HeaderKind.None\n                        };\n                        if (headerKind == HeaderKind.None && !string.IsNullOrWhiteSpace(job.MediaType))\n                        {\n                            headerKind = job.MediaType.ToLowerInvariant() switch\n                            {\n                                \"text\" => HeaderKind.Text,\n                                \"image\" => HeaderKind.Image,\n                                \"video\" => HeaderKind.Video,\n                                \"document\" => HeaderKind.Document,\n                                _ => HeaderKind.None\n                            };\n                        }\n\n                        var providerEnum = ProviderUtil.Parse(job.Provider);\n                        var buttonsFromTemplate = GetTemplateButtonsCached(tmplRow);\n\n                        var plan = new SendPlan(\n                            BusinessId: job.BusinessId,\n                            Provider: providerEnum,\n                            PhoneNumberId: job.PhoneNumberId!,\n                            TemplateName: job.TemplateName!,\n                            LanguageCode: lang,\n                            HeaderKind: headerKind,\n                            HeaderUrl: job.HeaderMediaUrl,\n                            Buttons: buttonsFromTemplate\n                        );\n\n                        var recipient = new RecipientPlan(\n                            RecipientId: job.RecipientId,\n                            ToPhoneE164: recipientPhone,\n                            ParametersJson: job.ResolvedParamsJson ?? \"[]\",\n                            ButtonParamsJson: job.ResolvedButtonUrlsJson,\n                            IdempotencyKey: job.IdempotencyKey ?? $\"{job.CampaignId}:{recipientPhone}:{job.TemplateName}\"\n                        );\n\n                        var envelope = builder.Build(plan, recipient);\n\n                        var (ok, error) = validator.Validate(plan, recipient, envelope, tmplRow);\n                        if (!ok)\n                        {\n                            job.Status = \"Failed\";\n                            job.Attempt += 1;\n                            job.LastError = error ?? \"Validation failed.\";\n                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n                            db.Update(job);\n                            await db.SaveChangesAsync(ct);\n\n                            logger.LogWarning(\"[Outbox] Validation failed job={JobId} error={Error}\", job.Id, job.LastError);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                            continue;\n                        }\n\n                        object payload = providerEnum switch\n                        {\n                            Provider.MetaCloud =>\n                                scope.ServiceProvider.GetRequiredService<MetaCloudPayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            Provider.Pinnacle =>\n                                scope.ServiceProvider.GetRequiredService<PinnaclePayloadMapper>()\n                                    .BuildPayload(plan, recipient, envelope),\n\n                            _ => throw new InvalidOperationException(\"Unknown provider\")\n                        };\n\n                        var sw = Stopwatch.StartNew();\n                        var engineResult = await engine.SendPayloadAsync(job.BusinessId, job.Provider, payload, job.PhoneNumberId);\n                        sw.Stop();\n                        MetricsRegistry.SendLatencyMs.Record(sw.Elapsed.TotalMilliseconds);\n\n                        if (!engineResult.Success)\n                        {\n                            var err = engineResult.ErrorMessage ?? string.Empty;\n                            if (err.Contains(\"429\", StringComparison.Ordinal) ||\n                                err.Contains(\"Too Many Requests\", StringComparison.OrdinalIgnoreCase))\n                            {\n                                limiter.UpdateLimits(senderKey, permitsPerSecond: 5, burst: 5);\n                                MetricsRegistry.RateLimited429s.Add(1);\n                            }\n                        }\n\n                        // âœ… Surface provider ID and raw body for visibility\n                        var providerMsgId = !string.IsNullOrWhiteSpace(engineResult.MessageId)\n                            ? engineResult.MessageId\n                            : TryExtractProviderMessageId(engineResult.RawResponse);\n\n                        if (engineResult.Success)\n                        {\n                            logger.LogInformation(\"Provider send OK | providerMessageId={ProviderId} job={JobId} to={To}\",\n                                providerMsgId, job.Id, recipientPhone);\n                        }\n                        else\n                        {\n                            logger.LogWarning(\"Provider send FAILED | job={JobId} to={To} error={Error} body={Body}\",\n                                job.Id, recipientPhone, engineResult.ErrorMessage, engineResult.RawResponse);\n                        }\n\n                        // Persist MessageLogs (COPY sink)\n                        var now = DateTime.UtcNow;\n                        var runId = Guid.NewGuid();\n                        var logId = Guid.NewGuid();\n\n                        logger.LogInformation(\n                            \"[OutboundSenderWorker] Enqueue MessageLog id={LogId} recipient={RecipientId} job={JobId}\",\n                            logId, job.RecipientId, job.Id);\n\n                        messageLogSink.Enqueue(new MessageLog\n                        {\n                            Id = logId,\n                            BusinessId = job.BusinessId,\n                            CampaignId = job.CampaignId,\n                            RecipientNumber = recipientPhone,\n                            MessageContent = job.TemplateName,\n                            MediaUrl = job.HeaderMediaUrl,\n                            Status = engineResult.Success ? \"Sent\" : \"Failed\",\n                            MessageId = providerMsgId,\n                            ErrorMessage = engineResult.ErrorMessage,\n                            RawResponse = engineResult.RawResponse,\n                            CreatedAt = now,\n                            SentAt = engineResult.Success ? now : (DateTime?)null,\n                            Source = \"campaign\",\n                            RunId = runId,\n                            Provider = job.Provider,\n                            ProviderMessageId = providerMsgId,\n                            IsIncoming = false,\n                            IsChargeable = false\n                        });\n\n                        // Batched CampaignSendLog (COPY via sink)\n                        logSink.Enqueue(new CampaignLogRecord(\n                            Id: Guid.NewGuid(),\n                            RunId: runId,\n                            MessageId: providerMsgId,\n                            CampaignId: job.CampaignId,\n                            ContactId: null,\n                            RecipientId: job.RecipientId,\n                            MessageBody: job.MessageBody ?? job.TemplateName,\n                            TemplateId: job.TemplateName,\n                            SendStatus: engineResult.Success ? \"Sent\" : \"Failed\",\n                            ErrorMessage: engineResult.ErrorMessage,\n                            CreatedAt: now,\n                            CreatedBy: \"system\",\n                            SentAt: engineResult.Success ? now : (DateTime?)null,\n                            DeliveredAt: null,\n                            ReadAt: null,\n                            IpAddress: null,\n                            DeviceInfo: null,\n                            MacAddress: null,\n                            SourceChannel: \"campaign\",\n                            DeviceType: null,\n                            Browser: null,\n                            Country: null,\n                            City: null,\n                            IsClicked: false,\n                            ClickedAt: null,\n                            ClickType: null,\n                            RetryCount: job.Attempt,\n                            LastRetryAt: now,\n                            LastRetryStatus: engineResult.Success ? \"Success\" : \"Failed\",\n                            AllowRetry: job.Attempt < DEFAULT_MAX_ATTEMPTS,\n                            MessageLogId: logId,\n                            BusinessId: job.BusinessId,\n                            CTAFlowConfigId: null,\n                            CTAFlowStepId: null,\n                            ButtonBundleJson: null\n                        ));\n\n                        // Update job (retry/backoff if needed)\n                        job.Status = engineResult.Success ? \"Sent\" : \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = engineResult.ErrorMessage;\n\n                        if (!engineResult.Success)\n                        {\n                            var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                            MetricsRegistry.MessagesFailed.Add(1);\n                        }\n                        else\n                        {\n                            job.NextAttemptAt = null;\n                            MetricsRegistry.MessagesSent.Add(1);\n                        }\n\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n\n                        await billing.IngestFromSendResponseAsync(\n                            job.BusinessId,\n                            logId,\n                            job.Provider,\n                            engineResult.RawResponse ?? \"{}\"\n                        );\n                    }\n                }\n                catch (TaskCanceledException)\n                {\n                }\n                catch (Exception ex)\n                {\n                    try\n                    {\n                        using var scope = _sp.CreateScope();\n                        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                        job.Status = \"Failed\";\n                        job.Attempt += 1;\n                        job.LastError = ex.Message;\n                        var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n                        job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n                        db.Update(job);\n                        await db.SaveChangesAsync(ct);\n                    }\n                    catch { /* swallow */ }\n\n                    MetricsRegistry.MessagesFailed.Add(1);\n                    _log.LogError(ex, \"[Outbox] Consume error job={JobId}\", job.Id);\n                }\n            }\n        }\n    }\n}\n\n\n//// ðŸ“„ File: Features/CampaignModule/Workers/OutboundSenderWorker.cs\n//using System;\n//using System.Collections.Concurrent;\n//using System.Collections.Generic;   // NEW\n//using System.Diagnostics;\n//using System.Linq;\n//using System.Text.Json;            // NEW\n//using System.Text.RegularExpressions; // NEW\n//using System.Threading;\n//using System.Threading.Channels;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.DependencyInjection;\n//using Microsoft.Extensions.Hosting;\n//using Microsoft.Extensions.Logging;\n//using Npgsql;\n\n//using xbytechat.api;\n//using xbytechat.api.Features.CampaignModule.Models;\n//using xbytechat.api.Features.CampaignTracking.Logging;\n//using xbytechat.api.Features.CampaignTracking.Models;\n//using xbytechat.api.Features.MessageLogging.Services;\n//using xbytechat.api.Features.MessagesEngine.Abstractions;\n//using xbytechat.api.Features.CampaignModule.SendEngine;\n//using xbytechat_api.Features.Billing.Services;\n//using xbytechat.api.Infrastructure.Observability;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.WhatsAppSettings.Helpers;\n//using xbytechat.api.AuthModule.Models;\n\n//namespace xbytechat.api.Features.CampaignModule.Workers\n//{\n//    public class OutboundSenderWorker : BackgroundService\n//    {\n//        private readonly IServiceProvider _sp;\n//        private readonly ILogger<OutboundSenderWorker> _log;\n//        private readonly Channel<OutboundMessageJob> _channel;\n//        private const int DEFAULT_MAX_ATTEMPTS = 3;\n\n//        // Concurrency caps (override via appsettings if you expose options)\n//        private readonly int _globalDop = 32;   // total parallel consumers\n//        private readonly int _perNumberDop = 8; // per (provider, PhoneNumberId)\n\n//        private readonly TimeSpan _pollInterval = TimeSpan.FromMilliseconds(250);\n//        private static readonly TimeSpan _flightTimeout = TimeSpan.FromMinutes(5);\n\n//        private int _inChannel;\n//        private readonly Random _rand = new();\n\n//        // =========================[ NEW: Template Button Cache + Parsers ]=========================\n//        // Cache key = BusinessId|Provider|TemplateName|Language (upper-invariant)\n//        private static readonly ConcurrentDictionary<string, IReadOnlyList<ButtonMeta>> _btnCache =\n//            new(StringComparer.Ordinal);\n\n//        // Precompiled regexes for any legacy/raw variations (cheap + fast on hot path)\n//        private static readonly Regex RxButtonTypeMeta = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n//        private static readonly Regex RxButtonTypePinn = new(@\"^\\s*url\\s*$\", RegexOptions.IgnoreCase | RegexOptions.Compiled);\n\n//        private static string CacheKeyForTemplate(WhatsAppTemplate tpl)\n//            => $\"{tpl.BusinessId}|{tpl.Provider}|{tpl.Name}|{tpl.LanguageCode}\".ToUpperInvariant();\n\n//        private static IReadOnlyList<ButtonMeta> GetTemplateButtonsCached(WhatsAppTemplate tpl)\n//            => _btnCache.GetOrAdd(CacheKeyForTemplate(tpl), _ => ParseButtonsFromTemplateRow(tpl));\n\n//        private static IReadOnlyList<ButtonMeta> ParseButtonsFromTemplateRow(WhatsAppTemplate tpl)\n//        {\n//            // 1) Preferred: light-weight ButtonsJson (DTO-style) if available\n//            if (!string.IsNullOrWhiteSpace(tpl.UrlButtons))\n//            {\n//                try\n//                {\n//                    using var doc = JsonDocument.Parse(tpl.UrlButtons);\n//                    if (doc.RootElement.ValueKind == JsonValueKind.Array)\n//                    {\n//                        var list = new List<ButtonMeta>(capacity: 3);\n//                        foreach (var el in doc.RootElement.EnumerateArray())\n//                        {\n//                            // Support both historical shapes:\n//                            // { \"ButtonText\",\"ButtonType\",\"TargetUrl\" }  OR  { \"Text\",\"Type\",\"TargetUrl\" }\n//                            var text = el.TryGetProperty(\"ButtonText\", out var pText) ? pText.GetString() ?? \"\" :\n//                                       el.TryGetProperty(\"Text\", out var pText2) ? pText2.GetString() ?? \"\" : \"\";\n//                            var type = el.TryGetProperty(\"ButtonType\", out var pType) ? pType.GetString() ?? \"\" :\n//                                       el.TryGetProperty(\"Type\", out var pType2) ? pType2.GetString() ?? \"\" : \"\";\n//                            var url = el.TryGetProperty(\"TargetUrl\", out var pUrl) ? pUrl.GetString() : null;\n\n//                            if (!string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(type))\n//                                list.Add(new ButtonMeta(text, type, url));\n//                        }\n//                        return list;\n//                    }\n//                }\n//                catch\n//                {\n//                    // Fallthrough to RawJson parser\n//                }\n//            }\n\n//            // 2) Fallback: parse RawJson (provider-native). Look for button components with url subtype.\n//            if (!string.IsNullOrWhiteSpace(tpl.RawJson))\n//            {\n//                try\n//                {\n//                    using var doc = JsonDocument.Parse(tpl.RawJson);\n\n//                    // Try to locate \"components\" either under \"template\" or at root\n//                    JsonElement comps = default;\n//                    if (doc.RootElement.TryGetProperty(\"template\", out var tplNode) &&\n//                        tplNode.TryGetProperty(\"components\", out var comps1))\n//                    {\n//                        comps = comps1;\n//                    }\n//                    else if (doc.RootElement.TryGetProperty(\"components\", out var comps2))\n//                    {\n//                        comps = comps2;\n//                    }\n\n//                    if (comps.ValueKind == JsonValueKind.Array)\n//                    {\n//                        var list = new List<ButtonMeta>(capacity: 3);\n\n//                        foreach (var c in comps.EnumerateArray())\n//                        {\n//                            // Meta:   { \"type\":\"button\", \"sub_type\":\"url\", \"index\":\"0\", ... }\n//                            // Pinn.:  { \"type\":\"button\", \"subType\":\"url\", \"index\": 0, ... }\n//                            if (!c.TryGetProperty(\"type\", out var tProp)) continue;\n//                            if (!string.Equals(tProp.GetString(), \"button\", StringComparison.OrdinalIgnoreCase)) continue;\n\n//                            var isUrl =\n//                                (c.TryGetProperty(\"sub_type\", out var st) && RxButtonTypeMeta.IsMatch(st.GetString() ?? \"\")) ||\n//                                (c.TryGetProperty(\"subType\", out var st2) && RxButtonTypePinn.IsMatch(st2.GetString() ?? \"\"));\n\n//                            if (!isUrl) continue;\n\n//                            // Text label may not be present in raw; use a neutral label\n//                            string text = \"Open\";\n//                            string type = \"url\";\n//                            string? url = null;\n\n//                            // If static url parameter is present, try to read it\n//                            if (c.TryGetProperty(\"parameters\", out var pars) && pars.ValueKind == JsonValueKind.Array)\n//                            {\n//                                foreach (var p in pars.EnumerateArray())\n//                                {\n//                                    if (p.TryGetProperty(\"text\", out var txtProp))\n//                                    {\n//                                        var v = txtProp.GetString();\n//                                        if (!string.IsNullOrWhiteSpace(v)) { url = v; break; }\n//                                    }\n//                                }\n//                            }\n\n//                            list.Add(new ButtonMeta(text, type, url));\n//                            if (list.Count >= 3) break; // WhatsApp UI supports up to 3 buttons\n//                        }\n\n//                        return list;\n//                    }\n//                }\n//                catch\n//                {\n//                    // ignore, fallthrough\n//                }\n//            }\n\n//            return Array.Empty<ButtonMeta>();\n//        }\n//        // ==========================================================================================\n\n//        public OutboundSenderWorker(IServiceProvider sp, ILogger<OutboundSenderWorker> log)\n//        {\n//            _sp = sp;\n//            _log = log;\n\n//            _channel = Channel.CreateBounded<OutboundMessageJob>(new BoundedChannelOptions(5000)\n//            {\n//                SingleReader = false,\n//                SingleWriter = false,\n//                FullMode = BoundedChannelFullMode.Wait\n//            });\n//        }\n\n//        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//        {\n//            using var cts = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);\n//            var ct = cts.Token;\n\n//            var consumers = Enumerable.Range(0, _globalDop)\n//                .Select(_ => Task.Run(() => ConsumeAsync(ct), ct))\n//                .ToArray();\n\n//            var producer = Task.Run(() => ProduceAsync(ct), ct);\n\n//            var all = consumers.Append(producer).ToArray();\n\n//            try\n//            {\n//                await Task.WhenAll(all);\n//            }\n//            catch\n//            {\n//                try { cts.Cancel(); } catch { /* ignore */ }\n//                throw;\n//            }\n//        }\n\n//        private async Task ProduceAsync(CancellationToken ct)\n//        {\n//            const int ChannelCapacity = 5000;\n\n//            // Backoff controls\n//            var idleDelay = _pollInterval;                 // starts small\n//            var maxIdleDelay = TimeSpan.FromSeconds(1);    // back off up to 1s\n//            var longIdleDelay = TimeSpan.FromSeconds(30);  // after many empties\n//            int consecutiveEmpty = 0;\n\n//            // Prioritize due items; then FIFO by CreatedAt\n//            const string sql = @\"\n//WITH cte AS (\n//    SELECT \"\"Id\"\"\n//    FROM \"\"OutboundMessageJobs\"\"\n//    WHERE \"\"Status\"\" = 'Pending'\n//      AND (\"\"NextAttemptAt\"\" IS NULL OR \"\"NextAttemptAt\"\" <= NOW())\n//    ORDER BY \"\"NextAttemptAt\"\" NULLS FIRST, \"\"CreatedAt\"\"\n//    FOR UPDATE SKIP LOCKED\n//    LIMIT @take\n//)\n//UPDATE \"\"OutboundMessageJobs\"\" j\n//SET \"\"Status\"\" = 'InFlight',\n//    \"\"NextAttemptAt\"\" = NOW() + make_interval(secs => @flight),\n//    \"\"LastError\"\" = NULL\n//WHERE j.\"\"Id\"\" IN (SELECT \"\"Id\"\" FROM cte)\n//RETURNING j.*;\";\n\n//            // Small jittered pause on startup to avoid log bursts on app boot\n//            try { await Task.Delay(_rand.Next(100, 500), ct); } catch { /* ignore */ }\n\n//            while (!ct.IsCancellationRequested)\n//            {\n//                try\n//                {\n//                    using var scope = _sp.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//                    // Channel budget\n//                    var approxCount = Volatile.Read(ref _inChannel);\n//                    var budget = Math.Max(0, ChannelCapacity - approxCount);\n\n//                    if (budget <= 0)\n//                    {\n//                        await Task.Delay(idleDelay, ct);\n//                        idleDelay = TimeSpan.FromMilliseconds(\n//                            Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 1.25)\n//                        );\n//                        continue;\n//                    }\n\n//                    // We have budget; donâ€™t carry a long backoff into a fresh poll cycle\n//                    idleDelay = _pollInterval;\n\n//                    var take = Math.Min(budget, 2000);\n//                    var flightSecs = (int)Math.Ceiling(_flightTimeout.TotalSeconds);\n\n//                    var takeParam = new NpgsqlParameter<int>(\"take\", take);\n//                    var flightParam = new NpgsqlParameter<int>(\"flight\", flightSecs);\n\n//                    var prevTimeout = db.Database.GetCommandTimeout();\n//                    db.Database.SetCommandTimeout(5);\n\n//                    List<OutboundMessageJob> jobs;\n//                    try\n//                    {\n//                        jobs = await db.OutboundMessageJobs\n//                            .FromSqlRaw(sql, takeParam, flightParam)\n//                            .AsNoTracking()\n//                            .ToListAsync(ct);\n//                    }\n//                    finally\n//                    {\n//                        db.Database.SetCommandTimeout(prevTimeout);\n//                    }\n\n//                    // Push to channel; track occupancy\n//                    foreach (var job in jobs)\n//                    {\n//                        await _channel.Writer.WriteAsync(job, ct);\n//                        Interlocked.Increment(ref _inChannel);\n//                    }\n\n//                    if (jobs.Count == 0)\n//                    {\n//                        consecutiveEmpty++;\n\n//                        // No work â†’ exponential backoff, then step up to a longer 30s sleep\n//                        var jitterMs = _rand.Next(0, 200);\n//                        var delay = idleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n//                        // After several empty loops, cut DB chatter significantly\n//                        if (consecutiveEmpty >= 8 && idleDelay >= maxIdleDelay)\n//                            delay = longIdleDelay + TimeSpan.FromMilliseconds(jitterMs);\n\n//                        await Task.Delay(delay, ct);\n\n//                        if (idleDelay < maxIdleDelay)\n//                        {\n//                            idleDelay = TimeSpan.FromMilliseconds(\n//                                Math.Min(maxIdleDelay.TotalMilliseconds, idleDelay.TotalMilliseconds * 2)\n//                            );\n//                        }\n//                    }\n//                    else\n//                    {\n//                        consecutiveEmpty = 0;\n//                        idleDelay = _pollInterval;\n//                    }\n//                }\n//                catch (TaskCanceledException)\n//                {\n//                    // normal shutdown\n//                }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"[Outbox] Producer loop error\");\n//                    try { await Task.Delay(TimeSpan.FromSeconds(2), ct); } catch { /* ignore */ }\n//                }\n//            }\n//        }\n\n//        // ---- keyed concurrency gate (per sender) ---------------------------------------\n//        private sealed class KeyedSemaphore\n//        {\n//            private readonly ConcurrentDictionary<string, SemaphoreSlim> _map = new();\n//            public async Task<IDisposable> AcquireAsync(string key, int dop, CancellationToken ct)\n//            {\n//                var sem = _map.GetOrAdd(key, _ => new SemaphoreSlim(dop));\n//                await sem.WaitAsync(ct);\n//                return new Releaser(sem);\n//            }\n//            private sealed class Releaser : IDisposable\n//            {\n//                private readonly SemaphoreSlim _s;\n//                public Releaser(SemaphoreSlim s) => _s = s;\n//                public void Dispose() => _s.Release();\n//            }\n//        }\n//        private static readonly KeyedSemaphore _perSenderGate = new();\n//        // -------------------------------------------------------------------------------\n//        private async Task ConsumeAsync(CancellationToken ct)\n//        {\n//            // Resolve a phone number for a recipient (Contact.Phone or AudienceMember.PhoneE164/Raw)\n//            static async Task<string> ResolveRecipientPhoneAsync(AppDbContext db, Guid recipientId, CancellationToken ct2)\n//            {\n//                var phone = await db.CampaignRecipients\n//                    .AsNoTracking()\n//                    .Where(r => r.Id == recipientId)\n//                    .Select(r =>\n//                        r.Contact != null\n//                            ? r.Contact.PhoneNumber\n//                            : (r.AudienceMember != null\n//                                ? (r.AudienceMember.PhoneE164 ?? r.AudienceMember.PhoneRaw)\n//                                : null))\n//                    .FirstOrDefaultAsync(ct2);\n\n//                return phone ?? string.Empty;\n//            }\n\n//            while (await _channel.Reader.WaitToReadAsync(ct))\n//            {\n//                if (!_channel.Reader.TryRead(out var job))\n//                    continue;\n\n//                // decrement occupancy as soon as we pull from the channel\n//                Interlocked.Decrement(ref _inChannel);\n\n//                try\n//                {\n//                    using var scope = _sp.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//                    var engine = scope.ServiceProvider.GetRequiredService<IMessageEngineService>();\n//                    var billing = scope.ServiceProvider.GetRequiredService<IBillingIngestService>();\n//                    var logger = scope.ServiceProvider.GetRequiredService<ILogger<OutboundSenderWorker>>();\n//                    var logSink = scope.ServiceProvider.GetRequiredService<ICampaignLogSink>();\n//                    var limiter = scope.ServiceProvider.GetRequiredService<xbytechat.api.Infrastructure.RateLimiting.IPhoneNumberRateLimiter>();\n//                    var messageLogSink = scope.ServiceProvider.GetRequiredService<IMessageLogSink>();\n//                    var builder = scope.ServiceProvider.GetRequiredService<ITemplatePayloadBuilder>();\n//                    var validator = scope.ServiceProvider.GetRequiredService<ICampaignSendValidator>(); // âœ…\n\n//                    // Per-sender key = provider + phoneNumberId\n//                    var senderKey = $\"{job.Provider}|{job.PhoneNumberId}\";\n\n//                    using (await _perSenderGate.AcquireAsync(senderKey, _perNumberDop, ct))\n//                    {\n//                        // Rate limit per number (token bucket via your registered limiter)\n//                        var lease = await limiter.AcquireAsync(senderKey, ct);\n//                        if (!lease.IsAcquired)\n//                        {\n//                            await Task.Delay(50, ct);\n//                            continue;\n//                        }\n\n//                        // Resolve phone\n//                        var recipientPhone = await ResolveRecipientPhoneAsync(db, job.RecipientId, ct);\n//                        if (string.IsNullOrWhiteSpace(recipientPhone))\n//                        {\n//                            job.Status = \"Failed\";\n//                            job.Attempt += 1;\n//                            job.LastError = \"Recipient phone not found.\";\n//                            var backoff1 = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff1);\n//                            db.Update(job);\n//                            await db.SaveChangesAsync(ct);\n\n//                            logger.LogWarning(\"[Outbox] Recipient phone not found. job={JobId} recipient={RecipientId}\", job.Id, job.RecipientId);\n//                            MetricsRegistry.MessagesFailed.Add(1);\n//                            continue;\n//                        }\n\n//                        // ===== Load template row (cached metadata for validation)\n//                        var lang = job.LanguageCode ?? \"en_US\";\n//                        var tmplRow = await db.WhatsAppTemplates\n//                            .AsNoTracking()\n//                            .FirstOrDefaultAsync(t =>\n//                                t.BusinessId == job.BusinessId &&\n//                                t.Provider == job.Provider &&\n//                                t.Name == job.TemplateName &&\n//                                t.LanguageCode == lang,\n//                                ct);\n\n//                        if (tmplRow == null)\n//                        {\n//                            job.Status = \"Failed\";\n//                            job.Attempt += 1;\n//                            job.LastError = $\"Template not found: {job.TemplateName} ({lang}) for {job.Provider}.\";\n//                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n//                            db.Update(job);\n//                            await db.SaveChangesAsync(ct);\n\n//                            logger.LogWarning(\"[Outbox] Template not found. job={JobId} template={Template} lang={Lang} provider={Provider}\",\n//                                job.Id, job.TemplateName, lang, job.Provider);\n//                            MetricsRegistry.MessagesFailed.Add(1);\n//                            continue;\n//                        }\n\n//                        // Prefer DB header kind (normalized), fallback to job.MediaType\n//                        HeaderKind headerKind = tmplRow.HeaderKind?.ToLowerInvariant() switch\n//                        {\n//                            \"text\" => HeaderKind.Text,\n//                            \"image\" => HeaderKind.Image,\n//                            \"video\" => HeaderKind.Video,\n//                            \"document\" => HeaderKind.Document,\n//                            \"none\" or null => HeaderKind.None,\n//                            _ => HeaderKind.None\n//                        };\n//                        if (headerKind == HeaderKind.None && !string.IsNullOrWhiteSpace(job.MediaType))\n//                        {\n//                            headerKind = job.MediaType.ToLowerInvariant() switch\n//                            {\n//                                \"text\" => HeaderKind.Text,\n//                                \"image\" => HeaderKind.Image,\n//                                \"video\" => HeaderKind.Video,\n//                                \"document\" => HeaderKind.Document,\n//                                _ => HeaderKind.None\n//                            };\n//                        }\n\n//                        // ===== Build plan & recipient\n//                        var providerEnum = ProviderUtil.Parse(job.Provider);\n\n//                        // NEW: hydrate ButtonMeta list from the template row (cached)\n//                        var buttonsFromTemplate = GetTemplateButtonsCached(tmplRow);\n\n//                        var plan = new SendPlan(\n//                            BusinessId: job.BusinessId,\n//                            Provider: providerEnum,\n//                            PhoneNumberId: job.PhoneNumberId!,\n//                            TemplateName: job.TemplateName!,\n//                            LanguageCode: lang,\n//                            HeaderKind: headerKind,\n//                            HeaderUrl: job.HeaderMediaUrl,\n//                            Buttons: buttonsFromTemplate // <-- previously Array.Empty<ButtonMeta>()\n//                        );\n\n//                        var recipient = new RecipientPlan(\n//                            RecipientId: job.RecipientId,\n//                            ToPhoneE164: recipientPhone,\n//                            ParametersJson: job.ResolvedParamsJson ?? \"[]\",\n//                            ButtonParamsJson: job.ResolvedButtonUrlsJson,\n//                            IdempotencyKey: job.IdempotencyKey ?? $\"{job.CampaignId}:{recipientPhone}:{job.TemplateName}\"\n//                        );\n\n//                        // ===== Build envelope (generic) then VALIDATE before provider mapping\n//                        var envelope = builder.Build(plan, recipient); // TemplateEnvelope\n\n//                        // ICampaignSendValidator.Validate(plan, recipient, envelope, tmplRow)\n//                        var (ok, error) = validator.Validate(plan, recipient, envelope, tmplRow);\n//                        if (!ok)\n//                        {\n//                            job.Status = \"Failed\";\n//                            job.Attempt += 1;\n//                            job.LastError = error ?? \"Validation failed.\";\n//                            var backoff = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoff);\n//                            db.Update(job);\n//                            await db.SaveChangesAsync(ct);\n\n//                            logger.LogWarning(\"[Outbox] Validation failed job={JobId} error={Error}\", job.Id, job.LastError);\n//                            MetricsRegistry.MessagesFailed.Add(1);\n//                            continue;\n//                        }\n\n//                        // ===== Map to provider payload AFTER validation\n//                        object payload = providerEnum switch\n//                        {\n//                            Provider.MetaCloud =>\n//                                scope.ServiceProvider.GetRequiredService<MetaCloudPayloadMapper>()\n//                                    .BuildPayload(plan, recipient, envelope),\n\n//                            Provider.Pinnacle =>\n//                                scope.ServiceProvider.GetRequiredService<PinnaclePayloadMapper>()\n//                                    .BuildPayload(plan, recipient, envelope),\n\n//                            _ => throw new InvalidOperationException(\"Unknown provider\")\n//                        };\n//                        // ===== End unified build =====\n\n//                        // --- Send via engine + metrics timers ---\n//                        var sw = Stopwatch.StartNew();\n//                        var engineResult = await engine.SendPayloadAsync(job.BusinessId, job.Provider, payload, job.PhoneNumberId);\n//                        sw.Stop();\n//                        MetricsRegistry.SendLatencyMs.Record(sw.Elapsed.TotalMilliseconds);\n\n//                        // Adaptive nudge on 429 (based on error text)\n//                        if (!engineResult.Success)\n//                        {\n//                            var err = engineResult.ErrorMessage ?? string.Empty;\n//                            if (err.Contains(\"429\", StringComparison.Ordinal) ||\n//                                err.Contains(\"Too Many Requests\", StringComparison.OrdinalIgnoreCase))\n//                            {\n//                                limiter.UpdateLimits(senderKey, permitsPerSecond: 5, burst: 5);\n//                                MetricsRegistry.RateLimited429s.Add(1);\n//                            }\n//                        }\n\n//                        // Persist MessageLogs (COPY sink)\n//                        var now = DateTime.UtcNow;\n//                        var runId = Guid.NewGuid();\n//                        var logId = Guid.NewGuid();\n\n//                        messageLogSink.Enqueue(new MessageLog\n//                        {\n//                            Id = logId,\n//                            BusinessId = job.BusinessId,\n//                            CampaignId = job.CampaignId,\n//                            RecipientNumber = recipientPhone,\n//                            MessageContent = job.TemplateName,\n//                            MediaUrl = job.HeaderMediaUrl,\n//                            Status = engineResult.Success ? \"Sent\" : \"Failed\",\n//                            MessageId = engineResult.MessageId,\n//                            ErrorMessage = engineResult.ErrorMessage,\n//                            RawResponse = engineResult.RawResponse,\n//                            CreatedAt = now,\n//                            SentAt = engineResult.Success ? now : (DateTime?)null,\n//                            Source = \"campaign\",\n//                            RunId = runId,\n//                            Provider = job.Provider,\n//                            ProviderMessageId = engineResult.MessageId,\n//                            IsIncoming = false,\n//                            IsChargeable=false\n//                        });\n\n//                        // Batched CampaignSendLog (COPY via sink)\n//                        logSink.Enqueue(new CampaignLogRecord(\n//                            Id: Guid.NewGuid(),\n//                            RunId: runId,\n//                            MessageId: engineResult.MessageId,\n//                            CampaignId: job.CampaignId,\n//                            ContactId: null,\n//                            RecipientId: job.RecipientId,\n//                            MessageBody: job.MessageBody ?? job.TemplateName,\n//                            TemplateId: job.TemplateName,\n//                            SendStatus: engineResult.Success ? \"Sent\" : \"Failed\",\n//                            ErrorMessage: engineResult.ErrorMessage,\n//                            CreatedAt: now,\n//                            CreatedBy: \"system\",\n//                            SentAt: engineResult.Success ? now : (DateTime?)null,\n//                            DeliveredAt: null,\n//                            ReadAt: null,\n//                            IpAddress: null,\n//                            DeviceInfo: null,\n//                            MacAddress: null,\n//                            SourceChannel: \"campaign\",\n//                            DeviceType: null,\n//                            Browser: null,\n//                            Country: null,\n//                            City: null,\n//                            IsClicked: false,\n//                            ClickedAt: null,\n//                            ClickType: null,\n//                            RetryCount: job.Attempt,\n//                            LastRetryAt: now,\n//                            LastRetryStatus: engineResult.Success ? \"Success\" : \"Failed\",\n//                            AllowRetry: job.Attempt < DEFAULT_MAX_ATTEMPTS,\n//                            MessageLogId: logId,\n//                            BusinessId: job.BusinessId,\n//                            CTAFlowConfigId: null,\n//                            CTAFlowStepId: null,\n//                            ButtonBundleJson: null\n//                        ));\n\n//                        // Update job (retry/backoff if needed)\n//                        job.Status = engineResult.Success ? \"Sent\" : \"Failed\";\n//                        job.Attempt += 1;\n//                        job.LastError = engineResult.ErrorMessage;\n\n//                        if (!engineResult.Success)\n//                        {\n//                            var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                            job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n//                            MetricsRegistry.MessagesFailed.Add(1);\n//                        }\n//                        else\n//                        {\n//                            job.NextAttemptAt = null;\n//                            MetricsRegistry.MessagesSent.Add(1);\n//                        }\n\n//                        db.Update(job);\n//                        await db.SaveChangesAsync(ct);\n\n//                        // Async billing ingest (complete before scope disposed)\n//                        await billing.IngestFromSendResponseAsync(\n//                            job.BusinessId,\n//                            logId,\n//                            job.Provider,\n//                            engineResult.RawResponse ?? \"{}\"\n//                        );\n//                    }\n//                }\n//                catch (TaskCanceledException)\n//                {\n//                    // graceful shutdown\n//                }\n//                catch (Exception ex)\n//                {\n//                    try\n//                    {\n//                        using var scope = _sp.CreateScope();\n//                        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n//                        job.Status = \"Failed\";\n//                        job.Attempt += 1;\n//                        job.LastError = ex.Message;\n//                        var backoffSecs = (int)Math.Min(60, Math.Pow(2, job.Attempt) * 2);\n//                        job.NextAttemptAt = DateTime.UtcNow.AddSeconds(backoffSecs);\n//                        db.Update(job);\n//                        await db.SaveChangesAsync(ct);\n//                    }\n//                    catch { /* swallow */ }\n\n//                    MetricsRegistry.MessagesFailed.Add(1);\n//                    _log.LogError(ex, \"[Outbox] Consume error job={JobId}\", job.Id);\n//                }\n//            }\n//        }\n//    }\n//}\n\n\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Workers/OutboxReaperWorker.cs",
      "sha256": "62e23d9733ccd68ae2166ca2bc11a9b2024183cf0b91163984e6d7e40e7d2f15",
      "language": "csharp",
      "size": 3194,
      "content": "using Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.CampaignModule.Workers\n{\n    public sealed class OutboxReaperWorker : BackgroundService\n    {\n        private readonly IServiceProvider _sp;\n        private readonly ILogger<OutboxReaperWorker> _log;\n\n        // How often we sweep\n        private static readonly TimeSpan SweepEvery = TimeSpan.FromSeconds(30);\n\n        // Keep in sync with your sender logic / DEFAULT_MAX_ATTEMPTS\n        private const int MAX_ATTEMPTS = 3;\n\n        public OutboxReaperWorker(IServiceProvider sp, ILogger<OutboxReaperWorker> log)\n        {\n            _sp = sp;\n            _log = log;\n        }\n\n        // OutboxReaperWorker.cs\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var now = DateTime.UtcNow;\n\n                    // ---- Recover stale InFlight jobs (no Random in the expression) ----\n                    var jitterSeconds = 2 + (int)((ulong)DateTime.UtcNow.Ticks % 3); // 2..4s\n                    var backoffAt = now.AddSeconds(jitterSeconds);\n\n                    var recovered = await db.OutboundMessageJobs\n                        .Where(j => j.Status == \"InFlight\" &&\n                                    j.NextAttemptAt != null &&\n                                    j.NextAttemptAt < now)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Pending\")\n                            .SetProperty(j => j.NextAttemptAt, _ => backoffAt)\n                            .SetProperty(j => j.LastError, _ => \"Recovered from stale in-flight\"),\n                            stoppingToken);\n\n                    // ---- Kill over-retried jobs ----\n                    const int MAX_ATTEMPTS = 3;\n                    var killed = await db.OutboundMessageJobs\n                        .Where(j => (j.Status == \"Pending\" || j.Status == \"Failed\" || j.Status == \"InFlight\") &&\n                                    j.Attempt >= MAX_ATTEMPTS)\n                        .ExecuteUpdateAsync(s => s\n                            .SetProperty(j => j.Status, _ => \"Dead\")\n                            .SetProperty(j => j.NextAttemptAt, _ => (DateTime?)null)\n                            .SetProperty(j => j.LastError, _ => \"Max attempts exceeded\"),\n                            stoppingToken);\n\n                    if (recovered > 0 || killed > 0)\n                        _log.LogInformation(\"[OutboxReaper] recovered={Recovered} killed={Killed}\", recovered, killed);\n                }\n                catch (TaskCanceledException) { /* shutdown */ }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"[OutboxReaper] sweep failed\");\n                }\n\n                try { await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken); }\n                catch (TaskCanceledException) { /* shutdown */ }\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Config/TrackingOptions.cs",
      "sha256": "76b42450eeb28f2d73ad6fc86ec956bc6e278f17ee17f5e517e0689e8a247483",
      "language": "csharp",
      "size": 337,
      "content": "// ðŸ“„ Features/CampaignTracking/Config/TrackingOptions.cs\nnamespace xbytechat.api.Features.CampaignTracking.Config\n{\n    public class TrackingOptions\n    {\n        public string BaseUrl { get; set; } = \"\";\n        public string Secret { get; set; } = \"\";\n        public TimeSpan TokenTtl { get; set; } = TimeSpan.FromDays(30);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignAnalyticsController.cs",
      "sha256": "7542c47e6bbe6d8117004542788bb0f078570eeae04c8045b385fc3b7eb5dde4",
      "language": "csharp",
      "size": 2494,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class CampaignAnalyticsController : BusinessControllerBase\n    {\n        private readonly ICampaignAnalyticsService _campaignAnalyticsService;\n        public CampaignAnalyticsController(ICampaignAnalyticsService svc) => _campaignAnalyticsService = svc;\n\n        [HttpGet(\"top-campaigns\")]\n        public async Task<IActionResult> GetTopCampaigns([FromQuery] int count = 5)\n            => Ok(await _campaignAnalyticsService.GetTopCampaignsAsync(BusinessId, count));\n    }\n}\n\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using System.Security.Claims;\n//using xbytechat.api.Features.CampaignTracking.Services;\n\n//namespace xbytechat.api.Features.CampaignTracking.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/[controller]\")]\n//    [Authorize]\n//    public class CampaignAnalyticsController : ControllerBase\n//    {\n//        private readonly ICampaignAnalyticsService _campaignAnalyticsService;\n\n//        public CampaignAnalyticsController(ICampaignAnalyticsService campaignAnalyticsService)\n//        {\n//            _campaignAnalyticsService = campaignAnalyticsService;\n//        }\n\n//        [HttpGet(\"status-dashboard\")]\n//        //public async Task<IActionResult> GetStatusDashboard()\n//        //{\n//        //    var businessIdString = User.FindFirstValue(\"BusinessId\");\n//        //    if (!Guid.TryParse(businessIdString, out var businessId))\n//        //    {\n//        //        return Unauthorized(\"Invalid business identifier.\");\n//        //    }\n//        //    var result = await _campaignAnalyticsService.GetStatusDashboardAsync(businessId);\n//        //    return Ok(result);\n//        //}\n\n//        [HttpGet(\"top-campaigns\")]\n//        public async Task<IActionResult> GetTopCampaigns([FromQuery] int count = 5)\n//        {\n//            var businessIdString = User.FindFirstValue(\"BusinessId\");\n//            if (!Guid.TryParse(businessIdString, out var businessId))\n//            {\n//                return Unauthorized(\"Invalid business identifier.\");\n//            }\n//            var result = await _campaignAnalyticsService.GetTopCampaignsAsync(businessId, count);\n//            return Ok(result);\n//        }\n//    }\n//}"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignRetryController.cs",
      "sha256": "7fb4bd32c18410353886a39bebaf5c0c6e24ea48ce01a75d6bb0c553613438f8",
      "language": "csharp",
      "size": 1241,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Authorize] // âœ… add this\n    [Route(\"api/campaign-retry\")]\n    public class CampaignRetryController : ControllerBase\n    {\n        private readonly ICampaignTrackingRetryService _retryService;\n\n        public CampaignRetryController(ICampaignTrackingRetryService retryService)\n        {\n            _retryService = retryService;\n        }\n\n        [HttpPost(\"{logId}/retry\")]\n        public async Task<IActionResult> RetrySingle(Guid logId)\n        {\n            var success = await _retryService.RetrySingleAsync(logId);\n            if (!success) return BadRequest(new { message = \"Retry failed or not allowed for this log.\" });\n            return Ok(new { success = true, message = \"Retry completed.\" });\n        }\n\n        [HttpPost(\"campaign/{campaignId}/retry-all\")]\n        public async Task<IActionResult> RetryAllInCampaign(Guid campaignId)\n            => Ok(new { success = true, retriedCount = await _retryService.RetryFailedInCampaignAsync(campaignId) });\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignSendLogController.cs",
      "sha256": "95a189e3fdcff8f648aef7e688a3e3ee83fb7147e59f77d78259862f9b99d84b",
      "language": "csharp",
      "size": 4499,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaign-logs\")]\n    public class CampaignSendLogController : ControllerBase\n    {\n        private readonly ICampaignSendLogService _logService;\n        private readonly ICampaignTrackingRetryService _retryService;\n\n        public CampaignSendLogController(\n            ICampaignSendLogService logService,\n            ICampaignTrackingRetryService retryService\n        )\n        {\n            _logService = logService;\n            _retryService = retryService;\n        }\n\n        //[HttpGet(\"campaign/{campaignId}\")]\n        //public async Task<IActionResult> GetLogsByCampaign(Guid campaignId)\n        //{\n        //    var logs = await _logService.GetLogsByCampaignIdAsync(campaignId);\n        //    return Ok(logs);\n        //}\n        [HttpGet(\"campaign/{campaignId}\")]\n        public async Task<IActionResult> GetLogsByCampaign(\n         Guid campaignId,\n         [FromQuery] string? status,\n         [FromQuery] string? search,\n         [FromQuery] int page = 1,\n         [FromQuery] int pageSize = 10)\n        {\n            var result = await _logService.GetLogsByCampaignIdAsync(campaignId, status, search, page, pageSize);\n            return Ok(result);\n        }\n        [HttpGet(\"campaign/{campaignId}/contact/{contactId}\")]\n        public async Task<IActionResult> GetLogsForContact(Guid campaignId, Guid contactId)\n        {\n            var logs = await _logService.GetLogsForContactAsync(campaignId, contactId);\n            return Ok(logs);\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddSendLog([FromBody] CampaignSendLogDto dto)\n        {\n            var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n            var userAgent = Request.Headers[\"User-Agent\"].ToString() ?? \"unknown\";\n\n            var result = await _logService.AddSendLogAsync(dto, ipAddress, userAgent);\n            if (!result)\n                return BadRequest(new { message = \"Failed to add send log\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPut(\"{logId}/status\")]\n        public async Task<IActionResult> UpdateDeliveryStatus(Guid logId, [FromBody] DeliveryStatusUpdateDto dto)\n        {\n            var result = await _logService.UpdateDeliveryStatusAsync(logId, dto.Status, dto.DeliveredAt, dto.ReadAt);\n            if (!result)\n                return NotFound(new { message = \"Log not found\" });\n\n            return Ok(new { success = true });\n        }\n\n        [HttpPut(\"{logId}/track-click\")]\n        public async Task<IActionResult> TrackClick(Guid logId, [FromBody] ClickTrackDto dto)\n        {\n            var result = await _logService.TrackClickAsync(logId, dto.ClickType);\n            if (!result)\n                return NotFound(new { message = \"Log not found\" });\n\n            return Ok(new { success = true });\n        }\n\n        // âœ… FIXED: Retry a single log using correct interface method\n        [HttpPost(\"{logId}/retry\")]\n        public async Task<IActionResult> RetrySingle(Guid logId)\n        {\n            var result = await _retryService.RetrySingleAsync(logId);\n            if (!result)\n                return BadRequest(new { message = \"Retry failed\" });\n\n            return Ok(new { success = true });\n        }\n\n        // âœ… FIXED: Retry all failed logs using correct interface method\n        [HttpPost(\"campaign/{campaignId}/retry-all\")]\n        public async Task<IActionResult> RetryAll(Guid campaignId)\n        {\n            var result = await _retryService.RetryFailedInCampaignAsync(campaignId);\n            return Ok(new { success = true, retried = result });\n        }\n        // âœ… FIXED: Get summary of campaign logs as per Campaign ID\n        [HttpGet(\"campaign/{campaignId}/summary\")]\n        public async Task<IActionResult> GetCampaignSummary(Guid campaignId)\n        {\n            var summary = await _logService.GetCampaignSummaryAsync(campaignId);\n            return Ok(summary);\n        }\n\n    }\n\n    public class DeliveryStatusUpdateDto\n    {\n        public string Status { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n    }\n\n    public class ClickTrackDto\n    {\n        public string ClickType { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Controllers/CampaignTrackingController.cs",
      "sha256": "1e3e2b1e60144ec933cafdb53414ae6fad20463810533d32b90327dba457fde6",
      "language": "csharp",
      "size": 25258,
      "content": "// ðŸ“„ Features/CampaignTracking/Controllers/CampaignTrackingController.cs\nusing System.Text.Encodings.Web;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Features.CampaignTracking.Worker;\n\nnamespace xbytechat.api.Features.CampaignTracking.Controllers\n{\n    [ApiController]\n    [Route(\"r\")] // /r/{token}\n    public class CampaignTrackingController : ControllerBase\n    {\n        private static readonly HtmlEncoder HtmlEnc = HtmlEncoder.Default;\n\n        private readonly ILogger<CampaignTrackingController> _log;\n        private readonly IClickTokenService _token;\n        private readonly IClickEventQueue _queue;\n        private readonly AppDbContext _db;\n\n        public CampaignTrackingController(\n            ILogger<CampaignTrackingController> log,\n            IClickTokenService token,\n            IClickEventQueue queue,\n            AppDbContext db)\n        {\n            _log = log;\n            _token = token;\n            _queue = queue;\n            _db = db;\n        }\n\n        //[HttpGet(\"{token}\")]\n        //[AllowAnonymous]\n        //public async Task<IActionResult> RedirectByToken([FromRoute] string token, CancellationToken ct)\n        //{\n        //    // 1) Validate token\n        //    if (!_token.TryValidate(token, out var p, out var reason))\n        //    {\n        //        _log.LogWarning(\"Tracking token rejected. reason={Reason}\", reason);\n        //        return BadRequest(\"Invalid token.\");\n        //    }\n\n        //    // 2) Normalize + classify destination\n        //    if (!TryNormalizeAllowedDestination(p!.to, out var safeDest, out var scheme))\n        //    {\n        //        _log.LogWarning(\"Rejected destination for cid {Cid}: {Dest}\", p.cid, p.to);\n        //        return BadRequest(\"Invalid destination.\");\n        //    }\n\n        //    // 3) Capture client info\n        //    var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"0.0.0.0\";\n        //    var ua = Request.Headers.UserAgent.ToString();\n        //    var now = DateTime.UtcNow;\n\n        //    // 4) Determine click type (web | call | whatsapp)\n        //    var clickType = ClassifyClickType(safeDest, scheme);\n\n        //    // 4.1) Fetch related ids from the send log (for ContactId & CampaignId)\n        //    Guid? contactId = null;\n        //    Guid campaignId = Guid.Empty;\n        //    try\n        //    {\n        //        var sendLog = await _db.CampaignSendLogs\n        //            .AsNoTracking()\n        //            .Where(x => x.Id == p.cid)\n        //            .Select(x => new { x.ContactId, x.CampaignId })\n        //            .FirstOrDefaultAsync(ct);\n\n        //        if (sendLog is not null)\n        //        {\n        //            contactId = sendLog.ContactId;\n        //            campaignId = sendLog.CampaignId;\n        //        }\n        //        else\n        //        {\n        //            _log.LogWarning(\"SendLog not found for click cid={Cid}\", p.cid);\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Failed to fetch ContactId/CampaignId for cid={Cid}\", p.cid);\n        //    }\n\n        //    // 5) Write-through (guaranteed persistence)\n        //    try\n        //    {\n        //        await _db.CampaignClickLogs.AddAsync(new CampaignClickLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            CampaignSendLogId = p.cid,\n        //            CampaignId = campaignId,        // <-- populated if available (else Guid.Empty)\n        //            ContactId = contactId,          // <-- populated if available (nullable)\n        //            ButtonIndex = p.bi,\n        //            ButtonTitle = p.bt,\n        //            Destination = safeDest,\n        //            ClickedAt = now,\n        //            Ip = ip,\n        //            UserAgent = ua,\n        //            ClickType = clickType,\n        //            RunId = csl?.RunId\n        //        }, ct);\n\n        //        await _db.SaveChangesAsync(ct);\n\n        //        _log.LogInformation(\n        //            \"CLICK WRITE-THROUGH cid={Cid} idx={Idx} type={Type} dest={Dest}\",\n        //            p.cid, p.bi, clickType, safeDest);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Write-through insert failed. cid={Cid}\", p.cid);\n        //    }\n\n        //    // 6) Enqueue for async worker (best effort) â€” keeps existing ClickEvent signature\n        //    try\n        //    {\n        //        var enq = _queue.TryWrite(new ClickEvent(\n        //            CampaignSendLogId: p.cid,\n        //            ButtonIndex: p.bi,\n        //            ButtonTitle: p.bt,\n        //            Destination: safeDest,\n        //            ClickedAtUtc: now,\n        //            Ip: ip,\n        //            UserAgent: ua,\n        //            ClickType: clickType\n        //        ));\n        //        _log.LogInformation(\"CLICK ENQUEUE cid={Cid} idx={Idx} enqueued={Enqueued}\", p.cid, p.bi, enq);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Queue write threw. cid={Cid}\", p.cid);\n        //    }\n\n        //    // 7) First-click fast path\n        //    try\n        //    {\n        //        await _db.Database.ExecuteSqlRawAsync(\n        //            @\"update \"\"CampaignSendLogs\"\"\n        //                set \"\"IsClicked\"\"=TRUE, \"\"ClickedAt\"\"=NOW() at time zone 'utc'\n        //              where \"\"Id\"\"={0} and \"\"IsClicked\"\"=FALSE;\",\n        //            p.cid);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogDebug(ex, \"First-click update skipped.\");\n        //    }\n\n        //    // 8) Redirect handling\n        //    if (clickType is \"call\" or \"whatsapp\")\n        //    {\n        //        // Deep link â†’ return an HTML/JS shim to trigger immediately, with a safe fallback link.\n        //        var destHtml = HtmlEnc.Encode(safeDest);\n        //        var destJs = JsEscape(safeDest);\n\n        //        var html = $@\"<!doctype html>\n        //        <html lang=\"\"en\"\">\n        //        <head>\n        //          <meta charset=\"\"utf-8\"\">\n        //          <meta http-equiv=\"\"x-ua-compatible\"\" content=\"\"ie=edge\"\">\n        //          <meta name=\"\"viewport\"\" content=\"\"width=device-width, initial-scale=1\"\">\n        //          <meta http-equiv=\"\"refresh\"\" content=\"\"0;url={destHtml}\"\">\n        //          <title>Redirectingâ€¦</title>\n        //          <style>\n        //            body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:24px;}}\n        //            a{{color:#2563eb;text-decoration:underline;}}\n        //          </style>\n        //          <script>\n        //            // Trigger deep link immediately; reveal fallback if blocked by the browser.\n        //            window.addEventListener('load', function() {{\n        //              try {{ window.location.replace('{destJs}'); }} catch (e) {{}}\n        //              setTimeout(function() {{\n        //                var f = document.getElementById('fallback');\n        //                if (f) f.style.display = 'inline';\n        //              }}, 1200);\n        //            }});\n        //          </script>\n        //        </head>\n        //        <body>\n        //          <p>Redirectingâ€¦ If you are not redirected automatically, <a id=\"\"fallback\"\" style=\"\"display:none\"\" href=\"\"{destHtml}\"\">tap here</a>.</p>\n        //        </body>\n        //        </html>\";\n\n        //        Response.Headers[\"Cache-Control\"] = \"no-store, max-age=0\";\n        //        Response.Headers[\"Pragma\"] = \"no-cache\";\n        //        Response.Headers[\"X-Content-Type-Options\"] = \"nosniff\";\n        //        Response.Headers[\"Referrer-Policy\"] = \"no-referrer\";\n        //        Response.Headers[\"X-Frame-Options\"] = \"DENY\";\n        //        Response.Headers[\"Permissions-Policy\"] = \"geolocation=(), microphone=(), camera=()\";\n        //        Response.Headers[\"Content-Security-Policy\"] =\n        //            \"default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; base-uri 'none'; frame-ancestors 'none'\";\n\n        //        return new ContentResult\n        //        {\n        //            Content = html,\n        //            ContentType = \"text/html; charset=utf-8\",\n        //            StatusCode = 200\n        //        };\n        //    }\n\n        //    // Regular web links â†’ normal 302\n        //    return Redirect(safeDest);\n        //}\n\n        // --- helpers ---\n\n\n        //[HttpGet(\"{token}\")]\n        //[AllowAnonymous]\n\n\n        //[HttpGet(\"{token}\")]\n        //[AllowAnonymous]\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous]\n        public async Task<IActionResult> RedirectByToken([FromRoute] string token, CancellationToken ct)\n        {\n            // 1) Validate token\n            if (!_token.TryValidate(token, out var p, out var reason))\n            {\n                _log.LogWarning(\"Tracking token rejected. reason={Reason}\", reason);\n                return BadRequest(\"Invalid token.\");\n            }\n\n            // 2) Normalize + classify destination\n            if (!TryNormalizeAllowedDestination(p!.to, out var safeDest, out var scheme))\n            {\n                _log.LogWarning(\"Rejected destination for cid {Cid}: {Dest}\", p.cid, p.to);\n                return BadRequest(\"Invalid destination.\");\n            }\n\n            // 3) Capture client info\n            var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"0.0.0.0\";\n            var ua = Request.Headers.UserAgent.ToString();\n            var now = DateTime.UtcNow;\n\n            // 4) Determine click type (web | call | whatsapp)\n            var clickType = ClassifyClickType(safeDest, scheme);\n\n            // 4.1) Fetch related ids from the send log (ContactId, CampaignId, RunId)\n            Guid? contactId = null;\n            Guid? campaignId = null;   // <- make this nullable\n            Guid? runId = null;\n\n            try\n            {\n                var sendLog = await _db.CampaignSendLogs\n                    .AsNoTracking()\n                    .Where(x => x.Id == p.cid)\n                    .Select(x => new { x.ContactId, x.CampaignId, x.RunId })\n                    .FirstOrDefaultAsync(ct);\n\n                if (sendLog is not null)\n                {\n                    contactId = sendLog.ContactId;   // Guid?\n                    campaignId = sendLog.CampaignId;  // Guid?\n                    runId = sendLog.RunId;       // Guid?\n                }\n                else\n                {\n                    _log.LogWarning(\"SendLog not found for click cid={Cid}\", p.cid);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Failed to fetch ContactId/CampaignId/RunId for cid={Cid}\", p.cid);\n            }\n\n            // 5) Write-through (guaranteed persistence)\n            try\n            {\n                await _db.CampaignClickLogs.AddAsync(new CampaignClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    CampaignSendLogId = p.cid,\n                    // If the column is NON-nullable, coalesce to Guid.Empty; if you've made it nullable, assign campaignId directly.\n                    CampaignId = campaignId ?? Guid.Empty,\n                    ContactId = contactId,    // nullable OK\n                    ButtonIndex = p.bi,\n                    ButtonTitle = p.bt,\n                    Destination = safeDest,\n                    ClickedAt = now,\n                    Ip = ip,\n                    UserAgent = ua,\n                    ClickType = clickType,\n                    RunId = runId\n                }, ct);\n\n                await _db.SaveChangesAsync(ct);\n\n                _log.LogInformation(\"CLICK WRITE-THROUGH cid={Cid} idx={Idx} type={Type} dest={Dest}\",\n                    p.cid, p.bi, clickType, safeDest);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Write-through insert failed. cid={Cid}\", p.cid);\n            }\n\n            // 6) Enqueue for async worker (best effort)\n            try\n            {\n                var enq = _queue.TryWrite(new ClickEvent(\n                    CampaignSendLogId: p.cid,\n                    ButtonIndex: p.bi,\n                    ButtonTitle: p.bt,\n                    Destination: safeDest,\n                    ClickedAtUtc: now,\n                    Ip: ip,\n                    UserAgent: ua,\n                    ClickType: clickType\n                ));\n                _log.LogInformation(\"CLICK ENQUEUE cid={Cid} idx={Idx} enqueued={Enqueued}\", p.cid, p.bi, enq);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"Queue write threw. cid={Cid}\", p.cid);\n            }\n\n            // 7) First-click fast path\n            try\n            {\n                await _db.Database.ExecuteSqlRawAsync(\n                    @\"update \"\"CampaignSendLogs\"\"\n              set \"\"IsClicked\"\"=TRUE,\n                  \"\"ClickedAt\"\"=NOW() at time zone 'utc',\n                  \"\"ClickType\"\"={1}\n              where \"\"Id\"\"={0} and \"\"IsClicked\"\"=FALSE;\",\n                    p.cid, clickType);\n            }\n            catch (Exception ex)\n            {\n                _log.LogDebug(ex, \"First-click update skipped.\");\n            }\n\n            // 8) Redirect handling\n            if (clickType is \"call\" or \"whatsapp\")\n            {\n                // ... (unchanged deep-link HTML)\n            }\n\n            return Redirect(safeDest);\n        }\n\n        //public async Task<IActionResult> RedirectByToken([FromRoute] string token, CancellationToken ct)\n        //{\n        //    // 1) Validate token\n        //    if (!_token.TryValidate(token, out var p, out var reason))\n        //    {\n        //        _log.LogWarning(\"Tracking token rejected. reason={Reason}\", reason);\n        //        return BadRequest(\"Invalid token.\");\n        //    }\n\n        //    // 2) Normalize + classify destination\n        //    if (!TryNormalizeAllowedDestination(p!.to, out var safeDest, out var scheme))\n        //    {\n        //        _log.LogWarning(\"Rejected destination for cid {Cid}: {Dest}\", p.cid, p.to);\n        //        return BadRequest(\"Invalid destination.\");\n        //    }\n\n        //    // 3) Capture client info\n        //    var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"0.0.0.0\";\n        //    var ua = Request.Headers.UserAgent.ToString();\n        //    var now = DateTime.UtcNow;\n\n        //    // 4) Determine click type (web | call | whatsapp)\n        //    var clickType = ClassifyClickType(safeDest, scheme);\n\n        //    // 4.1) Fetch related ids from the send log (ContactId, CampaignId, **RunId**)\n        //    Guid? contactId = null;\n        //    Guid campaignId = Guid.Empty;\n        //    Guid? runId = null; // ðŸ‘ˆ NEW\n\n        //    try\n        //    {\n        //        var sendLog = await _db.CampaignSendLogs\n        //            .AsNoTracking()\n        //            .Where(x => x.Id == p.cid)\n        //            .Select(x => new { x.ContactId, x.CampaignId, x.RunId })\n        //            .FirstOrDefaultAsync(ct);\n\n        //        if (sendLog is not null)\n        //        {\n        //            contactId = sendLog.ContactId;\n        //            campaignId = sendLog.CampaignId;\n        //            runId = sendLog.RunId; // ðŸ‘ˆ carry through to click log\n        //        }\n        //        else\n        //        {\n        //            _log.LogWarning(\"SendLog not found for click cid={Cid}\", p.cid);\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Failed to fetch ContactId/CampaignId/RunId for cid={Cid}\", p.cid);\n        //    }\n\n        //    // 5) Write-through (guaranteed persistence)\n        //    try\n        //    {\n        //        await _db.CampaignClickLogs.AddAsync(new CampaignClickLog\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            CampaignSendLogId = p.cid,\n        //            CampaignId = campaignId,   // populated if available (else Guid.Empty)\n        //            ContactId = contactId,     // nullable\n        //            ButtonIndex = p.bi,\n        //            ButtonTitle = p.bt,\n        //            Destination = safeDest,\n        //            ClickedAt = now,\n        //            Ip = ip,\n        //            UserAgent = ua,\n        //            ClickType = clickType,\n        //            RunId = runId              // ðŸ‘ˆ bind click to the same run/session\n        //        }, ct);\n\n        //        await _db.SaveChangesAsync(ct);\n\n        //        _log.LogInformation(\n        //            \"CLICK WRITE-THROUGH cid={Cid} idx={Idx} type={Type} dest={Dest}\",\n        //            p.cid, p.bi, clickType, safeDest);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Write-through insert failed. cid={Cid}\", p.cid);\n        //    }\n\n        //    // 6) Enqueue for async worker (best effort) â€” keeps existing ClickEvent signature\n        //    try\n        //    {\n        //        var enq = _queue.TryWrite(new ClickEvent(\n        //            CampaignSendLogId: p.cid,\n        //            ButtonIndex: p.bi,\n        //            ButtonTitle: p.bt,\n        //            Destination: safeDest,\n        //            ClickedAtUtc: now,\n        //            Ip: ip,\n        //            UserAgent: ua,\n        //            ClickType: clickType\n        //        ));\n        //        _log.LogInformation(\"CLICK ENQUEUE cid={Cid} idx={Idx} enqueued={Enqueued}\", p.cid, p.bi, enq);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogError(ex, \"Queue write threw. cid={Cid}\", p.cid);\n        //    }\n\n        //    // 7) First-click fast path (also writes ClickType)\n        //    try\n        //    {\n        //        await _db.Database.ExecuteSqlRawAsync(\n        //            @\"update \"\"CampaignSendLogs\"\"\n        //        set \"\"IsClicked\"\"=TRUE,\n        //            \"\"ClickedAt\"\"=NOW() at time zone 'utc',\n        //            \"\"ClickType\"\"={1}\n        //      where \"\"Id\"\"={0} and \"\"IsClicked\"\"=FALSE;\",\n        //            p.cid, clickType);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _log.LogDebug(ex, \"First-click update skipped.\");\n        //    }\n\n        //    // 8) Redirect handling\n        //    if (clickType is \"call\" or \"whatsapp\")\n        //    {\n        //        // Deep link â†’ return an HTML/JS shim to trigger immediately, with a safe fallback link.\n        //        var destHtml = HtmlEnc.Encode(safeDest);\n        //        var destJs = JsEscape(safeDest);\n\n        //        var html = $@\"<!doctype html>\n        //                <html lang=\"\"en\"\">\n        //                <head>\n        //                  <meta charset=\"\"utf-8\"\">\n        //                  <meta http-equiv=\"\"x-ua-compatible\"\" content=\"\"ie=edge\"\">\n        //                  <meta name=\"\"viewport\"\" content=\"\"width=device-width, initial-scale=1\"\">\n        //                  <meta http-equiv=\"\"refresh\"\" content=\"\"0;url={destHtml}\"\">\n        //                  <title>Redirectingâ€¦</title>\n        //                  <style>\n        //                    body{{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:24px;}}\n        //                    a{{color:#2563eb;text-decoration:underline;}}\n        //                  </style>\n        //                  <script>\n        //                    // Trigger deep link immediately; reveal fallback if blocked by the browser.\n        //                    window.addEventListener('load', function() {{\n        //                      try {{ window.location.replace('{destJs}'); }} catch (e) {{}}\n        //                      setTimeout(function() {{\n        //                        var f = document.getElementById('fallback');\n        //                        if (f) f.style.display = 'inline';\n        //                      }}, 1200);\n        //                    }});\n        //                  </script>\n        //                </head>\n        //                <body>\n        //                  <p>Redirectingâ€¦ If you are not redirected automatically, <a id=\"\"fallback\"\" style=\"\"display:none\"\" href=\"\"{destHtml}\"\">tap here</a>.</p>\n        //                </body>\n        //                </html>\";\n\n        //        Response.Headers[\"Cache-Control\"] = \"no-store, max-age=0\";\n        //        Response.Headers[\"Pragma\"] = \"no-cache\";\n        //        Response.Headers[\"X-Content-Type-Options\"] = \"nosniff\";\n        //        Response.Headers[\"Referrer-Policy\"] = \"no-referrer\";\n        //        Response.Headers[\"X-Frame-Options\"] = \"DENY\";\n        //        Response.Headers[\"Permissions-Policy\"] = \"geolocation=(), microphone=(), camera=()\";\n        //        Response.Headers[\"Content-Security-Policy\"] =\n        //            \"default-src 'none'; script-src 'unsafe-inline'; style-src 'unsafe-inline'; base-uri 'none'; frame-ancestors 'none'\";\n\n        //        return new ContentResult\n        //        {\n        //            Content = html,\n        //            ContentType = \"text/html; charset=utf-8\",\n        //            StatusCode = 200\n        //        };\n        //    }\n\n        //    // Regular web links â†’ normal 302\n        //    return Redirect(safeDest);\n        //}\n\n\n        private static string ClassifyClickType(string normalizedDest, string scheme)\n        {\n            // scheme is pre-normalized by TryNormalizeAllowedDestination\n            if (string.Equals(scheme, \"tel\", StringComparison.OrdinalIgnoreCase)) return \"call\";\n            if (string.Equals(scheme, \"wa\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n            if (string.Equals(scheme, \"whatsapp\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n\n            // http/https â†’ still treat WhatsApp hosts as whatsapp\n            if (normalizedDest.StartsWith(\"https://wa.me/\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n            if (normalizedDest.StartsWith(\"https://api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase)) return \"whatsapp\";\n\n            return \"web\";\n        }\n\n        private static string JsEscape(string s) =>\n            s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"'\", \"\\\\'\").Replace(\"\\r\", \"\").Replace(\"\\n\", \"\");\n\n        /// <summary>\n        /// Accepts: http/https/tel/wa/whatsapp, plus shorthand wa.me/... and api.whatsapp.com/...\n        /// Returns normalized absolute string and a normalized scheme hint (\"http\",\"https\",\"tel\",\"wa\",\"whatsapp\").\n        /// </summary>\n        private static bool TryNormalizeAllowedDestination(string? input, out string normalized, out string scheme)\n        {\n            normalized = string.Empty;\n            scheme = string.Empty;\n            if (string.IsNullOrWhiteSpace(input)) return false;\n\n            var cleaned = new string(input.Trim().Where(c => !char.IsControl(c)).ToArray());\n\n            // Shorthand WhatsApp hosts without scheme â†’ prefix https://\n            if (!cleaned.Contains(\"://\", StringComparison.Ordinal))\n            {\n                if (cleaned.StartsWith(\"wa.me/\", StringComparison.OrdinalIgnoreCase) ||\n                    cleaned.StartsWith(\"api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var guess = \"https://\" + cleaned;\n                    if (Uri.TryCreate(guess, UriKind.Absolute, out var waAbs))\n                    {\n                        normalized = waAbs.AbsoluteUri;\n                        scheme = \"https\";\n                        return true;\n                    }\n                }\n            }\n\n            // WhatsApp custom schemes (wa:, whatsapp:)\n            if (cleaned.StartsWith(\"wa:\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalized = cleaned; scheme = \"wa\"; return true;\n            }\n            if (cleaned.StartsWith(\"whatsapp:\", StringComparison.OrdinalIgnoreCase))\n            {\n                normalized = cleaned; scheme = \"whatsapp\"; return true;\n            }\n\n            // Absolute URIs\n            if (Uri.TryCreate(cleaned, UriKind.Absolute, out var uri))\n            {\n                // tel:\n                if (uri.Scheme.Equals(\"tel\", StringComparison.OrdinalIgnoreCase))\n                {\n                    normalized = uri.ToString(); scheme = \"tel\"; return true;\n                }\n\n                // http/https (including WhatsApp hosts)\n                if (uri.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    normalized = uri.AbsoluteUri;\n                    scheme = uri.Scheme; // \"http\" or \"https\"\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignLogSummaryDto.cs",
      "sha256": "57aa29e375f6dda32b73602de1a84e9d5e89e3f8bf103914b21bfa14f0b786a9",
      "language": "csharp",
      "size": 415,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignLogSummaryDto\n    {\n        public int TotalSent { get; set; }\n        public int FailedCount { get; set; }\n        public int ClickedCount { get; set; }\n        public DateTime? LastSentAt { get; set; }\n\n        public int Delivered { get; set; }\n        public int Read { get; set; }\n        public int Sent { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignSendLogDto.cs",
      "sha256": "e4401d635c37b8b9990e5b0b8137ffe065550330c45ccf4638e336b803e6c5cf",
      "language": "csharp",
      "size": 1730,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignSendLogDto\n    {\n        public Guid Id { get; set; }\n\n        // ðŸ”— Relationships\n        public Guid CampaignId { get; set; }\n        public Guid? ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactPhone { get; set; }\n\n        public string? RecipientNumber { get; set; }\n        // ðŸ“¤ Message Info\n        public Guid RecipientId { get; set; }\n        public string MessageBody { get; set; }\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        // ðŸ•’ Timestamps\n        public DateTime CreatedAt { get; set; }\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // ðŸŒ Metadata\n        public string? SourceChannel { get; set; }\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n\n        // âœ… Enriched metadata\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // ðŸ“ˆ Click Tracking\n        public bool IsClicked { get; set; }\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // ðŸ” Retry Info\n        public string? RetryStatus { get; set; }     // Pending, Retried, Skipped\n        public int RetryCount { get; set; }\n        public DateTime? LastRetryAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/CampaignStatusDashboardDto.cs",
      "sha256": "21979b3b1de98ab2567e6485c9c0e4684b848735d36743226caaca66504e9b7b",
      "language": "csharp",
      "size": 1038,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class CampaignStatusDashboardDto\n    {\n        public Guid CampaignId { get; set; }\n\n        // ðŸ“Š Overall Stats\n        public int TotalRecipients { get; set; }\n        public int SentCount { get; set; }\n        public int DeliveredCount { get; set; }\n        public int ReadCount { get; set; }\n        public int FailedCount { get; set; }\n\n        // ðŸ•’ Delivery Timing (optional but insightful)\n        public DateTime? FirstSentAt { get; set; }\n        public DateTime? LastSentAt { get; set; }\n        public DateTime? FirstReadAt { get; set; }\n        public DateTime? LastReadAt { get; set; }\n\n        // ðŸ“‰ Delivery Rates\n        public double DeliveryRate => TotalRecipients == 0 ? 0 : (double)DeliveredCount / TotalRecipients * 100;\n        public double ReadRate => TotalRecipients == 0 ? 0 : (double)ReadCount / TotalRecipients * 100;\n        public double FailureRate => TotalRecipients == 0 ? 0 : (double)FailedCount / TotalRecipients * 100;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/DTOs/TopCampaignDto.cs",
      "sha256": "deebf224725de4a79f8363405623b0761fed9b776ec86cc8d6a9b05c5f79940e",
      "language": "csharp",
      "size": 295,
      "content": "namespace xbytechat.api.Features.CampaignTracking.DTOs\n{\n    public class TopCampaignDto\n    {\n        public Guid CampaignId { get; set; }\n        public string CampaignName { get; set; }\n        public double ReadRate { get; set; }\n        public double ClickThroughRate { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/EntityTypeConfigs/CampaignSendLogConfig.cs",
      "sha256": "cf880a46e9114af3187c8c4cd1f11e526a5b0c83fc9894ebc8dc39075e937247",
      "language": "csharp",
      "size": 1967,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore.Metadata.Builders;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.EntityTypeConfigs\n{\n    public class CampaignSendLogConfig : IEntityTypeConfiguration<CampaignSendLog>\n    {\n        public void Configure(EntityTypeBuilder<CampaignSendLog> e)\n        {\n            e.ToTable(\"CampaignSendLogs\"); // your table name\n            e.HasKey(x => x.Id);\n\n            // common lengths to keep COPY happy (adjust if you already have constraints)\n            e.Property(x => x.MessageId).HasMaxLength(128);\n            e.Property(x => x.TemplateId).HasMaxLength(128);\n            e.Property(x => x.SendStatus).HasMaxLength(32);\n            e.Property(x => x.ErrorMessage).HasMaxLength(1024);\n            e.Property(x => x.CreatedBy).HasMaxLength(128);\n            e.Property(x => x.IpAddress).HasMaxLength(64);\n            e.Property(x => x.DeviceInfo).HasMaxLength(256);\n            e.Property(x => x.MacAddress).HasMaxLength(64);\n            e.Property(x => x.SourceChannel).HasMaxLength(64);\n            e.Property(x => x.DeviceType).HasMaxLength(64);\n            e.Property(x => x.Browser).HasMaxLength(64);\n            e.Property(x => x.Country).HasMaxLength(64);\n            e.Property(x => x.City).HasMaxLength(64);\n            e.Property(x => x.ClickType).HasMaxLength(64);\n            e.Property(x => x.LastRetryStatus).HasMaxLength(32);\n\n            // CreatedAt default (UTC) if not set by code\n            e.Property(x => x.CreatedAt).HasDefaultValueSql(\"timezone('utc', now())\");\n\n            // helpful indexes\n            e.HasIndex(x => new { x.BusinessId, x.CampaignId, x.CreatedAt });\n            e.HasIndex(x => new { x.CampaignId, x.SendStatus, x.CreatedAt });\n            e.HasIndex(x => new { x.RecipientId, x.CreatedAt });\n            e.HasIndex(x => x.MessageId);\n            e.HasIndex(x => x.RunId);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogFlushWorker.cs",
      "sha256": "b00af09909773fe5a42fec957467b0749da9ef01e66ee094928dde050277ac59",
      "language": "csharp",
      "size": 1106,
      "content": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public class CampaignLogFlushWorker : BackgroundService\n    {\n        private readonly ICampaignLogSink _sink;\n        private readonly ILogger<CampaignLogFlushWorker> _log;\n        private readonly IOptionsMonitor<BatchingOptions> _opts;\n\n        public CampaignLogFlushWorker(ICampaignLogSink sink, ILogger<CampaignLogFlushWorker> log, IOptionsMonitor<BatchingOptions> opts)\n        {\n            _sink = sink; _log = log; _opts = opts;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try { await _sink.FlushAsync(stoppingToken); }\n                catch (Exception ex) { _log.LogError(ex, \"[CampaignLogFlushWorker] flush error\"); }\n                await Task.Delay(TimeSpan.FromMilliseconds(_opts.CurrentValue.CampaignLog.FlushEveryMs), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogRecord.cs",
      "sha256": "777772c74a122cabcaf3c59ae1aac8fd43c7b97b6d562d5c239921ed24c47be5",
      "language": "csharp",
      "size": 1067,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public record CampaignLogRecord(\n        Guid Id,\n        Guid? RunId,\n        string? MessageId,\n        Guid CampaignId,\n        Guid? ContactId,\n        Guid RecipientId,\n        string MessageBody,\n        string? TemplateId,\n        string? SendStatus,\n        string? ErrorMessage,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? SentAt,\n        DateTime? DeliveredAt,\n        DateTime? ReadAt,\n        string? IpAddress,\n        string? DeviceInfo,\n        string? MacAddress,\n        string? SourceChannel,\n        string? DeviceType,\n        string? Browser,\n        string? Country,\n        string? City,\n        bool IsClicked,\n        DateTime? ClickedAt,\n        string? ClickType,\n        int RetryCount,\n        DateTime? LastRetryAt,\n        string? LastRetryStatus,\n        bool AllowRetry,\n        Guid? MessageLogId,\n        Guid BusinessId,\n        Guid? CTAFlowConfigId,\n        Guid? CTAFlowStepId,\n        string? ButtonBundleJson\n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/CampaignLogSink.cs",
      "sha256": "1cb036d202b67bf8fdaa1e5f217c0c8c728b1ec98ec090f4bfbcfd40e46f3bc7",
      "language": "csharp",
      "size": 12526,
      "content": "using System.Collections.Concurrent;\nusing Microsoft.EntityFrameworkCore;\nusing System.Linq;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Npgsql;\nusing NpgsqlTypes;\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\nusing xbytechat.api.AuthModule.Models;               // AppDbContext\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public class CampaignLogSink : ICampaignLogSink\n    {\n        private readonly ConcurrentQueue<CampaignLogRecord> _queue = new();\n        private readonly ConcurrentDictionary<Guid, int> _attempts = new();\n        private readonly ILogger<CampaignLogSink> _log;\n        private readonly IServiceProvider _sp;\n        private readonly IOptionsMonitor<BatchingOptions> _opts;\n\n        private const int MaxAttempts = 3;\n\n        public CampaignLogSink(ILogger<CampaignLogSink> log, IServiceProvider sp, IOptionsMonitor<BatchingOptions> opts)\n        {\n            _log = log; _sp = sp; _opts = opts;\n        }\n\n        public void Enqueue(CampaignLogRecord rec) => _queue.Enqueue(rec);\n        public int PendingCount => _queue.Count;\n\n        public async Task FlushAsync(CancellationToken ct = default)\n        {\n            var max = _opts.CurrentValue.CampaignLog.MaxBatchSize;\n            var list = new List<CampaignLogRecord>(Math.Min(_queue.Count, max));\n            while (list.Count < max && _queue.TryDequeue(out var r)) list.Add(r);\n            if (list.Count == 0) return;\n\n            try\n            {\n                // Ensure all referenced MessageLogs exist before inserting send logs\n                var messageLogIds = list\n                    .Select(x => x.MessageLogId)\n                    .Where(id => id.HasValue && id.Value != Guid.Empty)\n                    .Select(id => id!.Value)\n                    .Distinct()\n                    .ToList();\n\n                _log.LogInformation(\n                    \"[CampaignLogSink] Batch size = {BatchCount}, messageLogIds = {IdCount}\",\n                    list.Count, messageLogIds.Count);\n\n                if (messageLogIds.Count > 0)\n                {\n                    using var scope = _sp.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                    var existingIds = await db.MessageLogs\n                        .AsNoTracking()\n                        .Where(m => messageLogIds.Contains(m.Id))\n                        .Select(m => m.Id)\n                        .ToListAsync(ct);\n\n                    var missing = messageLogIds.Except(existingIds).ToList();\n                    if (missing.Count > 0)\n                    {\n                        // Use first record Id as batch key\n                        var batchKey = list[0].Id;\n                        var attempt = _attempts.AddOrUpdate(batchKey, 1, (_, prev) => prev + 1);\n\n                        if (attempt <= MaxAttempts)\n                        {\n                            _log.LogWarning(\n                                \"[CampaignLogSink] Deferring batch (attempt {Attempt}/{Max}) â€“ messageLogIds={Ids} missingCount={MissingCount}\",\n                                attempt, MaxAttempts, string.Join(\",\", messageLogIds), missing.Count);\n                            foreach (var item in list) _queue.Enqueue(item);\n                            return;\n                        }\n\n                        _log.LogError(\n                            \"[CampaignLogSink] Dropping batch after {MaxAttempts} attempts â€“ still missing messageLogIds={Ids}\",\n                            MaxAttempts, string.Join(\",\", messageLogIds));\n                        _attempts.TryRemove(batchKey, out _);\n                        return; // drop to avoid FK violations / infinite loop\n                    }\n\n                    // All required MessageLogs exist; clear attempts for this batch key\n                    _attempts.TryRemove(list[0].Id, out _);\n                }\n\n                if (_opts.CurrentValue.CampaignLog.UseCopy)\n                    await CopyInsertAsync(list, ct);\n                else\n                    await EfInsertAsync(list, ct);\n            }\n            catch (Exception ex)\n            {\n                _log.LogError(ex, \"[CampaignLogSink] COPY failed; falling back to EF\");\n                try { await EfInsertAsync(list, ct); }\n                catch (Exception ex2)\n                {\n                    _log.LogError(ex2, \"[CampaignLogSink] EF fallback failed; requeueing {Count}\", list.Count);\n                    foreach (var rr in list) _queue.Enqueue(rr);\n                }\n            }\n        }\n\n        private static void WriteNullable<T>(NpgsqlBinaryImporter w, T? value, NpgsqlDbType type) where T : struct\n        {\n            if (value.HasValue) w.Write(value.Value, type);\n            else w.WriteNull();\n        }\n\n        private static void WriteNullableText(NpgsqlBinaryImporter w, string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) w.WriteNull();\n            else w.Write(value, NpgsqlDbType.Text);\n        }\n\n        private static void WriteNullableVarchar(NpgsqlBinaryImporter w, string? value)\n        {\n            if (string.IsNullOrWhiteSpace(value)) w.WriteNull();\n            else w.Write(value, NpgsqlDbType.Varchar);\n        }\n\n        private static void WriteNullableUuid(NpgsqlBinaryImporter w, Guid? value)\n        {\n            if (value.HasValue && value.Value != Guid.Empty) w.Write(value.Value, NpgsqlDbType.Uuid);\n            else w.WriteNull();\n        }\n\n        private async Task CopyInsertAsync(List<CampaignLogRecord> batch, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var connString = db.Database.GetDbConnection().ConnectionString;\n\n            await using var conn = new NpgsqlConnection(connString);\n            await conn.OpenAsync(ct);\n\n            const string sql = @\"\nCOPY \"\"CampaignSendLogs\"\" (\n    \"\"Id\"\",\n    \"\"RunId\"\",\n    \"\"MessageId\"\",\n    \"\"CampaignId\"\",\n    \"\"ContactId\"\",\n    \"\"RecipientId\"\",\n    \"\"MessageBody\"\",\n    \"\"TemplateId\"\",\n    \"\"SendStatus\"\",\n    \"\"ErrorMessage\"\",\n    \"\"CreatedAt\"\",\n    \"\"CreatedBy\"\",\n    \"\"SentAt\"\",\n    \"\"DeliveredAt\"\",\n    \"\"ReadAt\"\",\n    \"\"IpAddress\"\",\n    \"\"DeviceInfo\"\",\n    \"\"MacAddress\"\",\n    \"\"SourceChannel\"\",\n    \"\"DeviceType\"\",\n    \"\"Browser\"\",\n    \"\"Country\"\",\n    \"\"City\"\",\n    \"\"IsClicked\"\",\n    \"\"ClickedAt\"\",\n    \"\"ClickType\"\",\n    \"\"RetryCount\"\",\n    \"\"LastRetryAt\"\",\n    \"\"LastRetryStatus\"\",\n    \"\"AllowRetry\"\",\n    \"\"MessageLogId\"\",\n    \"\"BusinessId\"\",\n    \"\"CTAFlowConfigId\"\",\n    \"\"CTAFlowStepId\"\",\n    \"\"ButtonBundleJson\"\"\n) FROM STDIN (FORMAT BINARY);\";\n\n            try\n            {\n                await using var writer = await conn.BeginBinaryImportAsync(sql, ct);\n\n                foreach (var r in batch)\n                {\n                    await writer.StartRowAsync(ct);\n\n                    // Required IDs\n                    writer.Write(r.Id, NpgsqlDbType.Uuid);\n                    writer.Write(r.RunId, NpgsqlDbType.Uuid);\n\n                    // Strings / nullable fields\n                    WriteNullableVarchar(writer, r.MessageId);\n                    writer.Write(r.CampaignId, NpgsqlDbType.Uuid);\n                    WriteNullableUuid(writer, r.ContactId);\n                    WriteNullableUuid(writer, r.RecipientId);\n\n                    WriteNullableText(writer, r.MessageBody);\n                    WriteNullableVarchar(writer, r.TemplateId);\n                    WriteNullableVarchar(writer, r.SendStatus);\n                    WriteNullableVarchar(writer, r.ErrorMessage);\n\n                    // Timestamps\n                    writer.Write(r.CreatedAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.CreatedBy);\n                    WriteNullable(writer, r.SentAt, NpgsqlDbType.TimestampTz);\n                    WriteNullable(writer, r.DeliveredAt, NpgsqlDbType.TimestampTz);\n                    WriteNullable(writer, r.ReadAt, NpgsqlDbType.TimestampTz);\n\n                    // Device / network\n                    WriteNullableVarchar(writer, r.IpAddress);\n                    WriteNullableVarchar(writer, r.DeviceInfo);\n                    WriteNullableVarchar(writer, r.MacAddress);\n                    WriteNullableVarchar(writer, r.SourceChannel);\n                    WriteNullableVarchar(writer, r.DeviceType);\n                    WriteNullableVarchar(writer, r.Browser);\n                    WriteNullableVarchar(writer, r.Country);\n                    WriteNullableVarchar(writer, r.City);\n\n                    // Click info\n                    writer.Write(r.IsClicked, NpgsqlDbType.Boolean);\n                    WriteNullable(writer, r.ClickedAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.ClickType);\n\n                    // Retry info â€” RetryCount is non-nullable int in your model\n                    writer.Write(r.RetryCount, NpgsqlDbType.Integer);\n                    WriteNullable(writer, r.LastRetryAt, NpgsqlDbType.TimestampTz);\n                    WriteNullableVarchar(writer, r.LastRetryStatus);\n                    writer.Write(r.AllowRetry, NpgsqlDbType.Boolean);\n\n                    // FK to MessageLogs may be null initially\n                    WriteNullableUuid(writer, r.MessageLogId);\n\n                    // Remaining Ids\n                    writer.Write(r.BusinessId, NpgsqlDbType.Uuid);\n                    WriteNullableUuid(writer, r.CTAFlowConfigId);\n                    WriteNullableUuid(writer, r.CTAFlowStepId);\n\n                    // Bundle (text/json)\n                    WriteNullableText(writer, r.ButtonBundleJson);\n                }\n\n                await writer.CompleteAsync(ct);\n                _log.LogDebug(\"[CampaignLogSink] COPY inserted {Count} rows\", batch.Count);\n            }\n            catch\n            {\n                throw; // let FlushAsync() handle fallback/requeue\n            }\n        }\n\n        private async Task EfInsertAsync(List<CampaignLogRecord> batch, CancellationToken ct)\n        {\n            using var scope = _sp.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n            var entities = batch.Select(r => new CampaignSendLog\n            {\n                Id = r.Id,\n                RunId = r.RunId,\n                MessageId = r.MessageId,\n                CampaignId = r.CampaignId,\n                ContactId = r.ContactId,\n                RecipientId = r.RecipientId,\n                MessageBody = r.MessageBody,\n                TemplateId = r.TemplateId,\n                SendStatus = r.SendStatus,\n                ErrorMessage = r.ErrorMessage,\n                CreatedAt = r.CreatedAt,\n                CreatedBy = r.CreatedBy,\n                SentAt = r.SentAt,\n                DeliveredAt = r.DeliveredAt,\n                ReadAt = r.ReadAt,\n                IpAddress = r.IpAddress,\n                DeviceInfo = r.DeviceInfo,\n                MacAddress = r.MacAddress,\n                SourceChannel = r.SourceChannel,\n                DeviceType = r.DeviceType,\n                Browser = r.Browser,\n                Country = r.Country,\n                City = r.City,\n                IsClicked = r.IsClicked,\n                ClickedAt = r.ClickedAt,\n                ClickType = r.ClickType,\n                RetryCount = r.RetryCount,\n                LastRetryAt = r.LastRetryAt,\n                LastRetryStatus = r.LastRetryStatus,\n                AllowRetry = r.AllowRetry,\n                MessageLogId = r.MessageLogId,\n                BusinessId = r.BusinessId,\n                CTAFlowConfigId = r.CTAFlowConfigId,\n                CTAFlowStepId = r.CTAFlowStepId,\n                ButtonBundleJson = r.ButtonBundleJson\n            }).ToList();\n\n            var prev = db.ChangeTracker.AutoDetectChangesEnabled;\n            db.ChangeTracker.AutoDetectChangesEnabled = false;\n            await db.CampaignSendLogs.AddRangeAsync(entities, ct);\n            await db.SaveChangesAsync(ct);\n            db.ChangeTracker.AutoDetectChangesEnabled = prev;\n        }\n    }\n\n    public class BatchingOptions\n    {\n        public CampaignLogOptions CampaignLog { get; set; } = new();\n        public class CampaignLogOptions\n        {\n            public int FlushEveryMs { get; set; } = 500;\n            public int MaxBatchSize { get; set; } = 500;\n            public bool UseCopy { get; set; } = true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Logging/ICampaignLogSink.cs",
      "sha256": "2bb93f46e441543c54cae578d67d0768ae0a459d621727f54c8eb390ec2cdf38",
      "language": "csharp",
      "size": 303,
      "content": "using System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Logging\n{\n    public interface ICampaignLogSink\n    {\n        void Enqueue(CampaignLogRecord rec);\n        int PendingCount { get; }\n        Task FlushAsync(CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignClickDailyAgg.cs",
      "sha256": "f73f8e07824860d62b98ba1112933870fd6c223a3a75ca759bccf5899d9e9ffd",
      "language": "csharp",
      "size": 571,
      "content": "// ðŸ“„ Features/CampaignTracking/Models/CampaignClickDailyAgg.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    [Table(\"CampaignClickDailyAgg\")]\n    public class CampaignClickDailyAgg\n    {\n        [Key] public Guid Id { get; set; }\n        public Guid CampaignId { get; set; }\n        public DateTime Day { get; set; } // date-only (store as date in migration)\n        public int ButtonIndex { get; set; }\n        public long Clicks { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignClickLog.cs",
      "sha256": "c955c29fed1ef4d960a247c80426a21493ab53a3b657a4a21083d2f617d309cb",
      "language": "csharp",
      "size": 1205,
      "content": "// ðŸ“„ Features/CampaignTracking/Models/CampaignClickLog.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    [Table(\"CampaignClickLogs\")]\n    public class CampaignClickLog\n    {\n        [Key] public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        // FK through CampaignSendLog to CampaignId & ContactId\n        public Guid CampaignSendLogId { get; set; }\n\n        public Guid CampaignId { get; set; }      // denormalized for fast filtering\n        public Guid? ContactId { get; set; }      // denormalized if available\n\n        public int ButtonIndex { get; set; }\n\n        [MaxLength(120)]\n        public string ButtonTitle { get; set; } = \"\";\n\n        // NEW: \"web\" | \"call\" | \"whatsapp\" (lowercase)\n        [MaxLength(16)]\n        public string ClickType { get; set; } = \"web\";\n\n        [MaxLength(2048)]\n        public string Destination { get; set; } = \"\";\n\n        [MaxLength(64)]\n        public string Ip { get; set; } = \"\";\n\n        [MaxLength(512)]\n        public string UserAgent { get; set; } = \"\";\n\n        public DateTime ClickedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Models/CampaignSendLog.cs",
      "sha256": "a2e627b90aaaa87979a7551588cc2fd8150978b69ff34e6abeddd2d3ab58e1cd",
      "language": "csharp",
      "size": 2937,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Models\n{\n    public class CampaignSendLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        public string? MessageId { get; set; } // Unique WAMID from WhatsApp\n        // ðŸ”— Foreign Keys\n    \n        public Guid CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n \n        public Guid? ContactId { get; set; }\n\n        [Required]\n        public Guid RecipientId { get; set; }\n\n        // ðŸ“© Message Info\n        [Required]\n        public string MessageBody { get; set; } = \"\";\n\n        public string? TemplateId { get; set; }\n        public string? SendStatus { get; set; }\n        public string? ErrorMessage { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n\n        public DateTime? SentAt { get; set; }\n        public DateTime? DeliveredAt { get; set; }\n        public DateTime? ReadAt { get; set; }\n\n        // ðŸŒ Metadata\n        public string? IpAddress { get; set; }\n        public string? DeviceInfo { get; set; }\n        public string? MacAddress { get; set; }\n        public string? SourceChannel { get; set; }\n\n        // âœ… UX-Derived\n        public string? DeviceType { get; set; }\n        public string? Browser { get; set; }\n        public string? Country { get; set; }\n        public string? City { get; set; }\n\n        // ðŸ“Š Click Tracking\n        public bool IsClicked { get; set; } = false;\n        public DateTime? ClickedAt { get; set; }\n        public string? ClickType { get; set; }\n\n        // ðŸ” Retry Tracking (ðŸ’¡ New)\n        public int RetryCount { get; set; } = 0;                 // Number of retry attempts\n        public DateTime? LastRetryAt { get; set; }               // When retry last happened\n        public string? LastRetryStatus { get; set; }             // Success / Failed\n        public bool AllowRetry { get; set; } = true;             // Flag to enable/disable retry\n\n        // ðŸ‘ Navigation\n      \n        public Contact? Contact { get; set; }\n        public CampaignRecipient? Recipient { get; set; }\n\n\n        // ðŸ”— MessageLog reference (optional)\n        public Guid? MessageLogId { get; set; }\n        public MessageLog? MessageLog { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        // ðŸ†• Flow context snapshot for deterministic click resolution\n        public Guid? CTAFlowConfigId { get; set; }   // which flow this send belongs to (optional)\n        public Guid? CTAFlowStepId { get; set; }     // the entry step id (optional)\n\n        [Column(TypeName = \"text\")]\n        public string? ButtonBundleJson { get; set; }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignAnalyticsService.cs",
      "sha256": "ee9163439146987bfeebca642b380b914f7a0d5dae6fc4b2468b798b06840b3e",
      "language": "csharp",
      "size": 5226,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n\n\n    public class CampaignAnalyticsService : ICampaignAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n            //_context = context;\n        }\n\n        public async Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId)\n        {\n            var logs = await _context.CampaignSendLogs\n                .Where(l => l.CampaignId == campaignId)\n                .ToListAsync();\n\n            if (!logs.Any()) return null;\n\n            return new CampaignStatusDashboardDto\n            {\n                CampaignId = campaignId,\n                TotalRecipients = logs.Count,\n                SentCount = logs.Count(l => l.SendStatus == \"Sent\"),\n                DeliveredCount = logs.Count(l => l.SendStatus == \"Delivered\"),\n                ReadCount = logs.Count(l => l.SendStatus == \"Read\"),\n                FailedCount = logs.Count(l => l.SendStatus == \"Failed\"),\n                FirstSentAt = logs.Min(l => l.SentAt),\n                LastSentAt = logs.Max(l => l.SentAt),\n                FirstReadAt = logs.Min(l => l.ReadAt),\n                LastReadAt = logs.Max(l => l.ReadAt)\n            };\n        }\n\n        //public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        //{\n        //    var campaignStats = await _context.CampaignSendLogs\n        //        .Where(log => log.BusinessId == businessId)\n        //        .GroupBy(log => log.CampaignId)\n        //        .Select(group => new\n        //        {\n        //            CampaignId = group.Key,\n        //            TotalSent = group.Count(),\n        //            TotalRead = group.Count(l => l.ReadAt != null),\n        //            TotalClicked = group.Count(l => l.ClickedAt != null)\n        //        })\n        //        .Where(s => s.TotalSent > 0)\n        //        .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent)\n        //        .Take(count)\n        //        .ToListAsync();\n\n        //    if (!campaignStats.Any())\n        //    {\n        //        return new List<TopCampaignDto>();\n        //    }\n\n        //    var campaignIds = campaignStats.Select(s => s.CampaignId).ToList();\n        //    var campaigns = await _context.Campaigns\n        //        .Where(c => campaignIds.Contains(c.Id))\n        //        .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n        //    return campaignStats.Select(s => new TopCampaignDto\n        //    {\n        //        CampaignId = s.CampaignId,\n        //        CampaignName = campaigns.GetValueOrDefault(s.CampaignId, \"Unnamed Campaign\"),\n        //        ReadRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalRead / s.TotalSent) * 100, 2) : 0,\n        //        ClickThroughRate = s.TotalSent > 0 ? Math.Round(((double)s.TotalClicked / s.TotalSent) * 100, 2) : 0\n        //    });\n        //}\n\n\n\n        public async Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5)\n        {\n            if (count <= 0) count = 5;\n\n            // If you suspect legacy rows with Guid.Empty, keep the extra filter; otherwise you can drop it.\n            var campaignStats = await _context.CampaignSendLogs\n                .AsNoTracking()\n                .Where(log => log.BusinessId == businessId /* && log.CampaignId != Guid.Empty */)\n                .GroupBy(log => log.CampaignId) // CampaignId is non-nullable Guid\n                .Select(group => new\n                {\n                    CampaignId = group.Key,\n                    TotalSent = group.Count(),\n                    TotalRead = group.Count(l => l.ReadAt != null),\n                    TotalClicked = group.Count(l => l.ClickedAt != null)\n                })\n                .Where(s => s.TotalSent > 0)\n                .OrderByDescending(s => (double)s.TotalClicked / s.TotalSent) // CTR first\n                .ThenByDescending(s => s.TotalSent)                           // tie-breaker: volume\n                .Take(count)\n                .ToListAsync();\n\n            if (campaignStats.Count == 0)\n                return Array.Empty<TopCampaignDto>();\n\n            var ids = campaignStats.Select(s => s.CampaignId).ToList();\n\n            var names = await _context.Campaigns\n                .AsNoTracking()\n                .Where(c => ids.Contains(c.Id))\n                .ToDictionaryAsync(c => c.Id, c => c.Name);\n\n            var result = campaignStats.Select(s => new TopCampaignDto\n            {\n                CampaignId = s.CampaignId,\n                CampaignName = names.TryGetValue(s.CampaignId, out var n) && !string.IsNullOrWhiteSpace(n)\n                                        ? n\n                                        : \"Unnamed Campaign\",\n                ReadRate = Math.Round((double)s.TotalRead / s.TotalSent * 100, 2),\n                ClickThroughRate = Math.Round((double)s.TotalClicked / s.TotalSent * 100, 2)\n            });\n\n            return result;\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogEnricher.cs",
      "sha256": "6d1155127869663e221b9c1a80e5dce49dd32c3d57d218d8157691ed3bc8edeb",
      "language": "csharp",
      "size": 872,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing System;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogEnricher : ICampaignSendLogEnricher\n    {\n        public async Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress)\n        {\n            // ðŸ§  Device Detection (simplified for now)\n            log.DeviceInfo = userAgent;\n\n            // ðŸŒ IP Lookup - Mocked for now\n            if (!string.IsNullOrWhiteSpace(ipAddress))\n            {\n                log.IpAddress = ipAddress;\n                log.SourceChannel = \"API\"; // Example: mark origin\n                // Future: Use IPinfo or GeoLite2 for full location enrichment\n            }\n\n            // âŒ› Simulate async task for compatibility\n            await Task.CompletedTask;\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignSendLogService.cs",
      "sha256": "719776d788525701507db765a8a42a52f25b080ac4faa6be437690ce774e6345",
      "language": "csharp",
      "size": 13351,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CampaignTracking.Services;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignSendLogService : ICampaignSendLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ICampaignSendLogEnricher _enricher;\n\n\n        public CampaignSendLogService(AppDbContext context, ICampaignSendLogEnricher enricher)\n        {\n            _context = context;\n            _enricher = enricher;\n        }\n\n        //public async Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n        //Guid campaignId, string? status, string? search, int page, int pageSize)\n        //{\n        //    // Base query as IQueryable (not IIncludableQueryable)\n        //    IQueryable<CampaignSendLog> query = _context.CampaignSendLogs\n        //        .AsNoTracking()\n        //        .Where(log => log.CampaignId.HasValue && log.CampaignId.Value == campaignId);\n\n        //    if (!string.IsNullOrEmpty(status))\n        //        query = query.Where(log => log.SendStatus == status);\n\n        //    if (!string.IsNullOrEmpty(search))\n        //    {\n        //        var keyword = search.ToLower();\n\n        //        // Safe null checks + server-side case-insensitive matching\n        //        // If you're on PostgreSQL, EF.Functions.ILike is nicer; otherwise use ToLower().\n        //        query = query.Where(log =>\n        //            log.Contact != null &&\n        //           (log.Contact.Name.ToLower().Contains(keyword)\n        //         || log.Contact.PhoneNumber.Contains(keyword)));\n        //    }\n\n        //    // Add Include after filters to keep it IQueryable\n        //    query = query.Include(log => log.Contact);\n\n        //    var totalCount = await query.CountAsync();\n\n        //    var logs = await query\n        //        .OrderByDescending(log => log.CreatedAt)\n        //        .Skip((page - 1) * pageSize)\n        //        .Take(pageSize)\n        //        .Select(log => new CampaignSendLogDto\n        //        {\n        //            Id = log.Id,\n        //            CampaignId = log.CampaignId!.Value,       // unwrap once for DTO Guid\n        //            ContactId = log.ContactId,               // keep Guid? in DTO if CSV-only is allowed\n        //            ContactName = log.Contact != null ? log.Contact.Name : \"N/A\",\n        //            ContactPhone = log.Contact != null ? log.Contact.PhoneNumber : \"-\",\n        //            MessageBody = log.MessageBody,\n        //            TemplateId = log.TemplateId,\n        //            SendStatus = log.SendStatus,\n        //            ErrorMessage = log.ErrorMessage,\n        //            CreatedAt = log.CreatedAt,\n        //            SentAt = log.SentAt,\n        //            DeliveredAt = log.DeliveredAt,\n        //            ReadAt = log.ReadAt,\n        //            SourceChannel = log.SourceChannel,\n        //            IsClicked = log.IsClicked,\n        //            ClickedAt = log.ClickedAt,\n        //            ClickType = log.ClickType\n        //        })\n        //        .ToListAsync();\n\n        //    return new PagedResult<CampaignSendLogDto>\n        //    {\n        //        Items = logs,\n        //        TotalCount = totalCount,\n        //        Page = page,\n        //        PageSize = pageSize\n        //    };\n        //}\n\n\n        //public async Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId)\n        //{\n        //    return await _context.CampaignSendLogs\n        //        .Where(log => log.CampaignId == campaignId && log.ContactId == contactId)\n        //        .Select(log => new CampaignSendLogDto\n        //        {\n        //            Id = log.Id,\n        //            CampaignId = log.CampaignId,\n        //            ContactId = log.ContactId,\n        //            MessageBody = log.MessageBody,\n        //            TemplateId = log.TemplateId,\n        //            SendStatus = log.SendStatus,\n        //            ErrorMessage = log.ErrorMessage,\n        //            CreatedAt = log.CreatedAt,\n        //            SentAt = log.SentAt,\n        //            DeliveredAt = log.DeliveredAt,\n        //            ReadAt = log.ReadAt,\n        //            IpAddress = log.IpAddress,\n        //            DeviceInfo = log.DeviceInfo,\n        //            MacAddress = log.MacAddress,\n        //            SourceChannel = log.SourceChannel,\n        //            IsClicked = log.IsClicked,\n        //            ClickedAt = log.ClickedAt,\n        //            ClickType = log.ClickType\n        //        })\n        //        .ToListAsync();\n        //}\n\n        // ðŸ†• Create a new send log (with enrichment)\n\n        public async Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n       Guid campaignId, string? status, string? search, int page, int pageSize)\n        {\n            if (page <= 0) page = 1;\n            if (pageSize <= 0) pageSize = 10;\n\n            // Base (scoped to the campaign)\n            var q =\n                from log in _context.CampaignSendLogs.AsNoTracking()\n                where log.CampaignId == campaignId\n                join ml in _context.MessageLogs.AsNoTracking()\n                     on log.MessageLogId equals ml.Id into g\n                from ml in g.DefaultIfEmpty() // LEFT JOIN\n                select new { log, ml };\n\n            if (!string.IsNullOrWhiteSpace(status))\n                q = q.Where(x => x.log.SendStatus == status);\n\n            if (!string.IsNullOrWhiteSpace(search))\n            {\n                var kw = search.Trim();\n                var kwLike = $\"%{kw}%\";\n\n                q = q.Where(x =>\n                    // match CRM contact name/phone if present\n                    (x.log.Contact != null &&\n                        (EF.Functions.ILike(x.log.Contact.Name!, kwLike) ||\n                         x.log.Contact.PhoneNumber!.Contains(kw)))\n                    ||\n                    // match raw recipient number from message log (CSV-only etc.)\n                    (x.ml.RecipientNumber != null && x.ml.RecipientNumber.Contains(kw))\n                );\n            }\n\n            var total = await q.CountAsync();\n\n            var items = await q\n                .OrderByDescending(x => x.log.CreatedAt)\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .Select(x => new CampaignSendLogDto\n                {\n                    Id = x.log.Id,\n                    // CampaignId = x.log.CampaignId ?? campaignId,\n                    CampaignId = x.log.CampaignId,// âœ… fix\n                    ContactId = x.log.ContactId,\n                    ContactName = x.log.Contact != null ? x.log.Contact.Name : \"N/A\",\n                    ContactPhone = x.log.Contact != null ? x.log.Contact.PhoneNumber : \"-\",\n                    RecipientNumber = x.ml.RecipientNumber,\n                    RecipientId = x.log.RecipientId,\n                    MessageBody = x.log.MessageBody,\n                    TemplateId = x.log.TemplateId,\n                    SendStatus = x.log.SendStatus,\n                    ErrorMessage = x.log.ErrorMessage,\n                    CreatedAt = x.log.CreatedAt,\n                    SentAt = x.log.SentAt,\n                    DeliveredAt = x.log.DeliveredAt,\n                    ReadAt = x.log.ReadAt,\n                    SourceChannel = x.log.SourceChannel,\n                    IsClicked = x.log.IsClicked,\n                    ClickedAt = x.log.ClickedAt,\n                    ClickType = x.log.ClickType\n                })\n                .ToListAsync();\n\n            return new PagedResult<CampaignSendLogDto>\n            {\n                Items = items,\n                TotalCount = total,\n                Page = page,\n                PageSize = pageSize\n            };\n        }\n\n        public async Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId)\n        {\n            return await _context.CampaignSendLogs\n                .AsNoTracking()\n               .Where(log =>\n    log.CampaignId == campaignId &&\n    log.ContactId == contactId)\n                .Select(log => new CampaignSendLogDto\n                {\n                    Id = log.Id,\n                    CampaignId = log.CampaignId,\n                    ContactId = log.ContactId,  // unwrap after HasValue guard\n                    MessageBody = log.MessageBody,\n                    TemplateId = log.TemplateId,\n                    SendStatus = log.SendStatus,\n                    ErrorMessage = log.ErrorMessage,\n                    CreatedAt = log.CreatedAt,\n                    SentAt = log.SentAt,\n                    DeliveredAt = log.DeliveredAt,\n                    ReadAt = log.ReadAt,\n                    IpAddress = log.IpAddress,\n                    DeviceInfo = log.DeviceInfo,\n                    MacAddress = log.MacAddress,\n                    SourceChannel = log.SourceChannel,\n                    IsClicked = log.IsClicked,\n                    ClickedAt = log.ClickedAt,\n                    ClickType = log.ClickType\n                })\n                .ToListAsync();\n        }\n\n\n        public async Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent)\n        {\n            var log = new CampaignSendLog\n            {\n                Id = Guid.NewGuid(),\n                CampaignId = dto.CampaignId,\n                ContactId = dto.ContactId,\n                MessageBody = dto.MessageBody,\n                TemplateId = dto.TemplateId,\n                SendStatus = dto.SendStatus,\n                ErrorMessage = dto.ErrorMessage,\n                CreatedAt = DateTime.UtcNow,\n                SentAt = dto.SentAt,\n                DeliveredAt = dto.DeliveredAt,\n                ReadAt = dto.ReadAt,\n                SourceChannel = dto.SourceChannel,\n                IsClicked = dto.IsClicked,\n                ClickedAt = dto.ClickedAt,\n                ClickType = dto.ClickType,\n                RecipientId = dto.RecipientId\n            };\n\n            // âœ… Use enrichment service\n            await _enricher.EnrichAsync(log, userAgent, ipAddress);\n\n            _context.CampaignSendLogs.Add(log);\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ“¨ Update delivery or read status\n        public async Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.SendStatus = status;\n            log.DeliveredAt = deliveredAt ?? log.DeliveredAt;\n            log.ReadAt = readAt ?? log.ReadAt;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ“ˆ Track click (CTA)\n        public async Task<bool> TrackClickAsync(Guid logId, string clickType)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(l => l.Id == logId);\n            if (log == null) return false;\n\n            log.IsClicked = true;\n            log.ClickedAt = DateTime.UtcNow;\n            log.ClickType = clickType;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n        public async Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(Guid campaignId)\n        {\n            // This single, efficient query calculates all stats directly in the database.\n            var summary = await _context.CampaignSendLogs\n                .Where(l => l.CampaignId == campaignId)\n                .GroupBy(l => 1) // Group by a constant to aggregate all results\n                .Select(g => new\n                {\n                    TotalRecipients = g.Count(),\n\n                    // CORRECTED LOGIC: A message is \"Sent\" if its status is NOT \"Failed\".\n                    // This correctly includes messages that are \"Sent\", \"Delivered\", or \"Read\".\n                    SentCount = g.Count(l => l.SendStatus != \"Failed\"),\n\n                    FailedCount = g.Count(l => l.SendStatus == \"Failed\"),\n                    ClickedCount = g.Count(l => l.IsClicked),\n                    DeliveredCount = g.Count(l => l.DeliveredAt != null),\n                    ReadCount = g.Count(l => l.ReadAt != null),\n                    LastSentAt = g.Max(l => l.SentAt)\n                })\n                .FirstOrDefaultAsync();\n\n            if (summary == null)\n            {\n                // Return an empty DTO if no logs are found for the campaign\n                return new CampaignLogSummaryDto();\n            }\n\n            return new CampaignLogSummaryDto\n            {\n                TotalSent = summary.TotalRecipients,\n                Sent = summary.SentCount,\n                FailedCount = summary.FailedCount,\n                ClickedCount = summary.ClickedCount,\n                Delivered = summary.DeliveredCount,\n                Read = summary.ReadCount,\n                LastSentAt = summary.LastSentAt\n            };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/CampaignTrackingRetryService.cs",
      "sha256": "7b60dddd6aceae08b86da9813190186180881e6fc9efd8dc1190e497b51f9af1",
      "language": "csharp",
      "size": 2935,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public class CampaignTrackingRetryService : ICampaignTrackingRetryService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignTrackingRetryService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // âœ… Public method: Retry a single failed log\n        public async Task<bool> RetrySingleAsync(Guid logId)\n        {\n            return await RetrySendLogAsync(logId);\n        }\n\n        // âœ… Public method: Retry all failed logs in a campaign\n        public async Task<int> RetryFailedInCampaignAsync(Guid campaignId)\n        {\n            return await RetryAllFailedInCampaignAsync(campaignId);\n        }\n\n        // ðŸ” Private: Retry a specific log\n        private async Task<bool> RetrySendLogAsync(Guid logId)\n        {\n            var log = await _context.CampaignSendLogs.FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (log == null || log.SendStatus != \"Failed\" || !log.AllowRetry)\n                return false;\n\n            // ðŸ”„ Simulate re-send (replace with actual IMessageService.SendAsync later)\n            bool sent = SimulateSendMessage(log);\n\n            log.RetryCount += 1;\n            log.LastRetryAt = DateTime.UtcNow;\n            log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n            log.SendStatus = sent ? \"Sent\" : \"Failed\";\n            log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n            await _context.SaveChangesAsync();\n            return sent;\n        }\n\n        // ðŸ” Private: Retry all failed logs in a given campaign\n        private async Task<int> RetryAllFailedInCampaignAsync(Guid campaignId)\n        {\n            var failedLogs = await _context.CampaignSendLogs\n                .Where(log => log.CampaignId == campaignId && log.SendStatus == \"Failed\" && log.AllowRetry)\n                .ToListAsync();\n\n            int successCount = 0;\n\n            foreach (var log in failedLogs)\n            {\n                bool sent = SimulateSendMessage(log);\n\n                log.RetryCount += 1;\n                log.LastRetryAt = DateTime.UtcNow;\n                log.LastRetryStatus = sent ? \"Sent\" : \"Failed\";\n                log.SendStatus = sent ? \"Sent\" : \"Failed\";\n                log.ErrorMessage = sent ? null : \"Mock failure on retry\";\n\n                if (sent) successCount++;\n            }\n\n            await _context.SaveChangesAsync();\n            return successCount;\n        }\n\n        // ðŸ”§ Simulated send (replace with actual WhatsApp message logic)\n        private bool SimulateSendMessage(CampaignSendLog log)\n        {\n            return new Random().NextDouble() < 0.9; // 90% success rate\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ClickTokenService.cs",
      "sha256": "b80c48d547509139d45775d1f8447eceeec7d399e27cd9a55c20dc1aecb854fb",
      "language": "csharp",
      "size": 3152,
      "content": "// ðŸ“„ Features/CampaignTracking/Services/ClickTokenService.cs\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public record ClickTokenPayload(\n        Guid cid,            // CampaignSendLogId\n        int bi,              // button index\n        string bt,           // button title (optional)\n        string to,           // destination absolute URL\n        long iat,            // issued at (unix seconds)\n        long exp             // expiry (unix seconds)\n    );\n\n    public interface IClickTokenService\n    {\n        string Create(ClickTokenPayload payload);\n        bool TryValidate(string token, out ClickTokenPayload? payload, out string? error);\n    }\n\n    public class ClickTokenService : IClickTokenService\n    {\n        private readonly byte[] _key;\n\n        public ClickTokenService(IOptions<TrackingOptions> opt)\n        {\n            _key = Encoding.UTF8.GetBytes(opt.Value.Secret ?? throw new ArgumentNullException(nameof(opt.Value.Secret)));\n        }\n\n        public string Create(ClickTokenPayload payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var data = Encoding.UTF8.GetBytes(json);\n            var body = WebEncoders.Base64UrlEncode(data);\n\n            var sig = ComputeHmac(body);\n            return $\"{body}.{sig}\";\n        }\n\n        public bool TryValidate(string token, out ClickTokenPayload? payload, out string? error)\n        {\n            payload = null;\n            error = null;\n\n            var parts = token.Split('.');\n            if (parts.Length != 2) { error = \"format\"; return false; }\n\n            var body = parts[0];\n            var sig = parts[1];\n\n            var expected = ComputeHmac(body);\n            // timing-safe compare\n            if (!CryptographicOperations.FixedTimeEquals(Encoding.UTF8.GetBytes(sig), Encoding.UTF8.GetBytes(expected)))\n            { error = \"bad-signature\"; return false; }\n\n            try\n            {\n                var bytes = WebEncoders.Base64UrlDecode(body);\n                var obj = JsonSerializer.Deserialize<ClickTokenPayload>(bytes);\n                if (obj is null) { error = \"decode\"; return false; }\n\n                var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n                if (now > obj.exp) { error = \"expired\"; return false; }\n\n                // minimal URL sanity check\n                if (!Uri.TryCreate(obj.to, UriKind.Absolute, out var _)) { error = \"bad-destination\"; return false; }\n\n                payload = obj;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                error = \"exception:\" + ex.GetType().Name;\n                return false;\n            }\n        }\n\n        private string ComputeHmac(string body)\n        {\n            using var h = new HMACSHA256(_key);\n            var sig = h.ComputeHash(Encoding.UTF8.GetBytes(body));\n            return WebEncoders.Base64UrlEncode(sig);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignAnalyticsService.cs",
      "sha256": "c4c188f0eba3b537c076a7fc42ef62094de1ced491abcaecb619097e40debb8b",
      "language": "csharp",
      "size": 437,
      "content": "using xbytechat.api.Features.CampaignTracking.DTOs;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignAnalyticsService\n    {\n       // Task<CampaignStatusDashboardDto> GetStatusDashboardAsync(Guid businessId);\n        Task<IEnumerable<TopCampaignDto>> GetTopCampaignsAsync(Guid businessId, int count = 5);\n        Task<CampaignStatusDashboardDto?> GetCampaignStatsAsync(Guid campaignId);\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogEnricher.cs",
      "sha256": "9204a2182522e06e53fe6beb21100820231943995d044f01feb200bdcaa521de",
      "language": "csharp",
      "size": 290,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogEnricher\n    {\n        Task EnrichAsync(CampaignSendLog log, string userAgent, string ipAddress);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignSendLogService.cs",
      "sha256": "2be8275d1874b38f88f5395552b8a10412b7949d360e6abb4f12f10fdfa504f9",
      "language": "csharp",
      "size": 1276,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignTracking.DTOs;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignSendLogService\n    {\n        // This is the NEW signature that matches your updated service and controller\n        Task<PagedResult<CampaignSendLogDto>> GetLogsByCampaignIdAsync(\n            Guid campaignId, string? status, string? search, int page, int pageSize);\n        // ðŸ“ Get logs for a specific contact in a campaign\n        Task<List<CampaignSendLogDto>> GetLogsForContactAsync(Guid campaignId, Guid contactId);\n\n        // ðŸ†• Add a new send log entry with enrichment (IP, User-Agent)\n        Task<bool> AddSendLogAsync(CampaignSendLogDto dto, string ipAddress, string userAgent);\n\n        // ðŸ“¨ Update delivery or read status\n        Task<bool> UpdateDeliveryStatusAsync(Guid logId, string status, DateTime? deliveredAt, DateTime? readAt);\n\n        // ðŸ“ˆ Track CTA click (e.g., BuyNow, ViewDetails)\n        Task<bool> TrackClickAsync(Guid logId, string clickType);\n        // ðŸ“Š Get summary of campaign logs\n        Task<CampaignLogSummaryDto> GetCampaignSummaryAsync(Guid campaignId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Services/ICampaignTrackingRetryService.cs",
      "sha256": "0ea3dd070b8b87ab800873972e6200421e942c4e4536a316a8623bd7108e72ec",
      "language": "csharp",
      "size": 554,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CampaignTracking.Services\n{\n    public interface ICampaignTrackingRetryService\n    {\n\n        // Retry a single failed message log by its ID.\n        // will be used when user clicks \"Retry Now\" on a log row.\n        Task<bool> RetrySingleAsync(Guid logId);\n\n\n        // Retry all failed messages in a campaign where retry is allowed.\n        // will support \"Retry All Failed\" button from Campaign logs.\n        Task<int> RetryFailedInCampaignAsync(Guid campaignId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickEvent.cs",
      "sha256": "feba0a8efef3e111690aeca876198178018024d5c39d3415d1cb3db163a8e52e",
      "language": "csharp",
      "size": 380,
      "content": "// Features/CampaignTracking/Worker/ClickEvent.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed record ClickEvent(\n        Guid CampaignSendLogId,\n        int ButtonIndex,\n        string ButtonTitle,\n        string Destination,\n        DateTime ClickedAtUtc,\n        string Ip,\n        string UserAgent,\n         string ClickType\n         \n    );\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/ClickLogWorker.cs",
      "sha256": "6c5f66aa812a1532420b44d66e9a0d9b72234af71077dbb32151c78d78d30a97",
      "language": "csharp",
      "size": 8009,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class ClickLogWorker : BackgroundService\n    {\n        private readonly ILogger<ClickLogWorker> _log;\n        private readonly IClickEventQueue _queue;\n        private readonly IServiceScopeFactory _scopeFactory;\n\n        public ClickLogWorker(\n            ILogger<ClickLogWorker> log,\n            IClickEventQueue queue,\n            IServiceScopeFactory scopeFactory)\n        {\n            _log = log;\n            _queue = queue;\n            _scopeFactory = scopeFactory;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _log.LogInformation(\"ClickLogWorker started\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                List<ClickEvent> batch;\n                try\n                {\n                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n                    if (batch.Count == 0) continue;\n\n                    // quick visibility: confirm we are ingesting call/whatsapp/web events\n                    var byType = batch.GroupBy(e => e.ClickType ?? \"web\")\n                                      .Select(g => $\"{g.Key}:{g.Count()}\")\n                                      .ToArray();\n                    _log.LogInformation(\"WORKER processing {Count} events [{Kinds}]\",\n                        batch.Count, string.Join(\", \", byType));\n                }\n                catch (OperationCanceledException)\n                {\n                    break;\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Queue read failed; retrying\");\n                    try { await Task.Delay(500, stoppingToken); } catch { /* ignore */ }\n                    continue;\n                }\n\n                // nothing to do\n                if (batch.Count == 0) continue;\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    // Prefetch CampaignId for this batch (we only need CampaignId for the aggregates)\n                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n                    if (sendIds.Count == 0) continue;\n\n                    var sendMap = await db.CampaignSendLogs\n                        .Where(s => sendIds.Contains(s.Id))\n                        .Select(s => new { s.Id, s.CampaignId })\n                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n                    // Prepare aggregate groups: (CampaignId, Day, ButtonIndex) -> count\n                    var groups = batch\n                        .Select(e =>\n                        {\n                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n                        })\n                        .Where(x => x.CampaignId != Guid.Empty)\n                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n                        .ToList();\n\n                    if (groups.Count == 0) continue;\n\n                    foreach (var g in groups)\n                    {\n                        await db.Database.ExecuteSqlRawAsync(@\"\n                    insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n                    values ({0}, {1}, {2}, {3})\n                    on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n                    do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _log.LogError(ex, \"Aggregate update failed; skipped this batch.\");\n                }\n            }\n\n            _log.LogInformation(\"ClickLogWorker stopped\");\n        }\n    }\n}\n\n\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n\n//namespace xbytechat.api.Features.CampaignTracking.Worker\n//{\n//    public sealed class ClickLogWorker : BackgroundService\n//    {\n//        private readonly ILogger<ClickLogWorker> _log;\n//        private readonly IClickEventQueue _queue;\n//        private readonly IServiceScopeFactory _scopeFactory;\n\n//        public ClickLogWorker(\n//            ILogger<ClickLogWorker> log,\n//            IClickEventQueue queue,\n//            IServiceScopeFactory scopeFactory)\n//        {\n//            _log = log;\n//            _queue = queue;\n//            _scopeFactory = scopeFactory;\n//        }\n\n//        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n//        {\n//            _log.LogInformation(\"ClickLogWorker started\");\n\n//            while (!stoppingToken.IsCancellationRequested)\n//            {\n//                List<ClickEvent> batch;\n//                try\n//                {\n//                    batch = await _queue.ReadBatchAsync(200, TimeSpan.FromSeconds(1), stoppingToken);\n//                    if (batch.Count == 0) continue;\n//                    _log.LogInformation(\"WORKER processing {Count} events (aggregates only)\", batch.Count);\n//                }\n//                catch (OperationCanceledException) { break; }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Queue read failed; retrying\");\n//                    try { await Task.Delay(500, stoppingToken); } catch { }\n//                    continue;\n//                }\n\n//                try\n//                {\n//                    using var scope = _scopeFactory.CreateScope();\n//                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n//                    // Prefetch CampaignId for this batch\n//                    var sendIds = batch.Select(b => b.CampaignSendLogId).Distinct().ToList();\n//                    var sendMap = await db.CampaignSendLogs\n//                        .Where(s => sendIds.Contains(s.Id))\n//                        .Select(s => new { s.Id, s.CampaignId })\n//                        .ToDictionaryAsync(s => s.Id, s => s.CampaignId, stoppingToken);\n\n//                    // Build aggregate groups\n//                    var groups = batch\n//                        .Select(e =>\n//                        {\n//                            sendMap.TryGetValue(e.CampaignSendLogId, out var campaignId);\n//                            return new { CampaignId = campaignId, Day = e.ClickedAtUtc.Date, e.ButtonIndex };\n//                        })\n//                        .Where(x => x.CampaignId != Guid.Empty)\n//                        .GroupBy(x => new { x.CampaignId, x.Day, x.ButtonIndex })\n//                        .Select(g => new { g.Key.CampaignId, g.Key.Day, g.Key.ButtonIndex, Count = g.Count() })\n//                        .ToList();\n\n//                    foreach (var g in groups)\n//                    {\n//                        await db.Database.ExecuteSqlRawAsync(@\"\n//insert into \"\"CampaignClickDailyAgg\"\" (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\", \"\"Clicks\"\")\n//values ({0}, {1}, {2}, {3})\n//on conflict (\"\"CampaignId\"\", \"\"Day\"\", \"\"ButtonIndex\"\")\n//do update set \"\"Clicks\"\" = \"\"CampaignClickDailyAgg\"\".\"\"Clicks\"\" + {3};\",\n//                            g.CampaignId, g.Day, g.ButtonIndex, g.Count);\n//                    }\n//                }\n//                catch (Exception ex)\n//                {\n//                    _log.LogError(ex, \"Aggregate update failed; skipped.\");\n//                }\n//            }\n\n//            _log.LogInformation(\"ClickLogWorker stopped\");\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/IClickEventQueue.cs",
      "sha256": "a0e8a3bbb51c949024de93f0d4794c3ed494cc047e0b7dafdabe4cf696dad89c",
      "language": "csharp",
      "size": 304,
      "content": "// Features/CampaignTracking/Worker/IClickEventQueue.cs\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public interface IClickEventQueue\n    {\n        bool TryWrite(ClickEvent evt);\n        Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignTracking/Worker/InProcessClickEventQueue.cs",
      "sha256": "8344c869f22df147598c7b1db117ba72d4c518901138838f7fed724201392009",
      "language": "csharp",
      "size": 1254,
      "content": "using System.Threading.Channels;\n\nnamespace xbytechat.api.Features.CampaignTracking.Worker\n{\n    public sealed class InProcessClickEventQueue : IClickEventQueue\n    {\n        private readonly Channel<ClickEvent> _ch;\n\n        public InProcessClickEventQueue(int capacity = 20_000)\n        {\n            _ch = Channel.CreateBounded<ClickEvent>(new BoundedChannelOptions(capacity)\n            {\n                // keep newest; never block redirect\n                FullMode = BoundedChannelFullMode.DropOldest,\n                SingleReader = true,\n                SingleWriter = false\n            });\n        }\n\n        public bool TryWrite(ClickEvent evt) => _ch.Writer.TryWrite(evt);\n\n        public async Task<List<ClickEvent>> ReadBatchAsync(int maxItems, TimeSpan wait, CancellationToken ct)\n        {\n            var list = new List<ClickEvent>(maxItems);\n            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);\n            cts.CancelAfter(wait);\n\n            while (list.Count < maxItems && await _ch.Reader.WaitToReadAsync(cts.Token))\n            {\n                while (list.Count < maxItems && _ch.Reader.TryRead(out var item))\n                    list.Add(item);\n            }\n            return list;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogDashboardController.cs",
      "sha256": "f9186d5de3a12145a3d7a2411736c6510ca02a7b70409ebdcaaa0de5172c0370",
      "language": "csharp",
      "size": 1708,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-dashboard\")]\n    public class CatalogDashboardController : ControllerBase\n    {\n        private readonly ICatalogDashboardService _dashboardService;\n\n        public CatalogDashboardController(ICatalogDashboardService dashboardService)\n        {\n            _dashboardService = dashboardService;\n        }\n\n        [HttpGet(\"summary\")]\n        public async Task<ActionResult<CatalogDashboardSummaryDto>> GetSummary([FromQuery] Guid businessId)\n        {\n            var summary = await _dashboardService.GetDashboardSummaryAsync(businessId);\n            return Ok(summary);\n        }\n\n        [HttpGet(\"top-products\")]\n        public async Task<IActionResult> GetTopClickedProducts([FromQuery] Guid businessId, [FromQuery] int topN = 5)\n        {\n            var topProducts = await _dashboardService.GetTopClickedProductsAsync(businessId, topN);\n            return Ok(topProducts);\n        }\n        [HttpGet(\"cta-summary\")]\n        public async Task<IActionResult> GetCtaJourneySummary([FromQuery] Guid businessId)\n        {\n            var stats = await _dashboardService.GetCtaJourneyStatsAsync(businessId);\n            return Ok(stats);\n        }\n        [HttpGet(\"product-cta-breakdown\")]\n        public async Task<IActionResult> GetProductCtaBreakdown([FromQuery] Guid businessId)\n        {\n            var breakdown = await _dashboardService.GetProductCtaBreakdownAsync(businessId);\n            return Ok(breakdown);\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/CatalogTrackingController.cs",
      "sha256": "85581ce69ed9dbbad069ca060c3e8a2c356ec348d74d860ed2ed1905c46f9514",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/catalog-tracking\")]\n    public class CatalogTrackingController : ControllerBase\n    {\n        private readonly ICatalogTrackingService _trackingService;\n        private readonly ILogger<CatalogTrackingController> _logger;\n\n        public CatalogTrackingController(\n            ICatalogTrackingService trackingService,\n            ILogger<CatalogTrackingController> logger)\n        {\n            _trackingService = trackingService;\n            _logger = logger;\n        }\n\n        [HttpPost(\"log-click\")]\n        public async Task<IActionResult> LogClick([FromBody] CatalogClickLogDto dto)\n        {\n            var result = await _trackingService.LogClickAsync(dto);\n\n            if (!result.Success)\n            {\n                _logger.LogWarning(\"âŒ Catalog click log failed: {Msg}\", result.Message);\n                return BadRequest(result);\n            }\n\n            return StatusCode(201, result);\n        }\n\n        [HttpGet(\"recent\")]\n        public async Task<IActionResult> GetRecentLogs([FromQuery] int limit = 5)\n        {\n            var result = await _trackingService.GetRecentLogsAsync(limit);\n\n            if (!result.Success)\n            {\n                _logger.LogError(\"âŒ Failed to fetch recent logs: {Error}\", result.ErrorMessage);\n                return StatusCode(500, result);\n            }\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Controllers/ProductController.cs",
      "sha256": "96a44de270bbb3d5a3b88cc161908c14045b78ca5adab88fb776640f55de1a1b",
      "language": "csharp",
      "size": 3021,
      "content": "// ðŸ“„ File: Features/Catalog/Controllers/ProductController.cs\n\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Services;\nusing xbytechat.api.Helpers;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Middleware.Attributes;\n\nnamespace xbytechat.api.Features.Catalog.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductService _productService;\n\n        public ProductController(IProductService productService)\n        {\n            _productService = productService;\n        }\n\n        // âœ… GET /api/product?businessId=...\n        [HttpGet]\n        [RequirePermission(\"ViewCatalog\")]\n        public async Task<IActionResult> GetAll([FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.GetProductsByBusinessIdAsync(businessId);\n            return Ok(result);\n        }\n\n        // âœ… POST /api/product\n        [HttpPost]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Create([FromBody] CreateProductDto dto)\n        {\n            if (!ModelState.IsValid)\n            {\n                var errors = ModelState.Values\n                    .SelectMany(v => v.Errors)\n                    .Select(e => e.ErrorMessage)\n                    .ToList();\n\n                var errorString = string.Join(\"; \", errors);\n                return BadRequest(ResponseResult.ErrorInfo(\"Invalid product data.\", errorString));\n            }\n\n            var result = await _productService.AddProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return StatusCode(201, result);\n        }\n\n        // âœ… DELETE /api/product/{id}?businessId=...\n        [HttpDelete(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Delete(Guid id, [FromQuery] Guid businessId)\n        {\n            if (businessId == Guid.Empty)\n                return BadRequest(ResponseResult.ErrorInfo(\"BusinessId is required.\"));\n\n            var result = await _productService.RemoveProductAsync(id, businessId);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n\n        // âœ… PUT /api/product/{id}\n        [HttpPut(\"{id}\")]\n        [RequirePermission(\"ManageCatalog\")]\n        public async Task<IActionResult> Update(Guid id, [FromBody] UpdateProductDto dto)\n        {\n            if (id != dto.Id)\n                return BadRequest(ResponseResult.ErrorInfo(\"ID mismatch between route and body.\"));\n\n            var result = await _productService.UpdateProductAsync(dto);\n            if (!result.Success)\n                return BadRequest(result);\n\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogClickLogDto.cs",
      "sha256": "901cea612e459695f97b806841df45393d04066624affedbfd85cc9d7d3899ce",
      "language": "csharp",
      "size": 979,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogClickLogDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid? ContactId { get; set; }  // âœ… Add this\n        public Guid? ProductId { get; set; }\n\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        public string? BotId { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public string? CTAJourney { get; set; }\n        public Guid? MessageLogId { get; set; }      // âœ… ADD THIS FIELD\n        public string? RefMessageId { get; set; }\n\n        public string TemplateId { get; set; }\n        public string ButtonText { get; set; }\n\n        // ðŸ§  Optional: Used for A/B tracking and analytics\n        public string? PlanSnapshot { get; set; }\n\n        public string? Source { get; set; } // âœ… Add this\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CatalogDashboardSummaryDto.cs",
      "sha256": "31e171cf2d8c5bc006b770f4be2a968db3300aaad51072555faecd119e0e0e07",
      "language": "csharp",
      "size": 698,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CatalogDashboardSummaryDto\n    {\n        // Engagement Metrics\n        public int TotalMessagesSent { get; set; }\n        public int? UniqueCustomersMessaged { get; set; }\n        public int? ProductClicks { get; set; }\n\n        // Catalog Overview\n        public int? ActiveProducts { get; set; }\n        public int? ProductsSharedViaWhatsApp { get; set; }\n\n        // Lead Intelligence\n        public int? RepeatClickers { get; set; }\n        public int? NewClickersToday { get; set; }\n\n        // Timestamps\n        public DateTime? LastCatalogClickAt { get; set; }\n        public DateTime? LastMessageSentAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CreateProductDto.cs",
      "sha256": "8605a9900a0537d7cec14264a91a4a4432debcdaafb06cff99b177460bd47233",
      "language": "csharp",
      "size": 472,
      "content": "// File: Features/Catalog/DTOs/CreateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CreateProductDto\n    {\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/CtaJourneyStatsDto.cs",
      "sha256": "ca4efb6e222da04add4d8f9892be95a16ae180b34e53eec32d300c471ea503bd",
      "language": "csharp",
      "size": 188,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class CtaJourneyStatsDto\n    {\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductCtaBreakdownDto.cs",
      "sha256": "a94adfe171430503ede80ebb733fc9983f3fe1eae04b4a5a4ed6eb14d354bc10",
      "language": "csharp",
      "size": 284,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductCtaBreakdownDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public string CTAJourney { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/ProductDto.cs",
      "sha256": "9351e6b36ce1f707bd46bb92652331f1751b150a9d062ecfd31572a0998d59b7",
      "language": "csharp",
      "size": 549,
      "content": "// File: Features/Catalog/DTOs/ProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class ProductDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/TopProductDto.cs",
      "sha256": "464918c2b2d66c5710042f7d26d7b64fc8f4fb0380f12e7c756a0d248e613684",
      "language": "csharp",
      "size": 228,
      "content": "namespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class TopProductDto\n    {\n        public Guid ProductId { get; set; }\n        public string ProductName { get; set; }\n        public int ClickCount { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/DTOs/UpdateProductDto.cs",
      "sha256": "3d2fa63b4ce50da54504b1efa60375305ee53bd12498eb5c359bec2f13aeb11c",
      "language": "csharp",
      "size": 511,
      "content": "// File: Features/Catalog/DTOs/UpdateProductDto.cs\n\nnamespace xbytechat.api.Features.Catalog.DTOs\n{\n    public class UpdateProductDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/CatalogClickLog.cs",
      "sha256": "04b5faf86ec274241aa075f5ba6309899ae07f9c0074d1a34285b4f7c96b437d",
      "language": "csharp",
      "size": 1636,
      "content": "namespace xbytechat.api.Features.Catalog.Models\n{\n    public class CatalogClickLog\n    {\n        public Guid Id { get; set; }\n\n        // ðŸ”— Business & Product Info\n        public Guid BusinessId { get; set; }\n        public Guid? ProductId { get; set; }\n\n        // ðŸ‘¤ Customer Info\n        public string? UserId { get; set; }\n        public string? UserName { get; set; }\n        public string? UserPhone { get; set; }\n\n        // ðŸ¤– Bot / Messaging Context\n        public string? BotId { get; set; }\n\n        // ðŸ›ï¸ Browsing Context\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n\n        // ðŸ”˜ CTA Clicked\n        public string? CTAJourney { get; set; }\n        public string TemplateId { get; set; }\n        public string RefMessageId { get; set; }\n        public string ButtonText { get; set; }\n\n        // ðŸ•’ Meta\n        public DateTime? ClickedAt { get; set; } = DateTime.UtcNow;\n\n        // âœ… CRM / Campaign / Analytics\n        public Guid? CampaignSendLogId { get; set; }\n        public Guid? ContactId { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n        public string? LastInteractionType { get; set; }\n        public Guid? MessageLogId { get; set; }\n        public string? PlanSnapshot { get; set; }\n\n        // ðŸ†• [New Additions for CTA Campaign Tracking]\n        public Guid? CtaId { get; set; }             // Link to CTA definition\n        public Guid? CampaignId { get; set; }        // Link to campaign (if any)\n        public string Source { get; set; } = \"catalog\"; // \"catalog\", \"campaign\", \"auto-reply\"\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Models/Product.cs",
      "sha256": "428554206c02d4602a873704a1e49c995a274f4633e0f32d8c0991c4eea72a31",
      "language": "csharp",
      "size": 1062,
      "content": "// File: Features/Catalog/Models/Product.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.Catalog.Models\n{\n    public class Product\n    {\n        public Guid Id { get; set; }\n\n        // ðŸ”— Foreign Key - Business/Owner\n        public Guid BusinessId { get; set; }\n\n        // ðŸ“¦ Core Product Info\n        public string Name { get; set; } = string.Empty;\n        public string Description { get; set; } = string.Empty;\n        public decimal Price { get; set; }\n        public string Currency { get; set; } = \"INR\";\n        public string ImageUrl { get; set; } = string.Empty;\n\n        // âœ… Visibility & State\n        public bool IsActive { get; set; } = true;\n\n        // ðŸ“… Metadata\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public int TotalClicks { get; set; } = 0; // Total CTA clicks tracked\n        public DateTime? LastClickedAt { get; set; } // Last time a user clicked CTA for this product\n        public string? MostClickedCTA { get; set; } // Button text with highest click count (e.g., \"Buy Now\")\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogDashboardService.cs",
      "sha256": "3303616ebf70e99e2e646759834c707405060cc1b22ceb5f743dfa1d8af50198",
      "language": "csharp",
      "size": 6538,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Hosting.Server;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogDashboardService : ICatalogDashboardService\n    {\n        private readonly AppDbContext _context;\n\n        public CatalogDashboardService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n       \n        public async Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalMessagesSent = await _context.MessageLogs\n                .CountAsync(m => m.BusinessId == businessId);\n\n            var uniqueCustomersMessaged = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .Select(m => m.RecipientNumber)\n                .Distinct()\n                .CountAsync();\n\n            var productClicks = await _context.CatalogClickLogs\n                .CountAsync(c => c.BusinessId == businessId && c.ProductId != null);\n\n            var activeProducts = await _context.Products\n                .CountAsync(p => p.BusinessId == businessId);\n\n            var productsSharedViaWhatsapp = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .Select(c => c.ProductId)\n                .Distinct()\n                .CountAsync();\n\n            var repeatClickers = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.UserPhone)\n                .CountAsync(g => g.Count() > 1);\n\n            var newClickersToday = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ClickedAt.Value.Date == today)\n                .Select(c => c.UserPhone)\n                .Distinct()\n                .CountAsync();\n            //        var newClickersToday = _context.CatalogClickLogs\n            //.Where(c => c.BusinessId == businessId)\n            //.ToList() // now it's LINQ to Objects\n            //        .Where(c => c.ClickedAt?.Date == today)\n            //        .Select(c => c.UserPhone)\n            //        .Distinct()\n            //.Count();\n            //        But if your data is large, the first(server-side filtering) is the better choice.\n\n            var lastCatalogClickAt = await _context.CatalogClickLogs\n    .Where(c => c.BusinessId == businessId)\n    .MaxAsync(c => (DateTime?)c.ClickedAt);\n\n            var lastMessageSentAt = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId)\n                .MaxAsync(m => (DateTime?)m.SentAt);\n\n            return new CatalogDashboardSummaryDto\n            {\n                TotalMessagesSent = totalMessagesSent,\n                UniqueCustomersMessaged = uniqueCustomersMessaged,\n                ProductClicks = productClicks,\n                ActiveProducts = activeProducts,\n                ProductsSharedViaWhatsApp = productsSharedViaWhatsapp,\n                RepeatClickers = repeatClickers,\n                NewClickersToday = newClickersToday,\n                LastCatalogClickAt = lastCatalogClickAt,\n                LastMessageSentAt = lastMessageSentAt\n            };\n        }\n\n        public async Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5)\n        {\n            var topProducts = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null)\n                .GroupBy(c => c.ProductId)\n                .Select(g => new\n                {\n                    ProductId = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .Take(topN)\n                .ToListAsync();\n\n            // Now fetch product names to join with clicks\n            var productIds = topProducts.Select(x => x.ProductId).ToList();\n\n            var products = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            return topProducts.Select(x => new TopProductDto\n            {\n                ProductId = x.ProductId.Value,\n                ProductName = products.ContainsKey(x.ProductId.Value) ? products[x.ProductId.Value] : \"Unknown\",\n                ClickCount = x.ClickCount\n            }).ToList();\n        }\n        public async Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId)\n        {\n            var stats = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => c.CTAJourney)\n                .Select(g => new CtaJourneyStatsDto\n                {\n                    CTAJourney = g.Key,\n                    ClickCount = g.Count()\n                })\n                .OrderByDescending(x => x.ClickCount)\n                .ToListAsync();\n\n            return stats;\n        }\n        public async Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId)\n        {\n            var groupedClicks = await _context.CatalogClickLogs\n                .Where(c => c.BusinessId == businessId && c.ProductId != null && !string.IsNullOrEmpty(c.CTAJourney))\n                .GroupBy(c => new { c.ProductId, c.CTAJourney })\n                .Select(g => new\n                {\n                    ProductId = g.Key.ProductId.Value,\n                    CTAJourney = g.Key.CTAJourney,\n                    ClickCount = g.Count()\n                })\n                .ToListAsync();\n\n            // Fetch product names for all involved productIds\n            var productIds = groupedClicks.Select(g => g.ProductId).Distinct().ToList();\n\n            var productNames = await _context.Products\n                .Where(p => productIds.Contains(p.Id))\n                .ToDictionaryAsync(p => p.Id, p => p.Name);\n\n            var result = groupedClicks.Select(g => new ProductCtaBreakdownDto\n            {\n                ProductId = g.ProductId,\n                ProductName = productNames.ContainsKey(g.ProductId) ? productNames[g.ProductId] : \"Unknown\",\n                CTAJourney = g.CTAJourney,\n                ClickCount = g.ClickCount\n            }).ToList();\n\n            return result;\n        }\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/CatalogTrackingService.cs",
      "sha256": "466e53210d232226ec62ffaed236063b75a748eff0f420e423d8f482ff3a4fdf",
      "language": "csharp",
      "size": 6371,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;\nusing xbytechat.api.Services.Messages.Interfaces;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class CatalogTrackingService : ICatalogTrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMessageService _messageService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public CatalogTrackingService(\n            AppDbContext context,\n            IMessageService messageService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _context = context;\n            _messageService = messageService;\n            _leadTimelineService = leadTimelineService;\n        }\n\n        public async Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto)\n        {\n            if (dto == null || dto.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(dto.UserPhone))\n            {\n                Log.Warning(\"âŒ Invalid catalog click log attempt: missing businessId or userPhone.\");\n                return ResponseResult.ErrorInfo(\"Required fields are missing (businessId, userPhone).\");\n            }\n\n            try\n            {\n                Guid? campaignSendLogId = null;\n                Guid? contactId = null;\n                bool followUpSent = false;\n\n                // STEP 1: Link campaign log via RefMessageId if available\n                if (!string.IsNullOrWhiteSpace(dto.RefMessageId))\n                {\n                    var sendLog = await _context.CampaignSendLogs\n                        .FirstOrDefaultAsync(x => x.MessageId == dto.RefMessageId);\n\n                    if (sendLog != null)\n                    {\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = DateTime.UtcNow;\n                        sendLog.ClickType = dto.CTAJourney ?? dto.ButtonText;\n                        campaignSendLogId = sendLog.Id;\n                    }\n                }\n\n                // STEP 2: Link or Create CRM Contact\n                if (!string.IsNullOrWhiteSpace(dto.UserPhone))\n                {\n                    var contact = await _context.Contacts\n                        .FirstOrDefaultAsync(c => c.PhoneNumber == dto.UserPhone && c.BusinessId == dto.BusinessId);\n\n                    if (contact == null)\n                    {\n                        contact = new Contact\n                        {\n                            Id = Guid.NewGuid(),\n                            Name = dto.UserName ?? \"Lead\",\n                            PhoneNumber = dto.UserPhone,\n                            BusinessId = dto.BusinessId,\n                            CreatedAt = DateTime.UtcNow\n                        };\n                        _context.Contacts.Add(contact);\n                        await _context.SaveChangesAsync();\n                    }\n\n                    contactId = contact.Id;\n\n                    // STEP 3: Auto follow-up if plan allows\n                    var business = await _context.Businesses\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(b => b.Id == dto.BusinessId);\n\n                    if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                    {\n                        var message = $\"Hi {contact.Name ?? \"there\"}, how can I help you?\";\n                        await _messageService.SendFollowUpAsync(contact.PhoneNumber, message);\n                        followUpSent = true;\n                    }\n                }\n\n                // STEP 4: Save the click with all linked data\n                var log = new CatalogClickLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ProductId = dto.ProductId,\n                    UserId = dto.UserId,\n                    UserName = dto.UserName,\n                    UserPhone = dto.UserPhone,\n                    BotId = dto.BotId,\n                    CategoryBrowsed = dto.CategoryBrowsed,\n                    ProductBrowsed = dto.ProductBrowsed,\n                    CTAJourney = dto.CTAJourney,\n                    TemplateId = dto.TemplateId,\n                    ButtonText = dto.ButtonText,\n                    RefMessageId = dto.RefMessageId,\n                    ClickedAt = DateTime.UtcNow,\n                    CampaignSendLogId = campaignSendLogId,\n                    ContactId = contactId,\n                    FollowUpSent = followUpSent,\n                    LastInteractionType = \"Clicked\",\n                    PlanSnapshot = dto.PlanSnapshot\n                };\n\n                _context.CatalogClickLogs.Add(log);\n                await _context.SaveChangesAsync();\n\n                // STEP 5: Save into LeadTimeline (no await error)\n                await _leadTimelineService.AddFromCatalogClickAsync(log);\n\n                Log.Information(\"ðŸ“Š Catalog click tracked: {BusinessId}, {UserPhone}, {CTA}\", dto.BusinessId, dto.UserPhone, dto.CTAJourney);\n                return ResponseResult.SuccessInfo(\"âœ… Click tracked successfully.\", log.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to log catalog click\");\n                return ResponseResult.ErrorInfo(\"âŒ Error while tracking catalog click.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetRecentLogsAsync(int limit)\n        {\n            try\n            {\n                var logs = await _context.CatalogClickLogs\n                    .OrderByDescending(x => x.ClickedAt)\n                    .Take(limit)\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Recent logs fetched.\", logs);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to fetch recent catalog click logs\");\n                return ResponseResult.ErrorInfo(\"Failed to fetch logs.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogDashboardService.cs",
      "sha256": "9cac16574ec18c7343c13d49a28395b9ab04bf296e8d7b910b05d1cc88378a7d",
      "language": "csharp",
      "size": 546,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogDashboardService\n    {\n        Task<CatalogDashboardSummaryDto> GetDashboardSummaryAsync(Guid businessId);\n        Task<List<TopProductDto>> GetTopClickedProductsAsync(Guid businessId, int topN = 5);\n        Task<List<CtaJourneyStatsDto>> GetCtaJourneyStatsAsync(Guid businessId);\n        Task<List<ProductCtaBreakdownDto>> GetProductCtaBreakdownAsync(Guid businessId);\n\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ICatalogTrackingService.cs",
      "sha256": "b9ea119f807697f7e52cbea8b7c3aa4320c2ffe23326d076d1d1f0f9a2f12310",
      "language": "csharp",
      "size": 342,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface ICatalogTrackingService\n    {\n        Task<ResponseResult> LogClickAsync(CatalogClickLogDto dto);\n        Task<ResponseResult> GetRecentLogsAsync(int limit);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/IProductService.cs",
      "sha256": "23245f8c5da029c4146e515732f03b3e815636c1fddfec0f38a3a26355bdc1b1",
      "language": "csharp",
      "size": 510,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public interface IProductService\n    {\n        Task<ResponseResult> AddProductAsync(CreateProductDto dto);\n        Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId);\n        Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto);\n        Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Catalog/Services/ProductService.cs",
      "sha256": "b42253a9398257b4f84555e31c4423127d843bd60b73560f7730b71433d17fd0",
      "language": "csharp",
      "size": 5527,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Catalog.Services\n{\n    public class ProductService : IProductService\n    {\n        private readonly AppDbContext _context;\n\n        public ProductService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<ResponseResult> AddProductAsync(CreateProductDto dto)\n        {\n            try\n            {\n                var exists = await _context.Products\n                    .AnyAsync(p => p.BusinessId == dto.BusinessId && p.Name == dto.Name);\n\n                if (exists)\n                {\n                    Log.Warning(\"âŒ Duplicate product add attempt: {ProductName} for BusinessId: {BusinessId}\", dto.Name, dto.BusinessId);\n                    return ResponseResult.ErrorInfo(\"Product with this name already exists.\");\n                }\n\n                var newProduct = new Product\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    Price = dto.Price,\n                    Currency = dto.Currency,\n                    ImageUrl = dto.ImageUrl,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                await _context.Products.AddAsync(newProduct);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"âœ… Product created: {ProductName} ({ProductId})\", dto.Name, newProduct.Id);\n                return ResponseResult.SuccessInfo(\"âœ… Product added successfully.\", newProduct.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to add product: {ProductName}\", dto.Name);\n                return ResponseResult.ErrorInfo(\"Failed to add product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> RemoveProductAsync(Guid id, Guid businessId)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == id && p.BusinessId == businessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"âŒ Attempted to delete non-existent product: {ProductId}\", id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                _context.Products.Remove(product);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"ðŸ—‘ï¸ Product deleted: {ProductId}\", id);\n                return ResponseResult.SuccessInfo(\"ðŸ—‘ï¸ Product deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to delete product: {ProductId}\", id);\n                return ResponseResult.ErrorInfo(\"Failed to delete product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> UpdateProductAsync(UpdateProductDto dto)\n        {\n            try\n            {\n                var product = await _context.Products\n                    .FirstOrDefaultAsync(p => p.Id == dto.Id && p.BusinessId == dto.BusinessId);\n\n                if (product == null)\n                {\n                    Log.Warning(\"âŒ Attempted to update non-existent product: {ProductId}\", dto.Id);\n                    return ResponseResult.ErrorInfo(\"Product not found.\");\n                }\n\n                product.Name = dto.Name;\n                product.Description = dto.Description;\n                product.Price = dto.Price;\n                product.Currency = dto.Currency;\n                product.ImageUrl = dto.ImageUrl;\n\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"âœ… Product updated: {ProductId}\", dto.Id);\n                return ResponseResult.SuccessInfo(\"âœ… Product updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to update product: {ProductId}\", dto.Id);\n                return ResponseResult.ErrorInfo(\"Failed to update product.\", ex.Message);\n            }\n        }\n\n        public async Task<ResponseResult> GetProductsByBusinessIdAsync(Guid businessId)\n        {\n            try\n            {\n                var products = await _context.Products\n                    .Where(p => p.BusinessId == businessId && p.IsActive)\n                    .Select(p => new ProductDto\n                    {\n                        Id = p.Id,\n                        BusinessId = p.BusinessId,\n                        Name = p.Name,\n                        Description = p.Description,\n                        Price = p.Price,\n                        Currency = p.Currency,\n                        ImageUrl = p.ImageUrl,\n                        IsActive = p.IsActive\n                    })\n                    .ToListAsync();\n\n                return ResponseResult.SuccessInfo(\"Products fetched.\", products);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to fetch products for BusinessId: {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"Failed to fetch products.\", ex.Message);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs",
      "sha256": "a4d7703060f27a3527a15f3159f436e52c46728ed6d1fa07570a4e002bcc0e0f",
      "language": "csharp",
      "size": 7002,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/Controllers/ChatInboxController.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.ChatInbox.Services;\n\nnamespace xbytechat.api.Features.ChatInbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/chat-inbox\")]\n    public sealed class ChatInboxController : ControllerBase\n    {\n        private readonly IChatInboxQueryService _queryService;\n        private readonly IChatInboxCommandService _commandService;\n\n        public ChatInboxController(\n            IChatInboxQueryService queryService,\n            IChatInboxCommandService commandService)\n        {\n            _queryService = queryService ?? throw new ArgumentNullException(nameof(queryService));\n            _commandService = commandService ?? throw new ArgumentNullException(nameof(commandService));\n        }\n\n        // ðŸš© Conversations list\n        [HttpGet(\"conversations\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxConversationDto>), 200)]\n        public async Task<IActionResult> GetConversations(\n            [FromQuery] Guid businessId,\n            [FromQuery] Guid? currentUserId,\n            [FromQuery] string? tab,\n            [FromQuery] string? numberId,\n            [FromQuery] string? search,\n            [FromQuery] int? limit,\n            CancellationToken cancellationToken)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            var filter = new ChatInboxFilterDto\n            {\n                BusinessId = businessId,\n                CurrentUserId = currentUserId,\n                Tab = tab,\n                NumberId = string.IsNullOrWhiteSpace(numberId) ? null : numberId,\n                SearchTerm = string.IsNullOrWhiteSpace(search) ? null : search,\n                Limit = limit.GetValueOrDefault(50),\n            };\n\n            switch (tab?.ToLowerInvariant())\n            {\n                case \"unassigned\":\n                    filter.OnlyUnassigned = true;\n                    break;\n                case \"my\":\n                    filter.OnlyAssignedToMe = true;\n                    break;\n            }\n\n            var result = await _queryService.GetConversationsAsync(filter, cancellationToken);\n            return Ok(result);\n        }\n\n        // ðŸ’¬ Messages for a conversation\n        [HttpGet(\"messages\")]\n        [ProducesResponseType(typeof(IReadOnlyList<ChatInboxMessageDto>), 200)]\n        public async Task<ActionResult<IReadOnlyList<ChatInboxMessageDto>>> GetMessages(\n            [FromQuery] Guid businessId,\n            [FromQuery] string contactPhone,\n            [FromQuery] int limit = 50,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n            {\n                return BadRequest(\"businessId is required.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n            {\n                return BadRequest(\"contactPhone is required.\");\n            }\n\n            var messages = await _queryService.GetMessagesForConversationAsync(\n                businessId,\n                contactPhone,\n                limit,\n                ct);\n\n            return Ok(messages);\n        }\n\n        // ðŸ“¤ Send a message from agent â†’ customer (used by Chat Inbox middle panel)\n        [HttpPost(\"send-message\")]\n        [ProducesResponseType(typeof(ChatInboxMessageDto), 200)]\n        public async Task<ActionResult<ChatInboxMessageDto>> SendMessage(\n            [FromBody] ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            var result = await _commandService.SendAgentMessageAsync(request, ct);\n            return Ok(result);\n        }\n\n        // âœ… Mark conversation as read for current user\n        [HttpPost(\"mark-read\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> MarkRead(\n            [FromBody] ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            await _commandService.MarkConversationAsReadAsync(request, ct);\n            return NoContent();\n        }\n\n        // ðŸ‘¤ Assign conversation to an agent\n        [HttpPost(\"assign\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> Assign(\n            [FromBody] ChatInboxAssignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty ||\n                request.UserId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId, ContactId and UserId are required.\");\n            }\n\n            await _commandService.AssignConversationAsync(request, ct);\n            return NoContent();\n        }\n\n        // ðŸš« Unassign conversation\n        [HttpPost(\"unassign\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> Unassign(\n            [FromBody] ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty ||\n                request.ContactId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId and ContactId are required.\");\n            }\n\n            await _commandService.UnassignConversationAsync(request, ct);\n            return NoContent();\n        }\n\n        [HttpPost(\"status\")]\n        [ProducesResponseType(204)]\n        public async Task<IActionResult> ChangeStatus(\n            [FromBody] ChatInboxChangeStatusRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null)\n            {\n                return BadRequest(\"Request body is required.\");\n            }\n\n            if (request.BusinessId == Guid.Empty || request.ContactId == Guid.Empty)\n            {\n                return BadRequest(\"BusinessId and ContactId are required.\");\n            }\n\n            await _commandService.ChangeConversationStatusAsync(request, ct);\n            return NoContent();\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs",
      "sha256": "1070b71e595443da5bb86c5ae223123d517333fd06193925c55359d7d2e869ae",
      "language": "csharp",
      "size": 1156,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxAssignRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for assigning a conversation (contact) to a specific user.\n    /// </summary>\n    public sealed class ChatInboxAssignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Agent/user who will own this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n    }\n\n    /// <summary>\n    /// Request payload for unassigning a conversation.\n    /// </summary>\n    public sealed class ChatInboxUnassignRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact id representing the conversation.\n        /// </summary>\n        public Guid ContactId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs",
      "sha256": "272eac87602469cf471a8599cfe4fecc87e11b2cb22b59c430a28de6e1296a39",
      "language": "csharp",
      "size": 923,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxChangeStatusRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Command payload for changing the status of an Inbox conversation.\n    /// Internally this maps to Contact.IsArchived / IsActive.\n    /// </summary>\n    public sealed class ChatInboxChangeStatusRequestDto\n    {\n        /// <summary>\n        /// Tenant / business id (required).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Contact whose conversation we want to change (required).\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Target status: \"Open\" | \"Closed\" (case-insensitive).\n        /// We also accept \"New\"/\"Pending\" but treat them as Open internally.\n        /// </summary>\n        public string? TargetStatus { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs",
      "sha256": "76991e3473373fb2fb8f90fbb2191461275be41a786a6b5e04dbf02ac32b3668",
      "language": "csharp",
      "size": 2451,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxConversationDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Lightweight conversation summary for the Chat Inbox UI.\n    /// Mirrors the front-end ConversationSummary model.\n    /// </summary>\n    public sealed class ChatInboxConversationDto\n    {\n        /// <summary>\n        /// Conversation identifier for the UI.\n        /// For v1 this can be derived from (ContactId + NumberId).\n        /// In the future, if you create an InboxConversation table,\n        /// use its primary key here.\n        /// </summary>\n        public string Id { get; set; } = default!;\n\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } = string.Empty;\n        public string ContactPhone { get; set; } = string.Empty;\n\n        public string LastMessagePreview { get; set; } = string.Empty;\n        public DateTime LastMessageAt { get; set; }\n\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// \"New\" | \"Open\" | \"Pending\" | \"Closed\"\n        /// </summary>\n        public string Status { get; set; } = \"New\";\n\n        /// <summary>\n        /// WhatsApp number id (e.g. wa-num-1).\n        /// Later you may map this to WhatsAppPhoneNumber.Id.\n        /// </summary>\n        public string NumberId { get; set; } = string.Empty;\n\n        public string NumberLabel { get; set; } = string.Empty;\n\n        /// <summary>\n        /// True if within 24h messaging window (WhatsApp session).\n        /// </summary>\n        public bool Within24h { get; set; }\n\n        public string? AssignedToUserId { get; set; }\n        public string? AssignedToUserName { get; set; }\n        public bool IsAssignedToMe { get; set; }\n\n        /// <summary>\n        /// \"automation\" | \"agent\"\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// \"AutoReply\" | \"Campaign\" | \"Manual\" | \"Unknown\"\n        /// </summary>\n        public string SourceType { get; set; } = \"Unknown\";\n\n        /// <summary>\n        /// Campaign name / AutoReply flow name / other source label.\n        /// </summary>\n        public string? SourceName { get; set; }\n\n        public DateTime? FirstSeenAt { get; set; }\n        public int TotalMessages { get; set; }\n\n        public DateTime? LastAgentReplyAt { get; set; }\n        public DateTime? LastAutomationAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs",
      "sha256": "edeb9ca6d210c4107c4f2982f08c387f6350b04fd2bf31bfbe643f36b2b97729",
      "language": "csharp",
      "size": 1707,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxFilterDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Filters used by the Chat Inbox conversation list endpoint.\n    /// This matches the UI needs: tab, number, search, \"my\" vs \"unassigned\".\n    /// </summary>\n    public sealed class ChatInboxFilterDto\n    {\n        /// <summary>\n        /// Business Id (tenant). Mandatory for multi-tenant isolation.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Currently logged-in user id (for \"my\" filter).\n        /// Optional: if null, \"my\" filter is ignored.\n        /// </summary>\n        public Guid? CurrentUserId { get; set; }\n\n        /// <summary>\n        /// \"live\" | \"history\" | \"unassigned\" | \"my\"\n        /// </summary>\n        public string? Tab { get; set; }\n\n        /// <summary>\n        /// WhatsApp number id, e.g. \"wa-num-1\". If null or \"all\", no filter.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Free text search over name, phone, and last message preview.\n        /// </summary>\n        public string? SearchTerm { get; set; }\n\n        /// <summary>\n        /// Max number of conversations to return. Hard-capped to 200.\n        /// </summary>\n        public int Limit { get; set; } = 50;\n\n        /// <summary>\n        /// If true: only conversations without AssignedToUserId.\n        /// </summary>\n        public bool OnlyUnassigned { get; set; }\n\n        /// <summary>\n        /// If true: only conversations assigned to CurrentUserId.\n        /// </summary>\n        public bool OnlyAssignedToMe { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs",
      "sha256": "9375b5c5b9178604658d3f966c53db98de8d656c7eef85e219477f817cd16df8",
      "language": "csharp",
      "size": 1031,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMarkReadRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for marking a conversation as \"read\"\n    /// for a given user in the Chat Inbox.\n    /// </summary>\n    public sealed class ChatInboxMarkReadRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id whose messages are being marked as read.\n        /// </summary>\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// The user (agent) that just read this conversation.\n        /// </summary>\n        public Guid UserId { get; set; }\n\n        /// <summary>\n        /// Optional timestamp for \"last read\". If not supplied,\n        /// the server will use DateTime.UtcNow.\n        /// </summary>\n        public DateTime? LastReadAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs",
      "sha256": "c75975d0670537a2936e7dd5a8e79c9bd7bdbed9de88fc166b02e78200c61c45",
      "language": "csharp",
      "size": 1804,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Single message in a Chat Inbox conversation.\n    /// Kept intentionally simple and stable so the React UI\n    /// can bind to it without worrying about provider details.\n    /// </summary>\n    public sealed class ChatInboxMessageDto\n    {\n        public Guid Id { get; set; }\n\n        /// <summary>\n        /// \"in\"  = message came from customer to us.\n        /// \"out\" = message we sent to customer.\n        /// For now we only have reliable data for \"out\"; we keep\n        /// the string type so we can extend it later without schema changes.\n        /// </summary>\n        public string Direction { get; set; } = \"out\";\n\n        /// <summary>\n        /// Channel identifier (e.g. \"whatsapp\") â€“ future-proofing.\n        /// </summary>\n        public string Channel { get; set; } = \"whatsapp\";\n\n        /// <summary>\n        /// Rendered text content for the bubble.\n        /// For templates weâ€™ll store the final rendered body.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n\n        /// <summary>\n        /// When we created/sent the message (UTC).\n        /// If SentAt is missing, falls back to CreatedAt.\n        /// </summary>\n        public DateTime SentAtUtc { get; set; }\n\n        /// <summary>\n        /// Provider / delivery status (â€œSentâ€, â€œDeliveredâ€, â€œReadâ€, â€œFailedâ€, etc.),\n        /// mapped from MessageLog.Status.\n        /// </summary>\n        public string? Status { get; set; }\n\n        /// <summary>\n        /// For failed messages, a short error string from MessageLog.ErrorMessage.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs",
      "sha256": "2b73973de1d335932a58540ba4a31877247732c77d7ddc345d910b40883913af",
      "language": "csharp",
      "size": 1554,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/DTOs/ChatInboxSendMessageRequestDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Request payload for sending an agent reply from the Chat Inbox.\n    /// This is what the React ChatInbox.jsx will POST.\n    /// </summary>\n    public sealed class ChatInboxSendMessageRequestDto\n    {\n        /// <summary>\n        /// Tenant/business id (required for multi-tenant isolation).\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Conversation id from the UI. For v1 this is typically ContactId.ToString().\n        /// Mainly for tracing; not mandatory for the send logic.\n        /// </summary>\n        public string? ConversationId { get; set; }\n\n        /// <summary>\n        /// CRM Contact id for this chat (preferred for lookups).\n        /// </summary>\n        public Guid? ContactId { get; set; }\n\n        /// <summary>\n        /// Target phone number (normalized WhatsApp number).\n        /// Same as selectedConversation.contactPhone in the UI.\n        /// </summary>\n        public string To { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Optional: which WhatsApp number we are sending from\n        /// (e.g. \"wa-1\"). Useful when you support multiple WABA numbers.\n        /// </summary>\n        public string? NumberId { get; set; }\n\n        /// <summary>\n        /// Message body typed by the agent.\n        /// </summary>\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/DTOs/ConversationSummaryDto.cs",
      "sha256": "8d4800233670cbca833d145eba5da1a64e0b2a520e5f5bfc65ea5a36c2c9ce86",
      "language": "csharp",
      "size": 2421,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.ChatInbox.DTOs\n{\n    /// <summary>\n    /// Read model used by the Chat Inbox to show the left-hand conversation list.\n    /// Mirrors the shape used in ChatInbox.jsx (INITIAL_CONVERSATIONS).\n    /// </summary>\n    public class ConversationSummaryDto\n    {\n        public Guid ContactId { get; set; }\n\n        /// <summary>\n        /// Primary display name (CRM contact name).\n        /// </summary>\n        public string? Name { get; set; }\n\n        /// <summary>\n        /// WhatsApp phone number (normalized).\n        /// </summary>\n        public string PhoneNumber { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Latest WhatsApp profile.name we saw.\n        /// </summary>\n        public string? ProfileName { get; set; }\n\n        /// <summary>\n        /// Short preview of the last message in this conversation.\n        /// </summary>\n        public string? LastMessagePreview { get; set; }\n\n        /// <summary>\n        /// When the last message was seen/sent.\n        /// </summary>\n        public DateTime? LastMessageAt { get; set; }\n\n        /// <summary>\n        /// Count of unread inbound messages for this contact.\n        /// </summary>\n        public int UnreadCount { get; set; }\n\n        /// <summary>\n        /// Priority like \"Hot\", \"Warm\", \"Cold\" (CRM-driven, optional).\n        /// </summary>\n        public string? Priority { get; set; }\n\n        /// <summary>\n        /// True if this contact is treated as VIP or important.\n        /// </summary>\n        public bool IsVip { get; set; }\n\n        /// <summary>\n        /// Conversation mode: \"automation\" or \"agent\".\n        /// </summary>\n        public string Mode { get; set; } = \"automation\";\n\n        /// <summary>\n        /// Name of the assigned agent (if any).\n        /// </summary>\n        public string? AssignedAgentName { get; set; }\n\n        /// <summary>\n        /// CRM tags as chips for quick context (e.g. VIP, Lead, Follow-up).\n        /// </summary>\n        public List<string> Tags { get; set; } = new();\n\n        /// <summary>\n        /// Text like \"3 notes â€¢ 1 reminder today\".\n        /// </summary>\n        public string? LastActivitySummary { get; set; }\n\n        /// <summary>\n        /// Text like \"Next follow-up tomorrow at 11:30 AM\".\n        /// </summary>\n        public string? TaskSummary { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs",
      "sha256": "7dc0c8eb585a5b0432d326d952073ca870913b850b774b051dedc0d077c3e409",
      "language": "csharp",
      "size": 11813,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/Services/ChatInboxCommandService.cs\nusing System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Models;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Default write-side handler for Chat Inbox actions.\n    /// Delegates the actual send to the central MessagesEngine so that\n    /// MessageLogs / provider calls stay consistent across the app.\n    /// Also manages per-user read state (ContactReads) and assignment.\n    /// </summary>\n    public sealed class ChatInboxCommandService : IChatInboxCommandService\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n\n        public ChatInboxCommandService(\n            AppDbContext db,\n            IMessageEngineService messageEngine)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n        }\n\n        public async Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.To))\n                throw new ArgumentException(\"Target phone (To) is required.\", nameof(request));\n\n            if (string.IsNullOrWhiteSpace(request.Text))\n                throw new ArgumentException(\"Text is required.\", nameof(request));\n\n            var businessId = request.BusinessId;\n            var phone = request.To.Trim();\n\n            // ðŸ”Ž Resolve contact:\n            Guid? contactId = request.ContactId;\n\n            if (!contactId.HasValue)\n            {\n                var contact = await _db.Contacts\n                    .AsNoTracking()\n                    .Where(c => c.BusinessId == businessId && c.PhoneNumber == phone)\n                    .FirstOrDefaultAsync(ct)\n                    .ConfigureAwait(false);\n\n                contactId = contact?.Id;\n            }\n\n            var effectiveContactId = contactId ?? Guid.Empty;\n\n            // ðŸ“¨ Build the DTO expected by MessagesEngine text pipeline.\n            var textDto = new TextMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = phone,\n                TextContent = request.Text,\n                ContactId = effectiveContactId,\n                PhoneNumberId = string.IsNullOrWhiteSpace(request.NumberId)\n                    ? null\n                    : request.NumberId.Trim(),\n                Provider = null,         // let engine resolve default provider/number\n                Source = \"agent\"         // so analytics can separate human replies\n            };\n\n            // ðŸ§  Delegate to the central MessagesEngine.\n            var result = await _messageEngine\n                .SendTextDirectAsync(textDto)\n                .ConfigureAwait(false);\n\n            // Try to load the MessageLog row so we can return a rich bubble DTO.\n            MessageLog? log = null;\n            if (result.LogId.HasValue)\n            {\n                log = await _db.MessageLogs\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(m => m.Id == result.LogId.Value, ct)\n                    .ConfigureAwait(false);\n            }\n\n            var nowUtc = DateTime.UtcNow;\n            var sentAt = nowUtc;\n            var bubbleText = request.Text;\n            string? status = null;\n            string? errorMessage = null;\n            Guid bubbleId;\n\n            if (log != null)\n            {\n                bubbleId = log.Id;\n                bubbleText = log.MessageContent ?? request.Text;\n\n                var ts = log.SentAt ?? log.CreatedAt;\n                sentAt = ts.Kind == DateTimeKind.Utc ? ts : ts.ToUniversalTime();\n\n                status = log.Status;\n                errorMessage = log.ErrorMessage;\n            }\n            else\n            {\n                bubbleId = Guid.NewGuid();\n                sentAt = nowUtc;\n                status = result.Success ? \"Sent\" : \"Failed\";\n                errorMessage = result.Success ? null : result.Message;\n            }\n\n            // ðŸ§± Map to ChatInboxMessageDto so the UI can render the bubble immediately.\n            var dto = new ChatInboxMessageDto\n            {\n                Id = bubbleId,\n                Direction = \"out\",           // agent â†’ customer\n                Channel = \"whatsapp\",\n                Text = bubbleText,\n                SentAtUtc = sentAt,\n                Status = status,\n                ErrorMessage = errorMessage\n            };\n\n            return dto;\n        }\n\n        public async Task MarkConversationAsReadAsync(\n            ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            if (request.UserId == Guid.Empty)\n                throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n            var businessId = request.BusinessId;\n            var contactId = request.ContactId;\n            var userId = request.UserId;\n            var nowUtc = DateTime.UtcNow;\n\n            var lastReadAt = request.LastReadAtUtc.HasValue\n                ? (request.LastReadAtUtc.Value.Kind == DateTimeKind.Utc\n                    ? request.LastReadAtUtc.Value\n                    : request.LastReadAtUtc.Value.ToUniversalTime())\n                : nowUtc;\n\n            // Either insert or update ContactReads row.\n            var existing = await _db.ContactReads\n                .FirstOrDefaultAsync(\n                    r => r.BusinessId == businessId\n                         && r.ContactId == contactId\n                         && r.UserId == userId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (existing == null)\n            {\n                var entity = new ContactRead\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    UserId = userId,\n                    LastReadAt = lastReadAt\n                };\n\n                await _db.ContactReads.AddAsync(entity, ct).ConfigureAwait(false);\n            }\n            else\n            {\n                // Only move forward in time; never move LastReadAt backwards.\n                if (existing.LastReadAt < lastReadAt)\n                {\n                    existing.LastReadAt = lastReadAt;\n                    _db.ContactReads.Update(existing);\n                }\n            }\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task AssignConversationAsync(\n            ChatInboxAssignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            if (request.UserId == Guid.Empty)\n                throw new ArgumentException(\"UserId is required.\", nameof(request));\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for assignment.\");\n            }\n\n            contact.AssignedAgentId = request.UserId;\n            _db.Contacts.Update(contact);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task UnassignConversationAsync(\n            ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for unassign.\");\n            }\n\n            contact.AssignedAgentId = null;\n            _db.Contacts.Update(contact);\n\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n\n        public async Task ChangeConversationStatusAsync(\n           ChatInboxChangeStatusRequestDto request,\n           CancellationToken ct = default)\n        {\n            if (request == null) throw new ArgumentNullException(nameof(request));\n\n            if (request.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(request));\n\n            if (request.ContactId == Guid.Empty)\n                throw new ArgumentException(\"ContactId is required.\", nameof(request));\n\n            var rawStatus = request.TargetStatus ?? string.Empty;\n            var normalized = rawStatus.Trim();\n\n            if (string.IsNullOrEmpty(normalized))\n                throw new ArgumentException(\"TargetStatus is required.\", nameof(request));\n\n            normalized = normalized.ToLowerInvariant();\n\n            // We accept: \"open\", \"closed\", \"new\", \"pending\"\n            var close = normalized switch\n            {\n                \"closed\" => true,\n                \"open\" => false,\n                \"new\" => false,\n                \"pending\" => false,\n                _ => throw new ArgumentException(\n                    \"TargetStatus must be one of: Open, Closed, New, Pending.\",\n                    nameof(request))\n            };\n\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(\n                    c => c.BusinessId == request.BusinessId && c.Id == request.ContactId,\n                    ct)\n                .ConfigureAwait(false);\n\n            if (contact == null)\n            {\n                throw new InvalidOperationException(\"Contact not found for status change.\");\n            }\n\n            if (close)\n            {\n                contact.IsArchived = true;\n                contact.IsActive = false;\n            }\n            else\n            {\n                contact.IsArchived = false;\n                contact.IsActive = true;\n            }\n\n            _db.Contacts.Update(contact);\n            await _db.SaveChangesAsync(ct).ConfigureAwait(false);\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs",
      "sha256": "d5a3d95f42b211f1232fd16ff6d0868ae3ec2d9f8ecf9751c385d08bbdd828dc",
      "language": "csharp",
      "size": 17553,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/Services/ChatInboxQueryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.ChatInbox.DTOs;\nusing xbytechat.api.Models; // AppDbContext\n// We avoid referencing MessageLog / Contact types by name so we don't fight namespaces.\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Default implementation of IChatInboxQueryService.\n    /// \n    /// v1 implementation:\n    ///  - Groups MessageLogs by ContactId for a Business.\n    ///  - Joins Contacts for display name / phone.\n    ///  - Computes last message, unread count (per user), 24h window, assignment flags.\n    ///  - Applies tab filters (\"live\", \"history\", \"unassigned\", \"my\") and search.\n    /// \n    /// This is intentionally conservative and can be optimized later\n    /// (server-side aggregates, better indexes, source-type mapping, etc.).\n    /// </summary>\n    public sealed class ChatInboxQueryService : IChatInboxQueryService\n    {\n        private readonly AppDbContext _db;\n\n        public ChatInboxQueryService(AppDbContext db)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n        }\n\n        public async Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default)\n        {\n            if (filter == null) throw new ArgumentNullException(nameof(filter));\n            if (filter.BusinessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId is required.\", nameof(filter));\n\n            // Hard cap to avoid insane result sets\n            var limit = filter.Limit <= 0 ? 50 : filter.Limit;\n            if (limit > 200) limit = 200;\n\n            var businessId = filter.BusinessId;\n            var currentUserId = filter.CurrentUserId;\n\n            // Base query: all message logs for this business that are linked to a contact.\n            // NOTE: we rely on AppDbContext.MessageLogs and ContactId being non-null for chat contacts.\n            var baseMessagesQuery = _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.ContactId != null);\n\n            // --- 1) Aggregate per contact: last message, first seen, total count ---\n            // This is done server-side; we only bring down a small projection.\n            var convoAggregates = await baseMessagesQuery\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => new\n                {\n                    ContactId = g.Key,\n                    LastMessageAt = g.Max(m => m.CreatedAt),\n                    FirstSeenAt = g.Min(m => m.CreatedAt),\n                    TotalMessages = g.Count()\n                })\n                .OrderByDescending(x => x.LastMessageAt)\n                .Take(limit)\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            if (convoAggregates.Count == 0)\n            {\n                return Array.Empty<ChatInboxConversationDto>();\n            }\n\n            var contactIds = convoAggregates.Select(x => x.ContactId).ToList();\n\n            // --- 2) Load contacts for those ids (CRM) ---\n            // We assume AppDbContext.Contacts exists and has basic fields we need.\n            var contacts = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && contactIds.Contains(c.Id))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var contactsById = contacts.ToDictionary(c => c.Id, c => c);\n\n            // --- 3) Load last messages for preview (one per contact) ---\n            // We re-query MessageLogs but only for the selected contactIds.\n            var lastMessages = await _db.MessageLogs\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId\n                            && m.ContactId != null\n                            && contactIds.Contains(m.ContactId.Value))\n                .GroupBy(m => m.ContactId!.Value)\n                .Select(g => g\n                    .OrderByDescending(m => m.CreatedAt)\n                    .FirstOrDefault())\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var lastMessageByContactId = lastMessages\n                .Where(m => m != null && m.ContactId != null)\n                .ToDictionary(m => m!.ContactId!.Value, m => m!);\n\n            // --- 4) Compute unread counts for the current user (if any) ---\n            var unreadCounts = new Dictionary<Guid, int>();\n\n            if (currentUserId.HasValue)\n            {\n                // ContactReads for this user + business\n                var reads = await _db.ContactReads\n                    .AsNoTracking()\n                    .Where(r => r.BusinessId == businessId\n                                && r.UserId == currentUserId.Value\n                                && contactIds.Contains(r.ContactId))\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                var lastReadByContact = reads.ToDictionary(r => r.ContactId, r => r.LastReadAt);\n\n                // Inbound messages for those contacts\n                var inboundMessages = await _db.MessageLogs\n                    .AsNoTracking()\n                    .Where(m => m.BusinessId == businessId\n                                && m.ContactId != null\n                                && contactIds.Contains(m.ContactId.Value)\n                                && m.IsIncoming)\n                    .Select(m => new { m.ContactId, m.CreatedAt })\n                    .ToListAsync(ct)\n                    .ConfigureAwait(false);\n\n                foreach (var group in inboundMessages.GroupBy(x => x.ContactId!.Value))\n                {\n                    var cid = group.Key;\n                    DateTime? lastRead = null;\n                    if (lastReadByContact.TryGetValue(cid, out var value))\n                    {\n                        lastRead = value;\n                    }\n\n                    var count = lastRead.HasValue\n                        ? group.Count(x => x.CreatedAt > lastRead.Value)\n                        : group.Count();\n\n                    unreadCounts[cid] = count;\n                }\n            }\n\n            // --- 5) Load session state for \"mode\" (automation vs agent), if available ---\n            // We assume ChatSessionStates table exists and tracks Mode + last touch.\n            var sessionStates = await _db.ChatSessionStates\n                .AsNoTracking()\n                .Where(s => s.BusinessId == businessId && contactIds.Contains(s.ContactId))\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            var sessionByContactId = sessionStates.ToDictionary(s => s.ContactId, s => s);\n\n            // --- 6) Build DTOs in memory ---\n            var nowUtc = DateTime.UtcNow;\n            var results = new List<ChatInboxConversationDto>(convoAggregates.Count);\n\n            foreach (var agg in convoAggregates)\n            {\n                if (!contactsById.TryGetValue(agg.ContactId, out var contact))\n                {\n                    // Contact might have been hard-deleted. Skip for now.\n                    continue;\n                }\n\n                lastMessageByContactId.TryGetValue(agg.ContactId, out var lastMsg);\n\n                var preview = lastMsg?.RenderedBody ?? lastMsg?.MessageContent ?? string.Empty;\n                if (preview.Length > 140)\n                {\n                    preview = preview.Substring(0, 140) + \"â€¦\";\n                }\n\n                var unread = unreadCounts.TryGetValue(agg.ContactId, out var count) ? count : 0;\n\n                var within24h = (nowUtc - agg.LastMessageAt).TotalHours <= 24;\n\n                // Conversation status heuristic:\n                // - Archived / inactive contact => Closed\n                // - Else if unread > 0 => Open\n                // - Else => Pending\n                var status =\n                    (contact.IsArchived || !contact.IsActive) ? \"Closed\"\n                    : unread > 0 ? \"Open\"\n                    : \"Pending\";\n\n                // Assignment\n                var assignedUserId = contact.AssignedAgentId;\n                var assignedUserIdString = assignedUserId?.ToString();\n                var isAssignedToMe =\n                    currentUserId.HasValue &&\n                    assignedUserId.HasValue &&\n                    assignedUserId.Value == currentUserId.Value;\n\n                // Mode: if we have ChatSessionState, use that; else infer from last message.\n                string mode = \"automation\";\n                if (sessionByContactId.TryGetValue(agg.ContactId, out var session))\n                {\n                    // Assuming session.Mode is an enum or string; normalize to lower-case string.\n                    mode = session.Mode?.ToString().ToLowerInvariant() ?? \"automation\";\n                }\n                else if (lastMsg != null)\n                {\n                    // Fallback: if last message is an outgoing \"agent\" message\n                    // we treat it as agent mode; otherwise automation.\n                    // (This depends on how you store Source; adjust later.)\n                    if (!lastMsg.IsIncoming && string.Equals(lastMsg.Source, \"agent\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        mode = \"agent\";\n                    }\n                }\n\n                // For v1 we don't yet decode exact SourceType / SourceName from Campaign / AutoReply / CTAFlow.\n                // We'll set \"Unknown\" and fill this later when we wire analytics.\n                var dto = new ChatInboxConversationDto\n                {\n                    // For v1 we use the ContactId as conversation id.\n                    Id = agg.ContactId.ToString(),\n\n                    ContactId = agg.ContactId,\n                    ContactName = string.IsNullOrWhiteSpace(contact.Name)\n                        ? (contact.ProfileName ?? contact.PhoneNumber)\n                        : contact.Name,\n                    ContactPhone = contact.PhoneNumber,\n\n                    LastMessagePreview = preview,\n                    LastMessageAt = agg.LastMessageAt,\n\n                    UnreadCount = unread,\n                    Status = status,\n\n                    // NumberId/NumberLabel: for now we leave empty.\n                    // Once WhatsApp phone mapping is wired, we can fill these.\n                    NumberId = string.Empty,\n                    NumberLabel = string.Empty,\n\n                    Within24h = within24h,\n\n                    AssignedToUserId = assignedUserIdString,\n                    AssignedToUserName = null,  // will be filled in v2 by joining Users table\n                    IsAssignedToMe = isAssignedToMe,\n\n                    Mode = mode,\n                    SourceType = \"Unknown\",\n                    SourceName = null,\n\n                    FirstSeenAt = agg.FirstSeenAt,\n                    TotalMessages = agg.TotalMessages,\n\n                    LastAgentReplyAt = null,     // can be filled later via MessageLogs aggregate\n                    LastAutomationAt = null      // same as above\n                };\n\n                results.Add(dto);\n            }\n\n            // --- 7) Apply tab filters (\"live\", \"history\", \"unassigned\", \"my\") + number + search ---\n\n            IEnumerable<ChatInboxConversationDto> filtered = results;\n\n            if (!string.IsNullOrWhiteSpace(filter.Tab))\n            {\n                var tab = filter.Tab.ToLowerInvariant();\n                switch (tab)\n                {\n                    case \"live\":\n                        filtered = filtered.Where(c => c.Within24h);\n                        break;\n                    case \"history\":\n                        filtered = filtered.Where(c => !c.Within24h);\n                        break;\n                    // \"unassigned\" and \"my\" were already mapped to flags in the controller,\n                    // but we double-check here too (harmless).\n                    case \"unassigned\":\n                        filtered = filtered.Where(c => string.IsNullOrEmpty(c.AssignedToUserId));\n                        break;\n                    case \"my\":\n                        if (currentUserId.HasValue)\n                        {\n                            filtered = filtered.Where(c => c.IsAssignedToMe);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            if (filter.OnlyUnassigned)\n            {\n                filtered = filtered.Where(c => string.IsNullOrEmpty(c.AssignedToUserId));\n            }\n\n            if (filter.OnlyAssignedToMe && currentUserId.HasValue)\n            {\n                filtered = filtered.Where(c => c.IsAssignedToMe);\n            }\n\n            // NumberId filter: for now we don't yet know which number a conversation belongs to.\n            // Once MessageLogs have NumberId / PhoneNumberId we can populate dto.NumberId and filter here.\n            if (!string.IsNullOrWhiteSpace(filter.NumberId)\n                && !string.Equals(filter.NumberId, \"all\", StringComparison.OrdinalIgnoreCase))\n            {\n                filtered = filtered.Where(c => string.Equals(c.NumberId, filter.NumberId, StringComparison.OrdinalIgnoreCase));\n            }\n\n            // Search: name, phone, last message preview (case-insensitive)\n            if (!string.IsNullOrWhiteSpace(filter.SearchTerm))\n            {\n                var term = filter.SearchTerm.Trim();\n                var termLower = term.ToLowerInvariant();\n\n                filtered = filtered.Where(c =>\n                    (!string.IsNullOrEmpty(c.ContactName) && c.ContactName.ToLowerInvariant().Contains(termLower)) ||\n                    (!string.IsNullOrEmpty(c.ContactPhone) && c.ContactPhone.Contains(term)) ||\n                    (!string.IsNullOrEmpty(c.LastMessagePreview) && c.LastMessagePreview.ToLowerInvariant().Contains(termLower)));\n            }\n\n            // Final cap (defensive)\n            var finalList = filtered\n                .OrderByDescending(c => c.LastMessageAt)\n                .Take(limit)\n                .ToList();\n\n            return finalList;\n        }\n\n        // ðŸ’¬ Messages for a single conversation (center pane)\n        // inside ChatInboxQueryService\n\n        // ðŸ’¬ Messages for a single conversation (center pane)\n        // inside ChatInboxQueryService\n\n        public async Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"BusinessId must be a non-empty GUID.\", nameof(businessId));\n\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"Contact phone is required.\", nameof(contactPhone));\n\n            if (limit <= 0)\n                limit = 50;\n            if (limit > 500)\n                limit = 500;\n\n            var trimmedPhone = contactPhone.Trim();\n\n            // ðŸŸ¢ Step 1: resolve ContactId from phone number for this business\n            var contactId = await _db.Contacts\n                .AsNoTracking()\n                .Where(c => c.BusinessId == businessId && c.PhoneNumber == trimmedPhone)\n                .Select(c => (Guid?)c.Id)\n                .FirstOrDefaultAsync(ct)\n                .ConfigureAwait(false);\n\n            if (contactId == null)\n            {\n                // No such contact â†’ no messages\n                return Array.Empty<ChatInboxMessageDto>();\n            }\n\n            // ðŸŸ¢ Step 2: fetch all messages for this contact (both directions)\n            var query = _db.MessageLogs\n                .AsNoTracking()\n                .Where(x => x.BusinessId == businessId &&\n                            x.ContactId == contactId.Value);\n\n            // Newest first\n            query = query\n                .OrderByDescending(x => x.SentAt ?? x.CreatedAt)\n                .ThenByDescending(x => x.Id)\n                .Take(limit);\n\n            var rows = await query\n                .ToListAsync(ct)\n                .ConfigureAwait(false);\n\n            // Map to DTOs (newest â†’ oldest; UI can reverse if needed).\n            var list = rows\n                .Select(x =>\n                {\n                    var instant = x.SentAt ?? x.CreatedAt;\n                    var utcInstant = instant.Kind == DateTimeKind.Utc\n                        ? instant\n                        : instant.ToUniversalTime();\n\n                    return new ChatInboxMessageDto\n                    {\n                        Id = x.Id,\n\n                        // âœ… Use MessageLog.IsIncoming to decide bubble side\n                        Direction = x.IsIncoming ? \"in\" : \"out\",\n\n                        Channel = \"whatsapp\",\n\n                        // Prefer rendered template body when available\n                        Text = x.RenderedBody ?? x.MessageContent ?? string.Empty,\n\n                        SentAtUtc = utcInstant,\n                        Status = x.Status,\n                        ErrorMessage = x.ErrorMessage\n                    };\n                })\n                .ToList();\n\n            return list;\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxCommandService.cs",
      "sha256": "4741408b7d2642c02f2c810518a363a0a18086afbf5fe1dbd5a30b8c66936951",
      "language": "csharp",
      "size": 1165,
      "content": "using xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    public interface IChatInboxCommandService\n    {\n        /// <summary>\n        /// Sends an agent-authored text message to a contact from the Chat Inbox\n        /// and returns the resulting message DTO for the UI bubble.\n        /// </summary>\n        Task<ChatInboxMessageDto> SendAgentMessageAsync(\n            ChatInboxSendMessageRequestDto request,\n            CancellationToken ct = default);\n        Task MarkConversationAsReadAsync(\n            ChatInboxMarkReadRequestDto request,\n            CancellationToken ct = default);\n\n        Task AssignConversationAsync(\n           ChatInboxAssignRequestDto request,\n           CancellationToken ct = default);\n\n        /// <summary>\n        /// Unassigns a conversation (sets AssignedAgentId to null).\n        /// </summary>\n        Task UnassignConversationAsync(\n            ChatInboxUnassignRequestDto request,\n            CancellationToken ct = default);\n\n        Task ChangeConversationStatusAsync(\n           ChatInboxChangeStatusRequestDto request,\n           CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs",
      "sha256": "12fea9a47aa0deb5812b81de304846b9de47b8d4ed1cda7b11eb159a7353ac13",
      "language": "csharp",
      "size": 870,
      "content": "// ðŸ“„ xbytechat-api/Features/ChatInbox/Services/IChatInboxQueryService.cs\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.ChatInbox.DTOs;\n\nnamespace xbytechat.api.Features.ChatInbox.Services\n{\n    /// <summary>\n    /// Read-only query service for Chat Inbox conversations.\n    /// This is a pure \"read model\" projection over MessageLogs + CRM.\n    /// </summary>\n    public interface IChatInboxQueryService\n    {\n        Task<IReadOnlyList<ChatInboxConversationDto>> GetConversationsAsync(\n            ChatInboxFilterDto filter,\n            CancellationToken ct = default);\n        Task<IReadOnlyList<ChatInboxMessageDto>> GetMessagesForConversationAsync(\n            Guid businessId,\n            string contactPhone,\n            int limit,\n            CancellationToken ct = default);\n    }\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/ContactsController.cs",
      "sha256": "91d4a67e40e7f64a2681fc17937e9d420cacf129993c12967cb41f3a03968377",
      "language": "csharp",
      "size": 8378,
      "content": "using CsvHelper.Configuration;\nusing CsvHelper;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Globalization;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ContactsController : ControllerBase\n    {\n        private readonly IContactService _contactService;\n        private readonly ILogger<ContactsController> _logger;\n        public ContactsController(IContactService contactService, ILogger<ContactsController> logger)\n        {\n            _contactService = contactService;\n            _logger = logger;\n        }\n\n        // POST: api/contacts\n        [HttpPost(\"create\")]\n        public async Task<IActionResult> AddContact([FromBody] ContactDto dto)\n        {\n            if (!ModelState.IsValid)\n                return BadRequest(ResponseResult.ErrorInfo(\"âŒ Invalid contact payload.\"));\n\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _contactService.AddContactAsync(businessId, dto);\n\n                return result.Success\n                    ? Ok(result)\n                    : BadRequest(result); // Already ResponseResult.ErrorInfo\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ðŸš¨ Unexpected error in AddContact\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"ðŸš¨ Server error while creating contact.\", ex.ToString()));\n            }\n        }\n\n\n\n\n        // GET: api/contacts/{id}\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetContactById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var contact = await _contactService.GetContactByIdAsync(businessId, id);\n            if (contact == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Contact loaded.\", contact));\n        }\n\n        // PUT: api/contacts/{id}\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateContact(Guid id, [FromBody] ContactDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            dto.Id = id;\n            var success = await _contactService.UpdateContactAsync(businessId, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Contact updated.\"));\n        }\n\n        // DELETE: api/contacts/{id}\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteContact(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _contactService.DeleteContactAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Contact deleted.\"));\n        }\n\n        // POST: api/contacts/parse-csv\n        [ApiExplorerSettings(IgnoreApi = true)]\n        [HttpPost(\"parse-csv\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> ParseCsvToContactsAsync([FromForm] IFormFile file)\n        {\n            if (file == null || file.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n            using var stream = file.OpenReadStream();\n\n            try\n            {\n                var parseResult = await _contactService.ParseCsvToContactsAsync(businessId, stream);\n                return Ok(ResponseResult.SuccessInfo(\"CSV parsed with detailed results.\", parseResult));\n            }\n            catch (Exception ex)\n            {\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV parsing failed: \" + ex.Message));\n            }\n        }\n\n        // PATCH: /api/contacts/{id}/favorite\n        [HttpPatch(\"{id}/favorite\")]\n        public async Task<IActionResult> ToggleFavorite(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _contactService.ToggleFavoriteAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Favorite toggled.\"));\n        }\n\n        // PATCH: /api/contacts/{id}/archive\n        [HttpPatch(\"{id}/archive\")]\n        public async Task<IActionResult> ToggleArchive(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _contactService.ToggleArchiveAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Contact not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Archive toggled.\"));\n        }\n\n        // POST: api/contacts/bulk-assign-tag\n        [HttpPost(\"bulk-assign-tag\")]\n        public async Task<IActionResult> AssignTagToContacts([FromBody] AssignTagToContactsDto dto)\n        {\n            if (dto.ContactIds == null || !dto.ContactIds.Any())\n                return BadRequest(ResponseResult.ErrorInfo(\"No contact IDs provided.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n            await _contactService.AssignTagToContactsAsync(businessId, dto.ContactIds, dto.TagId);\n\n            return Ok(ResponseResult.SuccessInfo(\"Tag assigned to selected contacts.\"));\n        }\n\n        //[HttpGet(\"contacts\")]\n        [HttpGet]\n        public async Task<IActionResult> GetAllContacts(\n        [FromQuery] string? tab = \"all\",\n        [FromQuery] int page = 1,\n        [FromQuery] int pageSize = 25)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var pagedResult = await _contactService.GetPagedContactsAsync(businessId, tab, page, pageSize);\n            return Ok(ResponseResult.SuccessInfo(\"Contacts loaded.\", pagedResult));\n        }\n        // GET: api/contacts/all\n        [HttpGet(\"all\")]\n        public async Task<IActionResult> GetAllContactsFlat()\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var allContacts = await _contactService.GetAllContactsAsync(businessId); // This returns IEnumerable<ContactDto>\n            return Ok(allContacts); // Returns plain array!\n        }\n\n        [HttpPost(\"filter-by-tags\")]\n        public async Task<IActionResult> GetContactsByTags([FromBody] List<string> tags)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n\n            // âœ… Convert to Guid list safely\n            var tagGuids = tags\n                .Where(x => Guid.TryParse(x, out _))\n                .Select(Guid.Parse)\n                .ToList();\n\n            var contacts = await _contactService.GetContactsByTagsAsync(businessId, tagGuids);\n\n            return Ok(ResponseResult.SuccessInfo(\"Contacts filtered successfully\", contacts));\n        }\n\n        [HttpPost(\"bulk-import\")]\n        [Consumes(\"multipart/form-data\")]\n        public async Task<IActionResult> BulkImportContactsAsync(IFormFile file)\n        {\n            if (file == null || file.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required.\"));\n\n            var businessId = HttpContext.User.GetBusinessId();\n\n            try\n            {\n                var result = await _contactService.BulkImportAsync(businessId, file.OpenReadStream());\n                return Ok(ResponseResult.SuccessInfo(\"Contacts imported successfully.\", result));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Bulk import failed.\");\n                return BadRequest(ResponseResult.ErrorInfo(\"Import failed: \" + ex.Message));\n            }\n        }\n\n        [HttpGet(\"by-tags\")]\n        public async Task<IActionResult> GetContactsByTags([FromQuery] List<Guid> tagIds)\n        {\n            var businessId = User.GetBusinessId();  // Your tenant logic\n            var contacts = await _contactService.GetContactsByTagsAsync(businessId, tagIds);\n            return Ok(contacts);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/CrmContactSummaryController.cs",
      "sha256": "804c510c09cab8b7fd6a474121078cb64210d3660e08bcd90b1bea1dbd167883",
      "language": "csharp",
      "size": 5514,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    /// <summary>\n    /// Read-only CRM aggregation endpoint used by Chat Inbox right panel.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm\")]\n    public sealed class CrmContactSummaryController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<CrmContactSummaryController> _log;\n\n        public CrmContactSummaryController(\n            AppDbContext db,\n            ILogger<CrmContactSummaryController> log)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _log = log ?? throw new ArgumentNullException(nameof(log));\n        }\n\n        /// <summary>\n        /// Returns a compact \"Contact 360\" summary for Inbox.\n        /// </summary>\n        [HttpGet(\"contact-summary/{contactId:guid}\")]\n        public async Task<ActionResult<CrmContactSummaryDto>> GetContactSummary(\n            Guid contactId,\n            CancellationToken cancellationToken)\n        {\n            // 1ï¸âƒ£ Load the contact (also gives us BusinessId for scoping)\n            var contact = await _db.Contacts\n                .AsNoTracking()\n                .FirstOrDefaultAsync(c => c.Id == contactId, cancellationToken);\n\n            if (contact == null)\n            {\n                return NotFound(new { message = \"Contact not found.\" });\n            }\n\n            var businessId = contact.BusinessId;\n\n            var dto = new CrmContactSummaryDto\n            {\n                ContactId = contact.Id,\n                BusinessId = businessId,\n                // Map with typical Contact fields (adjust if your entity differs)\n                Name = contact.Name,\n                PhoneNumber = contact.PhoneNumber,\n                Email = contact.Email,\n                LeadSource = contact.LeadSource,\n                CreatedAt = contact.CreatedAt\n            };\n\n            // 2ï¸âƒ£ Tags â€“ simple many-to-many via ContactTags\n            var tagQuery =\n                from ct in _db.ContactTags.AsNoTracking()\n                join t in _db.Tags.AsNoTracking()\n                    on ct.TagId equals t.Id\n                where ct.ContactId == contactId\n                      && ct.BusinessId == businessId\n                select new CrmTagChipDto\n                {\n                    Id = t.Id,\n                    TagName = t.Name,\n                    ColorHex = t.ColorHex\n                };\n\n            dto.Tags = await tagQuery\n                .OrderBy(t => t.TagName)\n                .ToListAsync(cancellationToken);\n\n            // 3ï¸âƒ£ Recent notes â€“ last 3\n            var noteQuery = _db.Notes\n                .AsNoTracking()\n                .Where(n => n.ContactId == contactId && n.BusinessId == businessId)\n                .OrderByDescending(n => n.CreatedAt)\n                .Take(3)\n                .Select(n => new CrmNoteSnippetDto\n                {\n                    Id = n.Id,\n                    Title = n.Title,\n                    Content = n.Content,\n                    CreatedByName = n.CreatedBy,\n                    CreatedAt = n.CreatedAt\n                });\n\n            dto.RecentNotes = await noteQuery.ToListAsync(cancellationToken);\n\n            // 4ï¸âƒ£ Next reminder â€“ nearest future reminder (not completed)\n            var nowUtc = DateTime.UtcNow;\n\n            var nextReminderEntity = await _db.Reminders\n                .AsNoTracking()\n                .Where(r =>\n                    r.ContactId == contactId &&\n                    r.BusinessId == businessId &&\n                    r.DueAt >= nowUtc &&\n                    r.Status != \"Completed\") // using Status instead of IsCompleted\n                .OrderBy(r => r.DueAt)\n                .FirstOrDefaultAsync(cancellationToken);\n\n            if (nextReminderEntity != null)\n            {\n                dto.NextReminder = new CrmReminderSnippetDto\n                {\n                    Id = nextReminderEntity.Id,\n                    Title = nextReminderEntity.Title,\n                    Description = nextReminderEntity.Description,\n                    Status = nextReminderEntity.Status,\n                    DueAt = nextReminderEntity.DueAt,\n                    Priority = nextReminderEntity.Priority\n                };\n            }\n\n            // 5ï¸âƒ£ Recent timeline â€“ last 5 timeline events\n            var timelineQuery = _db.LeadTimelines\n                .AsNoTracking()\n                .Where(e => e.ContactId == contactId && e.BusinessId == businessId)\n                .OrderByDescending(e => e.CreatedAt)\n                .Take(5)\n                .Select(e => new CrmTimelineEventDto\n                {\n                    Id = e.Id,\n                    Title = e.Description, // no Title/ShortDescription on model\n                    Source = e.Source,\n                    Category = e.Category,\n                    EventType = e.EventType,\n                    CreatedAt = e.CreatedAt\n                });\n\n            dto.RecentTimeline = await timelineQuery.ToListAsync(cancellationToken);\n\n            _log.LogInformation(\n                \"[CRM] Contact summary loaded: Business={BusinessId} Contact={ContactId}\",\n                businessId,\n                contactId);\n\n            return Ok(dto);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/NotesController.cs",
      "sha256": "ebce43df28dd9a59eb8a21a1b39592edf5a00e1527501b27fff1f47b9536631b",
      "language": "csharp",
      "size": 2959,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class NotesController : ControllerBase\n    {\n        private readonly INoteService _noteService;\n\n        public NotesController(INoteService noteService)\n        {\n            _noteService = noteService;\n        }\n\n        [HttpPost(\"notes\")]\n        public async Task<IActionResult> AddNote([FromBody] NoteDto dto)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _noteService.AddNoteAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"Note created.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"Error creating note\", ex.Message));\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetNotesByContact(Guid contactId)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var result = await _noteService.GetNotesByContactAsync(businessId, contactId);\n                return Ok(ResponseResult.SuccessInfo(\"Notes loaded.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"Error fetching notes\", ex.Message));\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetNoteById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var result = await _noteService.GetNoteByIdAsync(businessId, id);\n            if (result == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Note loaded.\", result));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateNote(Guid id, [FromBody] NoteDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _noteService.UpdateNoteAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Note updated.\"));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteNote(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _noteService.DeleteNoteAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Note not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Note deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/RemindersController.cs",
      "sha256": "94768043e5877270f9ca797c084d60b10d081df7b7973bed29466c4b07018405",
      "language": "csharp",
      "size": 3241,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class RemindersController : ControllerBase\n    {\n        private readonly IReminderService _reminderService;\n\n        public RemindersController(IReminderService reminderService)\n        {\n            _reminderService = reminderService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddReminder(ReminderDto dto)\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                if (dto == null)\n                    return BadRequest(ResponseResult.ErrorInfo(\"Reminder data is missing.\"));\n\n                var result = await _reminderService.AddReminderAsync(businessId, dto);\n                return Ok(ResponseResult.SuccessInfo(\"Reminder created.\", result));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"An error occurred while adding the reminder.\", ex.Message));\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllReminders()\n        {\n            try\n            {\n                var businessId = HttpContext.User.GetBusinessId();\n                var reminders = await _reminderService.GetAllRemindersAsync(businessId);\n                return Ok(ResponseResult.SuccessInfo(\"Reminders loaded.\", reminders));\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"An error occurred while fetching reminders.\", ex.Message));\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetReminderById(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var reminder = await _reminderService.GetReminderByIdAsync(businessId, id);\n            if (reminder == null)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder loaded.\", reminder));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateReminder(Guid id, [FromBody] ReminderDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _reminderService.UpdateReminderAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder updated.\"));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteReminder(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _reminderService.DeleteReminderAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Reminder not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Reminder deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Controllers/TagsController.cs",
      "sha256": "aaa8771539b4136dcbfb5a98734d5e4ae2e6b14ad2179be7822746ac6fa3d93b",
      "language": "csharp",
      "size": 1999,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TagsController : ControllerBase\n    {\n        private readonly ITagService _tagService;\n\n        public TagsController(ITagService tagService)\n        {\n            _tagService = tagService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTag([FromBody] TagDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var result = await _tagService.AddTagAsync(businessId, dto);\n            return Ok(ResponseResult.SuccessInfo(\"Tag created.\", result));\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateTag(Guid id, [FromBody] TagDto dto)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _tagService.UpdateTagAsync(businessId, id, dto);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Tag updated.\"));\n        }\n\n        [HttpGet(\"get-tags\")]\n        public async Task<IActionResult> GetAllTags()\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var tags = await _tagService.GetAllTagsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"Tags loaded.\", tags));\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteTag(Guid id)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            var success = await _tagService.DeleteTagAsync(businessId, id);\n            if (!success)\n                return NotFound(ResponseResult.ErrorInfo(\"Tag not found.\"));\n            return Ok(ResponseResult.SuccessInfo(\"Tag deleted.\"));\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/AssignTagToContactsDto.cs",
      "sha256": "905dc04f16dd3b6ee269a89e0ea202a6af3dea76b223c9013713e74bb418bb24",
      "language": "csharp",
      "size": 198,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class AssignTagToContactsDto\n    {\n        public List<Guid> ContactIds { get; set; } = new();\n        public Guid TagId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/BulkImportResultDto.cs",
      "sha256": "fe6c5584078fe7488e519566ddc228be57d05be0a7a67f1427ceb0b3e90949fd",
      "language": "csharp",
      "size": 342,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class BulkImportResultDto\n    {\n        public int Imported { get; set; }\n        public List<CsvImportError> Errors { get; set; } = new();\n    }\n\n    public class CsvImportErrorMsg\n    {\n        public int RowNumber { get; set; }\n        public string ErrorMessage { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactDto.cs",
      "sha256": "83bef17a1c7bc4901f020261fb9a4d30c7bab7acab03e82fe3182e4eb4a24de3",
      "language": "csharp",
      "size": 1365,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactDto\n    {\n        public Guid? Id { get; set; } // Nullable for Create (used in PUT)\n\n        public string Name { get; set; } // Contact full name\n\n        public string PhoneNumber { get; set; } // WhatsApp-compatible number\n\n        public string? Email { get; set; } // Optional email address\n\n        public string? LeadSource { get; set; } // e.g., \"WhatsApp\", \"Facebook\", \"Landing Page\"\n\n        public DateTime? LastContactedAt { get; set; } // Last WhatsApp or CRM interaction\n\n        public DateTime? NextFollowUpAt { get; set; } // For scheduling reminders\n\n        public string? Notes { get; set; } // Internal notes for the contact\n\n        public DateTime? CreatedAt { get; set; } // Read-only timestamp\n\n        // âœ… NEW: Structured Tags (replaces comma-separated strings)\n        // Example: [{ id: 1, name: \"VIP\" }, { id: 2, name: \"Follow-up\" }]\n        public List<ContactTagDto> Tags { get; set; } = new();\n\n        public bool IsFavorite { get; set; } = false;\n        public bool IsArchived { get; set; } = false;\n        public string? Group { get; set; }\n\n        public bool IsTemporary { get; set; } = false;\n        public Guid? SourceCampaignId { get; set; }\n        public DateTime? ExpiresAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactDtoCsvMap.cs",
      "sha256": "dde35933fff5c8c84bc55769637d7467f36135c71549b547b60773aa4cf8da62",
      "language": "csharp",
      "size": 482,
      "content": "using CsvHelper.Configuration;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactDtoCsvMap : ClassMap<ContactDto>\n    {\n        public ContactDtoCsvMap()\n        {\n            Map(m => m.Name).Name(\"name\", \"Name\", \"full name\");\n            Map(m => m.PhoneNumber).Name(\"phone\", \"Phone\", \"mobile\", \"mobile number\");\n            Map(m => m.Email).Name(\"email\", \"Email\").Optional();\n            Map(m => m.Notes).Name(\"notes\", \"Notes\").Optional();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ContactTagDto.cs",
      "sha256": "69e97156f1e9453485bbaa39803b7c132d5a991e27091eb6cb648b42a148fc7a",
      "language": "csharp",
      "size": 281,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ContactTagDto\n    {\n        public Guid TagId { get; set; }\n        public string TagName { get; set; } = string.Empty;\n        public string? ColorHex { get; set; }\n        public string? Category { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/CrmContactSummaryDto.cs",
      "sha256": "320c7a1b0dd1223ea9e8a517b258e7235d2c12f71a798317c71483d95d2b0d26",
      "language": "csharp",
      "size": 2012,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.DTOs\n{\n    public sealed class CrmContactSummaryDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n        public string PhoneNumber { get; set; } = string.Empty;\n        public string? Email { get; set; }\n        public string? LeadSource { get; set; }\n        public DateTime? CreatedAt { get; set; }\n\n        // ðŸ‘‡ These names match ChatInbox.jsx usage\n        public List<CrmTagChipDto> Tags { get; set; } = new();\n        public List<CrmNoteSnippetDto> RecentNotes { get; set; } = new();\n        public CrmReminderSnippetDto? NextReminder { get; set; }\n        public List<CrmTimelineEventDto> RecentTimeline { get; set; } = new();\n    }\n\n    public sealed class CrmTagChipDto\n    {\n        public Guid Id { get; set; }\n        public string TagName { get; set; } = string.Empty;\n        public string? ColorHex { get; set; }\n    }\n\n    public sealed class CrmNoteSnippetDto\n    {\n        public Guid Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string Content { get; set; } = string.Empty;\n        public string? CreatedByName { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public sealed class CrmReminderSnippetDto\n    {\n        public Guid Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string? Description { get; set; }\n        public string? Status { get; set; }\n        public DateTime DueAt { get; set; }\n        public int? Priority { get; set; }\n    }\n\n    public sealed class CrmTimelineEventDto\n    {\n        public int Id { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public string? EventType { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/CsvImportResult.cs",
      "sha256": "b960c95f03cdabf593c9264c4a26457bc30278af2e88d77efe9a54ae066dd3c7",
      "language": "csharp",
      "size": 373,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class CsvImportResult<T>\n    {\n        public List<T> SuccessRecords { get; set; } = new();\n        public List<CsvImportError> Errors { get; set; } = new();\n    }\n\n    public class CsvImportError\n    {\n        public int RowNumber { get; set; }\n        public string ErrorMessage { get; set; } = string.Empty;\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/NoteDto.cs",
      "sha256": "2cf81a6442725d71886e1a87250278823b8c5d4d653ff38ab6d8f7b83e5a0586",
      "language": "csharp",
      "size": 524,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class NoteDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }\n        public string Title { get; set; }\n        public string Content { get; set; }\n        public string Source { get; set; }\n        public string CreatedBy { get; set; }\n        public bool IsPinned { get; set; }\n        public bool IsInternal { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public DateTime? EditedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/PagedResult.cs",
      "sha256": "fecb6fb29ec3bedc245dacd6fb2198d2f2c98335be5a5d93cd5a787d9248faa3",
      "language": "csharp",
      "size": 351,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class PagedResult<T>\n    {\n        public List<T> Items { get; set; } = new();\n        public int TotalCount { get; set; }\n\n        public int Page { get; set; }\n        public int PageSize { get; set; }\n        public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/ReminderDto.cs",
      "sha256": "50148cbe3ff493fa413666d9cd8590f078edc71c0a9127144a5b7c6116020f92",
      "language": "csharp",
      "size": 955,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Dtos\n{\n    public class ReminderDto\n    {\n        public Guid? Id { get; set; }  // Null when creating, present when updating\n\n        public Guid? ContactId { get; set; }\n\n        public string Title { get; set; } = default!;\n\n        public string? Description { get; set; }\n\n        public DateTime DueAt { get; set; }\n\n        public string? Status { get; set; } = \"Pending\";\n\n        public string? ReminderType { get; set; }\n\n        public int? Priority { get; set; }\n\n        public bool IsRecurring { get; set; }\n\n        public string? RecurrencePattern { get; set; }\n\n        public bool SendWhatsappNotification { get; set; }\n\n        public string? LinkedCampaign { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime? CreatedAt { get; set; }\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public DateTime? CompletedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Dtos/TagDto.cs",
      "sha256": "cd0010264a2cc4567c59311afd6d637f23f2e070be2d4da68f6be0ab97e46ff4",
      "language": "csharp",
      "size": 521,
      "content": "namespace xbytechat.api.Features.CRM.Dtos\n{\n    public class TagDto\n    {\n        public Guid? Id { get; set; }\n\n        public string Name { get; set; } = default!;\n\n        public string? ColorHex { get; set; }\n\n        public string? Category { get; set; }\n\n        public string? Notes { get; set; }\n\n        public bool IsSystemTag { get; set; } = false;\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime? CreatedAt { get; set; }\n\n        public DateTime? LastUsedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IContactService.cs",
      "sha256": "b7ca4f37c5420dd9e44b8fd2d03c1c0fff462256304cae410fbd5a135aa261b9",
      "language": "csharp",
      "size": 1862,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    /// <summary>\n    /// Defines the contract for all operations related to managing contacts.\n    /// </summary>\n    public interface IContactService\n    {\n\n        Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto);\n        Task<ContactDto> GetContactByIdAsync(Guid businessId, Guid contactId);\n        Task<bool> UpdateContactAsync(Guid businessId, ContactDto dto);\n        Task<bool> DeleteContactAsync(Guid businessId, Guid contactId);\n        Task<CsvImportResult<ContactDto>> ParseCsvToContactsAsync(Guid businessId, Stream csvStream);\n        Task<Contact> FindOrCreateAsync(Guid businessId, string phoneNumber);\n        Task<bool> ToggleFavoriteAsync(Guid businessId, Guid contactId);\n        Task<bool> ToggleArchiveAsync(Guid businessId, Guid contactId);\n        Task<IEnumerable<ContactDto>> GetAllContactsAsync(Guid businessId, string? tab = \"all\");\n        Task AssignTagToContactsAsync(Guid businessId, List<Guid> contactIds, Guid tagId);\n        Task<PagedResult<ContactDto>> GetPagedContactsAsync(\n             Guid businessId,\n             string? tab = \"all\",\n             int page = 1,\n             int pageSize = 25,\n             string? searchTerm = null\n            );\n        // âœ… Tag-based filtering support\n        Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<Guid> tags);\n\n        Task<BulkImportResultDto> BulkImportAsync(Guid businessId, Stream csvStream);\n        // ðŸ“Œ New method to support flow node â†’ tag assignment\n        Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tags);\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/INoteService.cs",
      "sha256": "3a55224ed1bd77632f1df5c60e2b9e83f76c595578c5cb47c07bd3965bda4360",
      "language": "csharp",
      "size": 705,
      "content": "using xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface INoteService\n    {\n        // For creating new note\n        Task<NoteDto> AddNoteAsync(Guid businessId, NoteDto dto);\n\n        // List all notes for dashboard view\n        Task<IEnumerable<NoteDto>> GetNotesByContactAsync(Guid businessId, Guid contactId);\n\n        // For loading note in edit mode\n        Task<NoteDto?> GetNoteByIdAsync(Guid businessId, Guid noteId);\n        // Handles editing\n        Task<bool> UpdateNoteAsync(Guid businessId, Guid noteId, NoteDto dto);\n        // Soft delete â†’ IsActive = false\n        Task<bool> DeleteNoteAsync(Guid businessId, Guid noteId);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/IReminderService.cs",
      "sha256": "ee0bb73d2c3d212a59012abdf1d71ab3ef240b6f785d25dde255e5c7d30f3e16",
      "language": "csharp",
      "size": 824,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface IReminderService\n    {\n        //For creating new reminder\n        Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto);\n\n        //List all reminders for dashboard view\n        Task<IEnumerable<ReminderDto>> GetAllRemindersAsync(Guid businessId);\n\n        //For loading reminder in edit mode\n        Task<ReminderDto?> GetReminderByIdAsync(Guid businessId, Guid reminderId);\n\n        //Handles editing\n        Task<bool> UpdateReminderAsync(Guid businessId, Guid reminderId, ReminderDto dto);\n        //Soft delete â†’ IsActive = false\n        Task<bool> DeleteReminderAsync(Guid businessId, Guid reminderId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Interfaces/ITagService.cs",
      "sha256": "736259ffc3b829a1b584543e52713f6207c977647abd89389fb465385b7aaaaa",
      "language": "csharp",
      "size": 652,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Interfaces\n{\n    public interface ITagService\n    {\n        Task<TagDto> AddTagAsync(Guid businessId, TagDto dto);\n\n        Task<IEnumerable<TagDto>> GetAllTagsAsync(Guid businessId);\n        Task<bool> UpdateTagAsync(Guid businessId, Guid tagId, TagDto dto);\n        Task<bool> DeleteTagAsync(Guid businessId, Guid tagId);\n        // Task AssignTagAsync(Guid businessId, string phone, string tag);\n        Task AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tagNames);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/ContactDtoCsvMap.cs",
      "sha256": "5cd5f3e2a53b4eabb3f3dd20e5afcc50f2c101f9f2a4225fa9aae68e11507167",
      "language": "csharp",
      "size": 396,
      "content": "using CsvHelper.Configuration;\nusing xbytechat.api.Features.CRM.Dtos;\n\npublic sealed class ContactDtoCsvMap : ClassMap<ContactDto>\n{\n    public ContactDtoCsvMap()\n    {\n        Map(m => m.Name).Name(\"Name\");\n        Map(m => m.PhoneNumber).Name(\"Phone\");\n        Map(m => m.Email).Name(\"Email\");\n        Map(m => m.LeadSource).Name(\"LeadSource\");\n        Map(m => m.Notes).Name(\"Notes\");\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/NoteMapper.cs",
      "sha256": "c1a7011bee26e547e4064999d2b18acaa207560f62b38ce965cbe2d2c6c93ee1",
      "language": "csharp",
      "size": 1265,
      "content": "using xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Mappers\n{\n    public static class NoteMapper\n    {\n        public static NoteDto MapToDto(Note note)\n        {\n            return new NoteDto\n            {\n                Id = note.Id,\n                ContactId = note.ContactId,\n                Title = note.Title,\n                Content = note.Content,\n                Source = note.Source,\n                CreatedBy = note.CreatedBy,\n                IsPinned = note.IsPinned,\n                IsInternal = note.IsInternal,\n                CreatedAt = note.CreatedAt,\n                EditedAt = note.EditedAt\n            };\n        }\n\n        public static Note MapToEntity(NoteDto dto, Guid businessId)\n        {\n            return new Note\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = dto.ContactId,\n                Title = dto.Title,\n                Content = dto.Content,\n                Source = dto.Source,\n                CreatedBy = dto.CreatedBy,\n                IsPinned = dto.IsPinned,\n                IsInternal = dto.IsInternal,\n                CreatedAt = DateTime.UtcNow\n            };\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Mappers/ReminderMapper.cs",
      "sha256": "950330c648a97a44de32a21621ac0b162359f35f1354664a00a509cab43a0dba",
      "language": "csharp",
      "size": 892,
      "content": "namespace xbytechat.api.Features.CRM.Mappers\n{\n    using xbytechat.api.Features.CRM.Dtos;\n    using xbytechat.api.Features.CRM.Models;\n\n    public static class ReminderMapper\n    {\n        public static ReminderDto MapToDto(Reminder r)\n        {\n            return new ReminderDto\n            {\n                Id = r.Id,\n                Title = r.Title,\n                Description = r.Description,\n                DueAt = r.DueAt,\n                ReminderType = r.ReminderType,\n                Priority = r.Priority,\n                IsRecurring = r.IsRecurring,\n                RecurrencePattern = r.RecurrencePattern,\n                SendWhatsappNotification = r.SendWhatsappNotification,\n                LinkedCampaign = r.LinkedCampaign,\n                Status = r.Status,\n                CreatedAt = r.CreatedAt,\n                ContactId = r.ContactId\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Contact.cs",
      "sha256": "b1e174cb56e84029fb8007267b479da61257b0097a0b522c5b6eab5a4f7b2280",
      "language": "csharp",
      "size": 2370,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Contact\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; } = null!;\n        // ðŸ”— FK to Business\n        [Required]\n        [MaxLength(100)]\n        public string Name { get; set; }\n\n        [Required]\n        [MaxLength(20)]\n        public string PhoneNumber { get; set; }\n\n        [MaxLength(100)]\n        public string? Email { get; set; }\n\n        [MaxLength(50)]\n        public string? LeadSource { get; set; }\n\n        [MaxLength(200)]\n        public string? Tags { get; set; } // Legacy, will be deprecated after ContactTag rollout\n\n        public DateTime? LastContactedAt { get; set; }\n        public DateTime? NextFollowUpAt { get; set; }\n\n        [MaxLength(500)]\n        public string? Notes { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        // ðŸ§© NEW: Link to Tags\n        public ICollection<ContactTag> ContactTags { get; set; } = new List<ContactTag>();\n        // âœ… New: Navigation property for many-to-many tags\n        //public ICollection<ContactTag> TagsLink { get; set; } = new List<ContactTag>();\n\n        public DateTime? LastCTAInteraction { get; set; }\n        public string? LastCTAType { get; set; }\n        public Guid? LastClickedProductId { get; set; }\n\n        // ðŸš¦ If true, skip automation flows (manually or programmatically paused)\n        public bool IsAutomationPaused { get; set; } = false;\n\n        // ðŸ‘¤ If agent assigned, automation should pause (runtime check)\n        public Guid? AssignedAgentId { get; set; }\n\n        public bool IsFavorite { get; set; } = false;\n        public bool IsArchived { get; set; } = false;\n        public string? Group { get; set; }\n        public bool IsActive { get; set; } = true;\n\n\n        //public bool IsTemporary { get; set; } = false;\n        //public Guid? SourceCampaignId { get; set; }\n        //public DateTime? ExpiresAt { get; set; }\n\n        public string? ProfileName { get; set; }            // latest WA profile.name we saw inbound\n        public DateTime? ProfileNameUpdatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/ContactTag.cs",
      "sha256": "de88c1bdb0a34e2703e0bb2d9c83c80f2d4af9f2c008e11782fa4949ae0dc782",
      "language": "csharp",
      "size": 510,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.CRM.Models;\n\npublic class ContactTag\n{\n    [Key]\n    public Guid Id { get; set; }\n\n    [Required]\n    public Guid ContactId { get; set; }\n\n    public Contact Contact { get; set; }\n\n    [Required]\n    public Guid TagId { get; set; }\n\n    public Tag Tag { get; set; }\n\n    [Required]\n    public Guid BusinessId { get; set; }\n\n    public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n\n    public string? AssignedBy { get; set; }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Note.cs",
      "sha256": "00b6b2dacb3efff3e8043beb4d763a5e8196378a60d699f59f0253b718c6d65d",
      "language": "csharp",
      "size": 923,
      "content": "namespace xbytechat.api.Features.CRM.Models\n{\n    public class Note\n    {\n        public Guid Id { get; set; }\n\n        // ðŸ”— Ownership & Association\n        public Guid? BusinessId { get; set; }\n        public Guid? ContactId { get; set; }\n\n        // ðŸ“ Core Content\n        public string Title { get; set; } // Optional short title (for pinning or preview)\n        public string Content { get; set; }\n\n        // ðŸ”– Contextual Intelligence\n        public string Source { get; set; } // e.g., \"Manual\", \"Call Log\", \"WhatsApp\", \"LeadForm\"\n        public string CreatedBy { get; set; } // Store agent/user name or userId\n\n        // ðŸ“Œ UX Flags\n        public bool IsPinned { get; set; } = false;\n        public bool IsInternal { get; set; } = false; // if true, only visible to team\n\n        // ðŸ•“ Timestamps\n        public DateTime CreatedAt { get; set; }\n        public DateTime? EditedAt { get; set; }\n    }\n}"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Reminder.cs",
      "sha256": "fc98f9aad251b376a21b81c2984660a17369d962f22e44a6fdc4b404508542c1",
      "language": "csharp",
      "size": 1728,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Reminder\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }   // For multi-tenant isolation\n\n        public Guid ContactId { get; set; }    // Which contact this reminder is for\n\n        public string Title { get; set; } = default!; // Main reminder title (e.g., \"Call back about invoice\")\n\n        public string? Description { get; set; } // Longer notes, optional (for internal detail)\n\n        public DateTime DueAt { get; set; }    // When reminder should notify\n\n        public string Status { get; set; } = \"Pending\"; // \"Pending\", \"Done\", \"Overdue\"\n\n        public string? ReminderType { get; set; } // e.g., \"Call\", \"Email\", \"Follow-up\", \"Meeting\"\n\n        public int? Priority { get; set; } // e.g., 1 (High), 2 (Medium), 3 (Low)\n\n        public bool IsRecurring { get; set; } = false; // For future â†’ repeat reminder\n\n        public string? RecurrencePattern { get; set; } // e.g., \"Weekly\", \"Monthly\" (optional)\n\n        public bool SendWhatsappNotification { get; set; } = false; // Future: auto-WA message trigger\n\n        public string? LinkedCampaign { get; set; } // Optional: which campaign this reminder relates to\n\n        public bool IsActive { get; set; } = true;  // Soft delete support\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public DateTime? CompletedAt { get; set; } // Track when it was marked Done\n\n        public string? LastCTAType { get; set; } // e.g., Confirm, Reschedule\n        public DateTime? LastClickedAt { get; set; }\n        public bool FollowUpSent { get; set; } = false;\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Models/Tag.cs",
      "sha256": "387b3c7cd221661c2ced818b097b3a5cc250067db94531b997e4ed61f1e43e35",
      "language": "csharp",
      "size": 1117,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CRM.Models\n{\n    public class Tag\n    {\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }             // Multi-tenant isolation\n\n        public string Name { get; set; } = default!;     // e.g., \"VIP\", \"Follow-up\"\n\n        public string? ColorHex { get; set; }            // For UI tag styling (e.g., #FF5733)\n\n        public string? Category { get; set; }            // e.g., \"Priority\", \"Campaign\", \"Stage\"\n\n        public string? Notes { get; set; }               // Admin/internal notes about this tag\n\n        public bool IsSystemTag { get; set; } = false;   // Reserved tags like \"New\", \"Subscribed\"\n\n        public bool IsActive { get; set; } = true;       // For soft-deactivation (future bulk ops)\n\n        public DateTime CreatedAt { get; set; }          // For analytics / sorting\n\n        public DateTime? LastUsedAt { get; set; }        // Useful for CRM insights later\n\n        public ICollection<ContactTag> ContactTags { get; set; } = new List<ContactTag>(); // Linked contacts\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactProfileService.cs",
      "sha256": "080cb0423a22385c8529565389af54c7ef55d8ba2e5b4ffb05fe5345afc3e644",
      "language": "csharp",
      "size": 3349,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public sealed class ContactProfileService : IContactProfileService\n    {\n        private readonly AppDbContext _db;\n\n        public ContactProfileService(AppDbContext db) => _db = db;\n\n        public async Task UpsertProfileNameAsync(\n            Guid businessId,\n            string phoneE164,\n            string? profileName,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(phoneE164) || string.IsNullOrWhiteSpace(profileName))\n                return;\n\n            static string Digits(string s) => new string(s.Where(char.IsDigit).ToArray());\n            var phoneDigits = Digits(phoneE164);\n            var newName = profileName.Trim();\n            var now = DateTime.UtcNow;\n\n            // Try digits first; fall back to raw (handles legacy rows)\n            var contact = await _db.Contacts.FirstOrDefaultAsync(\n                c => c.BusinessId == businessId &&\n                     (c.PhoneNumber == phoneDigits || c.PhoneNumber == phoneE164),\n                ct);\n\n            if (contact == null)\n            {\n                // Concurrency-safe create\n                try\n                {\n                    _db.Contacts.Add(new Contact\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        PhoneNumber = phoneDigits,          // canonical = digits-only\n                        Name = newName,                     // display fallback\n                        ProfileName = newName,              // WA profile name\n                        ProfileNameUpdatedAt = now,\n                        CreatedAt = now,\n                        LastContactedAt = now\n                    });\n                    await _db.SaveChangesAsync(ct);\n                    return;\n                }\n                catch (DbUpdateException)\n                {\n                    // Someone else created it â€” refetch and continue as update\n                    contact = await _db.Contacts.FirstOrDefaultAsync(\n                        c => c.BusinessId == businessId && c.PhoneNumber == phoneDigits, ct);\n                    if (contact == null) return;\n                }\n            }\n\n            var anyChange = false;\n\n            if (!string.Equals(contact.ProfileName, newName, StringComparison.Ordinal))\n            {\n                contact.ProfileName = newName;\n                contact.ProfileNameUpdatedAt = now;\n                anyChange = true;\n            }\n\n            // Backfill Name if empty/placeholder/phone\n            if (string.IsNullOrWhiteSpace(contact.Name) ||\n                contact.Name == \"WhatsApp User\" ||\n                contact.Name == contact.PhoneNumber)\n            {\n                if (!string.Equals(contact.Name, newName, StringComparison.Ordinal))\n                {\n                    contact.Name = newName;\n                    anyChange = true;\n                }\n            }\n\n            if (anyChange)\n            {\n                contact.ProfileNameUpdatedAt = now;\n                await _db.SaveChangesAsync(ct);\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ContactService.cs",
      "sha256": "2c3488314b614bd3c4500ad7ffdb8a64eec31c213e87616fafe5f86f51e7acfd",
      "language": "csharp",
      "size": 36981,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing CsvHelper;\nusing CsvHelper.Configuration;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ContactService : IContactService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ContactService> _logger;\n\n        public ContactService(AppDbContext db, ILogger<ContactService> logger)\n        {\n            _db = db;\n            _logger = logger;\n        }\n\n        //public async Task<ContactDto> AddContactAsync(Guid businessId, ContactDto dto)\n        //{\n        //    _logger.LogInformation(\"AddContactAsync called for businessId={BusinessId}, Name={Name}\", businessId, dto.Name);\n\n        //    var contact = new Contact\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        BusinessId = businessId,\n        //        Name = dto.Name,\n        //        PhoneNumber = dto.PhoneNumber,\n        //        Email = dto.Email,\n        //        LeadSource = dto.LeadSource,\n        //        LastContactedAt = dto.LastContactedAt?.ToUniversalTime(),\n        //        NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime(),\n        //        Notes = dto.Notes,\n        //        CreatedAt = DateTime.UtcNow,\n        //        IsFavorite = dto.IsFavorite,\n        //        IsArchived = dto.IsArchived,\n        //        Group = dto.Group\n        //    };\n\n        //    if (dto.Tags != null && dto.Tags.Any())\n        //    {\n        //        contact.ContactTags = dto.Tags.Select(t => new ContactTag\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            ContactId = contact.Id,\n        //            TagId = t.TagId,\n        //            BusinessId = businessId,\n        //            AssignedAt = DateTime.UtcNow,\n        //            AssignedBy = \"system\"\n        //        }).ToList();\n        //    }\n\n        //    _db.Contacts.Add(contact);\n\n        //    try\n        //    {\n        //        await _db.SaveChangesAsync();\n        //        _logger.LogInformation(\"Contact added: {ContactId} for businessId={BusinessId}\", contact.Id, businessId);\n        //    }\n        //    catch (DbUpdateException ex)\n        //    {\n        //        _logger.LogError(ex, \"DB error in AddContactAsync (Contact: {Contact}, BusinessId={BusinessId})\", contact, businessId);\n        //        var innerMessage = ex.InnerException?.Message ?? ex.Message;\n        //        throw new Exception(\"âŒ DB save error (Contact): \" + innerMessage, ex);\n        //    }\n\n        //    return new ContactDto\n        //    {\n        //        Id = contact.Id,\n        //        Name = contact.Name,\n        //        PhoneNumber = contact.PhoneNumber,\n        //        Email = contact.Email,\n        //        LeadSource = contact.LeadSource,\n        //        LastContactedAt = contact.LastContactedAt,\n        //        NextFollowUpAt = contact.NextFollowUpAt,\n        //        Notes = contact.Notes,\n        //        CreatedAt = contact.CreatedAt,\n        //        Tags = dto.Tags ?? new List<ContactTagDto>()\n        //    };\n        //}\n\n        //public async Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto)\n        //{\n        //    _logger.LogInformation(\"ðŸ“© AddContactAsync called for businessId={BusinessId}, Name={Name}\", businessId, dto.Name);\n\n        //    try\n        //    {\n        //        // 1. Duplicate check\n        //        if (!string.IsNullOrWhiteSpace(dto.PhoneNumber))\n        //        {\n        //            var existingContact = await _db.Contacts.FirstOrDefaultAsync(c =>\n        //                c.BusinessId == businessId && c.PhoneNumber == dto.PhoneNumber);\n\n        //            if (existingContact != null)\n        //            {\n        //                _logger.LogWarning(\"âš ï¸ Duplicate contact attempt for phone {Phone}\", dto.PhoneNumber);\n        //                return ResponseResult.ErrorInfo(\n        //                    $\"âŒ A contact with the phone number '{dto.PhoneNumber}' already exists.\"\n        //                );\n        //            }\n        //        }\n\n        //        // 2. Build entity\n        //        var contact = new Contact\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            BusinessId = businessId,\n        //            Name = dto.Name,\n        //            PhoneNumber = dto.PhoneNumber,\n        //            Email = dto.Email,\n        //            LeadSource = dto.LeadSource,\n        //            LastContactedAt = dto.LastContactedAt?.ToUniversalTime(),\n        //            NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime(),\n        //            Notes = dto.Notes,\n        //            CreatedAt = DateTime.UtcNow,\n        //            IsFavorite = dto.IsFavorite,\n        //            IsArchived = dto.IsArchived,\n        //            Group = dto.Group\n        //        };\n\n        //        // 3. Tags mapping\n        //        if (dto.Tags != null && dto.Tags.Any())\n        //        {\n        //            contact.ContactTags = dto.Tags.Select(t => new ContactTag\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                ContactId = contact.Id,\n        //                TagId = t.TagId,\n        //                BusinessId = businessId,\n        //                AssignedAt = DateTime.UtcNow,\n        //                AssignedBy = \"system\"\n        //            }).ToList();\n        //        }\n\n        //        _db.Contacts.Add(contact);\n\n        //        // 4. Save\n        //        try\n        //        {\n        //            await _db.SaveChangesAsync();\n        //            _logger.LogInformation(\"âœ… Contact added successfully: {ContactId} (BusinessId={BusinessId})\", contact.Id, businessId);\n        //        }\n        //        catch (DbUpdateException ex)\n        //        {\n        //            _logger.LogError(ex, \"âŒ DB error in AddContactAsync (BusinessId={BusinessId})\", businessId);\n        //            var innerMessage = ex.InnerException?.Message ?? ex.Message;\n        //            return ResponseResult.ErrorInfo(\"âŒ Database save error (Contact): \" + innerMessage);\n        //        }\n\n        //        // 5. Map back to DTO\n        //        var resultDto = new ContactDto\n        //        {\n        //            Id = contact.Id,\n        //            Name = contact.Name,\n        //            PhoneNumber = contact.PhoneNumber,\n        //            Email = contact.Email,\n        //            LeadSource = contact.LeadSource,\n        //            LastContactedAt = contact.LastContactedAt,\n        //            NextFollowUpAt = contact.NextFollowUpAt,\n        //            Notes = contact.Notes,\n        //            CreatedAt = contact.CreatedAt,\n        //            IsFavorite = contact.IsFavorite,\n        //            IsArchived = contact.IsArchived,\n        //            Group = contact.Group,\n        //            Tags = dto.Tags ?? new List<ContactTagDto>()\n        //        };\n\n        //        return ResponseResult.SuccessInfo(\"âœ… Contact created successfully.\", resultDto);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"ðŸš¨ Unexpected error in AddContactAsync (BusinessId={BusinessId})\", businessId);\n        //        return ResponseResult.ErrorInfo(\"ðŸš¨ A server error occurred while creating the contact.\", ex.Message);\n        //    }\n        //}\n\n        public async Task<ResponseResult> AddContactAsync(Guid businessId, ContactDto dto)\n        {\n            _logger.LogInformation(\"ðŸ“© AddContactAsync called for businessId={BusinessId}, Name={Name}\", businessId, dto.Name);\n\n            try\n            {\n                // 1. Normalize the phone number using your private method first.\n                var normalizedPhone = NormalizePhone(dto.PhoneNumber);\n\n                // 2. Validate the normalized number.\n                // Your NormalizePhone method returns an empty string for invalid numbers.\n                if (string.IsNullOrWhiteSpace(normalizedPhone))\n                {\n                    return ResponseResult.ErrorInfo(\"âŒ Phone number is invalid. It must contain exactly 10 digits.\");\n                }\n\n                // 3. Use the clean, normalized number for the duplicate check.\n                var existingContact = await _db.Contacts.FirstOrDefaultAsync(c =>\n                    c.BusinessId == businessId && c.PhoneNumber == normalizedPhone);\n\n                if (existingContact != null)\n                {\n                    _logger.LogWarning(\"âš ï¸ Duplicate contact attempt for phone {Phone}\", dto.PhoneNumber);\n                    return ResponseResult.ErrorInfo(\n                        $\"âŒ A contact with the phone number '{dto.PhoneNumber}' already exists.\"\n                    );\n                }\n\n                // 4. Build the new contact entity, SAVING the normalized number.\n                var contact = new Contact\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = dto.Name,\n                    PhoneNumber = normalizedPhone, // Save the standardized number\n                    Email = dto.Email,\n                    LeadSource = dto.LeadSource,\n                    LastContactedAt = dto.LastContactedAt?.ToUniversalTime(),\n                    NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime(),\n                    Notes = dto.Notes,\n                    CreatedAt = DateTime.UtcNow,\n                    IsFavorite = dto.IsFavorite,\n                    IsArchived = dto.IsArchived,\n                    Group = dto.Group\n                };\n\n                // Map tags if they are provided\n                if (dto.Tags != null && dto.Tags.Any())\n                {\n                    contact.ContactTags = dto.Tags.Select(t => new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        ContactId = contact.Id,\n                        TagId = t.TagId,\n                        BusinessId = businessId,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = \"system\"\n                    }).ToList();\n                }\n\n                _db.Contacts.Add(contact);\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"âœ… Contact added successfully: {ContactId}\", contact.Id);\n\n                // Map the created entity back to a DTO for the response\n                var resultDto = new ContactDto\n                {\n                    Id = contact.Id,\n                    Name = contact.Name,\n                    PhoneNumber = contact.PhoneNumber,\n                    Email = contact.Email,\n                    LeadSource = contact.LeadSource,\n                    CreatedAt = contact.CreatedAt,\n                    Tags = contact.ContactTags?.Select(ct => new ContactTagDto { TagId = ct.TagId }).ToList() ?? new List<ContactTagDto>()\n                };\n\n                return ResponseResult.SuccessInfo(\"âœ… Contact created successfully.\", resultDto);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ðŸš¨ Unexpected error in AddContactAsync for business {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"ðŸš¨ A server error occurred while creating the contact.\", ex.Message);\n            }\n        }\n        public async Task<ContactDto> GetContactByIdAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"GetContactByIdAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n            try\n            {\n                var contact = await _db.Contacts\n                     .Where(c => c.BusinessId == businessId && c.Id == contactId && c.IsActive)\n                    .Include(c => c.ContactTags)\n                        .ThenInclude(ct => ct.Tag)\n                    .FirstOrDefaultAsync();\n\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                    return null;\n                }\n\n                return new ContactDto\n                {\n                    Id = contact.Id,\n                    Name = contact.Name,\n                    PhoneNumber = contact.PhoneNumber,\n                    Email = contact.Email,\n                    LeadSource = contact.LeadSource,\n                    LastContactedAt = contact.LastContactedAt,\n                    NextFollowUpAt = contact.NextFollowUpAt,\n                    Notes = contact.Notes,\n                    CreatedAt = contact.CreatedAt,\n                    Tags = contact.ContactTags?\n                        .Where(ct => ct.Tag != null)\n                        .Select(ct => new ContactTagDto\n                        {\n                            TagId = ct.TagId,\n                            TagName = ct.Tag.Name\n                        })\n                        .ToList() ?? new List<ContactTagDto>()\n                };\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error fetching contact by id: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                throw;\n            }\n        }\n\n        public async Task<bool> UpdateContactAsync(Guid businessId, ContactDto dto)\n        {\n            _logger.LogInformation(\"UpdateContactAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, dto.Id);\n            try\n            {\n                var contact = await _db.Contacts\n                    .Include(c => c.ContactTags)\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == dto.Id);\n\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found for update: businessId={BusinessId}, contactId={ContactId}\", businessId, dto.Id);\n                    return false;\n                }\n\n                contact.Name = dto.Name;\n                contact.PhoneNumber = dto.PhoneNumber;\n                contact.Email = dto.Email;\n                contact.LeadSource = dto.LeadSource;\n                contact.LastContactedAt = dto.LastContactedAt?.ToUniversalTime();\n                contact.NextFollowUpAt = dto.NextFollowUpAt?.ToUniversalTime();\n                contact.Notes = dto.Notes;\n\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact updated: {ContactId}\", contact.Id);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating contact: businessId={BusinessId}, contactId={ContactId}\", businessId, dto.Id);\n                throw;\n            }\n        }\n\n        public async Task<bool> DeleteContactAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"DeleteContactAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n            try\n            {\n                var contact = await _db.Contacts\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId && c.IsActive);\n\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found for delete: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                    return false;\n                }\n\n                contact.IsActive = false; // ðŸ‘ˆ Soft delete\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact soft-deleted: {ContactId}\", contactId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting contact: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                throw;\n            }\n        }\n\n\n        public async Task<CsvImportResult<ContactDto>> ParseCsvToContactsAsync(Guid businessId, Stream csvStream)\n        {\n            _logger.LogInformation(\"ParseCsvToContactsAsync: businessId={BusinessId}\", businessId);\n\n            var result = new CsvImportResult<ContactDto>();\n\n            var config = new CsvConfiguration(CultureInfo.InvariantCulture)\n            {\n                HeaderValidated = null,\n                MissingFieldFound = null\n            };\n\n            using var reader = new StreamReader(csvStream);\n            using var csv = new CsvReader(reader, config);\n\n            // Register custom column mapping for ContactDto\n            csv.Context.RegisterClassMap<ContactDtoCsvMap>();\n\n            int rowNumber = 1;\n\n            await csv.ReadAsync();     // Move to first row\n            csv.ReadHeader();          // Read header row\n\n            while (await csv.ReadAsync())\n            {\n                rowNumber++;\n                try\n                {\n                    var record = csv.GetRecord<ContactDto>();\n                    record.CreatedAt = DateTime.UtcNow;\n\n                    result.SuccessRecords.Add(record);\n                }\n                catch (Exception ex)\n                {\n                    // Avoid ambiguity by using explicit object instantiation\n                    var error = new CsvImportError\n                    {\n                        RowNumber = rowNumber,\n                        ErrorMessage = ex.Message\n                    };\n                    result.Errors.Add(error);\n                }\n            }\n\n            _logger.LogInformation(\"CSV parsed with {SuccessCount} successes and {ErrorCount} errors.\",\n                result.SuccessRecords.Count, result.Errors.Count);\n\n            return result;\n        }\n\n        //private string NormalizePhone(string phoneNumber)\n        //{\n        //    if (string.IsNullOrWhiteSpace(phoneNumber))\n        //        return phoneNumber;\n\n        //    var digits = new string(phoneNumber.Where(char.IsDigit).ToArray());\n\n        //    // If it starts with \"91\" and length = 12 â†’ add +\n        //    if (digits.StartsWith(\"91\") && digits.Length == 12)\n        //        return \"+\" + digits;\n\n        //    // If it starts with \"91\" and length = 10 (missing country code) â†’ add +91\n        //    if (digits.Length == 10)\n        //        return \"+91\" + digits;\n\n        //    // If it already includes country code with + (13 digits for India)\n        //    if (digits.StartsWith(\"91\") && digits.Length == 12)\n        //        return \"+\" + digits;\n\n        //    // Fallback â†’ return with +\n        //    if (!digits.StartsWith(\"+\"))\n        //        return \"+\" + digits;\n\n        //    return digits;\n        //}\n\n        private string NormalizePhone(string phoneNumber)\n        {\n            // 1. Handle empty or null input\n            if (string.IsNullOrWhiteSpace(phoneNumber))\n            {\n                return string.Empty;\n            }\n\n            // 2. Extract only the numeric digits from the string\n            var digits = new string(phoneNumber.Where(char.IsDigit).ToArray());\n\n            // 3. If the number starts with India's country code (91) and is 12 digits long,\n            //    strip the country code to get the core 10-digit number.\n            if (digits.StartsWith(\"91\") && digits.Length == 12)\n            {\n                digits = digits.Substring(2);\n            }\n\n            // 4. NEW: Strictly validate that the result is 10 digits long.\n            if (digits.Length != 10)\n            {\n                // If the number of digits is not exactly 10, it's invalid.\n                // Return an empty string to signal that it could not be normalized.\n                return string.Empty;\n            }\n\n            // 5. If the number is a valid 10 digits, return it in the standard +91 format.\n            return \"+91\" + digits;\n        }\n        public async Task<Contact> FindOrCreateAsync(Guid businessId, string phoneNumber)\n        {\n            var normalized = NormalizePhone(phoneNumber);\n            _logger.LogInformation(\"FindOrCreateAsync: businessId={BusinessId}, rawPhone={PhoneNumber}, normalized={Normalized}\",\n                businessId, phoneNumber, normalized);\n\n            try\n            {\n                var contact = await _db.Contacts\n                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == normalized);\n\n                if (contact != null)\n                {\n                    _logger.LogInformation(\"Contact already exists: contactId={ContactId}\", contact.Id);\n                    return contact;\n                }\n\n                var newContact = new Contact\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = \"WhatsApp User\",\n                    PhoneNumber = normalized,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _db.Contacts.Add(newContact);\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact created: {ContactId}\", newContact.Id);\n\n                return newContact;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error in FindOrCreateAsync: businessId={BusinessId}, phoneNumber={PhoneNumber}\", businessId, phoneNumber);\n                throw;\n            }\n        }\n\n        public async Task<bool> ToggleFavoriteAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"ToggleFavoriteAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n            try\n            {\n                var contact = await _db.Contacts.FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId);\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found for favorite toggle: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                    return false;\n                }\n\n                contact.IsFavorite = !contact.IsFavorite;\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact favorite toggled: {ContactId} -> {IsFavorite}\", contactId, contact.IsFavorite);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error toggling favorite: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                throw;\n            }\n        }\n\n        public async Task AssignTagToContactsAsync(Guid businessId, List<Guid> contactIds, Guid tagId)\n        {\n            _logger.LogInformation(\"AssignTagToContactsAsync: businessId={BusinessId}, tagId={TagId}, contactIds={ContactIds}\", businessId, tagId, contactIds);\n            try\n            {\n                var contacts = await _db.Contacts\n                    .Where(c => c.BusinessId == businessId && contactIds.Contains(c.Id))\n                    .Include(c => c.ContactTags)\n                    .ToListAsync();\n\n                foreach (var contact in contacts)\n                {\n                    bool alreadyAssigned = contact.ContactTags.Any(link => link.TagId == tagId);\n                    if (!alreadyAssigned)\n                    {\n                        contact.ContactTags.Add(new ContactTag\n                        {\n                            ContactId = contact.Id,\n                            TagId = tagId\n                        });\n                    }\n                }\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Tags assigned to contacts\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error assigning tag: businessId={BusinessId}, tagId={TagId}\", businessId, tagId);\n                throw;\n            }\n        }\n\n        public async Task<bool> ToggleArchiveAsync(Guid businessId, Guid contactId)\n        {\n            _logger.LogInformation(\"ToggleArchiveAsync: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n            try\n            {\n                var contact = await _db.Contacts.FirstOrDefaultAsync(c => c.BusinessId == businessId && c.Id == contactId);\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"Contact not found for archive toggle: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                    return false;\n                }\n\n                contact.IsArchived = !contact.IsArchived;\n                await _db.SaveChangesAsync();\n                _logger.LogInformation(\"Contact archive toggled: {ContactId} -> {IsArchived}\", contactId, contact.IsArchived);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error toggling archive: businessId={BusinessId}, contactId={ContactId}\", businessId, contactId);\n                throw;\n            }\n        }\n\n        public async Task<IEnumerable<ContactDto>> GetAllContactsAsync(Guid businessId, string? tab = \"all\")\n        {\n            _logger.LogInformation(\"GetAllContactsAsync: businessId={BusinessId}, tab={Tab}\", businessId, tab);\n            try\n            {\n                var baseQuery = _db.Contacts\n                    .Where(c => c.BusinessId == businessId && c.IsActive);\n\n                if (tab == \"favourites\")\n                    baseQuery = baseQuery.Where(c => c.IsFavorite);\n                else if (tab == \"archived\")\n                    baseQuery = baseQuery.Where(c => c.IsArchived);\n                else if (tab == \"groups\")\n                    baseQuery = baseQuery.Where(c => !string.IsNullOrEmpty(c.Group));\n\n                var query = baseQuery\n                    .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag);\n\n                var contacts = await query.ToListAsync();\n\n                var result = contacts.Select(c => new ContactDto\n                {\n                    Id = c.Id,\n                    Name = c.Name,\n                    PhoneNumber = c.PhoneNumber,\n                    Email = c.Email,\n                    LeadSource = c.LeadSource,\n                    LastContactedAt = c.LastContactedAt,\n                    NextFollowUpAt = c.NextFollowUpAt,\n                    Notes = c.Notes,\n                    CreatedAt = c.CreatedAt,\n                    IsFavorite = c.IsFavorite,\n                    IsArchived = c.IsArchived,\n                    Group = c.Group,\n                    Tags = c.ContactTags?\n                        .Where(ct => ct.Tag != null)\n                        .Select(ct => new ContactTagDto\n                        {\n                            TagId = ct.TagId,\n                            TagName = ct.Tag.Name,\n                            ColorHex = ct.Tag.ColorHex,\n                            Category = ct.Tag.Category\n                        })\n                        .ToList() ?? new List<ContactTagDto>()\n                });\n\n                _logger.LogInformation(\"GetAllContactsAsync returned {Count} contacts\", contacts.Count);\n                return result;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error in GetAllContactsAsync: businessId={BusinessId}\", businessId);\n                throw;\n            }\n        }\n        public async Task<PagedResult<ContactDto>> GetPagedContactsAsync(Guid businessId, string? tab, int page, int pageSize, string? searchTerm)\n        {\n            _logger.LogInformation(\"GetPagedContactsAsync: businessId={BusinessId}, tab={Tab}, page={Page}, pageSize={PageSize}\",\n                businessId, tab, page, pageSize);\n\n            if (page < 1) page = 1;\n            if (pageSize < 1) pageSize = 25;\n            if (pageSize > 100) pageSize = 100; // max limit\n\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.IsActive);\n\n            if (tab == \"favourites\")\n                baseQuery = baseQuery.Where(c => c.IsFavorite);\n            else if (tab == \"archived\")\n                baseQuery = baseQuery.Where(c => c.IsArchived);\n            else if (tab == \"groups\")\n                baseQuery = baseQuery.Where(c => !string.IsNullOrEmpty(c.Group));\n\n            var totalCount = await baseQuery.CountAsync();\n\n            var contacts = await baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .OrderBy(c => c.Name) // or any order preferred\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .ToListAsync();\n\n            var items = contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Email = c.Email,\n                LeadSource = c.LeadSource,\n                LastContactedAt = c.LastContactedAt,\n                NextFollowUpAt = c.NextFollowUpAt,\n                Notes = c.Notes,\n                CreatedAt = c.CreatedAt,\n                IsFavorite = c.IsFavorite,\n                IsArchived = c.IsArchived,\n                Group = c.Group,\n                Tags = c.ContactTags?\n                    .Where(ct => ct.Tag != null)\n                    .Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.TagId,\n                        TagName = ct.Tag.Name,\n                        ColorHex = ct.Tag.ColorHex,\n                        Category = ct.Tag.Category\n                    })\n                    .ToList() ?? new List<ContactTagDto>()\n            }).ToList();\n\n            return new PagedResult<ContactDto>\n            {\n                Items = items,\n                TotalCount = totalCount\n            };\n        }\n\n        public async Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<string> tags)\n        {\n            var contacts = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && !c.IsArchived)\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag)\n                .Where(c => c.ContactTags.Any(ct => tags.Contains(ct.Tag.Name))) // ðŸ” Filter by tag names\n                .OrderBy(c => c.Name)\n                .Select(c => new ContactDto\n                {\n                    Id = c.Id,\n                    Name = c.Name,\n                    PhoneNumber = c.PhoneNumber,\n                    Email = c.Email,\n                    Notes = c.Notes,\n                    Tags = c.ContactTags.Select(ct => new ContactTagDto\n                    {\n                        TagId = ct.Tag.Id,\n                        TagName = ct.Tag.Name,\n                        ColorHex = ct.Tag.ColorHex,\n                        Category = ct.Tag.Category\n                    }).ToList()\n                })\n                .ToListAsync();\n\n            return contacts;\n        }\n        public async Task<BulkImportResultDto> BulkImportAsync(Guid businessId, Stream csvStream)\n        {\n            _logger.LogInformation(\"Bulk import started for businessId={BusinessId}\", businessId);\n\n            var result = new BulkImportResultDto();\n            var config = new CsvConfiguration(CultureInfo.InvariantCulture)\n            {\n                HeaderValidated = null,\n                MissingFieldFound = null\n            };\n\n            using var reader = new StreamReader(csvStream);\n            using var csv = new CsvReader(reader, config);\n            csv.Context.RegisterClassMap<ContactDtoCsvMap>();\n\n            await csv.ReadAsync();\n            csv.ReadHeader();\n\n            var contactsToAdd = new List<Contact>();\n            int row = 1;\n\n            while (await csv.ReadAsync())\n            {\n                row++;\n                try\n                {\n                    var dto = csv.GetRecord<ContactDto>();\n                    if (string.IsNullOrWhiteSpace(dto.PhoneNumber)) continue;\n\n                    var contact = new Contact\n                    {\n                        Id = Guid.NewGuid(),\n                        Name = dto.Name?.Trim() ?? \"Unnamed\",\n                        PhoneNumber = dto.PhoneNumber.Trim(),\n                        Email = dto.Email?.Trim(),\n                        Notes = dto.Notes,\n                        BusinessId = businessId,\n                        CreatedAt = DateTime.UtcNow\n                    };\n\n                    contactsToAdd.Add(contact);\n                    result.Imported++;\n                }\n                catch (Exception ex)\n                {\n                    result.Errors.Add(new CsvImportError\n                    {\n                        RowNumber = row,\n                        ErrorMessage = ex.Message\n                    });\n                }\n            }\n\n            await _db.Contacts.AddRangeAsync(contactsToAdd);\n            await _db.SaveChangesAsync();\n\n            _logger.LogInformation(\"Bulk import completed: {Imported} contacts, {Errors} errors\",\n                result.Imported, result.Errors.Count);\n\n            return result;\n        }\n        public async Task<IEnumerable<ContactDto>> GetContactsByTagsAsync(Guid businessId, List<Guid> tagIds)\n        {\n            // Step 1: Prepare base query (without Include yet)\n            var baseQuery = _db.Contacts\n                .Where(c => c.BusinessId == businessId && !c.IsArchived);\n\n            // Step 2: Apply tag filter only if tagIds are provided\n            if (tagIds?.Any() == true)\n            {\n                baseQuery = baseQuery.Where(c =>\n                    c.ContactTags.Any(ct =>\n                        tagIds.Contains(ct.TagId)\n                    )\n                );\n            }\n\n            // Step 3: Add Includes after filtering to avoid cast issue\n            var queryWithIncludes = baseQuery\n                .Include(c => c.ContactTags)\n                    .ThenInclude(ct => ct.Tag);\n\n            // Step 4: Fetch data\n            var contacts = await queryWithIncludes.ToListAsync();\n\n            // Step 5: Project to DTO\n            return contacts.Select(c => new ContactDto\n            {\n                Id = c.Id,\n                Name = c.Name,\n                PhoneNumber = c.PhoneNumber,\n                Tags = c.ContactTags.Select(ct => new ContactTagDto\n                {\n                    TagId = ct.Tag.Id,\n                    TagName = ct.Tag.Name,\n                    ColorHex = ct.Tag.ColorHex,\n                    Category = ct.Tag.Category\n                }).ToList()\n            });\n        }\n        public async Task<bool> AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tags)\n        {\n            if (tags == null || tags.Count == 0)\n                return false;\n\n            // ðŸ§  Step 1: Find the contact by phone\n            var contact = await _db.Contacts\n                .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phoneNumber && !c.IsArchived);\n\n            if (contact == null)\n                return false;\n\n            foreach (var tagName in tags)\n            {\n                if (string.IsNullOrWhiteSpace(tagName))\n                    continue;\n\n                // âœ… Step 2: Find or create the tag (by name)\n                var tag = await _db.Tags\n                    .FirstOrDefaultAsync(t => t.BusinessId == businessId && t.Name == tagName && t.IsActive);\n\n                if (tag == null)\n                {\n                    tag = new Tag\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        Name = tagName,\n                        ColorHex = \"#8c8c8c\", // default gray if not assigned\n                        IsActive = true,\n                        CreatedAt = DateTime.UtcNow\n                    };\n                    _db.Tags.Add(tag);\n                }\n\n                // ðŸ§ª Step 3: Check if contact already has this tag\n                var alreadyTagged = await _db.ContactTags.AnyAsync(ct =>\n                    ct.ContactId == contact.Id && ct.TagId == tag.Id);\n\n                if (!alreadyTagged)\n                {\n                    _db.ContactTags.Add(new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        ContactId = contact.Id,\n                        TagId = tag.Id\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/IContactProfileService.cs",
      "sha256": "2238c717846876f685aeb1424a5812b4673fd589105f31cdfbe116672d1cfd61",
      "language": "csharp",
      "size": 492,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public interface IContactProfileService\n    {\n        /// <summary>\n        /// Update contact's ProfileName if changed. Lookup by (BusinessId, E.164 phone).\n        /// No-op if contact not found or name is empty.\n        /// </summary>\n        Task UpsertProfileNameAsync(Guid businessId, string phoneE164, string? profileName, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/NoteService.cs",
      "sha256": "1a01e1930780a7e13d5e36302be3472e247d730a0224537fc195291d0de6f3ed",
      "language": "csharp",
      "size": 4460,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Mappers;\nusing xbytechat.api.Features.CRM.Timelines.Services;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class NoteService : INoteService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService; // âœ… Injected Timeline Service\n\n        // âœ… Constructor: Inject AppDbContext + TimelineService\n        public NoteService(AppDbContext db, ITimelineService timelineService)\n        {\n            _db = db;\n            _timelineService = timelineService;\n        }\n\n        // ðŸ“ Add a new Note + Log into LeadTimeline\n        public async Task<NoteDto> AddNoteAsync(Guid businessId, NoteDto dto)\n        {\n            // 1ï¸âƒ£ Map incoming DTO to Note entity\n            var note = NoteMapper.MapToEntity(dto, businessId);\n\n            // 2ï¸âƒ£ Save the Note into database\n            _db.Notes.Add(note);\n            await _db.SaveChangesAsync();\n\n            // 3ï¸âƒ£ Log this Note creation into LeadTimeline (only if ContactId is present)\n            if (dto.ContactId.HasValue)\n            {\n                try\n                {\n                    await _timelineService.LogNoteAddedAsync(new CRMTimelineLogDto\n                    {\n                        ContactId = dto.ContactId.Value,       // âž” Which contact the note is related to\n                        BusinessId = businessId,               // âž” Which business created this\n                        EventType = \"NoteAdded\",                // âž” Timeline event type\n                        Description = $\"ðŸ“ Note added: {dto.Title ?? \"(Untitled)\"}\", // âž” Friendly description\n                        ReferenceId = note.Id,                  // âž” Link back to Note Id\n                        CreatedBy = dto.CreatedBy,              // âž” Who created it\n                        Timestamp = DateTime.UtcNow             // âž” When created\n                    });\n                }\n                catch (Exception ex)\n                {\n                    // ðŸ›¡ Timeline saving failure should not break note creation\n                    Console.WriteLine($\"âš ï¸ Timeline log failed for NoteId {note.Id}: {ex.Message}\");\n                }\n            }\n\n            // 4ï¸âƒ£ Return the saved note as DTO\n            return NoteMapper.MapToDto(note);\n        }\n\n        // ðŸ“‹ List all Notes by Contact\n        public async Task<IEnumerable<NoteDto>> GetNotesByContactAsync(Guid businessId, Guid contactId)\n        {\n            return await _db.Notes\n                .AsNoTracking()\n                .Where(n => n.BusinessId == businessId && n.ContactId == contactId)\n                .OrderByDescending(n => n.CreatedAt)\n                .Select(n => NoteMapper.MapToDto(n))\n                .ToListAsync();\n        }\n\n        // ðŸ“‹ Get a single Note by Id\n        public async Task<NoteDto?> GetNoteByIdAsync(Guid businessId, Guid noteId)\n        {\n            var note = await _db.Notes\n                .AsNoTracking()\n                .FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n\n            return note == null ? null : NoteMapper.MapToDto(note);\n        }\n\n        // âœï¸ Update an existing Note\n        public async Task<bool> UpdateNoteAsync(Guid businessId, Guid noteId, NoteDto dto)\n        {\n            var note = await _db.Notes.FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n            if (note == null) return false;\n\n            note.Title = dto.Title;\n            note.Content = dto.Content;\n            note.IsPinned = dto.IsPinned;\n            note.IsInternal = dto.IsInternal;\n            note.EditedAt = DateTime.SpecifyKind(DateTime.UtcNow, DateTimeKind.Utc); // Always UTC timestamp\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        // ðŸ—‘ï¸ Soft delete (actually remove) a Note\n        public async Task<bool> DeleteNoteAsync(Guid businessId, Guid noteId)\n        {\n            var note = await _db.Notes.FirstOrDefaultAsync(n => n.Id == noteId && n.BusinessId == businessId);\n            if (note == null) return false;\n\n            _db.Notes.Remove(note);\n            await _db.SaveChangesAsync();\n            return true;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/ReminderService.cs",
      "sha256": "a5618517be86901337fa64637ecc7f8e0fc365fa99a2d58e8304c544f0e72451",
      "language": "csharp",
      "size": 5949,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Mappers;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class ReminderService : IReminderService\n    {\n        private readonly AppDbContext _db;\n\n        public ReminderService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        //public async Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto)\n        //{\n        //    var reminder = new Reminder\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        BusinessId = businessId,\n        //        //ContactId = dto.ContactId,\n        //        Title = dto.Title,\n        //        Description = dto.Description,\n        //        DueAt = dto.DueAt,\n        //        Status = dto.Status ?? \"Pending\",\n        //        ReminderType = dto.ReminderType,\n        //        Priority = dto.Priority,\n        //        IsRecurring = dto.IsRecurring,\n        //        RecurrencePattern = dto.RecurrencePattern,\n        //        SendWhatsappNotification = dto.SendWhatsappNotification,\n        //        LinkedCampaign = dto.LinkedCampaign,\n        //        CreatedAt = DateTime.UtcNow,\n        //        IsActive = true\n        //    };\n\n        //    _db.Reminders.Add(reminder);\n        //    await _db.SaveChangesAsync();\n\n        //    return MapToDto(reminder);\n        //}\n        public async Task<ReminderDto> AddReminderAsync(Guid businessId, ReminderDto dto)\n        {\n            try\n            {\n                var reminder = new Reminder\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = dto.ContactId ?? Guid.Empty, // add default fallback\n                    Title = dto.Title,\n                    Description = dto.Description,\n                    DueAt = DateTime.SpecifyKind(dto.DueAt, DateTimeKind.Utc),\n                    Status = dto.Status ?? \"Pending\",\n                    ReminderType = dto.ReminderType,\n                    Priority = dto.Priority,\n                    IsRecurring = dto.IsRecurring,\n                    RecurrencePattern = dto.RecurrencePattern,\n                    SendWhatsappNotification = dto.SendWhatsappNotification,\n                    LinkedCampaign = dto.LinkedCampaign,\n                    CreatedAt = DateTime.SpecifyKind(dto.DueAt, DateTimeKind.Utc),\n                    IsActive = true\n                };\n\n                _db.Reminders.Add(reminder);\n                await _db.SaveChangesAsync();\n\n                return MapToDto(reminder);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"âŒ Error in AddReminderAsync: \" + ex.Message);\n                throw;\n            }\n        }\n\n        public async Task<IEnumerable<ReminderDto>> GetAllRemindersAsync(Guid businessId)\n        {\n            return await _db.Reminders\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.IsActive)\n                .OrderBy(r => r.DueAt)\n                .Select(r => ReminderMapper.MapToDto(r))\n                .ToListAsync();\n        }\n\n\n        public async Task<ReminderDto?> GetReminderByIdAsync(Guid businessId, Guid reminderId)\n        {\n            var reminder = await _db.Reminders\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n\n            return reminder == null ? null : MapToDto(reminder);\n        }\n\n        public async Task<bool> UpdateReminderAsync(Guid businessId, Guid reminderId, ReminderDto dto)\n        {\n            var reminder = await _db.Reminders.FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n            if (reminder == null) return false;\n\n            reminder.Title = dto.Title;\n            reminder.Description = dto.Description;\n            reminder.DueAt = DateTime.SpecifyKind(dto.DueAt, DateTimeKind.Utc);\n            reminder.Status = dto.Status ?? reminder.Status;\n            reminder.ReminderType = dto.ReminderType;\n            reminder.Priority = dto.Priority;\n            reminder.IsRecurring = dto.IsRecurring;\n            reminder.RecurrencePattern = dto.RecurrencePattern;\n            reminder.SendWhatsappNotification = dto.SendWhatsappNotification;\n            reminder.LinkedCampaign = dto.LinkedCampaign;\n            reminder.UpdatedAt = DateTime.UtcNow;\n\n            if (dto.Status?.ToLower() == \"done\")\n                reminder.CompletedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> DeleteReminderAsync(Guid businessId, Guid reminderId)\n        {\n            var reminder = await _db.Reminders.FirstOrDefaultAsync(r => r.BusinessId == businessId && r.Id == reminderId && r.IsActive);\n            if (reminder == null) return false;\n\n            reminder.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        private ReminderDto MapToDto(Reminder r)\n        {\n            return new ReminderDto\n            {\n                Id = r.Id,\n                ContactId = r.ContactId,\n                Title = r.Title,\n                Description = r.Description,\n                DueAt = r.DueAt,\n                Status = r.Status,\n                ReminderType = r.ReminderType,\n                Priority = r.Priority,\n                IsRecurring = r.IsRecurring,\n                RecurrencePattern = r.RecurrencePattern,\n                SendWhatsappNotification = r.SendWhatsappNotification,\n                LinkedCampaign = r.LinkedCampaign,\n                CreatedAt = r.CreatedAt,\n                UpdatedAt = r.UpdatedAt,\n                CompletedAt = r.CompletedAt,\n                IsActive = r.IsActive\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Services/TagService.cs",
      "sha256": "e5d685392f0ff2c71b90f89621b099c06623f9f07a79907ee7c67fdb58b967d6",
      "language": "csharp",
      "size": 8716,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CRM.Models;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Timelines.Services;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Services\n{\n    public class TagService : ITagService\n    {\n        private readonly AppDbContext _db;\n        private readonly ITimelineService _timelineService; // âœ… Injected TimelineService\n        private readonly ILogger<TagService> _logger;\n        public TagService(AppDbContext db, ITimelineService timelineService, ILogger<TagService> logger)\n        {\n            _db = db;\n            _timelineService = timelineService;\n            _logger = logger;\n        }\n\n        public async Task<TagDto> AddTagAsync(Guid businessId, TagDto dto)\n        {\n            var tag = new Tag\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                Name = dto.Name,\n                ColorHex = dto.ColorHex,\n                Category = dto.Category,\n                Notes = dto.Notes,\n                IsSystemTag = dto.IsSystemTag,\n                IsActive = dto.IsActive,\n                CreatedAt = DateTime.UtcNow,\n                LastUsedAt = null\n            };\n\n            _db.Tags.Add(tag);\n            await _db.SaveChangesAsync();\n\n            // âœ… After saving tag â†’ try logging into Timeline (non-blocking)\n            try\n            {\n                await _timelineService.LogTagAppliedAsync(new CRMTimelineLogDto\n                {\n                    ContactId = Guid.Empty,    // âž¡ï¸ No specific contact, general event\n                    BusinessId = businessId,\n                    EventType = \"TagCreated\",\n                    Description = $\"ðŸ·ï¸ New tag created: {dto.Name}\",\n                    ReferenceId = tag.Id,\n                    CreatedBy = \"System\",\n                    Timestamp = DateTime.UtcNow,\n                    Category = \"CRM\"\n                });\n            }\n            catch (Exception ex)\n            {\n                // ðŸ›¡ Fail-safe: Do not block tag creation if timeline fails\n                Console.WriteLine($\"âš ï¸ Timeline log failed for TagId {tag.Id}: {ex.Message}\");\n            }\n\n            return new TagDto\n            {\n                Id = tag.Id,\n                Name = tag.Name,\n                ColorHex = tag.ColorHex,\n                Category = tag.Category,\n                Notes = tag.Notes,\n                IsSystemTag = tag.IsSystemTag,\n                IsActive = tag.IsActive,\n                CreatedAt = tag.CreatedAt,\n                LastUsedAt = tag.LastUsedAt\n            };\n        }\n\n        public async Task<IEnumerable<TagDto>> GetAllTagsAsync(Guid businessId)\n        {\n            return await _db.Tags\n                .Where(t => t.BusinessId == businessId && t.IsActive)\n                .OrderByDescending(t => t.CreatedAt)\n                .Select(t => new TagDto\n                {\n                    Id = t.Id,\n                    Name = t.Name,\n                    ColorHex = t.ColorHex,\n                    Category = t.Category,\n                    Notes = t.Notes,\n                    IsSystemTag = t.IsSystemTag,\n                    IsActive = t.IsActive,\n                    CreatedAt = t.CreatedAt,\n                    LastUsedAt = t.LastUsedAt\n                })\n                .ToListAsync();\n        }\n\n        public async Task<bool> UpdateTagAsync(Guid businessId, Guid tagId, TagDto dto)\n        {\n            var tag = await _db.Tags.FirstOrDefaultAsync(t => t.Id == tagId && t.BusinessId == businessId);\n            if (tag == null) return false;\n\n            tag.Name = dto.Name;\n            tag.ColorHex = dto.ColorHex;\n            tag.Category = dto.Category;\n            tag.Notes = dto.Notes;\n            tag.IsSystemTag = dto.IsSystemTag;\n            tag.IsActive = dto.IsActive;\n            tag.LastUsedAt = DateTime.UtcNow;\n\n            await _db.SaveChangesAsync();\n            return true;\n        }\n\n        public async Task<bool> DeleteTagAsync(Guid businessId, Guid tagId)\n        {\n            var tag = await _db.Tags.FirstOrDefaultAsync(t => t.Id == tagId && t.BusinessId == businessId);\n            if (tag == null) return false;\n\n            tag.IsActive = false;\n            await _db.SaveChangesAsync();\n            return true;\n        }\n        //public async Task AssignTagAsync(Guid businessId, string phone, string tag)\n        //{\n        //    try\n        //    {\n        //        // âœ… Step 1: Lookup contact\n        //        var contact = await _db.Contacts\n        //            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phone);\n\n        //        if (contact == null)\n        //        {\n        //            _logger.LogWarning(\"âš ï¸ Contact not found for phone: {Phone}\", phone);\n        //            return;\n        //        }\n\n        //        // âœ… Step 2: Check if tag exists\n        //        var existingTag = await _db.Tags\n        //            .FirstOrDefaultAsync(t => t.BusinessId == businessId && t.Name == tag);\n\n        //        if (existingTag == null)\n        //        {\n        //            existingTag = new Tag\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                BusinessId = businessId,\n        //                Name = tag,\n        //                CreatedAt = DateTime.UtcNow\n        //            };\n\n        //            await _db.Tags.AddAsync(existingTag);\n        //        }\n\n        //        // âœ… Step 3: Associate tag with contact if not already\n        //        var alreadyTagged = await _db.ContactTags\n        //            .AnyAsync(ct => ct.ContactId == contact.Id && ct.TagId == existingTag.Id);\n\n        //        if (!alreadyTagged)\n        //        {\n        //            await _db.ContactTags.AddAsync(new ContactTag\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                ContactId = contact.Id,\n        //                TagId = existingTag.Id,\n        //                AssignedAt = DateTime.UtcNow\n        //            });\n\n        //            _logger.LogInformation(\"ðŸ· Tag '{Tag}' assigned to contact {ContactId}\", tag, contact.Id);\n        //        }\n\n        //        await _db.SaveChangesAsync();\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"âŒ Error assigning tag to contact.\");\n        //        throw;\n        //    }\n        //}\n        public async Task AssignTagsAsync(Guid businessId, string phoneNumber, List<string> tagNames)\n        {\n            if (tagNames == null || !tagNames.Any())\n                return;\n\n            // ðŸ” Fetch the contact and existing tag links\n            var contact = await _db.Contacts\n             .Include(c => c.ContactTags)\n             .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == phoneNumber);\n\n\n            if (contact == null) return;\n\n            var existingTagIds = contact.ContactTags.Select(t => t.TagId).ToHashSet();\n\n            // ðŸ” Ensure tags exist or create them\n            var tags = await _db.Tags\n                .Where(t => t.BusinessId == businessId && tagNames.Contains(t.Name))\n                .ToListAsync();\n\n            var existingNames = tags.Select(t => t.Name).ToHashSet(StringComparer.OrdinalIgnoreCase);\n            var missingNames = tagNames.Where(t => !existingNames.Contains(t)).Distinct().ToList();\n\n            foreach (var name in missingNames)\n            {\n                var newTag = new Tag\n                {\n                    Id = Guid.NewGuid(),\n                    Name = name,\n                    BusinessId = businessId,\n                    CreatedAt = DateTime.UtcNow\n                };\n                _db.Tags.Add(newTag);\n                tags.Add(newTag);\n            }\n\n            await _db.SaveChangesAsync(); // Save new tags before linking\n\n            // âœ… Link new tags to contact\n            foreach (var tag in tags)\n            {\n                if (!existingTagIds.Contains(tag.Id))\n                {\n                    contact.ContactTags.Add(new ContactTag\n                    {\n                        Id = Guid.NewGuid(),\n                        TagId = tag.Id,\n                        ContactId = contact.Id,\n                        BusinessId = businessId,\n                        AssignedAt = DateTime.UtcNow,\n                        AssignedBy = \"automation\" // optional: set to flow name\n                    });\n                }\n            }\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Summary/Controllers/CrmSummaryController.cs",
      "sha256": "d45879a7c0b131ba0bc44d157fee084c9cd8f431793fd32fe5a957582d8e1e43",
      "language": "csharp",
      "size": 2810,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Summary/Controllers/CrmSummaryController.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.CRM.Summary.Interfaces;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CRM.Summary.Controllers\n{\n    /// <summary>\n    /// Thin API surface for CRM summary endpoints used by Chat Inbox\n    /// and future dashboards.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm-summary\")]\n    public sealed class CrmSummaryController : ControllerBase\n    {\n        private readonly IContactSummaryService _contactSummaryService;\n        private readonly ILogger<CrmSummaryController> _logger;\n\n        public CrmSummaryController(\n            IContactSummaryService contactSummaryService,\n            ILogger<CrmSummaryController> logger)\n        {\n            _contactSummaryService = contactSummaryService ?? throw new ArgumentNullException(nameof(contactSummaryService));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        /// <summary>\n        /// Returns a compact CRM snapshot for a given contact:\n        /// Contact core fields, tags, recent notes, next reminder, recent timeline entries.\n        /// </summary>\n        [HttpGet(\"contact-summary/{contactId:guid}\")]\n        public async Task<IActionResult> GetContactSummary(Guid contactId, CancellationToken ct)\n        {\n            var businessId = HttpContext.User.GetBusinessId();\n            if (businessId == Guid.Empty)\n            {\n                return Unauthorized(ResponseResult.ErrorInfo(\"Missing BusinessId in user claims.\"));\n            }\n\n            try\n            {\n                var summary = await _contactSummaryService.GetContactSummaryAsync(businessId, contactId, ct);\n                if (summary == null)\n                {\n                    return NotFound(ResponseResult.ErrorInfo(\"Contact not found for this business.\"));\n                }\n\n                return Ok(ResponseResult.SuccessInfo(\"Contact summary loaded.\", summary));\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(\n                    ex,\n                    \"âŒ Failed to load contact summary. Business={BusinessId}, Contact={ContactId}\",\n                    businessId,\n                    contactId);\n\n                // You already have global error handling, but we still wrap with ResponseResult for consistency.\n                return StatusCode(\n                    500,\n                    ResponseResult.ErrorInfo(\n                        \"An error occurred while loading contact summary.\",\n                        ex.Message));\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Summary/Dtos/ContactSummaryResponseDto.cs",
      "sha256": "c001cccb870161328a9e37057c268eb9c5304d4be4b557a60e9ed297a89ba236",
      "language": "csharp",
      "size": 1483,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Summary/Dtos/ContactSummaryResponseDto.cs\nusing System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Summary.Dtos\n{\n    /// <summary>\n    /// Compact CRM snapshot for a contact:\n    /// - Core contact fields\n    /// - Tags\n    /// - Recent notes\n    /// - Next reminder\n    /// - Recent timeline events\n    /// </summary>\n    public sealed class ContactSummaryResponseDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        // Core contact profile\n        public string Name { get; set; } = string.Empty;\n        public string PhoneNumber { get; set; } = string.Empty;\n        public string? Email { get; set; }\n        public string? LeadSource { get; set; }\n\n        public bool IsFavorite { get; set; }\n        public bool IsArchived { get; set; }\n        public string? Group { get; set; }\n\n        public DateTime? LastContactedAt { get; set; }\n        public DateTime? NextFollowUpAt { get; set; }\n\n        // Structured tags (from ContactDto.ContactTags â†’ ContactTagDto)\n        public List<ContactTagDto> Tags { get; set; } = new();\n\n        // Mini timeline section\n        public List<NoteDto> RecentNotes { get; set; } = new();\n\n        public ReminderDto? NextReminder { get; set; }\n\n        public List<LeadTimelineDto> RecentTimeline { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Summary/Interfaces/IContactSummaryService.cs",
      "sha256": "2adcd4704ac049cb3e7ee5b2652d8b389427a1bfeb1acf6a8fa6c1aee0a1c6eb",
      "language": "csharp",
      "size": 791,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Summary/Interfaces/IContactSummaryService.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Summary.Dtos;\n\nnamespace xbytechat.api.Features.CRM.Summary.Interfaces\n{\n    /// <summary>\n    /// Aggregates data from CRM modules (Contacts, Notes, Reminders, Timeline)\n    /// into a single contact summary for the Chat Inbox / dashboards.\n    /// </summary>\n    public interface IContactSummaryService\n    {\n        /// <summary>\n        /// Returns a compact CRM snapshot for the given contact and business.\n        /// </summary>\n        Task<ContactSummaryResponseDto?> GetContactSummaryAsync(\n            Guid businessId,\n            Guid contactId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Summary/Services/ContactSummaryService.cs",
      "sha256": "c9f37c47799808a8aac1a5bf84b09b88dcc7b0649a86892a49ecead6ad52fe5b",
      "language": "csharp",
      "size": 4428,
      "content": "// ðŸ“„ xbytechat-api/Features/CRM/Summary/Services/ContactSummaryService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Dtos;\nusing xbytechat.api.Features.CRM.Interfaces;\nusing xbytechat.api.Features.CRM.Summary.Dtos;\nusing xbytechat.api.Features.CRM.Summary.Interfaces;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Mappers;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Summary.Services\n{\n    /// <summary>\n    /// Default implementation of IContactSummaryService.\n    /// Orchestrates calls into existing CRM services and returns\n    /// a single response model tailored for UI consumption.\n    /// </summary>\n    public sealed class ContactSummaryService : IContactSummaryService\n    {\n        private readonly IContactService _contactService;\n        private readonly INoteService _noteService;\n        private readonly IReminderService _reminderService;\n        private readonly ILeadTimelineService _leadTimelineService;\n\n        public ContactSummaryService(\n            IContactService contactService,\n            INoteService noteService,\n            IReminderService reminderService,\n            ILeadTimelineService leadTimelineService)\n        {\n            _contactService = contactService ?? throw new ArgumentNullException(nameof(contactService));\n            _noteService = noteService ?? throw new ArgumentNullException(nameof(noteService));\n            _reminderService = reminderService ?? throw new ArgumentNullException(nameof(reminderService));\n            _leadTimelineService = leadTimelineService ?? throw new ArgumentNullException(nameof(leadTimelineService));\n        }\n\n        public async Task<ContactSummaryResponseDto?> GetContactSummaryAsync(\n            Guid businessId,\n            Guid contactId,\n            CancellationToken ct = default)\n        {\n            // 1) Core contact (this already returns ContactDto with tags)\n            var contact = await _contactService.GetContactByIdAsync(businessId, contactId);\n            if (contact == null)\n            {\n                return null;\n            }\n\n            // 2) Notes â€“ latest 3 by CreatedAt\n            var notes = await _noteService.GetNotesByContactAsync(businessId, contactId);\n            var recentNotes = notes\n                .OrderByDescending(n => n.CreatedAt)\n                .Take(3)\n                .ToList();\n\n            // 3) Next upcoming reminder for this contact (in-memory filter from service)\n            var allReminders = await _reminderService.GetAllRemindersAsync(businessId);\n            var nowUtc = DateTime.UtcNow;\n\n            var nextReminder = allReminders\n                .Where(r =>\n                    r.ContactId == contactId &&\n                    r.IsActive &&\n                    string.Equals(r.Status, \"Pending\", StringComparison.OrdinalIgnoreCase) &&\n                    r.DueAt >= nowUtc)\n                .OrderBy(r => r.DueAt)\n                .FirstOrDefault();\n\n            // 4) Recent timeline entries (latest 5 by CreatedAt)\n            var timelineEntities = await _leadTimelineService.GetTimelineByContactIdAsync(contactId);\n\n            var recentTimeline = timelineEntities\n                .OrderByDescending(e => e.CreatedAt)\n                .Take(5)\n                .Select(LeadTimelineMapper.ToDto)\n                .Where(dto => dto != null)\n                .ToList()!; // mapper may return null, we filter just in case\n\n            // 5) Assemble response\n            return new ContactSummaryResponseDto\n            {\n                BusinessId = businessId,\n                ContactId = contactId,\n\n                Name = contact.Name,\n                PhoneNumber = contact.PhoneNumber,\n                Email = contact.Email,\n                LeadSource = contact.LeadSource,\n                LastContactedAt = contact.LastContactedAt,\n                NextFollowUpAt = contact.NextFollowUpAt,\n                IsFavorite = contact.IsFavorite,\n                IsArchived = contact.IsArchived,\n                Group = contact.Group,\n\n                Tags = contact.Tags ?? new List<ContactTagDto>(),\n\n                RecentNotes = recentNotes,\n                NextReminder = nextReminder,\n                RecentTimeline = recentTimeline\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Controllers/LeadTimelineController.cs",
      "sha256": "acbf1f3b85665c403e9ba8358653b9dbf039c8881b112af442083b59f7c6d1ee",
      "language": "csharp",
      "size": 2035,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Services;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class LeadTimelineController : ControllerBase\n    {\n        private readonly ILeadTimelineService _timelineService;\n\n        public LeadTimelineController(ILeadTimelineService timelineService)\n        {\n            _timelineService = timelineService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTimelineEntry([FromBody] LeadTimelineDto dto)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                    return BadRequest(ModelState);\n\n                var result = await _timelineService.AddTimelineEntryAsync(dto);\n\n                Log.Information(\"âœ… Timeline entry created for ContactId: {ContactId}\", dto.ContactId);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to add timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw;\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetTimeline(Guid contactId)\n        {\n            try\n            {\n                var timeline = await _timelineService.GetTimelineByContactIdAsync(contactId);\n\n                Log.Information(\"ðŸ“„ Retrieved {Count} entries for ContactId: {ContactId}\", timeline.Count, contactId);\n\n                return Ok(timeline);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to get timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll()\n        {\n            var timelines = await _timelineService.GetAllTimelinesAsync();\n            return Ok(timelines);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/CampaignTimelineLogDto.cs",
      "sha256": "b279e39522b2d36effd77fe29c36653ca83b93c6cc9a1281d1ed6b3e596b96e3",
      "language": "csharp",
      "size": 361,
      "content": "public class CampaignTimelineLogDto\n{\n    public Guid ContactId { get; set; }\n    public Guid BusinessId { get; set; }   // âœ… Needed for timeline insertion\n    public Guid CampaignId { get; set; }\n    public string CampaignName { get; set; } = string.Empty; // âœ… Safe default to avoid null issues\n    public DateTime? Timestamp { get; set; } // optional\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/CRMTimelineLogDto.cs",
      "sha256": "523614f609f53bf0e19c490cf47a69ceb3ccc7df61bba97b431fcbcf6c739bdf",
      "language": "csharp",
      "size": 695,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Timelines.DTOs\n{\n    public class CRMTimelineLogDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public string EventType { get; set; }  // ðŸ§© Example: \"NoteAdded\", \"ReminderSet\", \"TagApplied\"\n        public string Description { get; set; }\n        public Guid? ReferenceId { get; set; }  // ðŸ†” Related NoteId, ReminderId, TagId (optional)\n        public string CreatedBy { get; set; }\n        public string? Category { get; set; } = \"CRM\";  // ðŸ“‚ Default category: CRM\n        public DateTime? Timestamp { get; set; }  // â° Custom time if needed (else CreatedAt = now)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/DTOs/LeadTimelineDto.cs",
      "sha256": "3b83f102ec5c0ddae6f265b6d33ddbd741f854e83baa0f696a1a05a7d9639104",
      "language": "csharp",
      "size": 687,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CRM.Timelines.DTOs\n{\n    public class LeadTimelineDto\n    {\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactNumber { get; set; }\n        public string EventType { get; set; }\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }\n        public bool IsSystemGenerated { get; set; } = false;\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Mappers/LeadTimelineMapper.cs",
      "sha256": "d3a2ed675f44c84af1ce0317d44c4407bf3fc23bf4bfdd91ebf0c52bf63a9296",
      "language": "csharp",
      "size": 1843,
      "content": "using xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Mappers\n{\n    public static class LeadTimelineMapper\n    {\n        public static LeadTimelineDto ToDto(Models.LeadTimeline entry)\n        {\n            if (entry == null) return null;\n\n            return new LeadTimelineDto\n            {\n                ContactId = entry.ContactId,\n                ContactName = entry.Contact?.Name,                // âœ… Enriched from navigation\n                ContactNumber = entry.Contact?.PhoneNumber,       // âœ… Enriched from navigation\n                EventType = entry.EventType,\n                Description = entry.Description,\n                Data = entry.Data,\n                ReferenceId = entry.ReferenceId,\n                IsSystemGenerated = entry.IsSystemGenerated,\n                CreatedBy = entry.CreatedBy,\n                Source = entry.Source,\n                Category = entry.Category,\n                // âœ… CreatedAt is intentionally excluded from DTO\n            };\n        }\n\n        // Optional for create/update, include only necessary fields\n        public static Models.LeadTimeline ToModel(LeadTimelineDto dto)\n        {\n            if (dto == null) return null;\n\n            return new Models.LeadTimeline\n            {\n                ContactId = dto.ContactId,\n                EventType = dto.EventType,\n                Description = dto.Description,\n                Data = dto.Data,\n                ReferenceId = dto.ReferenceId,\n                IsSystemGenerated = dto.IsSystemGenerated,\n                CreatedBy = dto.CreatedBy,\n                Source = dto.Source,\n                Category = dto.Category,\n                CreatedAt = DateTime.UtcNow // âœ… Always use UTC when creating\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Models/LeadTimeline.cs",
      "sha256": "3f31e8a170176d76713be299c4d314a5d1aaf17514d4903adb3685d41ca42572",
      "language": "csharp",
      "size": 1206,
      "content": "using xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CRM.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Models\n{\n    public class LeadTimeline\n    {\n        public int Id { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }  // optional\n\n        public Contact Contact { get; set; } // ðŸ†• Navigation property\n\n        public string EventType { get; set; }\n\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }           // âœ… New\n        public bool IsSystemGenerated { get; set; } = false;  // âœ… New\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n        public string? CTAType { get; set; } // e.g., \"BuyNow\", \"PriceCheck\", \"ConfirmReminder\"\n        public string? CTASourceType { get; set; } // e.g., \"catalog\", \"campaign\", \"reminder\"\n        public Guid? CTASourceId { get; set; } // ID of the source object (productId, reminderId)\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/ILeadTimelineService.cs",
      "sha256": "50629497a65281bae0ab515aa0b85e6a12eba14d8da57398c82e68cff749f58e",
      "language": "csharp",
      "size": 717,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public interface ILeadTimelineService\n    {\n        Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto);\n        Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId);\n        Task<List<LeadTimelineDto>> GetAllTimelinesAsync();\n        Task AddFromCatalogClickAsync(CatalogClickLog log);\n        Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto);\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/ITimelineService.cs",
      "sha256": "66f4590edcc54a2259174e6cb8efd54989b43d5250c46de459fd7d3b0907086f",
      "language": "csharp",
      "size": 452,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public interface ITimelineService\n    {\n        // Already existing methods...\n\n        // ðŸ†• CRM related methods\n        Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto);\n        Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/LeadTimelineService.cs",
      "sha256": "509c3bc3cf8d36b9acac08b54bf211a5992bb367934df75327f233af36eb9333",
      "language": "csharp",
      "size": 7570,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.Catalog.Models;\nusing static xbytechat.api.Features.BusinessModule.Models.Business;\nusing System.Text.Json;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public class LeadTimelineService : ILeadTimelineService\n    {\n        private readonly AppDbContext _context;\n\n\n        public LeadTimelineService(AppDbContext context)\n        {\n            _context = context;\n\n        }\n\n        public async Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto)\n        {\n            try\n            {\n                var entry = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    EventType = dto.EventType,\n                    Description = dto.Description,\n                    Data = dto.Data,\n                    ReferenceId = dto.ReferenceId,\n                    IsSystemGenerated = dto.IsSystemGenerated,\n                    CreatedBy = dto.CreatedBy,\n                    Source = dto.Source,\n                    Category = dto.Category,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(entry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"âœ… Timeline entry added for ContactId: {ContactId}\", dto.ContactId);\n\n                return entry;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Error adding timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw; // Let global middleware handle this\n            }\n        }\n\n        public async Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId)\n        {\n            try\n            {\n                var results = await _context.LeadTimelines\n                    .Where(x => x.ContactId == contactId)\n                    .OrderByDescending(x => x.CreatedAt)\n                    .ToListAsync();\n\n                Log.Information(\"ðŸ“„ Fetched {Count} timeline entries for ContactId: {ContactId}\", results.Count, contactId);\n\n                return results;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to fetch timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        public async Task<List<LeadTimelineDto>> GetAllTimelinesAsync()\n        {\n            try\n            {\n                var entries = await _context.LeadTimelines\n                    .Include(t => t.Contact) // for Contact Name/Phone\n                    .OrderByDescending(e => e.CreatedAt)\n                    .ToListAsync();\n\n                var dtoList = entries.Select(entry => new LeadTimelineDto\n                {\n                    ContactId = entry.ContactId,\n                    EventType = entry.EventType,\n                    Description = entry.Description,\n                    Data = entry.Data,\n                    ReferenceId = entry.ReferenceId,\n                    CreatedAt = entry.CreatedAt,\n                    CreatedBy = entry.CreatedBy,\n                    Source = entry.Source,\n                    Category = entry.Category,\n                    IsSystemGenerated = entry.IsSystemGenerated,\n                    ContactName = entry.Contact?.Name,\n                    ContactNumber = entry.Contact?.PhoneNumber\n                }).ToList();\n\n                Log.Information(\"ðŸ“„ Loaded {Count} total timeline entries\", dtoList.Count);\n                return dtoList;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Failed to fetch all timeline entries\");\n                throw;\n            }\n        }\n        public async Task AddFromCatalogClickAsync(CatalogClickLog log)\n        {\n            if (log == null)\n            {\n                Log.Warning(\"CatalogClickLog is null. Skipping timeline creation.\");\n                return;\n            }\n\n            try\n            {\n                var business = await _context.Businesses\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(b => b.Id == log.BusinessId);\n\n                if (business == null)\n                {\n                    Log.Warning(\"Business not found for ID: {BusinessId}. Skipping timeline creation.\", log.BusinessId);\n                    return;\n                }\n\n                // if (business.Plan == PlanType.Advanced)\n                if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                {\n                    Log.Information(\"Timeline skipped for Basic Plan - BusinessId: {BusinessId}\", business.Id);\n                    return;\n                }\n\n\n                var description = $\"{log.ProductBrowsed} | {log.CTAJourney}\";\n\n                var timelineEntry = new LeadTimeline\n                {\n                    BusinessId = log.BusinessId,\n                    ContactId = log.ContactId ?? Guid.Empty,\n                    EventType = \"CatalogCTA\",\n                    Description = description,\n                    Data = JsonSerializer.Serialize(log),\n                    ReferenceId = null,\n                    CreatedBy = \"system\",\n                    IsSystemGenerated = true,\n                    Source = \"Catalog\",\n                    Category = log.CategoryBrowsed,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(timelineEntry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"ðŸ“ˆ Timeline entry created from CatalogClick for UserId: {UserId}\", log.UserId);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"âŒ Error creating timeline entry from CatalogClick for UserId: {UserId}\", log.UserId);\n                // Safe swallow\n            }\n        }\n\n        public async Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"CampaignSend\",\n                    Description = $\"Campaign '{dto.CampaignName}' was sent.\", // âœ… Timeline me readable text\n                    ReferenceId = dto.CampaignId, // âœ… Linking to campaign record\n                    IsSystemGenerated = false,    // âœ… Default (campaign sending is manual action)\n                    CreatedBy = \"system\",         // âœ… Or actual user email if needed later\n                    Source = \"CampaignModule\",    // âœ… Source field for clarity\n                    Category = \"Messaging\",       // âœ… Logical grouping\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow // âœ… Use given Timestamp or fallback to now\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"âœ… Campaign send event logged into timeline.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"âŒ Failed to log campaign send event: \" + ex.Message);\n            }\n        }\n\n\n    }\n\n\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CRM/Timelines/Services/TimelineService.cs",
      "sha256": "15812c9261e54e2de1c7290ff48319573169fbc694ea5c6adf072f40d9bbfbff",
      "language": "csharp",
      "size": 3347,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CRM.Timelines.DTOs;\nusing xbytechat.api.Features.CRM.Timelines.Models;\n\nnamespace xbytechat.api.Features.CRM.Timelines.Services\n{\n    public class TimelineService : ITimelineService\n    {\n        private readonly AppDbContext _context;\n\n        public TimelineService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // ðŸ§© Log Note Added into Timeline\n        public async Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"NoteAdded\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // â° Log Reminder Set into Timeline\n        public async Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"ReminderSet\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // ðŸ·ï¸ Log Tag Applied into Timeline\n        public async Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"TagApplied\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Controllers/CrmAnalyticsController.cs",
      "sha256": "9148ea0201bfa24665b2fc92339cec7f58019baa66443aba80189bc1a4c9c833",
      "language": "csharp",
      "size": 1948,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.Services;\nusing xbytechat.api.Shared;\nusing System.Security.Claims;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Controllers\n{\n    /// <summary>\n    /// Handles CRM analytics summary and trends.\n    /// </summary>\n    [ApiController]\n    [Route(\"api/crm\")]\n    public class CrmAnalyticsController : ControllerBase\n    {\n        private readonly ICrmAnalyticsService _crmAnalyticsService;\n\n        public CrmAnalyticsController(ICrmAnalyticsService crmAnalyticsService)\n        {\n            _crmAnalyticsService = crmAnalyticsService;\n        }\n\n        /// <summary>\n        /// Returns dashboard summary stats for the CRM.\n        /// </summary>\n        [HttpGet(\"summary\")]\n        public async Task<IActionResult> GetSummary()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetSummaryAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"ðŸ“Š CRM analytics loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Returns contacts-added-over-time trend for graph.\n        /// </summary>\n        [HttpGet(\"trends/contacts\")]\n        public async Task<IActionResult> GetContactTrends()\n        {\n            var businessId = GetBusinessIdFromContext();\n            var result = await _crmAnalyticsService.GetContactTrendsAsync(businessId);\n            return Ok(ResponseResult.SuccessInfo(\"ðŸ“ˆ Contact trends loaded successfully.\", result));\n        }\n\n        /// <summary>\n        /// Extracts the businessId (Guid) from current user claims.\n        /// </summary>\n        private Guid GetBusinessIdFromContext()\n        {\n            return Guid.TryParse(HttpContext.User.FindFirst(\"BusinessId\")?.Value, out var id)\n                ? id\n                : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/ContactTrendsDto.cs",
      "sha256": "132d9271e14f9c3f2a65c9241917f67bc8129c91c7050c86a67df545c68419bc",
      "language": "csharp",
      "size": 362,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    /// <summary>\n    /// Represents the number of contacts added on a specific date.\n    /// Used for trend charting on the CRM dashboard.\n    /// </summary>\n    public class ContactTrendsDto\n    {\n        public string Date { get; set; } // Format: yyyy-MM-dd\n        public int Count { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/DTOs/CrmAnalyticsSummaryDto.cs",
      "sha256": "73027ff6ddc0b680b03714267bbf642053cdc28f2d97c16b593a3321186ab9d9",
      "language": "csharp",
      "size": 619,
      "content": "namespace xbytechat.api.Features.CrmAnalytics.DTOs\n{\n    public class CrmAnalyticsSummaryDto\n    {\n        public int TotalContacts { get; set; }\n        public int TaggedContacts { get; set; }\n        public int ActiveReminders { get; set; }\n        public int CompletedReminders { get; set; }\n        public int TotalNotes { get; set; }\n        public int LeadsWithTimeline { get; set; }\n        public int NewContactsToday { get; set; }\n        public int NotesAddedToday { get; set; }\n        public DateTime? LastContactAddedAt { get; set; }\n        public DateTime? LastReminderCompletedAt { get; set; }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/CrmAnalyticsService.cs",
      "sha256": "8fae1f725576dc5f6402559df557282ba8991f65bb324b614a65b4e9225167c5",
      "language": "csharp",
      "size": 4014,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\nusing xbytechat.api.Features.CrmAnalytics.Services;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Provides implementation for CRM analytics calculations.\n    /// Gathers contact, tag, note, and reminder metrics for the dashboard.\n    /// </summary>\n    public class CrmAnalyticsService : ICrmAnalyticsService\n    {\n        private readonly AppDbContext _context;\n\n        public CrmAnalyticsService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        /// <summary>\n        /// Generates a summarized snapshot of CRM data for the given business.\n        /// </summary>\n        /// <param name=\"businessId\">The unique ID of the business</param>\n        /// <returns>CrmAnalyticsSummaryDto containing insights</returns>\n        public async Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId)\n        {\n            var today = DateTime.UtcNow.Date;\n\n            var totalContacts = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId);\n\n            var taggedContacts = await _context.Contacts\n                .Where(c => c.BusinessId == businessId && c.Tags.Any())\n                .CountAsync();\n\n            var activeReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Pending\");\n\n            var completedReminders = await _context.Reminders\n                .CountAsync(r => r.BusinessId == businessId && r.Status == \"Completed\");\n\n            var totalNotes = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId);\n\n            var leadsWithTimeline = await _context.LeadTimelines\n                .Where(t => t.BusinessId == businessId)\n                .Select(t => t.ContactId)\n                .Distinct()\n                .CountAsync();\n\n            var newContactsToday = await _context.Contacts\n                .CountAsync(c => c.BusinessId == businessId && c.CreatedAt.Date == today);\n\n            var notesAddedToday = await _context.Notes\n                .CountAsync(n => n.BusinessId == businessId && n.CreatedAt.Date == today);\n\n            var lastContactAddedAt = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .OrderByDescending(c => c.CreatedAt)\n                .Select(c => (DateTime?)c.CreatedAt)\n                .FirstOrDefaultAsync();\n\n            var lastReminderCompletedAt = await _context.Reminders\n                .Where(r => r.BusinessId == businessId && r.Status == \"Completed\")\n                .OrderByDescending(r => r.CompletedAt)\n                .Select(r => (DateTime?)r.CompletedAt)\n                .FirstOrDefaultAsync();\n\n            return new CrmAnalyticsSummaryDto\n            {\n                TotalContacts = totalContacts,\n                TaggedContacts = taggedContacts,\n                ActiveReminders = activeReminders,\n                CompletedReminders = completedReminders,\n                TotalNotes = totalNotes,\n                LeadsWithTimeline = leadsWithTimeline,\n                NewContactsToday = newContactsToday,\n                NotesAddedToday = notesAddedToday,\n                LastContactAddedAt = lastContactAddedAt,\n                LastReminderCompletedAt = lastReminderCompletedAt\n            };\n        }\n        public async Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId)\n        {\n            var trends = await _context.Contacts\n                .Where(c => c.BusinessId == businessId)\n                .GroupBy(c => c.CreatedAt.Date)\n                .OrderBy(g => g.Key)\n                .Select(g => new ContactTrendsDto\n                {\n                    Date = g.Key.ToString(\"yyyy-MM-dd\"),\n                    Count = g.Count()\n                })\n                .ToListAsync();\n\n            return trends;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CrmAnalytics/Services/ICrmAnalyticsService.cs",
      "sha256": "24d70810ed26415792ab48592900090d8d1b7682d926e46f4bdc4595b24c5659",
      "language": "csharp",
      "size": 895,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.CrmAnalytics.DTOs;\n\nnamespace xbytechat.api.Features.CrmAnalytics.Services\n{\n    /// <summary>\n    /// Defines the contract for CRM Analytics services.\n    /// Handles lead-level analytics, summary metrics, and dashboard insights.\n    /// </summary>\n    public interface ICrmAnalyticsService\n    {\n        /// <summary>\n        /// Returns a summarized view of CRM statistics for a specific business.\n        /// This is used to power the CRM analytics dashboard.\n        /// </summary>\n        /// <param name=\"businessId\">The unique identifier of the business (tenant).</param>\n        /// <returns>A summary DTO containing contact, tag, note, and reminder insights.</returns>\n        Task<CrmAnalyticsSummaryDto> GetSummaryAsync(Guid businessId);\n        Task<List<ContactTrendsDto>> GetContactTrendsAsync(Guid businessId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CsvModule/CsvBatchValidationController.cs",
      "sha256": "daf00037fbe7c0f74272fe6dd650de7918d6f2f9a1bf91e40b01039a0e04f9cc",
      "language": "csharp",
      "size": 7225,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Shared;\nusing xbytechat_api.WhatsAppSettings.Services; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CsvModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/csv/batch/{batchId:guid}/validate\")]\n    [Authorize]\n    public sealed class CsvBatchValidationController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        public CsvBatchValidationController(AppDbContext db) => _db = db;\n\n        public sealed class ValidateRequest\n        {\n            public string? PhoneHeader { get; set; }              // e.g. \"phone\"\n            public List<string>? RequiredHeaders { get; set; }    // e.g. [\"parameter1\",\"headerpara1\",\"buttonpara1\"]\n            public bool NormalizePhone { get; set; } = true;\n            public bool CheckDuplicates { get; set; } = true;\n            public int? Limit { get; set; }                       // optional sample cap\n        }\n\n        public sealed class ValidateResponse\n        {\n            public bool Success { get; set; } = true;\n            public List<string> Problems { get; set; } = new();\n            public object Stats { get; set; } = new { rows = 0, missingPhone = 0, invalidPhones = 0, duplicatePhones = 0 };\n            public List<string> Headers { get; set; } = new();    // discovered headers in the batch\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Validate(Guid batchId, [FromBody] ValidateRequest req, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Load CSV rows for this batch (owned by business)\n            var rowsQ = _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == batchId)\n                .OrderBy(r => r.RowIndex);\n\n            var total = await rowsQ.CountAsync(ct);\n            if (total == 0)\n                return Ok(new ValidateResponse\n                {\n                    Problems = new List<string> { \"CSV batch is empty.\" },\n                    Stats = new { rows = 0, missingPhone = 0, invalidPhones = 0, duplicatePhones = 0 },\n                    Headers = new List<string>()\n                });\n\n            var rows = req.Limit.HasValue && req.Limit.Value > 0\n                ? await rowsQ.Take(req.Limit.Value).ToListAsync(ct)\n                : await rowsQ.ToListAsync(ct);\n\n            // Discover header set by union of row keys (case-insensitive compare)\n            var headerSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            foreach (var r in rows)\n                foreach (var k in KeysOfJson(r.DataJson))\n                    headerSet.Add(k);\n\n            var headers = headerSet.OrderBy(x => x, StringComparer.OrdinalIgnoreCase).ToList();\n\n            var problems = new List<string>();\n\n            // Validate phone header presence\n            var phoneHeader = (req.PhoneHeader ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(phoneHeader))\n            {\n                // Try helpful guesses\n                var guesses = new[] { \"phone\", \"mobile\", \"whatsapp\", \"number\", \"phonee164\", \"msisdn\", \"whatsapp_number\" };\n                var guess = guesses.FirstOrDefault(h => headerSet.Contains(h));\n                if (!string.IsNullOrEmpty(guess))\n                    phoneHeader = guess;\n            }\n\n            if (string.IsNullOrWhiteSpace(phoneHeader))\n            {\n                problems.Add(\"Phone column not specified and could not be guessed.\");\n            }\n            else if (!headerSet.Contains(phoneHeader))\n            {\n                problems.Add($\"Phone column â€œ{phoneHeader}â€ not found in CSV.\");\n            }\n\n            // Validate requiredHeaders presence (parameterN/headerparaN/buttonparaN)\n            var required = req.RequiredHeaders ?? new List<string>();\n            foreach (var h in required)\n            {\n                if (!headerSet.Contains(h))\n                    problems.Add($\"Required column â€œ{h}â€ is missing.\");\n            }\n\n            // Row-level checks\n            int missingPhone = 0, invalidPhones = 0, duplicatePhones = 0;\n            var seen = new HashSet<string>(StringComparer.Ordinal);\n\n            foreach (var r in rows)\n            {\n                var dict = JsonToDict(r.DataJson);\n\n                // phone\n                string? rawPhone = null;\n                if (!string.IsNullOrWhiteSpace(phoneHeader))\n                    dict.TryGetValue(phoneHeader, out rawPhone);\n\n                var normPhone = NormalizePhoneMaybe(rawPhone, req.NormalizePhone);\n                if (string.IsNullOrWhiteSpace(normPhone))\n                {\n                    missingPhone++;\n                    continue;\n                }\n\n                // naive validity check\n                if (!Regex.IsMatch(normPhone, @\"^\\d{10,15}$\"))\n                {\n                    invalidPhones++;\n                }\n\n                if (req.CheckDuplicates && !seen.Add(normPhone))\n                {\n                    duplicatePhones++;\n                }\n            }\n\n            var resp = new ValidateResponse\n            {\n                Problems = problems,\n                Stats = new { rows = total, missingPhone, invalidPhones, duplicatePhones },\n                Headers = headers\n            };\n\n            return Ok(resp);\n        }\n\n        // ---------- helpers ----------\n        private static IEnumerable<string> KeysOfJson(string? json)\n        {\n            if (string.IsNullOrWhiteSpace(json)) yield break;\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) yield break;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                yield return p.Name;\n        }\n\n        private static Dictionary<string, string> JsonToDict(string? json)\n        {\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            if (string.IsNullOrWhiteSpace(json)) return dict;\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) return dict;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                dict[p.Name] = p.Value.ValueKind == JsonValueKind.Null ? \"\" : p.Value.ToString();\n            return dict;\n        }\n\n        private static string? NormalizePhoneMaybe(string? raw, bool normalize)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var trimmed = raw.Trim();\n            if (!normalize) return trimmed;\n\n            // simple E.164-ish cleanup\n            var digits = Regex.Replace(trimmed, \"[^0-9]\", \"\");\n            digits = digits.TrimStart('0');\n            if (digits.Length == 10) digits = \"91\" + digits; // heuristic India\n            return digits;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/CTAFlowController.cs",
      "sha256": "ae0976baa15c4292f6fdc76a5e1b8810652df67fc18524f60eaf58037c5e4038",
      "language": "csharp",
      "size": 34615,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"api/cta-flow\")]\n    public class CTAFlowController : ControllerBase\n    {\n        private readonly ICTAFlowService _flowService;\n\n        public CTAFlowController(ICTAFlowService flowService)\n        {\n            _flowService = flowService;\n        }\n\n        // CREATE (draft-only)\n        [HttpPost(\"save-visual\")]\n        public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            Log.Information(\"ðŸ“¦ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n            var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? \"\").Trim();\n\n                // map common validation/conflict by message text (no result.Code available)\n                if (m.Contains(\"already exists\", StringComparison.OrdinalIgnoreCase))\n                    return Conflict(new { message = \"âŒ Duplicate flow name\", error = m });\n\n                if (m.Contains(\"required\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"empty flow\", StringComparison.OrdinalIgnoreCase) ||\n                    m.Contains(\"invalid\", StringComparison.OrdinalIgnoreCase))\n                    return BadRequest(new { message = \"âŒ Failed to save flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"âŒ Failed to save flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            Guid? flowId = null;\n            if (result.Data is not null)\n            {\n                try { dynamic d = result.Data; flowId = (Guid?)d.flowId; } catch { }\n            }\n\n            return Ok(new { message = \"âœ… Flow saved successfully\", flowId });\n        }\n\n        // PUBLISH (by id)\n        [HttpPost(\"{id:guid}/publish\")]\n        public async Task<IActionResult> Publish(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business.\" });\n\n            var ok = await _flowService.PublishFlowAsync(id, businessId, user);\n            return ok ? Ok(new { message = \"âœ… Flow published.\" }) : NotFound(new { message = \"âŒ Flow not found.\" });\n        }\n\n        // DELETE (only if not attached)\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business.\" });\n\n            var deletedBy = User.FindFirst(\"name\")?.Value\n                          ?? User.FindFirst(\"email\")?.Value\n                          ?? User.FindFirst(\"sub\")?.Value\n                          ?? \"system\";\n\n            var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n            if (!result.Success)\n            {\n                var msg = (result.ErrorMessage ?? result.Message ?? string.Empty).Trim();\n\n                // If message says it's attached, return 409 and include campaigns for the modal\n                if (msg.Contains(\"attached\", StringComparison.OrdinalIgnoreCase) ||\n                    msg.Contains(\"Cannot delete\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n                    return Conflict(new { message = msg, campaigns });\n                }\n\n                if (msg.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = msg });\n\n                return BadRequest(new { message = string.IsNullOrWhiteSpace(msg) ? \"Delete failed.\" : msg });\n            }\n\n            return Ok(new { message = result.Message ?? \"âœ… Flow deleted.\" });\n        }\n\n        // LISTS\n        [HttpGet(\"all-published\")]\n        public async Task<IActionResult> GetPublishedFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            var flows = await _flowService.GetAllPublishedFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        [HttpGet(\"all-draft\")]\n        public async Task<IActionResult> GetAllDraftFlows()\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            var flows = await _flowService.GetAllDraftFlowsAsync(businessId);\n            return Ok(flows);\n        }\n\n        // DETAIL\n        [HttpGet(\"by-id/{id:guid}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            var dto = await _flowService.GetVisualFlowByIdAsync(id, businessId);\n            if (dto is null) return NotFound(new { message = \"âŒ Flow not found.\" });\n\n            return Ok(dto);\n        }\n\n        [HttpGet(\"visual/{id:guid}\")]\n        public async Task<IActionResult> GetVisualFlow(Guid id)\n        {\n            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(businessIdClaim, out var businessId))\n                return BadRequest(new { message = \"âŒ Invalid business ID\" });\n\n            var result = await _flowService.GetVisualFlowAsync(id, businessId);\n            if (!result.Success)\n            {\n                var m = (result.ErrorMessage ?? string.Empty).Trim();\n                if (m.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n                    return NotFound(new { message = \"âŒ Failed to load flow\", error = m });\n\n                return StatusCode(StatusCodes.Status500InternalServerError,\n                    new { message = \"âŒ Failed to load flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n            }\n\n            return Ok(result.Data);\n        }\n\n        // USAGE (for delete guard)\n        [HttpGet(\"{id:guid}/usage\")]\n        public async Task<IActionResult> GetUsage(Guid id)\n        {\n            var biz = User.FindFirst(\"businessId\")?.Value;\n            if (!Guid.TryParse(biz, out var businessId))\n                return BadRequest(new { message = \"Invalid business.\" });\n\n            var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n            return Ok(new\n            {\n                canDelete = campaigns.Count == 0,\n                count = campaigns.Count,\n                campaigns\n            });\n        }\n    }\n}\n\n\n//// ðŸ“„ File: Features/CTAFlowBuilder/Controllers/CTAFlowController.cs\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.EntityFrameworkCore;\n//using Serilog;\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.CTAFlowBuilder.Services;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.Features.Tracking.Models;\n//using xbytechat.api.Features.Tracking.Services;\n//using xbytechat.api.Helpers;\n//using xbytechat.api.Shared;\n\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/cta-flow\")]\n//    public class CTAFlowController : ControllerBase\n//    {\n//        private readonly ICTAFlowService _flowService;\n//        private readonly IMessageEngineService _messageEngineService;\n//        private readonly ITrackingService _trackingService;\n//        public CTAFlowController(ICTAFlowService flowService, IMessageEngineService messageEngineService, ITrackingService trackingService)\n//        {\n//            _flowService = flowService;\n//            _messageEngineService = messageEngineService;\n//            _trackingService = trackingService;\n//        }\n\n//        [HttpPost(\"create\")]\n//        public async Task<IActionResult> CreateFlow([FromBody] CreateFlowDto dto)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//            if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"âŒ Invalid or missing businessId claim.\");\n\n//            var id = await _flowService.CreateFlowWithStepsAsync(dto, businessId, createdBy);\n//            return Ok(new { flowId = id });\n//        }\n\n//        //[HttpPost(\"publish\")]\n//        //public async Task<IActionResult> PublishFlow([FromBody] List<FlowStepDto> steps)\n//        //{\n//        //    var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//        //    var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//        //    if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n//        //        return BadRequest(\"âŒ Invalid or missing businessId claim.\");\n\n//        //    var result = await _flowService.PublishFlowAsync(businessId, steps, createdBy);\n//        //    if (!result.Success)\n//        //        return BadRequest(result.Message);\n\n//        //    return Ok(\"âœ… Flow published successfully.\");\n//        //}\n\n//        [HttpGet(\"current\")]\n//        public async Task<IActionResult> GetFlow()\n//        {\n//            var businessIdHeader = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdHeader, out var businessId))\n//                return BadRequest(\"âŒ Invalid or missing BusinessId header.\");\n\n//            var flow = await _flowService.GetFlowByBusinessAsync(businessId);\n\n//            // âœ… Always return 200 even if flow is null\n//            return Ok(flow);\n//        }\n\n//        [HttpGet(\"draft\")]\n//        public async Task<IActionResult> GetDraftFlow()\n//        {\n//            var businessIdHeader = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdHeader, out var businessId))\n//                return BadRequest(\"âŒ Invalid or missing BusinessId header.\");\n\n//            var draft = await _flowService.GetDraftFlowByBusinessAsync(businessId);\n//            if (draft == null)\n//                return NotFound(\"âŒ No draft flow found.\");\n\n//            return Ok(draft);\n//        }\n\n//        [HttpGet(\"match\")]\n//        public async Task<IActionResult> MatchButton(\n//            [FromQuery] string text,\n//            [FromQuery] string type,\n//            [FromQuery] string currentTemplateName,\n//            [FromQuery] Guid? campaignId) // Optional\n//        {\n//            var businessId = Guid.Parse(User.FindFirst(\"businessId\")?.Value!);\n\n//            var step = await _flowService.MatchStepByButtonAsync(\n//                businessId,\n//                text,\n//                type,\n//                currentTemplateName,\n//                campaignId\n//            );\n\n//            if (step == null)\n//                return NotFound(\"âŒ No matching step found.\");\n\n//            return Ok(new\n//            {\n//                step.TemplateToSend,\n//                step.TriggerButtonText,\n//                step.TriggerButtonType\n//            });\n//        }\n\n//        //[HttpPost(\"save-visual\")]\n//        //public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n//        //{\n//        //    var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//        //    var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//        //    if (!Guid.TryParse(businessIdClaim, out var businessId))\n//        //        return BadRequest(\"âŒ Invalid business ID\");\n\n//        //    Log.Information(\"ðŸ“¦ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n//        //    var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n//        //    if (!result.Success)\n//        //    {\n//        //        Log.Error(\"âŒ Failed to save flow. Error: {Error}. DTO: {@Dto}\", result.ErrorMessage, dto);\n//        //        return StatusCode(500, new\n//        //        {\n//        //            message = \"âŒ Failed to save flow\",\n//        //            error = result.ErrorMessage,\n//        //            // skipped = result.SkippedNodes ?? 0\n//        //        });\n//        //    }\n\n//        //    return Ok(new\n//        //    {\n//        //        message = \"âœ… Flow saved successfully\"\n//        //    });\n//        //}\n\n//        //[HttpPost(\"save-visual\")]\n//        //public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n//        //{\n//        //    var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//        //    var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//        //    if (!Guid.TryParse(businessIdClaim, out var businessId))\n//        //        return BadRequest(\"âŒ Invalid business ID\");\n\n//        //    Log.Information(\"ðŸ“¦ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n//        //    var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n//        //    if (!result.Success)\n//        //    {\n//        //        Log.Error(\"âŒ Failed to save flow. Error: {Error}. DTO: {@Dto}\", result.ErrorMessage, dto);\n//        //        return StatusCode(500, new\n//        //        {\n//        //            message = \"âŒ Failed to save flow\",\n//        //            error = result.ErrorMessage\n//        //        });\n//        //    }\n\n//        //    // Try to extract flowId from the service result (supports several shapes).\n//        //    Guid? flowId = null;\n//        //    try\n//        //    {\n//        //        switch (result.Data)\n//        //        {\n//        //            case Guid g:\n//        //                flowId = g;\n//        //                break;\n\n//        //            case string s when Guid.TryParse(s, out var gs):\n//        //                flowId = gs;\n//        //                break;\n\n//        //            case { } obj:\n//        //                // look for a property literally named \"flowId\"\n//        //                var prop = obj.GetType().GetProperty(\"flowId\")\n//        //                           ?? obj.GetType().GetProperty(\"FlowId\");\n//        //                if (prop?.GetValue(obj) is Guid pg)\n//        //                    flowId = pg;\n//        //                else if (prop?.GetValue(obj) is string ps && Guid.TryParse(ps, out var pgs))\n//        //                    flowId = pgs;\n//        //                break;\n//        //        }\n//        //    }\n//        //    catch\n//        //    {\n//        //        // non-fatal: just return without flowId if reflection fails\n//        //    }\n\n//        //    return Ok(new\n//        //    {\n//        //        message = \"âœ… Flow saved successfully\",\n//        //        flowId\n//        //    });\n//        //}\n//        // POST /api/cta-flow/save-visual\n//        // xbytechat.api/Features/CTAFlowBuilder/Controllers/CTAFlowController.cs\n//        [HttpPost(\"save-visual\")]\n//        public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"âŒ Invalid business ID\");\n\n//            Log.Information(\"ðŸ“¦ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n//            var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n\n//            // Helper: classify error message to proper HTTP status\n//            IActionResult ErrorToHttp(string? msg)\n//            {\n//                var m = (msg ?? \"\").Trim();\n\n//                // Validation problems â†’ 400\n//                if (m.Contains(\"Flow name is required\", StringComparison.OrdinalIgnoreCase) ||\n//                    m.Contains(\"Cannot save an empty flow\", StringComparison.OrdinalIgnoreCase) ||\n//                    m.Contains(\"invalid\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    Log.Warning(\"âš ï¸ Validation error while saving flow: {Error}\", m);\n//                    return BadRequest(new { message = \"âŒ Failed to save flow\", error = m });\n//                }\n\n//                // Duplicate name on create â†’ 409 (frontend will open rename modal)\n//                if (m.Contains(\"already exists\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    Log.Warning(\"âš ï¸ Duplicate flow name when creating: {Error}\", m);\n//                    return StatusCode(StatusCodes.Status409Conflict, new\n//                    {\n//                        message = \"âŒ Duplicate flow name\",\n//                        error = m\n//                        // intentionally no 'campaigns' array here (FE uses presence of it to show fork modal)\n//                    });\n//                }\n\n//                // Unknown â†’ 500\n//                Log.Error(\"âŒ Failed to save flow. Error: {Error}. DTO: {@Dto}\", m, dto);\n//                return StatusCode(StatusCodes.Status500InternalServerError, new\n//                {\n//                    message = \"âŒ Failed to save flow\",\n//                    error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m\n//                });\n//            }\n\n//            if (!result.Success)\n//                return ErrorToHttp(result.ErrorMessage);\n\n//            // Expect service to put { flowId = <Guid> } into result.Data\n//            Guid? flowId = null;\n//            if (result.Data is not null)\n//            {\n//                try\n//                {\n//                    if (result.Data is IDictionary<string, object> dict\n//                        && dict.TryGetValue(\"flowId\", out var obj) && obj is Guid g1)\n//                    {\n//                        flowId = g1;\n//                    }\n//                    else\n//                    {\n//                        // dynamic fallback\n//                        dynamic d = result.Data;\n//                        flowId = (Guid?)d.flowId;\n//                    }\n//                }\n//                catch\n//                {\n//                    // ignore shape issues; flowId stays null\n//                }\n//            }\n\n//            return Ok(new\n//            {\n//                message = \"âœ… Flow saved successfully\",\n//                flowId\n//            });\n//        }\n\n\n//        //[HttpPost(\"save-visual\")]\n//        //public async Task<IActionResult> SaveVisualFlow([FromBody] SaveVisualFlowDto dto)\n//        //{\n//        //    var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//        //    var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//        //    if (!Guid.TryParse(businessIdClaim, out var businessId))\n//        //        return BadRequest(\"âŒ Invalid business ID\");\n\n//        //    Log.Information(\"ðŸ“¦ Saving CTA Flow: {FlowName} by {User}\", dto.FlowName, createdBy);\n\n//        //    var result = await _flowService.SaveVisualFlowAsync(dto, businessId, createdBy);\n//        //    if (!result.Success)\n//        //    {\n//        //        Log.Error(\"âŒ Failed to save flow. Error: {Error}. DTO: {@Dto}\", result.ErrorMessage, dto);\n//        //        return StatusCode(500, new\n//        //        {\n//        //            message = \"âŒ Failed to save flow\",\n//        //            error = result.ErrorMessage\n//        //        });\n//        //    }\n\n//        //    // Expect service to put { flowId = <Guid> } into result.Data\n//        //    Guid? flowId = null;\n//        //    if (result.Data is not null)\n//        //    {\n//        //        try\n//        //        {\n//        //            // Support anonymous object or dictionary\n//        //            var dict = result.Data as IDictionary<string, object>;\n//        //            if (dict != null && dict.TryGetValue(\"flowId\", out var obj) && obj is Guid g1)\n//        //                flowId = g1;\n//        //            else\n//        //            {\n//        //                // dynamic fallback\n//        //                dynamic d = result.Data;\n//        //                flowId = (Guid?)d.flowId;\n//        //            }\n//        //        }\n//        //        catch { /* ignore shape issues; flowId stays null */ }\n//        //    }\n\n//        //    return Ok(new\n//        //    {\n//        //        message = \"âœ… Flow saved successfully\",\n//        //        flowId\n//        //    });\n//        //}\n\n//        [HttpGet(\"{id:guid}/usage\")]\n//        public async Task<IActionResult> GetUsage(Guid id)\n//        {\n//            var biz = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(biz, out var businessId)) return BadRequest(new { message = \"Invalid business.\" });\n\n//            var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n//            return Ok(new\n//            {\n//                canDelete = campaigns.Count == 0,\n//                count = campaigns.Count,\n//                campaigns\n//            });\n//        }\n\n//        //[HttpDelete(\"{id:guid}\")]\n//        //public async Task<IActionResult> Delete(Guid id)\n//        //{\n//        //    var biz = User.FindFirst(\"businessId\")?.Value;\n//        //    if (!Guid.TryParse(biz, out var businessId)) return BadRequest(new { message = \"Invalid business.\" });\n\n//        //    // Try hard delete\n//        //    var deleted = await _flowService.HardDeleteFlowIfUnusedAsync(id, businessId);\n//        //    if (deleted) return NoContent();\n\n//        //    // If not deleted, return 409 with whoâ€™s attached\n//        //    var campaigns = await _flowService.GetAttachedCampaignsAsync(id, businessId);\n//        //    if (campaigns.Count > 0)\n//        //    {\n//        //        return Conflict(new\n//        //        {\n//        //            message = \"Flow is attached to the following campaign(s). Delete them first, then delete the flow.\",\n//        //            campaigns\n//        //        });\n//        //    }\n\n//        //    // Not found (wrong tenant or already deleted)\n//        //    return NotFound(new { message = \"Flow not found.\" });\n//        //}\n//        // KEEP ONLY THIS ONE DELETE ENDPOINT\n\n//        [HttpDelete(\"{id:guid}\")]\n//        public async Task<IActionResult> Delete(Guid id)\n//        {\n//            var biz = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(biz, out var businessId))\n//                return BadRequest(new { message = \"âŒ Invalid business.\" });\n\n//            // who is deleting (audit)\n//            var deletedBy = User.FindFirst(\"name\")?.Value\n//                          ?? User.FindFirst(\"email\")?.Value\n//                          ?? User.FindFirst(\"sub\")?.Value\n//                          ?? \"system\";\n\n//            // Use your service that understands attachment rules and returns codes\n//            var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n//            // Frontend expects 409 to show the modal with attached campaigns\n//            if (!result.Success && result.Code == 409)\n//                return Conflict(new { message = result.Message, campaigns = result.Payload });\n\n//            if (!result.Success && result.Code == 404)\n//                return NotFound(new { message = result.Message });\n\n//            if (!result.Success)\n//                return BadRequest(new { message = result.Message });\n\n//            // FE treats 200 or 204 as success â€” return 200 with a message\n//            return Ok(new { message = result.Message });\n//        }\n\n\n\n//        [HttpGet(\"all-published\")]\n//        public async Task<IActionResult> GetPublishedFlows()\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"âŒ Invalid business ID\");\n\n//            var flows = await _flowService.GetAllPublishedFlowsAsync(businessId);\n//            return Ok(flows);\n//        }\n//        [HttpGet(\"all-draft\")]\n//        public async Task<IActionResult> GetAllDraftFlows()\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"âŒ Invalid business ID\");\n\n//            var flows = await _flowService.GetAllDraftFlowsAsync(businessId);\n//            return Ok(flows);\n//        }\n\n\n//        [HttpPost(\"execute-visual\")]\n//        public async Task<IActionResult> ExecuteVisualFlowAsync(\n//            [FromQuery] Guid nextStepId,\n//            [FromQuery] Guid trackingLogId,\n//            // âœ… 1. ADD the new optional parameter to the endpoint\n//            [FromQuery] Guid? campaignSendLogId = null)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"âŒ Invalid business ID\");\n\n//            // âœ… 2. PASS the new parameter to the service call\n//            var result = await _flowService.ExecuteVisualFlowAsync(businessId, nextStepId, trackingLogId, campaignSendLogId);\n\n//            if (result.Success)\n//                return Ok(result);\n//            else\n//                return BadRequest(result);\n//        }\n\n//        [HttpPost(\"create-config\")]\n//        public async Task<IActionResult> CreateConfigFlow([FromBody] CreateFlowDto dto)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            var createdBy = User.FindFirst(\"name\")?.Value ?? \"system\";\n\n//            if (string.IsNullOrWhiteSpace(businessIdClaim) || !Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"âŒ Invalid or missing businessId claim.\");\n\n//            try\n//            {\n//                var id = await _flowService.CreateFlowWithStepsAsync(dto, businessId, createdBy);\n\n//                return Ok(new\n//                {\n//                    flowId = id,\n//                    message = \"âœ… Flow config created successfully.\"\n//                });\n//            }\n//            catch (Exception ex)\n//            {\n//                return StatusCode(500, new\n//                {\n//                    error = \"âŒ Failed to create flow config.\",\n//                    details = ex.Message\n//                });\n//            }\n//        }\n\n//        [HttpGet(\"by-id/{id:guid}\")]\n//        public async Task<IActionResult> GetById(Guid id)\n//        {\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(\"âŒ Invalid business ID\");\n\n//            // Prefer a tenant-aware service method\n//            var dto = await _flowService.GetVisualFlowByIdAsync(id, businessId);\n//            if (dto is null) return NotFound(\"âŒ Flow not found.\");\n\n//            return Ok(dto); // { flowName, isPublished, nodes, edges } (camelCase via default JSON options)\n//        }\n\n//        // ðŸ“ Add this to your CTAFlowController\n//        // CTAFlowController.cs  â€” drop-in replacement for \"get visual flow\" endpoint\n//        [HttpGet(\"visual/{id:guid}\")]\n//        public async Task<IActionResult> GetVisualFlow(Guid id)\n//        {\n//            // business guard\n//            var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n//            if (!Guid.TryParse(businessIdClaim, out var businessId))\n//                return BadRequest(new { message = \"âŒ Failed to load flow\", error = \"Invalid business ID\" });\n\n//            // ask the service â€” this RETURNS YOUR ResponseResult, not a DTO\n//            var result = await _flowService.GetVisualFlowAsync(id, businessId);\n\n//            // Uniform error mapping (same style you use in SaveVisualFlow)\n//            if (!result.Success)\n//            {\n//                var m = (result.ErrorMessage ?? string.Empty).Trim();\n\n//                if (m.Contains(\"not found\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    // 404 when flow id doesnâ€™t exist / not visible for biz\n//                    return NotFound(new { message = \"âŒ Failed to load flow\", error = m });\n//                }\n\n//                if (m.Contains(\"forbidden\", StringComparison.OrdinalIgnoreCase) ||\n//                    m.Contains(\"unauthorized\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    // 403 when biz is not allowed to see this flow\n//                    return StatusCode(StatusCodes.Status403Forbidden,\n//                        new { message = \"âŒ Failed to load flow\", error = m });\n//                }\n\n//                // default â†’ 500\n//                return StatusCode(StatusCodes.Status500InternalServerError,\n//                    new { message = \"âŒ Failed to load flow\", error = string.IsNullOrWhiteSpace(m) ? \"Unknown error\" : m });\n//            }\n\n//            // SUCCESS: your service already builds the payload (FlowName, IsPublished, Nodes, Edges, etc.)\n//            // Just return it as-is so the FE can consume it.\n//            // Example shape expected by FE:\n//            // { flowName, isPublished, nodes: [...], edges: [...] }\n//            return Ok(result.Data);\n//        }\n\n\n//        //[HttpPut(\"{id:guid}\")]\n//        //public async Task<IActionResult> Update(Guid id, [FromBody] SaveVisualFlowDto dto)\n//        //{\n//        //    var biz = User.FindFirst(\"businessId\")?.Value;\n//        //    var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n//        //    if (!Guid.TryParse(biz, out var businessId)) return BadRequest(\"âŒ Invalid business.\");\n\n//        //    var result = await _flowService.UpdateVisualFlowAsync(id, dto, businessId, user);\n//        //    return result.Status switch\n//        //    {\n//        //        \"ok\" => Ok(new { message = \"Flow updated.\", needsRepublish = result.NeedsRepublish }),\n//        //        \"requiresFork\" => Conflict(new { message = result.Message, campaigns = result.Campaigns, requiresFork = true }),\n//        //        \"notFound\" => NotFound(\"âŒ Flow not found.\"),\n//        //        _ => BadRequest(new { message = result.Message ?? \"Unknown error\" })\n//        //    };\n//        //}\n\n\n//        [HttpPost(\"{id:guid}/publish\")]\n//        public async Task<IActionResult> Publish(Guid id)\n//        {\n//            var biz = User.FindFirst(\"businessId\")?.Value;\n//            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n//            if (!Guid.TryParse(biz, out var businessId)) return BadRequest(\"âŒ Invalid business.\");\n\n//            var ok = await _flowService.PublishFlowAsync(id, businessId, user);\n//            return ok ? Ok(new { message = \"âœ… Flow published.\" }) : NotFound(\"âŒ Flow not found.\");\n//        }\n\n\n//        //// ðŸ‘‡ NEW: publish\n//        //[HttpPost(\"{id:guid}/publish\")]\n//        //public async Task<IActionResult> Publish(Guid id)\n//        //{\n//        //    var biz = User.FindFirst(\"businessId\")?.Value;\n//        //    var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n//        //    if (!Guid.TryParse(biz, out var businessId)) return BadRequest(\"âŒ Invalid business.\");\n\n//        //    var ok = await _flowService.PublishFlowAsync(id, businessId, user);\n//        //    return ok ? Ok(new { message = \"âœ… Flow published.\" }) : NotFound(\"âŒ Flow not found.\");\n//        //}\n\n\n\n//        // ðŸ‘‡ NEW: fork (create new draft from live-locked flow)\n//        [HttpPost(\"{id:guid}/fork\")]\n//        public async Task<IActionResult> Fork(Guid id)\n//        {\n//            var biz = User.FindFirst(\"businessId\")?.Value;\n//            var user = User.FindFirst(\"name\")?.Value ?? \"system\";\n//            if (!Guid.TryParse(biz, out var businessId)) return BadRequest(\"âŒ Invalid business.\");\n\n//            var forkId = await _flowService.ForkFlowAsync(id, businessId, user);\n//            if (forkId == Guid.Empty) return NotFound(\"âŒ Flow not found.\");\n//            return Ok(new { flowId = forkId });\n//        }\n\n//        // ðŸ‘‡ BACK-COMPAT: keep existing delete route AND add /{id}\n//       // [HttpDelete(\"{id:guid}\")]\n//        //public async Task<IActionResult> DeletePlain(Guid id)\n//        //{\n//        //    var biz = User.FindFirst(\"businessId\")?.Value;\n//        //    if (!Guid.TryParse(biz, out var businessId))\n//        //        return BadRequest(\"âŒ Invalid business ID\");\n\n//        //    // Capture the user performing the delete\n//        //    var deletedBy = User.FindFirst(\"name\")?.Value\n//        //                 ?? User.FindFirst(\"email\")?.Value\n//        //                 ?? User.FindFirst(\"sub\")?.Value\n//        //                 ?? \"system\";\n\n//        //    var result = await _flowService.DeleteFlowAsync(id, businessId, deletedBy);\n\n//        //    if (!result.Success && result.Code == 409)\n//        //        return Conflict(new { message = result.Message, campaigns = result.Payload });\n\n//        //    if (!result.Success && result.Code == 404)\n//        //        return NotFound(new { message = result.Message });\n\n//        //    if (!result.Success)\n//        //        return BadRequest(new { message = result.Message });\n\n//        //    return Ok(new { message = result.Message });\n//        //}\n\n//    }\n\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs",
      "sha256": "8d5442a0a0fdb92dc7d69837cd74af882b22c6cf35ce999a7b87bfde5b27e7ca",
      "language": "csharp",
      "size": 2686,
      "content": "// ðŸ“„ Features/CTAFlowBuilder/Controllers/FlowRedirectController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Infrastructure.Flows;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"r/flow\")]\n    public class FlowRedirectController : ControllerBase\n    {\n        private readonly IFlowClickTokenService _tokens;\n        private readonly ICTAFlowService _flows;           // service to read flow steps/links\n        private readonly IFlowRuntimeService _runtime;     // service to execute next step\n\n        public FlowRedirectController(\n            IFlowClickTokenService tokens,\n            ICTAFlowService flows,\n            IFlowRuntimeService runtime)\n        {\n            _tokens = tokens;\n            _flows = flows;\n            _runtime = runtime;\n        }\n\n        [HttpGet(\"{token}\")]\n        [AllowAnonymous] // secure by token, tenant checks inside\n        public async Task<IActionResult> RedirectByToken(string token)\n        {\n            FlowClickPayload p;\n            try\n            {\n                p = _tokens.Validate(token);\n            }\n            catch (Exception ex)\n            {\n                return BadRequest($\"Invalid or expired token: {ex.Message}\");\n            }\n\n            // ðŸ”’ Tenant isolation: make sure the business in the token matches the current request context\n            // (if you have multi-tenant enforcement middleware, call it here)\n\n            // 1) Resolve the button link\n            var link = await _flows.GetLinkAsync(p.fid, p.sid, p.bi);\n            if (link is null)\n                return NotFound(\"Link not found for this flow step\");\n\n            var requestId = Guid.NewGuid(); // for idempotency\n            var exec = await _runtime.ExecuteNextAsync(new NextStepContext\n            {\n                BusinessId = p.biz,\n                FlowId = p.fid,\n                Version = p.ver,\n                SourceStepId = p.sid,\n                TargetStepId = link.NextStepId, // may be null â†’ terminal\n                ButtonIndex = p.bi,\n                MessageLogId = p.mlid,\n                ContactPhone = p.cp,\n                RequestId = requestId,\n\n                // ðŸ†• Pass the clicked button for runtime decision\n                ClickedButton = link\n            });\n\n\n            // 3) Redirect the user\n            // If button was a URL, use that; else go to a generic \"thank you\" page\n            var dest = exec.RedirectUrl ?? \"/thank-you\";\n            return Redirect(dest);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/AttachedCampaignDto.cs",
      "sha256": "0d3666aab91197bf746299620d01d22712744acbbcb28b0a787a8e399eaf123f",
      "language": "csharp",
      "size": 341,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed record AttachedCampaignDto(\n        Guid Id,\n        string Name,\n        string Status,\n        DateTime? ScheduledAt,\n        DateTime CreatedAt,\n        string? CreatedBy,\n        DateTime? FirstSentAt   // earliest non-null SentAt from CampaignSendLogs\n    );\n\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs",
      "sha256": "c23400a06816a2adc8886fa8d20dd77f12b8b93f993b5a772d81cb12d6612a1f",
      "language": "csharp",
      "size": 897,
      "content": "// ðŸ“„ File: xbytechat.api/Features/CTAFlowBuilder/DTOs/CreateFlowDto.cs\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CreateFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowStepDto> Steps { get; set; } = new();\n        public bool IsPublished { get; set; } = false; // âœ… NEW: Draft vs Published\n    }\n\n    public class FlowStepDto\n    {\n        public string TriggerButtonText { get; set; } = string.Empty;\n        public string TriggerButtonType { get; set; } = string.Empty;\n        public string TemplateToSend { get; set; } = string.Empty;\n        public int StepOrder { get; set; }\n        public List<ButtonLinkDto> ButtonLinks { get; set; } = new();\n    }\n\n    public class ButtonLinkDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid NextStepId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAButtonClickDto.cs",
      "sha256": "da355d853887193eb1d2b3e3fafcf076e6df764f0220cbf10f5c050d42b91df6",
      "language": "csharp",
      "size": 432,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAButtonClickDto\n    {\n        [Required]\n        public string ButtonText { get; set; } = string.Empty;\n\n        [Required]\n        public string ButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\", \"url\", etc.\n\n        [Required]\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CTAFlowExecutionRequest.cs",
      "sha256": "43fc0e1c1674d188b1a5385539f1314176ff81449d4547ea6665df9909a223bb",
      "language": "csharp",
      "size": 297,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class CTAFlowExecutionRequest\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"cta\";\n        public string RecipientNumber { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/CtaFlowRunResult.cs",
      "sha256": "2a042b3a78e66a762ca685c50cc13508c063fd3076e291597275bbc64620e6a1",
      "language": "csharp",
      "size": 433,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class CtaFlowRunResult\n    {\n        /// <summary>\n        /// True if the CTA flow was started/executed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Optional human-readable error message when Success = false.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowEdgeDto.cs",
      "sha256": "27e76e22a8aba502d5727d9959bec58ea011d2a1f0d4388a141bfa8108043eea",
      "language": "csharp",
      "size": 272,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowEdgeDto\n    {\n        public string FromNodeId { get; set; } = string.Empty;\n        public string ToNodeId { get; set; } = string.Empty;\n        public string? SourceHandle { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowNodeDto.cs",
      "sha256": "93c74e7a37bfe6a0a4538a39a3a942b2cf1c38fd11747714ba384590a18e2ec5",
      "language": "csharp",
      "size": 1221,
      "content": "    namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class FlowNodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n\n        public string TemplateName { get; set; } = string.Empty;\n        public string? TemplateType { get; set; } // âœ… e.g., \"image_template\", \"text_template\"\n        public string MessageBody { get; set; } = string.Empty;\n        public string? TriggerButtonText { get; set; }\n        public string? TriggerButtonType { get; set; }\n        public float PositionX { get; set; }\n        public float PositionY { get; set; }\n\n        public string? RequiredTag { get; set; }         \n        public string? RequiredSource { get; set; }      \n        public List<LinkButtonDto> Buttons { get; set; } = new();\n        public bool UseProfileName { get; set; }\n        public int? ProfileNameSlot { get; set; }\n        //(for flow trigger mapping)\n        // âœ… NEW: ReactFlow expects this structure\n        public PositionDto Position => new PositionDto\n        {\n            x = PositionX,\n            y = PositionY\n        };\n        public class PositionDto\n        {\n            public float x { get; set; }\n            public float y { get; set; }\n        }\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/FlowUpdateResult.cs",
      "sha256": "54f722166617e3353652e949aa4a89c87878d4a1d30d2e208a1fb816668d0dde",
      "language": "csharp",
      "size": 443,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public sealed class FlowUpdateResult\n    {\n        // ok | requiresFork | notFound | error\n        public string Status { get; set; } = \"ok\";\n        public string? Message { get; set; }\n        public bool NeedsRepublish { get; set; } // true when we flipped published->draft to allow editing\n        public object? Campaigns { get; set; }   // list for UI when requiresFork\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/LinkButtonDto.cs",
      "sha256": "e02e2c927a96e1e02c0537fb205fd7595289bdfaa9de15c0d7a55de64a90fbc5",
      "language": "csharp",
      "size": 522,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class LinkButtonDto\n    {\n        public string Text { get; set; } = string.Empty;\n        public int Index { get; set; } = -1;\n        public string? Type { get; set; } // ðŸ”¥ e.g., \"URL\", \"QUICK_REPLY\"\n        public string? SubType { get; set; } // ðŸ”¥ e.g., \"STATIC\", \"DYNAMIC\"\n        public string? Value { get; set; } // ðŸ”¥ the parameter or url or payload\n\n        public string? TargetNodeId { get; set; } // ðŸ”„ used for flow linking\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/SaveVisualFlowDto.cs",
      "sha256": "7de59d222a97efeaf9dc23dea2ef351d852087539cec12e7c946b02e11f1bd21",
      "language": "csharp",
      "size": 403,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class SaveVisualFlowDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n        public Guid? CampaignId { get; set; } // âœ… Add this line\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowLoadDto.cs",
      "sha256": "10bfe378ffd4c8fb74a0746f2abafec88897072e7a974d680396bde281aaf4af",
      "language": "csharp",
      "size": 289,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowLoadDto\n    {\n        public string FlowName { get; set; } = string.Empty;\n        public List<FlowNodeDto> Nodes { get; set; } = new();\n        public List<FlowEdgeDto> Edges { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/DTOs/VisualFlowSummaryDto.cs",
      "sha256": "70dcedd3219a474a4b38927e0f0fd4ff3e21ba16632d409f146a9d0d60d685a5",
      "language": "csharp",
      "size": 300,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.DTOs\n{\n    public class VisualFlowSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowClickLog.cs",
      "sha256": "ecbd408e613e8ef88e2bb39fdf60bc188163e209d8242317203dfb2bff8cebb8",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class CTAFlowClickLog\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs",
      "sha256": "a36019c3ace9f06dcc785152a4ea8e2acc280b169f9e831a28fd6efd2f9d2551",
      "language": "csharp",
      "size": 3404,
      "content": "// ðŸ“„ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Text.Json.Serialization;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n    /// </summary>\n    public class CTAFlowConfig\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string FlowName { get; set; } = string.Empty;\n\n        public bool IsActive { get; set; } = true;\n\n        public bool IsPublished { get; set; } = false; // âœ… NEW: Support draft/published\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public string? CreatedBy { get; set; }\n        public DateTime? UpdatedAt { get; set; }  // âœ… Add this line\n\n        // ðŸ” Navigation to steps\n        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n    }\n}\n\n// ðŸ“„ File: xbytechat.api/Features/CTAFlowBuilder/Models/CTAFlowConfig.cs\n//using System.ComponentModel.DataAnnotations;\n//using System.Text.Json.Serialization;\n//using Microsoft.EntityFrameworkCore;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Models\n//{\n//    /// <summary>\n//    /// Represents a complete flow configuration for a business, such as \"Interested Journey\".\n//    /// </summary>\n//    [Index(nameof(BusinessId), nameof(IsActive), nameof(FlowName), Name = \"ix_ctaflowconfigs_biz_active_name\")]\n//    [Index(nameof(BusinessId), nameof(IsPublished), Name = \"ix_ctaflowconfigs_biz_published\")]\n//    public class CTAFlowConfig\n//    {\n//        [Key]\n//        public Guid Id { get; set; }\n\n//        [Required]\n//        public Guid BusinessId { get; set; }\n\n//        [Required, MaxLength(100)]\n//        public string FlowName { get; set; } = string.Empty;\n\n//        /// <summary>\n//        /// Soft â€œenabled/disabledâ€ flag for listing/selection. We still hard-delete unused flows on request.\n//        /// </summary>\n//        public bool IsActive { get; set; } = true;\n\n//        /// <summary>\n//        /// Draft vs published for the builder.\n//        /// </summary>\n//        public bool IsPublished { get; set; } = false;\n\n//        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n//        public string? CreatedBy { get; set; }\n\n//        /// <summary>\n//        /// Last modification timestamp (updated in service on edits).\n//        /// </summary>\n//        public DateTime? UpdatedAt { get; set; }\n\n//        /// <summary>\n//        /// Optimistic concurrency token to avoid race conditions (e.g., editing while someone tries to delete).\n//        /// </summary>\n//        [Timestamp]\n//        public byte[]? RowVersion { get; set; }\n\n//        // ðŸ” Navigation to steps\n//        // Cascade delete is configured in OnModelCreating:\n//        // modelBuilder.Entity<CTAFlowConfig>()\n//        //   .HasMany(f => f.Steps).WithOne(s => s.Flow)\n//        //   .HasForeignKey(s => s.FlowId)\n//        //   .OnDelete(DeleteBehavior.Cascade);\n//        [JsonIgnore] // prevent huge payloads if you serialize configs somewhere else\n//        public ICollection<CTAFlowStep> Steps { get; set; } = new List<CTAFlowStep>();\n//    }\n//}\n\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/CTAFlowStep.cs",
      "sha256": "a0c230aa38fa4980c6dff6a4bfc2466ae805f9179280d41cc7b1ca975054e03f",
      "language": "csharp",
      "size": 1608,
      "content": "// ðŸ“„ File: Features/CTAFlowBuilder/Models/CTAFlowStep.cs\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Represents a single step in a CTA flow, triggered by a button.\n    /// </summary>\n    public class CTAFlowStep\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid CTAFlowConfigId { get; set; }\n\n        [ForeignKey(nameof(CTAFlowConfigId))]\n        public CTAFlowConfig Flow { get; set; } = null!;\n\n        public string TriggerButtonText { get; set; } = string.Empty;\n\n        public string TriggerButtonType { get; set; } = \"cta\"; // e.g., \"quick_reply\"\n\n        public string TemplateToSend { get; set; } = string.Empty;\n\n        public int StepOrder { get; set; }\n\n        public string? RequiredTag { get; set; }        // e.g., \"interested\"\n        public string? RequiredSource { get; set; }     // e.g., \"ads\", \"qr\", \"manual\"\n\n        // ðŸ”€ Multiple buttons linking to different steps\n        public List<FlowButtonLink> ButtonLinks { get; set; } = new();\n\n        public float? PositionX { get; set; }\n        public float? PositionY { get; set; }\n        public string? TemplateType { get; set; }\n\n        // âœ… Use WhatsApp Profile Name in this step's template?\n        public bool UseProfileName { get; set; } = false;\n\n        // âœ… 1-based placeholder index in the template body (e.g., {{1}})\n        public int? ProfileNameSlot { get; set; } = 1;\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowButtonLink.cs",
      "sha256": "6b265bc48b8286ca84e5937f9f8f6fe99b8b6580ca59a43aedda8290fc685aaa",
      "language": "csharp",
      "size": 807,
      "content": "namespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    public class FlowButtonLink\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? NextStepId { get; set; }\n        // âœ… NEW FIELDS FOR FUTURE AUTOMATION\n        public string ButtonType { get; set; } = \"QUICK_REPLY\";    // e.g., URL, QUICK_REPLY, FLOW\n        public string ButtonSubType { get; set; } = \"\";            // Optional: e.g., \"Catalog\", \"PricingCTA\"\n        public string ButtonValue { get; set; } = \"\";              // e.g., URL or deep link\n\n        // Optional FK back to Step if needed\n        public Guid CTAFlowStepId { get; set; }\n        public CTAFlowStep? Step { get; set; }\n\n        public short ButtonIndex { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionContext.cs",
      "sha256": "3b09934afbf7d4d7844c890fde23a96a3ba4d932fa506268da131b78ac6b5385",
      "language": "csharp",
      "size": 4023,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Canonical context/payload for logging a single flow step execution.\n    /// This wraps all the information we want to write into FlowExecutionLogs.\n    /// </summary>\n    public sealed class FlowExecutionContext\n    {\n        /// <summary>\n        /// Tenant / business that owns this flow execution.\n        /// </summary>\n        public Guid BusinessId { get; set; }\n\n        /// <summary>\n        /// Optional contact this journey is associated with.\n        /// </summary>\n        public Guid? ContactId { get; set; }   // ðŸ‘ˆ ADD THIS\n\n        /// <summary>\n        /// Which engine started this journey (Campaign, AutoReply, etc.).\n        /// </summary>\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown;\n\n        /// <summary>\n        /// Logical flow definition. For CTA flows this is CTAFlowConfig.Id.\n        /// </summary>\n        public Guid? FlowId { get; set; }\n\n        /// <summary>\n        /// Step being executed.\n        /// </summary>\n        public Guid StepId { get; set; }\n\n        /// <summary>\n        /// Optional friendly name for the step.\n        /// </summary>\n        public string? StepName { get; set; }\n\n        /// <summary>\n        /// Optional correlation id for one \"run\" of a journey.\n        /// Multiple steps in the same journey can share RunId.\n        /// </summary>\n        public Guid? RunId { get; set; }\n\n        /// <summary>\n        /// Optional higher-level campaign this journey belongs to.\n        /// </summary>\n        public Guid? CampaignId { get; set; }\n\n        /// <summary>\n        /// Optional AutoReplyFlow id when journey started from keyword matching.\n        /// </summary>\n        public Guid? AutoReplyFlowId { get; set; }\n\n        /// <summary>\n        /// Optional specific send log (CampaignSendLog) if this was tied to a blast.\n        /// </summary>\n        public Guid? CampaignSendLogId { get; set; }\n\n        /// <summary>\n        /// Optional tracking log id (CTA click tracking, etc.).\n        /// </summary>\n        public Guid? TrackingLogId { get; set; }\n\n        /// <summary>\n        /// Optional link to underlying MessageLog row.\n        /// </summary>\n        public Guid? MessageLogId { get; set; }\n\n        /// <summary>\n        /// Phone number in E.164 form that this step is interacting with.\n        /// </summary>\n        public string? ContactPhone { get; set; }\n\n        /// <summary>\n        /// Human-readable label of the button that triggered the step, if any.\n        /// </summary>\n        public string? TriggeredByButton { get; set; }\n\n        /// <summary>\n        /// Index of the clicked button (0..2) where applicable.\n        /// </summary>\n        public short? ButtonIndex { get; set; }\n\n        /// <summary>\n        /// Template name that was used in this step (if any).\n        /// </summary>\n        public string? TemplateName { get; set; }\n\n        /// <summary>\n        /// Template type / category (e.g. \"image_template\", \"text_template\").\n        /// </summary>\n        public string? TemplateType { get; set; }\n\n        /// <summary>\n        /// Per-request correlation id (can come from message engine, HTTP request, etc.).\n        /// </summary>\n        public Guid? RequestId { get; set; }\n\n        /// <summary>\n        /// Whether the step action completed successfully.\n        /// </summary>\n        public bool Success { get; set; }\n\n        /// <summary>\n        /// Error message when the step failed.\n        /// </summary>\n        public string? ErrorMessage { get; set; }\n\n        /// <summary>\n        /// Raw provider response or internal payload for debugging.\n        /// </summary>\n        public string? RawResponse { get; set; }\n\n        /// <summary>\n        /// When the step was executed (UTC).\n        /// If null, the logger will default to DateTime.UtcNow.\n        /// </summary>\n        public DateTime? ExecutedAtUtc { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionLog.cs",
      "sha256": "d859aa17be20179548d281edae56a6d0fb7b5321f5bd49144ada2ba82ad8e5a4",
      "language": "csharp",
      "size": 1635,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Logs when a visual flow step is executed (useful for analytics, debugging, audit).\n    /// </summary>\n    public class FlowExecutionLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid? RunId { get; set; }\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public Guid StepId { get; set; }\n        public string StepName { get; set; } = string.Empty;\n\n        public Guid? FlowId { get; set; }\n\n        public FlowExecutionOrigin Origin { get; set; } = FlowExecutionOrigin.Unknown; //new\n\n        public Guid? CampaignId { get; set; } // new \n        public Guid? AutoReplyFlowId { get; set; } // new\n\n        public Guid? CampaignSendLogId { get; set; }\n\n\n        public Guid? TrackingLogId { get; set; }\n\n        public string? ContactPhone { get; set; }\n\n        public string? TriggeredByButton { get; set; }\n\n        public string? TemplateName { get; set; }\n\n        public string? TemplateType { get; set; }\n\n        public bool Success { get; set; }\n\n        public string? ErrorMessage { get; set; }\n\n        public string? RawResponse { get; set; }\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n\n        public Guid? MessageLogId { get; set; }              // tie to originating message\n        public short? ButtonIndex { get; set; }              // which button was clicked (0..2)\n        public Guid? RequestId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Models/FlowExecutionOrigin.cs",
      "sha256": "34b36adc1c0b157360c81e219a5fc265c18612efb937a62fcbea1405a41280a7",
      "language": "csharp",
      "size": 1131,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Models\n{\n    /// <summary>\n    /// Describes where a flow execution was started from.\n    /// This is the key for analytics segmentation.\n    /// </summary>\n    public enum FlowExecutionOrigin\n    {\n        /// <summary>\n        /// Default / legacy rows before origin tracking was introduced.\n        /// </summary>\n        Unknown = 0,\n\n        /// <summary>\n        /// Flow started as part of a Campaign CTA (button click, deep link, etc.).\n        /// </summary>\n        Campaign = 1,\n\n        /// <summary>\n        /// Flow started from AutoReply word matching (keyword â†’ flow).\n        /// </summary>\n        AutoReply = 2,\n\n        /// <summary>\n        /// Flow started from a future â€œJourneyBotâ€ or similar orchestration engine.\n        /// </summary>\n        JourneyBot = 3,\n\n        /// <summary>\n        /// Flow started manually from Inbox or agent tools.\n        /// </summary>\n        Inbox = 4,\n\n        /// <summary>\n        /// System-driven or other internal triggers (backfill, test, etc.).\n        /// </summary>\n        System = 5\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs",
      "sha256": "380d5227b25215b5baaf9496aa9410b6dbec2b75c883bf875ec25f707dd0b5d6",
      "language": "csharp",
      "size": 19163,
      "content": "// ðŸ“„ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // ðŸ‘ˆ Keep this if AppDbContext is in the root namespace\n// If AppDbContext lives under xbytechat.api.Data, then use:\n// using xbytechat.api.Data;\n\nusing xbytechat.api.Features.CTAFlowBuilder.DTOs;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Enums;\nusing xbytechat.api.Features.MessagesEngine.Services;\n\nnamespace xbytechat.api.Features.CTAFlowBuilder.Services\n{\n    /// <summary>\n    /// Minimal CTA flow runtime engine (v1).\n    ///\n    /// Responsibilities:\n    /// - Load CTAFlowConfig + steps from DB.\n    /// - Execute the first step (template send) using IMessageEngineService.\n    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n    ///\n    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n    /// can later separate:\n    ///   - \"CTA flow started by AutoReply\"\n    ///   - \"CTA flow started by Campaign button\"\n    ///   - other origins (JourneyBot, Inbox, System).\n    /// </summary>\n    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly IFlowExecutionLogger _flowLogger;\n        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n        public CtaFlowRuntimeService(\n            AppDbContext db,\n            IMessageEngineService messageEngine,\n            IFlowExecutionLogger flowLogger,\n            ILogger<CtaFlowRuntimeService> logger)\n        {\n            _db = db ?? throw new ArgumentNullException(nameof(db));\n            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        }\n\n        public async Task<CtaFlowRunResult> StartFlowAsync(\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            Guid configId,\n            FlowExecutionOrigin origin,\n            Guid? autoReplyFlowId,\n            CancellationToken cancellationToken = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n            if (configId == Guid.Empty)\n                throw new ArgumentException(\"configId is required\", nameof(configId));\n            if (string.IsNullOrWhiteSpace(contactPhone))\n                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n            _logger.LogInformation(\n                \"ðŸš€ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n                businessId,\n                contactId,\n                contactPhone,\n                configId,\n                origin,\n                autoReplyFlowId);\n\n            // 1ï¸âƒ£ Load the CTA flow (must be active + published) with its steps\n            var flow = await _db.CTAFlowConfigs\n                .AsNoTracking()\n                .Include(f => f.Steps)\n                .FirstOrDefaultAsync(\n                    f => f.Id == configId\n                         && f.BusinessId == businessId\n                         && f.IsActive\n                         && f.IsPublished,\n                    cancellationToken);\n\n            if (flow == null)\n            {\n                var message =\n                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                // Log a failed \"meta-step\" so analytics can see the failure\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = configId,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log which contact we tried to start for\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = configId,          // no specific step; use flow id as placeholder\n                    StepName = \"FLOW_NOT_FOUND\",\n\n                    // No template here\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            // 2ï¸âƒ£ Pick the first step (v1 = simple linear flow)\n            var firstStep = flow.Steps\n                .OrderBy(s => s.StepOrder)\n                .FirstOrDefault();\n\n            if (firstStep == null)\n            {\n                var message =\n                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n                var failCtx = new FlowExecutionContext\n                {\n                    BusinessId = businessId,\n                    FlowId = flow.Id,\n                    AutoReplyFlowId = autoReplyFlowId,\n                    Origin = origin,\n\n                    // NEW: log contact context even on failure\n                    ContactId = contactId,\n                    ContactPhone = contactPhone,\n\n                    StepId = flow.Id,\n                    StepName = \"NO_STEPS\",\n\n                    TemplateName = null,\n                    TemplateType = null,\n\n                    Success = false,\n                    ErrorMessage = message,\n                    ExecutedAtUtc = DateTime.UtcNow\n                };\n\n                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n                return new CtaFlowRunResult\n                {\n                    Success = false,\n                    ErrorMessage = message\n                };\n            }\n\n            _logger.LogInformation(\n                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n                firstStep.Id,\n                firstStep.TemplateToSend,\n                flow.Id,\n                flow.FlowName);\n\n            // 3ï¸âƒ£ Build SimpleTemplateMessageDto with CTA tracking fields\n            var templateDto = new SimpleTemplateMessageDto\n            {\n                RecipientNumber = contactPhone,\n                TemplateName = firstStep.TemplateToSend,\n\n                // v1: no dynamic params here â€“ flows can be extended later\n                TemplateParameters = new List<string>(),\n\n                // v1: let MessageEngine choose routing / provider\n                HasStaticButtons = false,\n                Provider = string.Empty,\n                PhoneNumberId = null,\n\n                // ðŸ”— Link back to CTA flow config + step\n                CTAFlowConfigId = flow.Id,\n                CTAFlowStepId = firstStep.Id,\n\n                // Optional fields â€“ keep null for now\n                TemplateBody = null,\n                LanguageCode = null\n            };\n\n            // 4ï¸âƒ£ Send the message via MessageEngine (conversational â†’ Immediate)\n            var sendResult = await _messageEngine\n                .SendTemplateMessageSimpleAsync(\n                    businessId,\n                    templateDto,\n                    DeliveryMode.Immediate);\n\n            // 5ï¸âƒ£ Log the step into FlowExecutionLogs\n            var logCtx = new FlowExecutionContext\n            {\n                BusinessId = businessId,\n                FlowId = flow.Id,\n                AutoReplyFlowId = autoReplyFlowId,\n                Origin = origin,\n\n                // Contact context\n                ContactId = contactId,\n                ContactPhone = contactPhone,\n\n                // Step context\n                StepId = firstStep.Id,\n                StepName = firstStep.TemplateToSend,\n\n                // Template metadata for analytics\n                TemplateName = firstStep.TemplateToSend,\n                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n                // Result\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n                ExecutedAtUtc = DateTime.UtcNow\n\n                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n                // can be wired later once message engine returns those ids.\n            };\n\n            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n            return new CtaFlowRunResult\n            {\n                Success = sendResult.Success,\n                ErrorMessage = sendResult.Success ? null : sendResult.Message\n            };\n        }\n    }\n}\n\n\n//// ðŸ“„ xbytechat-api/Features/CTAFlowBuilder/Services/CtaFlowRuntimeService.cs\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api; // ðŸ‘ˆ Keep this if AppDbContext is in the root namespace\n//// If AppDbContext lives under xbytechat.api.Data, then use:\n//// using xbytechat.api.Data;\n\n//using xbytechat.api.Features.CTAFlowBuilder.DTOs;\n//using xbytechat.api.Features.CTAFlowBuilder.Models;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n\n//namespace xbytechat.api.Features.CTAFlowBuilder.Services\n//{\n//    /// <summary>\n//    /// Minimal CTA flow runtime engine (v1).\n//    ///\n//    /// Responsibilities:\n//    /// - Load CTAFlowConfig + steps from DB.\n//    /// - Execute the first step (template send) using IMessageEngineService.\n//    /// - Log the execution into FlowExecutionLogs via IFlowExecutionLogger.\n//    ///\n//    /// It uses FlowExecutionOrigin + AutoReplyFlowId / CampaignId so analytics\n//    /// can later separate:\n//    ///   - \"CTA flow started by AutoReply\"\n//    ///   - \"CTA flow started by Campaign button\"\n//    ///   - other origins (JourneyBot, Inbox, System).\n//    /// </summary>\n//    public sealed class CtaFlowRuntimeService : ICtaFlowRuntimeService\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IMessageEngineService _messageEngine;\n//        private readonly IFlowExecutionLogger _flowLogger;\n//        private readonly ILogger<CtaFlowRuntimeService> _logger;\n\n//        public CtaFlowRuntimeService(\n//            AppDbContext db,\n//            IMessageEngineService messageEngine,\n//            IFlowExecutionLogger flowLogger,\n//            ILogger<CtaFlowRuntimeService> logger)\n//        {\n//            _db = db ?? throw new ArgumentNullException(nameof(db));\n//            _messageEngine = messageEngine ?? throw new ArgumentNullException(nameof(messageEngine));\n//            _flowLogger = flowLogger ?? throw new ArgumentNullException(nameof(flowLogger));\n//            _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n//        }\n\n//        public async Task<CtaFlowRunResult> StartFlowAsync(\n//            Guid businessId,\n//            Guid contactId,\n//            string contactPhone,\n//            Guid configId,\n//            FlowExecutionOrigin origin,\n//            Guid? autoReplyFlowId,\n//            CancellationToken cancellationToken = default)\n//        {\n//            if (businessId == Guid.Empty)\n//                throw new ArgumentException(\"businessId is required\", nameof(businessId));\n//            if (configId == Guid.Empty)\n//                throw new ArgumentException(\"configId is required\", nameof(configId));\n//            if (string.IsNullOrWhiteSpace(contactPhone))\n//                throw new ArgumentException(\"contactPhone is required\", nameof(contactPhone));\n\n//            _logger.LogInformation(\n//                \"ðŸš€ [CTAFlowRuntime] StartFlowAsync Biz={BusinessId}, Contact={ContactId}, Phone={Phone}, Config={ConfigId}, Origin={Origin}, AutoReplyFlowId={AutoReplyFlowId}\",\n//                businessId,\n//                contactId,\n//                contactPhone,\n//                configId,\n//                origin,\n//                autoReplyFlowId);\n\n//            // 1ï¸âƒ£ Load the CTA flow (must be active + published) with its steps\n//            var flow = await _db.CTAFlowConfigs\n//                .AsNoTracking()\n//                .Include(f => f.Steps)\n//                .FirstOrDefaultAsync(\n//                    f => f.Id == configId\n//                         && f.BusinessId == businessId\n//                         && f.IsActive\n//                         && f.IsPublished,\n//                    cancellationToken);\n\n//            if (flow == null)\n//            {\n//                var message =\n//                    $\"CTA flow {configId} for business {businessId} not found, inactive, or not published.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                // Log a failed \"meta-step\" so analytics can see the failure\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = configId,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log which contact we tried to start for\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = configId,          // no specific step; use flow id as placeholder\n//                    StepName = \"FLOW_NOT_FOUND\",\n\n//                    // No template here\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            // 2ï¸âƒ£ Pick the first step (v1 = simple linear flow)\n//            var firstStep = flow.Steps\n//                .OrderBy(s => s.StepOrder)\n//                .FirstOrDefault();\n\n//            if (firstStep == null)\n//            {\n//                var message =\n//                    $\"CTA flow {flow.Id} ('{flow.FlowName}') has no steps configured.\";\n\n//                _logger.LogWarning(\"[CTAFlowRuntime] {Message}\", message);\n\n//                var failCtx = new FlowExecutionContext\n//                {\n//                    BusinessId = businessId,\n//                    FlowId = flow.Id,\n//                    AutoReplyFlowId = autoReplyFlowId,\n//                    Origin = origin,\n\n//                    // NEW: log contact context even on failure\n//                    ContactId = contactId,\n//                    ContactPhone = contactPhone,\n\n//                    StepId = flow.Id,\n//                    StepName = \"NO_STEPS\",\n\n//                    TemplateName = null,\n//                    TemplateType = null,\n\n//                    Success = false,\n//                    ErrorMessage = message,\n//                    ExecutedAtUtc = DateTime.UtcNow\n//                };\n\n//                await _flowLogger.LogStepAsync(failCtx, cancellationToken);\n\n//                return new CtaFlowRunResult\n//                {\n//                    Success = false,\n//                    ErrorMessage = message\n//                };\n//            }\n\n//            _logger.LogInformation(\n//                \"[CTAFlowRuntime] Executing first step {StepId} ({Template}) of flow {FlowId} ('{FlowName}')\",\n//                firstStep.Id,\n//                firstStep.TemplateToSend,\n//                flow.Id,\n//                flow.FlowName);\n\n//            // 3ï¸âƒ£ Build SimpleTemplateMessageDto with CTA tracking fields\n//            var templateDto = new SimpleTemplateMessageDto\n//            {\n//                RecipientNumber = contactPhone,\n//                TemplateName = firstStep.TemplateToSend,\n\n//                // v1: no dynamic params here â€“ flows can be extended later\n//                TemplateParameters = new List<string>(),\n\n//                // v1: let MessageEngine choose routing / provider\n//                HasStaticButtons = false,\n//                Provider = string.Empty,\n//                PhoneNumberId = null,\n\n//                // ðŸ”— Link back to CTA flow config + step\n//                CTAFlowConfigId = flow.Id,\n//                CTAFlowStepId = firstStep.Id,\n\n//                // Optional fields â€“ keep null for now\n//                TemplateBody = null,\n//                LanguageCode = null\n//            };\n\n//            // 4ï¸âƒ£ Send the message via MessageEngine\n//            var sendResult = await _messageEngine\n//                .SendTemplateMessageSimpleAsync(businessId, templateDto);\n\n//            // 5ï¸âƒ£ Log the step into FlowExecutionLogs\n//            var logCtx = new FlowExecutionContext\n//            {\n//                BusinessId = businessId,\n//                FlowId = flow.Id,\n//                AutoReplyFlowId = autoReplyFlowId,\n//                Origin = origin,\n\n//                // Contact context\n//                ContactId = contactId,\n//                ContactPhone = contactPhone,\n\n//                // Step context\n//                StepId = firstStep.Id,\n//                StepName = firstStep.TemplateToSend,\n\n//                // Template metadata for analytics\n//                TemplateName = firstStep.TemplateToSend,\n//                TemplateType = firstStep.TemplateType ?? \"CTA_FLOW_TEMPLATE\",\n\n//                // Result\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message,\n//                ExecutedAtUtc = DateTime.UtcNow\n\n//                // MessageLogId, CatalogClickLogId, CampaignId, etc.\n//                // can be wired later once message engine returns those ids.\n//            };\n\n//            await _flowLogger.LogStepAsync(logCtx, cancellationToken);\n\n//            return new CtaFlowRunResult\n//            {\n//                Success = sendResult.Success,\n//                ErrorMessage = sendResult.Success ? null : sendResult.Message\n//            };\n//        }\n//    }\n//}\n\n\n"
    }
  ]
}
