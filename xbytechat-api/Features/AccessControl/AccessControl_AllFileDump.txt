Folder and File Content Report
Root folder: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl
Generated at: 10-12-2025 13:28:29.09
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\MakeDump.bat 
====================================================== 
 
@echo off
REM This script will find relevant source files and output their names and contents into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh and write a small header
> "%outputFile%" (
    echo Folder and File Content Report
    echo Root folder: %cd%
    echo Generated at: %date% %time%
)
echo. >> "%outputFile%"

REM NOTE:
REM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)
REM This keeps the file smaller and much easier to review.

REM Loop through all relevant files in the current directory and subdirectories
REM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML
for /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (

    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)
    echo "%%F" | findstr /I /C:"\node_modules\" /C:"\bin\" /C:"\obj\" /C:"\.git\" /C:"\dist\" /C:"\.vs\" >nul
    if errorlevel 1 (
        echo ====================================================== >> "%outputFile%"
        echo FILE: %%F >> "%outputFile%"
        echo ====================================================== >> "%outputFile%"
        echo. >> "%outputFile%"
        type "%%F" >> "%outputFile%" 2>nul
        echo. >> "%outputFile%"
        echo. >> "%outputFile%"
    )
)

echo Finished! All content has been extracted to %outputFile%
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Attributes\HasPermissionAttribute.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Linq;
using System.Threading.Tasks;
using xbytechat.api.Features.AccessControl.Services;

namespace xbytechat.api.Features.AccessControl.Attributes
{
    public class HasPermissionAttribute : Attribute, IAsyncAuthorizationFilter
    {
        private readonly string _permissionCode;

        public HasPermissionAttribute(string permissionCode) => _permissionCode = permissionCode;

        public async Task OnAuthorizationAsync(AuthorizationFilterContext context)
        {
            var user = context.HttpContext.User;
            var planIdClaim = user.FindFirst("plan_id")?.Value;

            if (string.IsNullOrWhiteSpace(planIdClaim) || !Guid.TryParse(planIdClaim, out var planId))
            {
                context.Result = new ForbidResult();
                return;
            }

            var permissionService = context.HttpContext.RequestServices
                .GetRequiredService<IPermissionCacheService>();

            var permissions = await permissionService.GetPlanPermissionsAsync(planId);

            var hasPermission = permissions.Any(p =>
                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));

            if (!hasPermission)
                context.Result = new ForbidResult();
        }
    }
}


//using Microsoft.AspNetCore.Mvc;
//using Microsoft.AspNetCore.Mvc.Filters;
//using Microsoft.Extensions.DependencyInjection;
//using System;
//using System.Linq;
//using xbytechat.api.Features.AccessControl.Services;

//namespace xbytechat.api.Features.AccessControl.Attributes
//{
//    public class HasPermissionAttribute : Attribute, IAuthorizationFilter
//    {
//        private readonly string _permissionCode;

//        public HasPermissionAttribute(string permissionCode)
//        {
//            _permissionCode = permissionCode;
//        }

//        public void OnAuthorization(AuthorizationFilterContext context)
//        {
//            var user = context.HttpContext.User;
//            var planIdClaim = user.FindFirst("plan_id")?.Value;

//            if (string.IsNullOrEmpty(planIdClaim))
//            {
//                context.Result = new ForbidResult();
//                return;
//            }

//            if (!Guid.TryParse(planIdClaim, out var planId))
//            {
//                context.Result = new ForbidResult();
//                return;
//            }

//            var permissionService = context.HttpContext.RequestServices
//                .GetRequiredService<IPermissionCacheService>();

//            // Get permissions for this plan from cache
//            var permissions = permissionService.GetPlanPermissionsAsync(planId).Result;

//            // Check if any permission matches the requested code
//            bool hasPermission = permissions.Any(p =>
//                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));

//            if (!hasPermission)
//            {
//                context.Result = new ForbidResult();
//            }
//        }
//    }
//}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Controllers\PermissionController.cs 
====================================================== 
 
Ôªø// üìÑ Features/AccessControl/Controllers/PermissionController.cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using xbytechat.api.Features.AccessControl.DTOs;
using xbytechat.api.Features.AccessControl.Services;
using xbytechat.api.Helpers;

namespace xbytechat.api.Features.AccessControl.Controllers
{
    [ApiController]
    [Route("api/permission")]
    [Authorize]
    public class PermissionController : ControllerBase
    {
        private readonly IPermissionService _permissionService;

        public PermissionController(IPermissionService permissionService)
        {
            _permissionService = permissionService;
        }

        // --- Existing grouped endpoint (kept for compatibility) ---
        // GET /api/permission/grouped
        [HttpGet("grouped")]
        public async Task<IActionResult> GetGroupedPermissions(CancellationToken ct)
        {
            var grouped = await _permissionService.GetGroupedPermissionsAsync();
            return Ok(ResponseResult.SuccessInfo("Permissions grouped by category", grouped));
        }

        // --- New CRUD endpoints used by PermissionsPage ---

        // GET /api/permission
        [HttpGet]
        [Authorize(Roles = "superadmin,partneradmin,admin")]
        public async Task<ActionResult<IEnumerable<PermissionSummaryDto>>> GetAll(
            CancellationToken ct)
        {
            var list = await _permissionService.GetAllAsync(ct);
            return Ok(list); // React expects a plain array
        }

        // POST /api/permission
        [HttpPost]
        [Authorize(Roles = "superadmin,partneradmin,admin")]
        public async Task<ActionResult<PermissionSummaryDto>> Create(
            [FromBody] PermissionUpsertDto dto,
            CancellationToken ct)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            try
            {
                var created = await _permissionService.CreateAsync(dto, ct);
                return Ok(created);
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        // PUT /api/permission/{id}
        [HttpPut("{id:guid}")]
        [Authorize(Roles = "superadmin,partneradmin,admin")]
        public async Task<ActionResult<PermissionSummaryDto>> Update(
            Guid id,
            [FromBody] PermissionUpsertDto dto,
            CancellationToken ct)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            try
            {
                var updated = await _permissionService.UpdateAsync(id, dto, ct);
                return Ok(updated);
            }
            catch (KeyNotFoundException)
            {
                return NotFound();
            }
            catch (InvalidOperationException ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        // DELETE /api/permission/{id}  (soft delete)
        [HttpDelete("{id:guid}")]
        [Authorize(Roles = "superadmin,partneradmin,admin")]
        public async Task<IActionResult> Deactivate(
            Guid id,
            CancellationToken ct)
        {
            try
            {
                await _permissionService.DeactivateAsync(id, ct);
                return NoContent();
            }
            catch (KeyNotFoundException)
            {
                return NotFound();
            }
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Controllers\PlanController.cs 
====================================================== 
 
Ôªøusing Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System;
using System.Linq;
using System.Threading.Tasks;
using xbytechat.api.Features.AccessControl.DTOs;
using xbytechat.api.Features.AccessControl.Services;
using xbytechat.api.Helpers; // ‚úÖ For ResponseResult

namespace xbytechat.api.Features.AccessControl.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [Authorize]
    public class PlanController : ControllerBase
    {
        private readonly IPlanService _planService;
        private readonly IPermissionCacheService _permissionCacheService;
        private readonly ILogger<PlanController> _logger;
        public PlanController(IPlanService planService, IPermissionCacheService permissionCacheService, ILogger<PlanController> logger)
        {
            _planService = planService;
            _permissionCacheService = permissionCacheService;
            _logger = logger;
        }

        [HttpGet]
        public async Task<IActionResult> GetPlans()
        {
            try
            {
                var plans = await _planService.GetAllPlansAsync();
                return Ok(plans); // Return plain array
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to load plans");
                return BadRequest(new { message = "Failed to load plans", error = ex.Message });
            }
        }

        [HttpGet("{planId}/permissions")]
        public async Task<IActionResult> GetPlanPermissions(Guid planId)
        {
            try
            {
               // var permissions = await _planService.GetPermissionsForPlanAsync(planId);
                var permissions = await _permissionCacheService.GetPlanPermissionsAsync(planId);

                return Ok(permissions);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to load permissions for plan {PlanId}", planId);
                return BadRequest(new { message = "Failed to load permissions", error = ex.Message });
            }
        }

     
        [HttpPost("Create")]
        [Authorize(Roles = "superadmin,partneradmin,admin")]
        public async Task<IActionResult> CreatePlan([FromBody] CreatePlanDto dto)
        {
            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))
                return BadRequest(new { message = "Code and Name are required" });

            try
            {
                var newPlanId = await _planService.CreatePlanAsync(dto);
                return Ok(new { id = newPlanId, message = "Plan created successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to create plan {PlanName}", dto.Name);
                return BadRequest(new { message = "Failed to create plan", error = ex.Message });
            }
        }

        [HttpPut("{planId}")]
        [Authorize(Roles = "superadmin,partneradmin,admin")]
        public async Task<IActionResult> UpdatePlan(Guid planId, [FromBody] UpdatePlanDto dto)
        {
            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))
                return BadRequest(new { message = "Code and Name are required" });

            try
            {
                var updated = await _planService.UpdatePlanAsync(planId, dto);
                if (!updated)
                    return NotFound(new { message = "Plan not found" });

                return Ok(new { message = "Plan updated successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to update plan {PlanId}", planId);
                return BadRequest(new { message = "Failed to update plan", error = ex.Message });
            }
        }

        [HttpDelete("{planId}")]
        [Authorize(Roles = "superadmin,partneradmin,admin")]
        public async Task<IActionResult> DeletePlan(Guid planId)
        {
            try
            {
                var deleted = await _planService.DeletePlanAsync(planId);
                if (!deleted)
                    return NotFound(new { message = "Plan not found or already inactive" });
                // ‚úÖ Clear cache when plan is deleted
                _permissionCacheService.ClearPlanPermissionsCache(planId);
                return Ok(new { message = "Plan deleted successfully" });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to delete plan {PlanId}", planId);
                return BadRequest(new { message = "Failed to delete plan", error = ex.Message });
            }
        }
      
        [HttpGet("me/permissions")]
        public async Task<IActionResult> GetMyPlanPermissions(CancellationToken ct)
        {
            var role = User.FindFirst("role")?.Value ?? string.Empty;

            // Admin-like roles don't need a plan
            if (role is "superadmin" or "admin" or "partner" or "reseller")
                return Ok(new
                {
                    planId = (Guid?)null,
                    plan = (PlanDto?)null,
                    permissions = new[] { "*" }
                });

            var planIdStr = User.FindFirst("plan_id")?.Value;
            if (!Guid.TryParse(planIdStr, out var planId))
                return Ok(new
                {
                    planId = (Guid?)null,
                    plan = (PlanDto?)null,
                    permissions = Array.Empty<string>()
                });

            // permissions (cached)
            var permissionEntities = await _permissionCacheService.GetPlanPermissionsAsync(planId);
            var codes = permissionEntities
                .Where(p => p.IsActive)
                .Select(p => p.Code)
                .Distinct()
                .ToList();

            // ‚úÖ Fetch the plan once and return it as PlanDto
            var planDto = await _planService.GetByIdAsync(planId, ct);

            return Ok(new
            {
                planId,
                plan = planDto,     // PlanDto or null
                permissions = codes
            });
        }

        // üìÑ Features/AccessControl/Controllers/PlanController.cs
        [HttpPut("{planId:guid}/permissions")]
        [Authorize(Roles = "superadmin,partneradmin,admin")]
        public async Task<IActionResult> UpdatePlanPermissions(
            Guid planId,
            [FromBody] UpdatePlanPermissionsRequest body,
            CancellationToken ct)
        {
            var actor = User?.Identity?.Name ?? "system";
            await _planService.UpdatePlanPermissionsAsync(
                planId,
                body.PermissionIds,     // must be named PermissionIds
                body.ReplaceAll,        // default true
                actor,
                ct);

            return NoContent(); // 204
        }

        // üìÑ Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs
        public sealed class UpdatePlanPermissionsRequest
        {
            public List<Guid> PermissionIds { get; set; } = new();
            public bool ReplaceAll { get; set; } = true;
        }




    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Controllers\UserPermissionsController.cs 
====================================================== 
 
Ôªø#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using xbytechat.api.AuthModule.Models;
using xbytechat.api.Features.AccessControl.Models;

namespace xbytechat.api.Features.AccessControl.Controllers
{
    /// <summary>
    /// Manage per-user permission overrides.
    ///
    /// Important:
    /// - We do NOT calculate effective permissions here.
    ///   Plan ‚Üí permissions is handled by Plan/AccessControl services.
    /// - This controller only manages rows in UserPermission (allow/deny overrides).
    ///   The UI can merge:
    ///     a) plan permissions  + 
    ///     b) these overrides
    ///   to show the final state for each feature.
    /// </summary>
    [ApiController]
    [Route("api/admin/users/{userId:guid}/permissions")]
    [Authorize(Roles = "admin")]
    public sealed class UserPermissionsController : ControllerBase
    {
        private readonly AppDbContext _db;

        public UserPermissionsController(AppDbContext db)
        {
            _db = db;
        }

        // --------- DTOs (you can later move them to Features/AccessControl/DTOs) ---------

        public sealed class UserPermissionOverrideDto
        {
            public Guid PermissionId { get; set; }
            public string Code { get; set; } = string.Empty;
            public string Name { get; set; } = string.Empty;

            /// <summary>
            /// true  = explicit allow
            /// false = explicit deny
            /// </summary>
            public bool IsGranted { get; set; }

            /// <summary>
            /// true  = override is logically removed (soft delete)
            /// false = active override
            /// </summary>
            public bool IsRevoked { get; set; }

            public DateTime AssignedAt { get; set; }
            public string? AssignedBy { get; set; }
        }

        public sealed class UpsertUserPermissionRequest
        {
            public Guid PermissionId { get; set; }

            /// <summary>
            /// true  = allow
            /// false = deny
            /// </summary>
            public bool IsGranted { get; set; }
        }

        // ---------------- GET: list overrides for a user ----------------

        /// <summary>
        /// Returns all active overrides for the given user.
        /// The UI should combine this with plan permissions to show final state.
        /// </summary>
        [HttpGet]
        public async Task<ActionResult<List<UserPermissionOverrideDto>>> GetOverridesForUser(
            Guid userId,
            CancellationToken ct)
        {
            // Ensure the user exists (optional but nice for admin UX)
            var userExists = await _db.Set<User>()
                .AnyAsync(u => u.Id == userId, ct);

            if (!userExists)
            {
                return NotFound($"User {userId} not found.");
            }

            var overrides = await _db.Set<UserPermission>()
                .AsNoTracking()
                .Where(up => up.UserId == userId && !up.IsRevoked)
                .Include(up => up.Permission)
                .OrderBy(up => up.Permission.Code)
                .Select(up => new UserPermissionOverrideDto
                {
                    PermissionId = up.PermissionId,
                    Code = up.Permission.Code,
                    Name = up.Permission.Name,
                    IsGranted = up.IsGranted,
                    IsRevoked = up.IsRevoked,
                    AssignedAt = up.AssignedAt,
                    AssignedBy = up.AssignedBy
                })
                .ToListAsync(ct);

            return overrides;
        }

        // ---------------- POST: create/update override ----------------

        /// <summary>
        /// Create or update an override for the given user & permission.
        /// If row exists, we update IsGranted and clear IsRevoked.
        /// </summary>
        [HttpPost]
        public async Task<ActionResult<UserPermissionOverrideDto>> UpsertOverride(
            Guid userId,
            [FromBody] UpsertUserPermissionRequest request,
            CancellationToken ct)
        {
            if (request.PermissionId == Guid.Empty)
            {
                return BadRequest("PermissionId is required.");
            }

            var user = await _db.Set<User>()
                .FirstOrDefaultAsync(u => u.Id == userId, ct);

            if (user is null)
            {
                return NotFound($"User {userId} not found.");
            }

            var permission = await _db.Set<Permission>()
                .FirstOrDefaultAsync(p => p.Id == request.PermissionId, ct);

            if (permission is null)
            {
                return NotFound($"Permission {request.PermissionId} not found.");
            }

            var existing = await _db.Set<UserPermission>()
                .FirstOrDefaultAsync(
                    up => up.UserId == userId && up.PermissionId == request.PermissionId,
                    ct);

            if (existing is null)
            {
                existing = new UserPermission
                {
                    Id = Guid.NewGuid(),
                    UserId = userId,
                    PermissionId = request.PermissionId,
                    IsGranted = request.IsGranted,
                    IsRevoked = false,
                    AssignedAt = DateTime.UtcNow,
                    AssignedBy = User?.Identity?.Name ?? "system"
                };

                await _db.Set<UserPermission>().AddAsync(existing, ct);
            }
            else
            {
                existing.IsGranted = request.IsGranted;
                existing.IsRevoked = false;
                existing.AssignedAt = DateTime.UtcNow;
                existing.AssignedBy = User?.Identity?.Name ?? existing.AssignedBy;
            }

            await _db.SaveChangesAsync(ct);

            var dto = new UserPermissionOverrideDto
            {
                PermissionId = existing.PermissionId,
                Code = permission.Code,
                Name = permission.Name,
                IsGranted = existing.IsGranted,
                IsRevoked = existing.IsRevoked,
                AssignedAt = existing.AssignedAt,
                AssignedBy = existing.AssignedBy
            };

            return Ok(dto);
        }

        // ---------------- DELETE: soft-remove override ----------------

        /// <summary>
        /// Soft deletes an override by setting IsRevoked = true.
        /// Effective permission will fall back to plan-level mapping.
        /// </summary>
        [HttpDelete("{permissionId:guid}")]
        public async Task<IActionResult> DeleteOverride(
            Guid userId,
            Guid permissionId,
            CancellationToken ct)
        {
            var overrideRow = await _db.Set<UserPermission>()
                .FirstOrDefaultAsync(
                    up => up.UserId == userId && up.PermissionId == permissionId,
                    ct);

            if (overrideRow is null)
            {
                return NotFound();
            }

            overrideRow.IsRevoked = true;
            // Optional: also reset grant flag ‚Äì your entitlement logic can ignore revoked rows anyway
            // overrideRow.IsGranted = false;

            await _db.SaveChangesAsync(ct);
            return NoContent();
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\CreatePlanDto.cs 
====================================================== 
 
Ôªøusing System;

namespace xbytechat.api.Features.AccessControl.DTOs
{
    public class CreatePlanDto
    {
        public string Code { get; set; } // e.g. "FREE", "SMART"
        public string Name { get; set; }
        public string? Description { get; set; }
        public bool IsActive { get; set; } = true;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\GroupedPermissionDto.cs 
====================================================== 
 
Ôªøusing xbytechat.api.Features.AccessControl.Models;

namespace xbytechat.api.Features.AccessControl.DTOs
{
    public class GroupedPermissionDto
    {
        public string Group { get; set; }
        public List<Permission> Features { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\PermissionDto.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.AccessControl.DTOs
{
    public class PermissionDto
    {
        public Guid Id { get; set; }
        public string Code { get; set; }
        public string Name { get; set; }
        public string? Group { get; set; }
        public string? Description { get; set; }
        public bool IsActive { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\PermissionSummaryDto.cs 
====================================================== 
 
Ôªø// üìÑ Features/AccessControl/DTOs/PermissionSummaryDto.cs
using System;

namespace xbytechat.api.Features.AccessControl.DTOs
{
    /// <summary>
    /// Flat DTO used by the Permissions admin grid.
    /// </summary>
    public sealed class PermissionSummaryDto
    {
        public Guid Id { get; set; }

        public string Code { get; set; } = default!;
        public string Name { get; set; } = default!;

        public string? Group { get; set; }
        public string? Description { get; set; }

        public bool IsActive { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\PermissionUpsertDto.cs 
====================================================== 
 
Ôªø// üìÑ Features/AccessControl/DTOs/PermissionUpsertDto.cs
using System.ComponentModel.DataAnnotations;

namespace xbytechat.api.Features.AccessControl.DTOs
{
    /// <summary>
    /// Payload for creating or updating a Permission.
    /// Code is immutable once created (UI disables it for edit).
    /// </summary>
    public sealed class PermissionUpsertDto
    {
        [Required]
        [MaxLength(200)]
        public string Code { get; set; } = default!; // e.g. "MESSAGING.SEND.TEXT"

        [Required]
        [MaxLength(200)]
        public string Name { get; set; } = default!; // friendly label

        [MaxLength(200)]
        public string? Group { get; set; } // "Messaging", "Campaigns", etc.

        [MaxLength(1000)]
        public string? Description { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\PlanDto.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.AccessControl.DTOs
{
    public class PlanDto
    {
        public Guid Id { get; set; }
        public string Code { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public bool IsActive { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\RoleDto.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.AccessControl.DTOs;

// DTO: Role details used across layers
public class RoleDto
{
    /// <summary>Unique identifier of the role.</summary>
    public Guid Id { get; set; }

   
    public string Role { get; set; } = default!;

   
    public string Code { get; set; } = default!;

   
    public string? Description { get; set; }

    
    public bool IsActive { get; set; }

       public RoleDto() { }

    // Convenience constructor
    
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\UpdatePlanDto.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.AccessControl.DTOs
{
    public class UpdatePlanDto
    {
        public string Name { get; set; }
        public string Code { get; set; }
        public string Description { get; set; }
        public bool IsActive { get; set; }
    }

}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\UpdatePlanPermissionsRequest.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.AccessControl.DTOs
{
    public class UpdatePlanPermissionsRequest
    {
        public List<Guid> PermissionIds { get; set; } = new();
        public bool ReplaceAll { get; set; } = true; // optional flag your controller reads
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\UpdateRolePermissionsDto.cs 
====================================================== 
 
Ôªøusing System.ComponentModel.DataAnnotations;

namespace xbytechat.api.Features.AccessControl.DTOs
{
    public class UpdateRolePermissionsDto
    {
        [Required]
        public List<Guid> PermissionIds { get; set; } = new();
        public bool ReplaceAll { get; set; } = true;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\UpdateUserPermissionsDto.cs 
====================================================== 
 
Ôªøusing System.Collections.Generic;

namespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions
{
    public sealed class UpdateUserPermissionsDto
    {
        /// <summary>
        /// List of Permission.Code values that should be enabled for this user.
        /// Anything not in this list will be removed.
        /// </summary>
        public List<string> PermissionCodes { get; set; } = new();
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\UpsertPermissionRequest.cs 
====================================================== 
 
Ôªø// üìÅ Features/AccessControl/DTOs/UpsertPermissionRequest.cs
namespace xbytechat.api.Features.AccessControl.DTOs
{
    public class UpsertPermissionRequest
    {
        // Code is required only on create. On update, we ignore it.
        public string Code { get; set; } = string.Empty;

        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Logical group/module/workspace, e.g. "Messaging", "Campaigns", "CRM".
        /// This maps to Permission.Group in the model.
        /// </summary>
        public string? Group { get; set; }

        public string? Description { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\UserPermissions.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions
{
    public sealed class UserPermissionItemDto
    {
        public string PermissionCode { get; set; } = default!;
        public string Name { get; set; } = default!;
        public string? Description { get; set; }
        public bool IsAssigned { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\DTOs\UserPermissionSummaryDto.cs 
====================================================== 
 
Ôªøusing System;
using System.Collections.Generic;

namespace xbytechat.api.Features.AccessControl.DTOs.UserPermissions
{
    public sealed class UserPermissionSummaryDto
    {
        public Guid UserId { get; set; }
        public string UserEmail { get; set; } = default!;
        public Guid BusinessId { get; set; }
        public Guid PlanId { get; set; }

        public List<UserPermissionItemDto> Items { get; set; } = new();
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Models\Permission.cs 
====================================================== 
 
Ôªøusing System;
using System.Collections.Generic;

namespace xbytechat.api.Features.AccessControl.Models
{
    public class Permission
    {
        public Guid Id { get; set; }

        public string Code { get; set; } // Unique key like "ViewDashboard"

        public string Name { get; set; } // Friendly name like "View Dashboard"

        public string? Group { get; set; } // Optional grouping, e.g., "CRM", "Catalog", "Admin"

        public string? Description { get; set; }

        public bool IsActive { get; set; } = true;

        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        public ICollection<RolePermission> RolePermissions { get; set; }

        public ICollection<UserPermission> UserPermissions { get; set; }

        public ICollection<PlanPermission> PlanPermissions { get; set; }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Models\Plan.cs 
====================================================== 
 
Ôªøusing System;
using System.Collections.Generic;
using xbytechat.api.Features.BusinessModule.Models;

namespace xbytechat.api.Features.AccessControl.Models
{
    public class Plan
    {
        public Guid Id { get; set; }

        public string Code { get; set; } // e.g. "FREE", "SMART", "ADVANCED"
        public string Name { get; set; } // Friendly display name

        public string? Description { get; set; }

        public bool IsActive { get; set; } = true;

        public bool IsInternal { get; set; } = false;
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        public ICollection<PlanPermission> PlanPermissions { get; set; }
        public ICollection<Business> Businesses { get; set; } = new List<Business>();
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Models\PlanPermission.cs 
====================================================== 
 
Ôªøusing System;

namespace xbytechat.api.Features.AccessControl.Models
{
    public class PlanPermission
    {
        public Guid Id { get; set; }

        public Guid PlanId { get; set; }
        public Plan Plan { get; set; }

        public Guid PermissionId { get; set; }
        public Permission Permission { get; set; }

        public bool IsActive { get; set; } = true;

        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;
        public string? AssignedBy { get; set; } // Admin email or ID
    }
}

 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Models\Role.cs 
====================================================== 
 
Ôªøusing System;
using System.Collections.Generic;
using xbytechat.api.AuthModule.Models;

namespace xbytechat.api.Features.AccessControl.Models
{
    public class Role
    {
        public Guid Id { get; set; }

        public string Name { get; set; } // e.g. SuperAdmin, PartnerAdmin, BusinessAdmin, Staff, etc.

        public string? Description { get; set; }

        public bool IsSystemDefined { get; set; } = false; // true for SuperAdmin, PartnerAdmin

        public bool IsActive { get; set; } = true;

        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        public ICollection<RolePermission> RolePermissions { get; set; }
        public ICollection<User> Users { get; set; } // üß© One-to-many relation: Role ‚Üí Users

    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Models\RolePermission.cs 
====================================================== 
 
Ôªøusing System;

namespace xbytechat.api.Features.AccessControl.Models
{
    public class RolePermission
    {
        public Guid Id { get; set; }

        public Guid RoleId { get; set; }
        public Role Role { get; set; }

        public Guid PermissionId { get; set; }
        public Permission Permission { get; set; }

        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;
        public string? AssignedBy { get; set; } // Admin user email or ID

        public bool IsActive { get; set; } = true; // ‚úÖ Add this line
        public bool IsRevoked { get; set; } = false; // ‚úÖ Required
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Models\UserPermission.cs 
====================================================== 
 
Ôªøusing System;
using xbytechat.api.AuthModule.Models;

namespace xbytechat.api.Features.AccessControl.Models
{
    public class UserPermission
    {
        public Guid Id { get; set; }

        public Guid UserId { get; set; }
        public User User { get; set; }

        public Guid PermissionId { get; set; }
        public Permission Permission { get; set; }

        public bool IsGranted { get; set; } = true; // ‚úÖ true = allow, false = explicitly deny

        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;
        public string? AssignedBy { get; set; } // Admin or system

        public bool IsRevoked { get; set; } = false; // ‚úÖ Required
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Seeder\PermissionConstants.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.AccessControl.Seeder
{
    public static class PermissionConstants
    {
        public static class Dashboard
        {
            public const string View = "dashboard.view";
        }

        public static class Campaigns
        {
            public const string View = "campaign.view";
            public const string Create = "campaign.create";
            public const string Delete = "campaign.delete";
        }

        public static class Products
        {
            public const string View = "product.view";
            public const string Create = "product.create";
            public const string Delete = "product.delete";
        }

        public static class CRM
        {
            public const string ContactsView = "contacts.view";
            public const string TagsEdit = "tags.edit";
        }

        public static class Admin
        {
            public const string BusinessApprove = "admin.business.approve";
            public const string ViewLogs = "admin.logs.view";
        }

        // üÜï Add more modules and permissions here as needed
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Seeder\RolePermissionMapping.cs 
====================================================== 
 
Ôªønamespace xbytechat.api.Features.AccessControl.Seeder
{
    public static class RolePermissionMapping
    {
        public static readonly Dictionary<string, List<string>> RolePermissions = new()
        {
            ["admin"] = new()
            {
                PermissionConstants.Dashboard.View,
                PermissionConstants.Campaigns.View,
                PermissionConstants.Campaigns.Create,
                PermissionConstants.Campaigns.Delete,
                PermissionConstants.Products.View,
                PermissionConstants.Products.Create,
                PermissionConstants.Products.Delete,
                PermissionConstants.CRM.ContactsView,
                PermissionConstants.CRM.TagsEdit,
                PermissionConstants.Admin.BusinessApprove,
                PermissionConstants.Admin.ViewLogs
            },

            ["business"] = new()
            {
                PermissionConstants.Dashboard.View,
                PermissionConstants.Campaigns.View,
                PermissionConstants.CRM.ContactsView,
                PermissionConstants.Products.View
            },

            ["staff"] = new()
            {
                PermissionConstants.Dashboard.View,
                PermissionConstants.CRM.ContactsView
            }
        };
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Services\AccessControlService.cs 
====================================================== 
 
Ôªø//using Microsoft.EntityFrameworkCore;
//using System.Collections.Generic;
//using System.Security.Claims;
//using System.Threading.Tasks;

//using xbytechat.api.Features.AccessControl.Models;

//namespace xbytechat.api.Features.AccessControl.Services
//{
//    public class AccessControlService : IAccessControlService
//    {
//        private readonly AppDbContext _context;

//        public AccessControlService(AppDbContext context)
//        {
//            _context = context;
//        }

//        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()
//        {
//            return await _context.Permissions
//                .AsNoTracking()
//                .Where(p => p.IsActive)
//                .ToListAsync();
//        }
//        //public async Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId)
//        //{
//        //    // First, check if the user has direct permissions
//        //    var userPermissions = await _context.UserPermissions
//        //        .Where(up => up.UserId == userId && up.IsGranted && !up.IsRevoked)
//        //        .Select(up => up.Permission)
//        //        .Where(p => p.IsActive)
//        //        .ToListAsync();

//        //    // If no direct permissions, fall back to role permissions
//        //    if (!userPermissions.Any())
//        //    {
//        //        userPermissions = await _context.RolePermissions
//        //            .Where(rp => rp.Role.Users.Any(u => u.Id == userId) && rp.IsActive && !rp.IsRevoked)
//        //            .Select(rp => rp.Permission)
//        //            .Where(p => p.IsActive)
//        //            .ToListAsync();
//        //    }

//        //    return userPermissions;
//        //}
       
        
       
//    }
//}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using xbytechat.api.AuthModule.Models;
using xbytechat.api.Features.AccessControl.Models;
using xbytechat.api.Repositories.Interfaces;
using System.Linq.Expressions;


namespace xbytechat.api.Features.AccessControl.Services
{
    public class AccessControlService : IAccessControlService
    {
        private readonly IGenericRepository<User> _userRepo;
        private readonly IGenericRepository<RolePermission> _rolePermissionRepo;
        private readonly IGenericRepository<UserPermission> _userPermissionRepo;
        private readonly IGenericRepository<Permission> _permissionRepo;
        private readonly AppDbContext _context;
        public AccessControlService(
            IGenericRepository<User> userRepo,
            IGenericRepository<RolePermission> rolePermissionRepo,
            IGenericRepository<UserPermission> userPermissionRepo,
            IGenericRepository<Permission> permissionRepo, AppDbContext context
        )
        {
            _userRepo = userRepo;
            _rolePermissionRepo = rolePermissionRepo;
            _userPermissionRepo = userPermissionRepo;
            _permissionRepo = permissionRepo;
            _context = context;
        }

        /// <summary>
        /// ‚úÖ Fetch all permissions (Role-based + User-specific) for a given user
        /// </summary>
        //public async Task<List<string>> GetPermissionsAsync(Guid userId)
        //{
        //    var user = await _userRepo.FindByIdAsync(userId);
        //    if (user == null || user.RoleId == null)
        //        return new List<string>();

        //    // üîê Get Role-based permissions
        //    var rolePerms = await _rolePermissionRepo
        //        .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);

        //    // üîê Get User-specific extra permissions
        //    var userPerms = await _userPermissionRepo
        //        .WhereAsync(up => up.UserId == userId && !up.IsRevoked);

        //    // üß† Merge permission IDs
        //    var permissionIds = rolePerms.Select(r => r.PermissionId)
        //        .Union(userPerms.Select(u => u.PermissionId))
        //        .Distinct()
        //        .ToList();

        //    // üéØ Get full permission names from Permission table
        //    var allPerms = await _permissionRepo
        //        .WhereAsync(p => permissionIds.Contains(p.Id));

        //    return allPerms.Select(p => p.Code).Distinct().ToList(); // Use Code (standard)
        //}

        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()
        {
            return await _permissionRepo.WhereAsync(p => p.IsActive);
        }


        public async Task<List<string>> GetPermissionsAsync(Guid userId)
        {
            var user = await _userRepo.FindByIdAsync(userId);

            if (user == null || user.RoleId == null)
                return new List<string>();

            // üöÄ Bypass: SuperAdmin always gets full access
            if (user.Role != null && user.Role.Name.Equals("superadmin", StringComparison.OrdinalIgnoreCase))
            {
                var allPerms = await _permissionRepo.GetAllAsync();
                return allPerms.Select(p => p.Code).Distinct().ToList();
            }

            // üîê Get Role-based permissions
            var rolePerms = await _rolePermissionRepo
                .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);

            // üîê Get User-specific extra permissions
            var userPerms = await _userPermissionRepo
                .WhereAsync(up => up.UserId == userId && !up.IsRevoked);

            // üß† Merge permission IDs
            var permissionIds = rolePerms.Select(r => r.PermissionId)
                .Union(userPerms.Select(u => u.PermissionId))
                .Distinct()
                .ToList();

            // üéØ Get full permission names from Permission table
            var allAllowedPerms = await _permissionRepo
                .WhereAsync(p => permissionIds.Contains(p.Id));

            return allAllowedPerms.Select(p => p.Code).Distinct().ToList();
        }

        public bool HasPermission(ClaimsPrincipal user, string requiredPermission)
        {
            // üöÄ Bypass: SuperAdmin always passes
            //var roleClaim = user.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Role)?.Value;
            var roleClaim = user.Claims.FirstOrDefault(c =>
                c.Type == ClaimTypes.Role || c.Type.Equals("role", StringComparison.OrdinalIgnoreCase)
            )?.Value;

            if (!string.IsNullOrEmpty(roleClaim) && roleClaim.Equals("superadmin", StringComparison.OrdinalIgnoreCase))
                return true;

            var perms = user.Claims
                .Where(c => c.Type == "permissions")
                .Select(c => c.Value)
                .ToList();

            return perms.Contains(requiredPermission);
        }

        /// <summary>
        /// ‚úÖ Runtime permission checker (for controller/middleware)
        /// </summary>
        //public bool HasPermission(ClaimsPrincipal user, string requiredPermission)
        //{
        //    var perms = user.Claims
        //        .Where(c => c.Type == "permissions")
        //        .Select(c => c.Value)
        //        .ToList();

        //    return perms.Contains(requiredPermission);
        //}

        public async Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId)
        {
            if (!planId.HasValue)
                return new List<string>();

            return await _context.PlanPermissions
                .Where(pp => pp.PlanId == planId.Value && pp.IsActive)
                .Select(pp => pp.Permission.Code)
                .ToListAsync();
        }


    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Services\IAccessControlService.cs 
====================================================== 
 
Ôªø//using System.Collections.Generic;
//using System.Threading.Tasks;
//using xbytechat.api.Features.AccessControl.Models;

//namespace xbytechat.api.Features.AccessControl.Services
//{
//    public interface IAccessControlService
//    {
//        Task<IEnumerable<Permission>> GetAllPermissionsAsync();
//        Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId);

//    }
//}


using System.Security.Claims;
using xbytechat.api.Features.AccessControl.Models;

namespace xbytechat.api.Features.AccessControl.Services
{
    public interface IAccessControlService
    {
        Task<List<string>> GetPermissionsAsync(Guid userId);
        bool HasPermission(ClaimsPrincipal user, string permission);
        Task<IEnumerable<Permission>> GetAllPermissionsAsync();
        Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Services\IPermissionService.cs.cs 
====================================================== 
 
Ôªø// üìÑ Features/AccessControl/Services/IPermissionService.cs.cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using xbytechat.api.Features.AccessControl.DTOs;

namespace xbytechat.api.Features.AccessControl.Services
{
    public interface IPermissionService
    {
        // Existing grouped view (used by older UI / internal tools)
        Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync();

        // New flat CRUD endpoints
        Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(
            CancellationToken ct = default);

        Task<PermissionSummaryDto> CreateAsync(
            PermissionUpsertDto dto,
            CancellationToken ct = default);

        Task<PermissionSummaryDto> UpdateAsync(
            Guid id,
            PermissionUpsertDto dto,
            CancellationToken ct = default);

        /// <summary>
        /// Soft-delete / deactivate a permission.
        /// </summary>
        Task DeactivateAsync(Guid id, CancellationToken ct = default);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Services\IPlanService.cs 
====================================================== 
 
Ôªøusing System;
using System.Collections.Generic;
using System.Threading.Tasks;
using xbytechat.api.Features.AccessControl.DTOs;
using xbytechat.api.Features.AccessControl.Models;

namespace xbytechat.api.Features.AccessControl.Services
{
    public interface IPlanService
    {
        Task<IEnumerable<PlanDto>> GetAllPlansAsync();
        Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId);
       // Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);
        Task<Guid> CreatePlanAsync(CreatePlanDto dto);
        Task<bool> DeletePlanAsync(Guid planId);
        Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto);

        // New methods for permissions
        Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId);
        //Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);
        Task UpdatePlanPermissionsAsync(
    Guid planId,
    IReadOnlyCollection<Guid> permissionIds,
    bool replaceAll,
    string? assignedBy,
    CancellationToken ct);
        Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default);
    }
}

 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Services\PermissionCacheService.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using xbytechat.api.Features.AccessControl.Models;

namespace xbytechat.api.Features.AccessControl.Services
{
    public interface IPermissionCacheService
    {
        Task<List<Permission>> GetPlanPermissionsAsync(Guid planId);
        void ClearPlanPermissionsCache(Guid planId);
    }

    public class PermissionCacheService : IPermissionCacheService
    {
        private readonly AppDbContext _context;
        private readonly IMemoryCache _cache;
        private const string CacheKeyPrefix = "plan_permissions_";

        public PermissionCacheService(AppDbContext context, IMemoryCache cache)
        {
            _context = context;
            _cache = cache;
        }

        public async Task<List<Permission>> GetPlanPermissionsAsync(Guid planId)
        {
            var cacheKey = $"{CacheKeyPrefix}{planId}";

            // Try to get from cache
            if (_cache.TryGetValue(cacheKey, out List<Permission> cachedPermissions))
                return cachedPermissions;

            // Fetch from DB
            var permissions = await _context.PlanPermissions
                .Where(pp => pp.PlanId == planId && pp.IsActive)
                .Select(pp => pp.Permission)
                .ToListAsync();

            // Store in cache
            _cache.Set(cacheKey, permissions, TimeSpan.FromHours(1));

            return permissions;
        }

        public void ClearPlanPermissionsCache(Guid planId)
        {
            _cache.Remove($"{CacheKeyPrefix}{planId}");
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Services\PermissionService.cs 
====================================================== 
 
Ôªø// üìÑ Features/AccessControl/Services/PermissionService.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using xbytechat.api.Features.AccessControl.DTOs;
using xbytechat.api.Features.AccessControl.Models;

namespace xbytechat.api.Features.AccessControl.Services
{
    public class PermissionService : IPermissionService
    {
        private readonly AppDbContext _context;

        public PermissionService(AppDbContext context)
        {
            _context = context;
        }

        public async Task<IEnumerable<GroupedPermissionDto>> GetGroupedPermissionsAsync()
        {
            // Legacy / grouped view (kept for compatibility)
            return await _context.Permissions
                .Where(p => p.IsActive)
                .GroupBy(p => p.Group ?? "Ungrouped")
                .Select(g => new GroupedPermissionDto
                {
                    Group = g.Key,
                    Features = g.ToList()
                })
                .ToListAsync();
        }

        public async Task<IReadOnlyList<PermissionSummaryDto>> GetAllAsync(
            CancellationToken ct = default)
        {
            return await _context.Permissions
                .OrderBy(p => p.Group)
                .ThenBy(p => p.Code)
                .Select(p => new PermissionSummaryDto
                {
                    Id = p.Id,
                    Code = p.Code,
                    Name = p.Name,
                    Group = p.Group,
                    Description = p.Description,
                    IsActive = p.IsActive,
                    CreatedAt = p.CreatedAt
                })
                .ToListAsync(ct);
        }

        public async Task<PermissionSummaryDto> CreateAsync(
            PermissionUpsertDto dto,
            CancellationToken ct = default)
        {
            if (dto == null) throw new ArgumentNullException(nameof(dto));

            var code = dto.Code?.Trim();
            var name = dto.Name?.Trim();

            if (string.IsNullOrWhiteSpace(code) || string.IsNullOrWhiteSpace(name))
            {
                throw new InvalidOperationException("Code and Name are required.");
            }

            var normalizedCode = code.ToUpperInvariant();

            var exists = await _context.Permissions
                .AnyAsync(p => p.Code == normalizedCode, ct);

            if (exists)
            {
                throw new InvalidOperationException(
                    $"Permission code '{normalizedCode}' already exists.");
            }

            var permission = new Permission
            {
                Id = Guid.NewGuid(),
                Code = normalizedCode,
                Name = name,
                Group = string.IsNullOrWhiteSpace(dto.Group)
                    ? null
                    : dto.Group!.Trim(),
                Description = string.IsNullOrWhiteSpace(dto.Description)
                    ? null
                    : dto.Description!.Trim(),
                IsActive = true,
                CreatedAt = DateTime.UtcNow
            };

            _context.Permissions.Add(permission);
            await _context.SaveChangesAsync(ct);

            return ToSummary(permission);
        }

        public async Task<PermissionSummaryDto> UpdateAsync(
            Guid id,
            PermissionUpsertDto dto,
            CancellationToken ct = default)
        {
            if (dto == null) throw new ArgumentNullException(nameof(dto));

            var permission = await _context.Permissions
                .FirstOrDefaultAsync(p => p.Id == id, ct);

            if (permission == null)
                throw new KeyNotFoundException("Permission not found.");

            var name = dto.Name?.Trim();
            if (string.IsNullOrWhiteSpace(name))
                throw new InvalidOperationException("Name is required.");

            // Code is intentionally immutable (UI keeps it disabled).
            permission.Name = name;
            permission.Group = string.IsNullOrWhiteSpace(dto.Group)
                ? null
                : dto.Group!.Trim();
            permission.Description = string.IsNullOrWhiteSpace(dto.Description)
                ? null
                : dto.Description!.Trim();

            await _context.SaveChangesAsync(ct);

            return ToSummary(permission);
        }

        public async Task DeactivateAsync(Guid id, CancellationToken ct = default)
        {
            var permission = await _context.Permissions
                .FirstOrDefaultAsync(p => p.Id == id, ct);

            if (permission == null)
                throw new KeyNotFoundException("Permission not found.");

            if (!permission.IsActive)
                return;

            permission.IsActive = false;
            await _context.SaveChangesAsync(ct);
        }

        private static PermissionSummaryDto ToSummary(Permission p)
        {
            return new PermissionSummaryDto
            {
                Id = p.Id,
                Code = p.Code,
                Name = p.Name,
                Group = p.Group,
                Description = p.Description,
                IsActive = p.IsActive,
                CreatedAt = p.CreatedAt
            };
        }
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\AccessControl\Services\PlanService.cs 
====================================================== 
 
Ôªøusing Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using xbytechat.api.Features.AccessControl.DTOs;
using xbytechat.api.Features.AccessControl.Models;

namespace xbytechat.api.Features.AccessControl.Services
{
    public class PlanService : IPlanService
    {
        private readonly AppDbContext _context;
        private readonly ILogger<PlanService> _logger;
        private readonly IPermissionCacheService _permissionCacheService;

        public PlanService(AppDbContext context, ILogger<PlanService> logger, IPermissionCacheService permissionCacheService)
        {
            _context = context;
            _logger = logger;
            _permissionCacheService = permissionCacheService;
        }



        public async Task<IEnumerable<PlanDto>> GetAllPlansAsync()
        {
            return await _context.Plans
                .Where(p => p.IsActive)
                .Select(p => new PlanDto
                {
                    Id = p.Id,
                    Code = p.Code,
                    Name = p.Name,
                    Description = p.Description,
                    IsActive = p.IsActive
                })
                .ToListAsync();
        }
        public async Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId)
        {
            return await _context.PlanPermissions
                .Where(pp => pp.PlanId == planId && pp.IsActive)
                .Select(pp => new PermissionDto
                {
                    Id = pp.Permission.Id,
                    Code = pp.Permission.Code,
                    Name = pp.Permission.Name,
                    Group = pp.Permission.Group,
                    Description = pp.Permission.Description,
                    IsActive = pp.Permission.IsActive
                })
                .ToListAsync();
        }
        public async Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default)
        {
            return await _context.Plans
                .AsNoTracking()
                .Where(p => p.Id == planId)
                .Select(p => new PlanDto
                {
                    Id = p.Id,
                    Code = p.Code,
                    Name = p.Name,
                    Description = p.Description,
                    IsActive = p.IsActive
                })
                .FirstOrDefaultAsync(ct);
        }

        //public async Task<IEnumerable<Permission>> GetPermissionsForPlanAsync(Guid planId)
        //{
        //    _logger.LogInformation("Fetching permissions for plan {PlanId}", planId);
        //    try
        //    {
        //        return await _context.PlanPermissions
        //            .Where(pp => pp.PlanId == planId && pp.IsActive)
        //            .Include(pp => pp.Permission)
        //            .Select(pp => pp.Permission)
        //            .AsNoTracking()
        //            .ToListAsync();
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger.LogError(ex, "Error fetching permissions for plan {PlanId}", planId);
        //        throw;
        //    }
        //}

        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)
        //{
        //    _logger.LogInformation("Updating permissions for plan {PlanId}", planId);
        //    try
        //    {
        //        // Remove all existing permissions for the plan
        //        var existing = await _context.PlanPermissions
        //            .Where(pp => pp.PlanId == planId)
        //            .ToListAsync();

        //        _context.PlanPermissions.RemoveRange(existing);

        //        // Add new permissions
        //        var newPlanPermissions = permissionIds.Select(pid => new PlanPermission
        //        {
        //            Id = Guid.NewGuid(),
        //            PlanId = planId,
        //            PermissionId = pid,
        //            IsActive = true,
        //            AssignedAt = DateTime.UtcNow,
        //            AssignedBy = "System"
        //        });

        //        await _context.PlanPermissions.AddRangeAsync(newPlanPermissions);
        //        await _context.SaveChangesAsync();
        //        _logger.LogInformation("Permissions updated for plan {PlanId}", planId);
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger.LogError(ex, "Error updating permissions for plan {PlanId}", planId);
        //        throw;
        //    }
        //}

        public async Task<Guid> CreatePlanAsync(CreatePlanDto dto)
        {
            _logger.LogInformation("Creating new plan: {PlanName}", dto.Name);
            try
            {
                var plan = new Plan
                {
                    Id = Guid.NewGuid(),
                    Code = dto.Code,
                    Name = dto.Name,
                    Description = dto.Description,
                    IsActive = dto.IsActive
                };

                _context.Plans.Add(plan);
                await _context.SaveChangesAsync();

                _logger.LogInformation("Plan created with ID: {PlanId}", plan.Id);
                return plan.Id;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating plan {PlanName}", dto.Name);
                throw;
            }
        }

        public async Task<bool> DeletePlanAsync(Guid planId)
        {
            _logger.LogInformation("Deleting (soft) plan {PlanId}", planId);
            try
            {
                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);
                if (plan == null || !plan.IsActive)
                {
                    _logger.LogWarning("Plan not found or already inactive: {PlanId}", planId);
                    return false;
                }

                plan.IsActive = false;
                _context.Plans.Update(plan);
                await _context.SaveChangesAsync();

                _logger.LogInformation("Plan {PlanId} soft deleted.", planId);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting plan {PlanId}", planId);
                throw;
            }
        }

        public async Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto)
        {
            _logger.LogInformation("Updating plan {PlanId}", planId);
            try
            {
                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);
                if (plan == null)
                {
                    _logger.LogWarning("Plan not found: {PlanId}", planId);
                    return false;
                }

                plan.Code = dto.Code;
                plan.Name = dto.Name;
                plan.Description = dto.Description;
                plan.IsActive = dto.IsActive;

                _context.Plans.Update(plan);
                await _context.SaveChangesAsync();

                _logger.LogInformation("Plan {PlanId} updated successfully.", planId);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating plan {PlanId}", planId);
                throw;
            }
        }

        public async Task UpdatePlanPermissionsAsync(
         Guid planId,
         IReadOnlyCollection<Guid> permissionIds,
         bool replaceAll,
         string? assignedBy,
         CancellationToken ct)
        {
            using var trx = await _context.Database.BeginTransactionAsync(ct);

            var existing = await _context.PlanPermissions
                .Where(pp => pp.PlanId == planId)
                .ToListAsync(ct);

            var want = new HashSet<Guid>(permissionIds);
            var byPerm = existing.ToDictionary(pp => pp.PermissionId);

            // upsert requested permissions ‚Üí Active
            foreach (var pid in want)
            {
                if (byPerm.TryGetValue(pid, out var row))
                {
                    if (!row.IsActive)
                    {
                        row.IsActive = true;
                        row.AssignedAt = DateTime.UtcNow;
                        row.AssignedBy = assignedBy;
                        _context.PlanPermissions.Update(row);
                    }
                }
                else
                {
                    _context.PlanPermissions.Add(new PlanPermission
                    {
                        Id = Guid.NewGuid(),
                        PlanId = planId,
                        PermissionId = pid,
                        IsActive = true,
                        AssignedAt = DateTime.UtcNow,
                        AssignedBy = assignedBy
                    });
                }
            }

            // replaceAll => deactivate anything not requested
            if (replaceAll)
            {
                foreach (var row in existing)
                {
                    if (!want.Contains(row.PermissionId) && row.IsActive)
                    {
                        row.IsActive = false;
                        _context.PlanPermissions.Update(row);
                    }
                }
            }

            await _context.SaveChangesAsync(ct);
            await trx.CommitAsync(ct);

            // Bust the plan permission cache
            _permissionCacheService.ClearPlanPermissionsCache(planId);
        }



        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)
        //{
        //    // Remove old mappings
        //    var existing = await _context.PlanPermissions
        //        .Where(pp => pp.PlanId == planId)
        //        .ToListAsync();
        //    _context.PlanPermissions.RemoveRange(existing);

        //    // Add new mappings
        //    var newMappings = permissionIds.Select(pid => new PlanPermission
        //    {
        //        PlanId = planId,
        //        PermissionId = pid,
        //        AssignedAt = DateTime.UtcNow,
        //        AssignedBy = "system" // replace with logged-in admin
        //    });

        //    await _context.PlanPermissions.AddRangeAsync(newMappings);
        //    await _context.SaveChangesAsync();
        //    //// Clear cache
        //    _permissionCacheService.ClearPlanPermissionsCache(planId);
        //}
        public async Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId)
        {
            return await _context.PlanPermissions
                .Where(pp => pp.PlanId == planId && pp.IsActive)
                .Select(pp => new PermissionDto
                {
                    Id = pp.Permission.Id,
                    Code = pp.Permission.Code,
                    Name = pp.Permission.Name,
                    Group = pp.Permission.Group,
                    Description = pp.Permission.Description
                })
                .ToListAsync();
        }
    }
}
 
 
