Folder and File Content Report
Root folder: D:\xbytechat\xbytechat-api\xbytechat-api\Features\PlanManagement
Generated at: 10-12-2025 12:53:10.63
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\PlanManagement\MakeDump.bat 
====================================================== 
 
@echo off
REM This script will find relevant source files and output their names and contents into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh and write a small header
> "%outputFile%" (
    echo Folder and File Content Report
    echo Root folder: %cd%
    echo Generated at: %date% %time%
)
echo. >> "%outputFile%"

REM NOTE:
REM We now only dump RELEVANT text/code files (no binaries, no images, no node_modules, etc.)
REM This keeps the file smaller and much easier to review.

REM Loop through all relevant files in the current directory and subdirectories
REM Extensions included: C#, JS/TS/React, JSON, config, SQL, Markdown, YAML
for /R . %%F in (*.cs *.csproj *.jsx *.tsx *.js *.ts *.json *.config *.sql *.md *.yml *.yaml *.bat) do (

    REM Skip some noisy folders by path substring (node_modules, bin, obj, .git, dist, .vs)
    echo "%%F" | findstr /I /C:"\node_modules\" /C:"\bin\" /C:"\obj\" /C:"\.git\" /C:"\dist\" /C:"\.vs\" >nul
    if errorlevel 1 (
        echo ====================================================== >> "%outputFile%"
        echo FILE: %%F >> "%outputFile%"
        echo ====================================================== >> "%outputFile%"
        echo. >> "%outputFile%"
        type "%%F" >> "%outputFile%" 2>nul
        echo. >> "%outputFile%"
        echo. >> "%outputFile%"
    )
)

echo Finished! All content has been extracted to %outputFile%
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\PlanManagement\Models\BusinessPlanInfo.cs 
====================================================== 
 
ï»¿using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using xbytechat.api.Features.BusinessModule.Models;
using xbytechat.api.Features.PlanManagement.Models;

namespace xbytechat.api.Models.BusinessModel
{
    public class BusinessPlanInfo
    {
        [Key]
        public Guid Id { get; set; } = Guid.NewGuid();

        // ðŸ”— Foreign key to Business
        [Required]
        public Guid BusinessId { get; set; }

        [ForeignKey(nameof(BusinessId))]
        public Business Business { get; set; }

        // ðŸ“¦ Plan Management
        [Required]
        public PlanType Plan { get; set; } = PlanType.Trial; // Default Trial

        [Required]
        public int TotalMonthlyQuota { get; set; } = 100; // Default Trial Messages

        [Required]
        public int RemainingMessages { get; set; } = 100;

        public DateTime QuotaResetDate { get; set; } = DateTime.UtcNow.AddMonths(1);

        // ðŸ’° Wallet Management (optional)
        public decimal WalletBalance { get; set; } = 0.00m;

        // ðŸ“… Timestamps
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\PlanManagement\Models\PlanFeature.cs 
====================================================== 
 
ï»¿using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace xbytechat.api.Features.PlanManagement.Models
{
    [Table("PlanFeatureMatrix")]
    public class PlanFeatureMatrix
    {
        [Key]
        public Guid Id { get; set; }

        [Required]
        [MaxLength(20)]
        public string PlanName { get; set; } = string.Empty;  // "Basic", "Smart", "Advance"

        [Required]
        [MaxLength(50)]
        public string FeatureName { get; set; } = string.Empty; // "Contacts", "Catalog", etc.

        [Required]
        public bool IsEnabled { get; set; }  // Default state for this plan-feature pair
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\PlanManagement\Models\PlanType.cs 
====================================================== 
 
ï»¿namespace xbytechat.api.Features.PlanManagement.Models
{
    public enum PlanType
    {
       
        Basic = 0,
        Smart = 1,
        Advanced = 2,
            Trial = 3,
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\PlanManagement\Services\IPlanManager.cs 
====================================================== 
 
ï»¿using xbytechat.api.Helpers;
using xbytechat.api.Shared;

namespace xbytechat.api.Features.PlanManagement.Services
{
    public interface IPlanManager
    {
        /// <summary>
        /// Checks if business has enough quota to send a message.
        /// </summary>
        Task<ResponseResult> CheckQuotaBeforeSendingAsync(Guid businessId);
        Dictionary<string, bool> GetPlanFeatureMap(string plan);
    }
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-api\xbytechat-api\Features\PlanManagement\Services\PlanManager.cs 
====================================================== 
 
ï»¿// ðŸ“„ Features/PlanManagement/Services/PlanManager.cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using xbytechat.api.Features.Entitlements;
using xbytechat.api.Features.Entitlements.Services;
using xbytechat.api.Features.PlanManagement.Models;
using xbytechat.api.Helpers;
using xbytechat.api.Models.BusinessModel;
using xbytechat.api.Shared;

namespace xbytechat.api.Features.PlanManagement.Services
{
    public class PlanManager : IPlanManager
    {
        private readonly AppDbContext _db;
        private readonly IQuotaService _quota;

        public PlanManager(AppDbContext db, IQuotaService quota)
        {
            _db = db;
            _quota = quota;
        }

        /// <summary>
        /// Check and CONSUME 1 unit of "messages per month" quota for this business.
        /// If not allowed, returns a ResponseResult with a user-friendly error.
        /// </summary>
        public async Task<ResponseResult> CheckQuotaBeforeSendingAsync(Guid businessId)
        {
            // Load plan info for better error messaging (Trial vs Paid)
            var business = await _db.Businesses
                .Include(b => b.BusinessPlanInfo)
                .FirstOrDefaultAsync(b => b.Id == businessId);

            if (business is null)
            {
                return ResponseResult.ErrorInfo(
                    "Business not found.",
                    "Invalid business ID in CheckQuotaBeforeSendingAsync.");
            }

            var planType = business.BusinessPlanInfo?.Plan ?? PlanType.Trial;

            // Use the generic quota engine
            var result = await _quota.CheckAndConsumeAsync(
                businessId,
                QuotaKeys.MessagesPerMonth,
                amount: 1,
                ct: CancellationToken.None);

            if (!result.Allowed)
            {
                // 1) Prefer denial text coming from PlanQuotas / overrides
                var userMessage = !string.IsNullOrWhiteSpace(result.Message)
                    ? result.Message!
                    // 2) Fallback to your old behavior
                    : planType == PlanType.Trial
                        ? "Trial limit reached. Please upgrade your plan."
                        : "Monthly message quota exhausted. Please upgrade or wait for reset.";

                return ResponseResult.ErrorInfo(
                    userMessage,
                    $"Quota exceeded for {QuotaKeys.MessagesPerMonth}");
            }

            // OK â†’ caller (message send service) can proceed to send
            return ResponseResult.SuccessInfo("Quota check passed.");
        }

        /// <summary>
        /// Legacy feature map per plan.
        /// You can keep this for now; later we can align it with Permission/Entitlements.
        /// </summary>
        public Dictionary<string, bool> GetPlanFeatureMap(string plan)
        {
            // Keep your previous behavior here.
            // If your old code had slightly different maps, just plug them in.

            switch (plan?.Trim().ToLowerInvariant())
            {
                case "basic":
                    return new Dictionary<string, bool>
                    {
                        { "CATALOG", true },
                        { "MESSAGE_SEND", true },
                        { "CRM_NOTES", true },
                        { "CRM_TAGS", true }
                    };

                case "smart":
                    return new Dictionary<string, bool>
                    {
                        { "CATALOG", true },
                        { "MESSAGE_SEND", true },
                        { "CRM_NOTES", true },
                        { "CRM_TAGS", true }
                    };

                case "advanced":
                    return new Dictionary<string, bool>
                    {
                        { "CATALOG", true },
                        { "MESSAGE_SEND", true },
                        { "CRM_NOTES", true },
                        { "CRM_TAGS", true }
                    };

                default:
                    return new Dictionary<string, bool>();
            }
        }
    }
}
 
 
